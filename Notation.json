[{"Name": "Summation",
  "Symbol": "`Σ_,_`",
  "Command": "\\sum",
  "Explanation": "Denotes finite summation, `Finset.sum`. There are two uses : a. `Σ i in s,f i` denotes the summation over a set `s` of a space `α`, with `f` having domain `α`. We require `s` to be `Finset α`; b. `Σ i : α,f i` requires `Fintype α`. This is the additive version of product.",
  "Link": "https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Basic.html#Finset.sum",
  "Examples": ["example : {α : Type v} {s : Finset α} {m : ℕ} {f : α → ℕ}(h₁ : ∀ x ∈ s, f x = m) : ∑ x in s, f x = card s * m",
    "example : {β : Type u} {α : Type v} {γ : Type w} [Fintype α] [AddCommMonoid β] [AddCommMonoid γ] {G : Type u_2} [AddMonoidHomClass G β γ] (g : G) (f : α → β) : g (Σ x, f x) = Σ x, g (f x)",
    "example : {β : Type u} {α : Type v} {γ : Type w} [AddZeroClass β] [AddCommMonoid γ] (f : α → β →+ γ) (s : Finset α) (b : β) : (Σ x in s, f x) b = Σ x in s, f x b "]},
 {"Name": "Product",
  "Symbol": "`∏_,_`",
  "Command": "\\prod",
  "Explanation": "Denotes finite summation, `Finset.prod`. There are two uses : a. `∏ i in s,f i` denotes the summation over a set `s` of a space `α`, with `f` having domain `α`. We require `s` to be `Finset α`; b. `∏ i : α,f i` requires `Fintype α`.",
  "Link": "https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Basic.html#Finset.prod",
  "Examples": ["example : {α : Type v} {s : Finset α} {m : ℕ} {f : α → ℕ} (h₁ : ∀ x ∈ s, f x = m) :
  ∏ x in s, f x = m ^ (card s)",
    "example : {β : Type u} {α : Type v} {γ : Type w} [Fintype α] [CommMonoid β] [CommMonoid γ] {G : Type u_2} [MonoidHomClass G β γ] (g : G) (f : α → β) : g (∏ x, f x) = ∏ x, g (f x)",
    "example : {β : Type u} {α : Type v} {γ : Type w} [MulOneClass β] [CommMonoid γ] (f : α → β →* γ) (s : Finset α) (b : β) : (∏ x in s, f x) b = ∏ x in s, f x b "]},
  {"Name": "Subset",
  "Symbol": "`_⊆_`",
  "Command": "\\sub",
  "Explanation": "Denotes the subset relation, `HasSubset`. `a ⊆ b` implies `a` is a subset of `b`.",
  "Link": "https://leanprover-community.github.io/mathlib4_docs/Std/Classes/SetNotation.html#HasSubset",
  "Examples": ["example {α : Type v} {s : Set α} : s ⊆ s",
    "example {α : Type u} {s : Set α} : Set.univ ⊆ s ↔ s = Set.univ ",
    "example {α : Type u_1} {s : Set α} {t : Set α} : ¬s ⊆ t ↔ ∃ x, x ∈ s ∧ ¬x ∈ t"]},
  {"Name": "Addition",
  "Symbol": "`_+_`",
  "Command": "+",
  "Explanation": "Denotes the addition function, `HAdd`. `a + b` denotes the addition of `a` and `b` over any Types on which addition is defined. Note that `a`, `b` and `a + b` need not have the same type.",
  "Link": "https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#HAdd",
  "Examples": ["example (a : Int) : a + 0 = a",
    "example {G : Type u_1} [AddSemigroup G] (a : G) (b : G) (c : G) : a + b + c = a + (b + c)",
    "example {α : Type u_2} [Add α] {s : Set α} {t : Set α} : s + t = ∅ ↔ s = ∅ ∨ t = ∅ "]},
  {"Name": "Eventually equal",
  "Symbol": "`_=ᶠ[_]_`",
  "Command": "=\\^f",
  "Explanation": "Given functions `f` and `g` from `α` to `β`, and a filter `l` on `α`, `f=ᶠ[l]g` means that the set of `x` such that `f x = g x` belongs to `l`.",
  "Link": "https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.EventuallyEq",
  "Examples": ["example {α : Type u} {s : Set α} {l : Filter α} : s =ᶠ[l] Set.univ ↔ s ∈ l",
    "example {α : Type u} {s : Set α} {l : Filter α} : s =ᶠ[l] Set.univ ↔ s ∈ l",
    "example {α : Type u} {β : Type v} {l : Filter α} {f : α → β} {g : α → β} {h : α → β} (H₁ : f =ᶠ[l] g) (H₂ : g =ᶠ[l] h) : f =ᶠ[l] h"]},
  {"Name": "Multiplicative opposite",
  "Symbol": "`_ᵐᵒᵖ`",
  "Command": "\\mop",
  "Explanation": "Denotes the multiplicative opposite of a type. This is used to give a topological space structure to the units of a topological space. It comes equipped with two maps : `op : α → αᵐᵒᵖ` and `unop : αᵐᵒᵖ → α` which are inverses of each other.",
  "Link": "https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Opposites.html#MulOpposite",
  "Examples": ["example (α : Type u) [Nontrivial α] : Nontrivial αᵐᵒᵖ",
    "example {α : Type u_1} : α ≃ αᵐᵒᵖ",
    "example {α : Type u_1} {x : αᵐᵒᵖ} {y : αᵐᵒᵖ} : MulOpposite.unop x = MulOpposite.unop y ↔ x = y"]}
]
