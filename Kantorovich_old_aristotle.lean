/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean Toolchain version: leanprover/lean4:v4.20.0-rc5
Mathlib version: d62eab0cc36ea522904895389c301cf8d844fd69 (May 9, 2025)
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false
set_option linter.dupNamespace false
set_option linter.unusedSimpArgs false
set_option linter.unusedVariables false

noncomputable section

noncomputable section

open Real Topology Filter Set

namespace NewtonKantorovich

variable {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

def Phi (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x : E) : E := x - T (f x)

def newton_iteration (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) : ‚Ñï ‚Üí E
| 0 => x‚ÇÄ
| (n + 1) => let x_n := newton_iteration f T x‚ÇÄ n; x_n - T (f x_n)

lemma taylor_bound_quadratic
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (f' : E ‚Üí E ‚ÜíL[‚Ñù] F) (S : Set E) (L : ‚Ñù) (x y : E)
  (hS : Convex ‚Ñù S) (hx : x ‚àà S) (hy : y ‚àà S)
  (hf : ‚àÄ z ‚àà S, HasFDerivAt f (f' z) z)
  (hL : ‚àÄ z ‚àà S, ‚àÄ w ‚àà S, ‚Äñf' z - f' w‚Äñ ‚â§ L * ‚Äñz - w‚Äñ) :
  ‚Äñf y - f x - f' x (y - x)‚Äñ ‚â§ L / 2 * ‚Äñy - x‚Äñ ^ 2 := by
    -- Applying the fundamental theorem of calculus, we get:
    have h_ftc : ‚à´ (t : ‚Ñù) in (0 : ‚Ñù)..1, (f' (x + t ‚Ä¢ (y - x)) - f' x) (y - x) = f y - f x - (f' x) (y - x) := by
      have h_ftc : ‚à´ t in (0 : ‚Ñù)..1, deriv (fun t => f (x + t ‚Ä¢ (y - x))) t = f y - f x := by
        rw [ intervalIntegral.integral_deriv_eq_sub ] <;> norm_num;
        ¬∑ intro t ht‚ÇÅ ht‚ÇÇ
          have h_diff : DifferentiableAt ‚Ñù f (x + t ‚Ä¢ (y - x)) := by
            refine' ( hf _ _ |> HasFDerivAt.differentiableAt );
            exact hS.add_smul_sub_mem hx hy ( by constructor <;> linarith );
          exact h_diff.comp t ( DifferentiableAt.add ( differentiableAt_const _ ) ( differentiableAt_id.smul_const _ ) );
        ¬∑ -- The derivative of the function $t \mapsto f(x + t \cdot (y - x))$ is given by the chain rule and is continuous.
          have h_deriv_cont : ContinuousOn (fun t : ‚Ñù => f' (x + t ‚Ä¢ (y - x)) (y - x)) (Set.Icc 0 1) := by
            -- The derivative of the function $t \mapsto f(x + t \cdot (y - x))$ is given by the chain rule and is continuous because $f'$ is continuous.
            have h_cont : ContinuousOn (fun z => f' z) S := by
              rw [ Metric.continuousOn_iff ];
              exact fun z hz Œµ Œµ_pos => ‚ü® Œµ / ( Max.max L 1 ), div_pos Œµ_pos ( by positivity ), fun w hw hwz => by rw [ dist_eq_norm ] at hwz ‚ä¢; exact lt_of_le_of_lt ( hL _ hw _ hz ) ( by rw [ lt_div_iff‚ÇÄ ( by positivity ) ] at hwz; nlinarith [ norm_nonneg ( w - z ), le_max_left L 1, le_max_right L 1 ] ) ‚ü©;
            refine' ContinuousOn.comp ( h_cont.clm_apply continuousOn_const ) _ _;
            ¬∑ fun_prop;
            ¬∑ exact fun t ht => hS.add_smul_sub_mem hx hy ‚ü® ht.1, ht.2 ‚ü©;
          have h_deriv_eq : ‚àÄ t ‚àà Set.Ioo (0 : ‚Ñù) 1, deriv (fun t => f (x + t ‚Ä¢ (y - x))) t = f' (x + t ‚Ä¢ (y - x)) (y - x) := by
            field_simp;
            intro t ht‚ÇÅ ht‚ÇÇ; rw [ deriv ] ; have := hf ( x + t ‚Ä¢ ( y - x ) ) ( by exact hS.add_smul_sub_mem hx hy <| by constructor <;> linarith ) ; have := this.fderiv; aesop;
            convert HasDerivAt.deriv ( HasFDerivAt.hasDerivAt ( this_1.comp t ( HasFDerivAt.add ( hasFDerivAt_const _ _ ) ( HasFDerivAt.smul ( hasFDerivAt_id t ) ( hasFDerivAt_const _ _ ) ) ) ) ) using 1 ; simp +decide [ this ];
          rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le zero_le_one ];
          rw [ MeasureTheory.integrableOn_congr_fun ( fun t ht => h_deriv_eq t ht ) measurableSet_Ioo ] ; exact h_deriv_cont.integrableOn_Icc.mono_set <| Set.Ioo_subset_Icc_self;
      -- By the properties of the derivative, we can split the integral into two parts:
      have h_split : ‚à´ t in (0 : ‚Ñù)..1, (f' (x + t ‚Ä¢ (y - x)) - f' x) (y - x) = (‚à´ t in (0 : ‚Ñù)..1, f' (x + t ‚Ä¢ (y - x)) (y - x)) - (‚à´ t in (0 : ‚Ñù)..1, f' x (y - x)) := by
        rw [ ‚Üê intervalIntegral.integral_sub ];
        ¬∑ simp +decide [ sub_smul ];
        ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' ContinuousOn.comp ( show ContinuousOn ( fun z => f' z ( y - x ) ) S from _ ) ( show ContinuousOn ( fun t : ‚Ñù => x + t ‚Ä¢ ( y - x ) ) ( Set.uIcc 0 1 ) from _ ) fun t ht => _;
          ¬∑ refine' ContinuousOn.comp ( show ContinuousOn ( fun z => ( z : E ‚ÜíL[‚Ñù] F ) ( y - x ) ) ( Set.range f' ) from _ ) ( show ContinuousOn f' S from _ ) fun z hz => _;
            ¬∑ exact Continuous.continuousOn ( by continuity );
            ¬∑ rw [ Metric.continuousOn_iff ];
              exact fun z hz Œµ Œµpos => ‚ü® Œµ / ( Max.max L 1 ), div_pos Œµpos ( by positivity ), fun w hw hzw => by rw [ dist_eq_norm ] at *; exact lt_of_le_of_lt ( hL _ hw _ hz ) ( by rw [ lt_div_iff‚ÇÄ ( by positivity ) ] at *; nlinarith [ le_max_left L 1, le_max_right L 1, norm_nonneg ( w - z ) ] ) ‚ü©;
            ¬∑ exact Set.mem_range_self _;
          ¬∑ fun_prop;
          ¬∑ aesop;
            exact hS.add_smul_sub_mem hx hy ( by constructor <;> linarith );
        ¬∑ norm_num;
      have h_deriv : ‚àÄ t ‚àà Set.Icc (0 : ‚Ñù) 1, deriv (fun t => f (x + t ‚Ä¢ (y - x))) t = f' (x + t ‚Ä¢ (y - x)) (y - x) := by
        intro t ht;
        convert HasDerivAt.deriv ( HasFDerivAt.hasDerivAt ( hf ( x + t ‚Ä¢ ( y - x ) ) ?_ |> HasFDerivAt.comp t <| HasFDerivAt.add ( hasFDerivAt_const _ _ ) <| HasFDerivAt.smul ( hasFDerivAt_id t ) <| hasFDerivAt_const _ _ ) ) using 1;
        ¬∑ simp +decide;
        ¬∑ exact hS.add_smul_sub_mem hx hy ( by aesop );
      rw [ h_split, intervalIntegral.integral_congr fun t ht => h_deriv t <| by simpa using ht ] at * ; aesop;
    rw [ ‚Üê h_ftc, intervalIntegral.integral_of_le zero_le_one ];
    -- Applying the Lipschitz condition to the integrand:
    have h_integrand_bound : ‚àÄ t ‚àà Set.Icc (0 : ‚Ñù) 1, ‚Äñ(f' (x + t ‚Ä¢ (y - x)) - f' x) (y - x)‚Äñ ‚â§ L * ‚Äñy - x‚Äñ^2 * t := by
      intro t ht
      have h_integrand_bound : ‚Äñ(f' (x + t ‚Ä¢ (y - x)) - f' x)‚Äñ ‚â§ L * ‚Äñy - x‚Äñ * t := by
        convert hL ( x + t ‚Ä¢ ( y - x ) ) _ x hx using 1 <;> norm_num [ norm_smul, abs_of_nonneg ht.1 ] ; ring;
        exact hS.add_smul_sub_mem hx hy ( by aesop );
      exact le_trans ( ContinuousLinearMap.le_opNorm _ _ ) ( by convert mul_le_mul_of_nonneg_right h_integrand_bound ( norm_nonneg ( y - x ) ) using 1 ; ring );
    refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
    refine' fun t => L * ‚Äñy - x‚Äñ ^ 2 * t;
    ¬∑ exact Filter.Eventually.of_forall fun t => norm_nonneg _;
    ¬∑ exact Continuous.integrableOn_Ioc ( by continuity );
    ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_integrand_bound t <| Set.Ioc_subset_Icc_self ht;
    ¬∑ rw [ ‚Üê intervalIntegral.integral_of_le ] <;> norm_num [ mul_comm ] ; ring_nf ; norm_num


namespace NewtonKantorovich

lemma Phi_sub_Phi_x0_eq
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ x : E)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E) :
  Phi f T x - Phi f T x‚ÇÄ = - T (f x - f x‚ÇÄ - fderiv ‚Ñù f x‚ÇÄ (x - x‚ÇÄ)) := by
    unfold NewtonKantorovich.Phi; simp +decide [ ContinuousLinearMap.ext_iff ] at h_left_inv ‚ä¢; aesop;
    abel1

end NewtonKantorovich


namespace NewtonKantorovich

lemma norm_Phi_sub_Phi_x0
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ x : E) (L : ‚Ñù)
  (S : Set E) (hS : Convex ‚Ñù S) (hx‚ÇÄ : x‚ÇÄ ‚àà S) (hx : x ‚àà S)
  (hf_diff : ‚àÄ z ‚àà S, HasFDerivAt f (fderiv ‚Ñù f z) z)
  (h_lip : ‚àÄ z ‚àà S, ‚àÄ w ‚àà S, ‚Äñfderiv ‚Ñù f z - fderiv ‚Ñù f w‚Äñ ‚â§ L * ‚Äñz - w‚Äñ)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E) :
  ‚ÄñPhi f T x - Phi f T x‚ÇÄ‚Äñ ‚â§ ‚ÄñT‚Äñ * (L / 2 * ‚Äñx - x‚ÇÄ‚Äñ ^ 2) := by
    -- Apply the definition of Phi and the left inverse property of T.
    have h_diff : NewtonKantorovich.Phi f T x - NewtonKantorovich.Phi f T x‚ÇÄ = -T (f x - f x‚ÇÄ - fderiv ‚Ñù f x‚ÇÄ (x - x‚ÇÄ)) := by
      exact Phi_sub_Phi_x0_eq f T x‚ÇÄ x h_left_inv;
    -- Apply the property of the operator norm: ‚ÄñT y‚Äñ ‚â§ ‚ÄñT‚Äñ * ‚Äñy‚Äñ.
    have h_op_norm : ‚ÄñT (f x - f x‚ÇÄ - fderiv ‚Ñù f x‚ÇÄ (x - x‚ÇÄ))‚Äñ ‚â§ ‚ÄñT‚Äñ * ‚Äñf x - f x‚ÇÄ - fderiv ‚Ñù f x‚ÇÄ (x - x‚ÇÄ)‚Äñ := by
      exact T.le_opNorm _;
    -- Use the quadratic remainder bound to bound ‚Äñf x - f x‚ÇÄ - fderiv ‚Ñù f x‚ÇÄ (x - x‚ÇÄ)‚Äñ.
    have h_quad_bound : ‚Äñf x - f x‚ÇÄ - fderiv ‚Ñù f x‚ÇÄ (x - x‚ÇÄ)‚Äñ ‚â§ L / 2 * ‚Äñx - x‚ÇÄ‚Äñ^2 := by
      apply taylor_bound_quadratic f (fun z => fderiv ‚Ñù f z) S L x‚ÇÄ x hS hx‚ÇÄ hx (fun z hz => hf_diff z hz) (fun z hz w hw => h_lip z hz w hw);
    simpa only [ h_diff, norm_neg ] using h_op_norm.trans ( mul_le_mul_of_nonneg_left h_quad_bound ( norm_nonneg _ ) )

end NewtonKantorovich


lemma rho_inequality
  (M L Œ∑ h : ‚Ñù) (h_h : h = M * L * Œ∑) (h_pos : 0 < M * L) (h_le : h ‚â§ 1 / 2)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  Œ∑ + M * L / 2 * œÅ ^ 2 ‚â§ œÅ := by
    -- Substitute œÅ from h_œÅ into the inequality and multiply both sides by (M*L) to eliminate the denominator.
    have h_sub : Œ∑ * (M * L) + (1 - Real.sqrt (1 - 2 * h))^2 / 2 ‚â§ 1 - Real.sqrt (1 - 2 * h) := by
      nlinarith [ Real.sqrt_nonneg ( 1 - 2 * h ), Real.mul_self_sqrt ( show 0 ‚â§ 1 - 2 * h by linarith ) ];
    rw [ h_œÅ, div_pow ];
    rw [ le_div_iff‚ÇÄ ] <;> nlinarith [ mul_div_cancel‚ÇÄ ( ( 1 - Real.sqrt ( 1 - 2 * h ) ) ^ 2 ) ( ne_of_gt ( sq_pos_of_pos h_pos ) ) ]


namespace NewtonKantorovich

lemma Phi_maps_closed_ball
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) (L œÅ Œ∑ M h : ‚Ñù)
  (S : Set E) (hS : Convex ‚Ñù S) (hx‚ÇÄ : x‚ÇÄ ‚àà S)
  (h_open : IsOpen S)
  (h_ball_subset : Metric.closedBall x‚ÇÄ œÅ ‚äÜ S)
  (hf_diff : ‚àÄ z ‚àà S, HasFDerivAt f (fderiv ‚Ñù f z) z)
  (h_lip : ‚àÄ z ‚àà S, ‚àÄ w ‚àà S, ‚Äñfderiv ‚Ñù f z - fderiv ‚Ñù f w‚Äñ ‚â§ L * ‚Äñz - w‚Äñ)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_M : M = ‚ÄñT‚Äñ) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ) (h_h : h = M * L * Œ∑)
  (h_pos : 0 < M * L) (h_le : h ‚â§ 1 / 2)
  (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  MapsTo (Phi f T) (Metric.closedBall x‚ÇÄ œÅ) (Metric.closedBall x‚ÇÄ œÅ) := by
    -- By definition of $Phi$, we know that for any $x \in \overline{B}(x_0, \rho)$, $\Phi(x) \in \overline{B}(x_0, \rho)$.
    intros x hx
    have h_Phi_mem : ‚ÄñPhi f T x - x‚ÇÄ‚Äñ ‚â§ Œ∑ + M * L / 2 * ‚Äñx - x‚ÇÄ‚Äñ ^ 2 := by
      -- Apply the norm_Phi_sub_Phi_x0 lemma to get the bound on ‚ÄñPhi(x) - Phi(x‚ÇÄ)‚Äñ.
      have h_norm_Phi_sub_Phi_x0 : ‚ÄñPhi f T x - Phi f T x‚ÇÄ‚Äñ ‚â§ ‚ÄñT‚Äñ * (L / 2) * ‚Äñx - x‚ÇÄ‚Äñ ^ 2 := by
        convert norm_Phi_sub_Phi_x0 f T x‚ÇÄ x L S hS hx‚ÇÄ ( h_ball_subset hx ) hf_diff h_lip h_left_inv using 1 ; ring;
      -- Since $\|\Phi(x_0) - x_0\| = \|x_0 - T(f(x_0)) - x_0\| = \|T(f(x_0))\| = \eta$, we have $\|\Phi(x) - x_0\| \le \eta + \frac{ML}{2} \|x - x_0\|^2$.
      have h_norm_Phi_x0 : ‚ÄñPhi f T x‚ÇÄ - x‚ÇÄ‚Äñ = ‚ÄñT (f x‚ÇÄ)‚Äñ := by
        simp [NewtonKantorovich.Phi];
      have := norm_add_le ( NewtonKantorovich.Phi f T x - NewtonKantorovich.Phi f T x‚ÇÄ ) ( NewtonKantorovich.Phi f T x‚ÇÄ - x‚ÇÄ ) ; aesop; nlinarith;
    -- Apply the rho_inequality lemma to conclude that Œ∑ + (M * L / 2) * œÅ¬≤ ‚â§ œÅ.
    have h_rho_ineq : Œ∑ + (M * L / 2) * œÅ ^ 2 ‚â§ œÅ := by
      convert rho_inequality M L Œ∑ h h_h h_pos h_le œÅ h_œÅ using 1;
    simp_all +decide [ dist_eq_norm ];
    exact h_Phi_mem.trans ( le_trans ( add_le_add_left ( mul_le_mul_of_nonneg_left ( pow_le_pow_left‚ÇÄ ( norm_nonneg _ ) hx 2 ) ( by positivity ) ) _ ) h_rho_ineq )

end NewtonKantorovich


namespace NewtonKantorovich

lemma Phi_derivative
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (z : E)
  (hf_diff : HasFDerivAt f (fderiv ‚Ñù f z) z) :
  HasFDerivAt (Phi f T) (ContinuousLinearMap.id ‚Ñù E - T.comp (fderiv ‚Ñù f z)) z := by
    exact HasFDerivAt.sub ( hasFDerivAt_id z ) ( T.hasFDerivAt.comp z hf_diff )

lemma Phi_derivative_bound
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ z : E) (L M : ‚Ñù)
  (S : Set E) (hS : Convex ‚Ñù S) (hx‚ÇÄ : x‚ÇÄ ‚àà S) (hz : z ‚àà S)
  (hf_diff : HasFDerivAt f (fderiv ‚Ñù f z) z)
  (h_lip : ‚àÄ w ‚àà S, ‚Äñfderiv ‚Ñù f w - fderiv ‚Ñù f x‚ÇÄ‚Äñ ‚â§ L * ‚Äñw - x‚ÇÄ‚Äñ)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_M : M = ‚ÄñT‚Äñ) :
  ‚ÄñContinuousLinearMap.id ‚Ñù E - T.comp (fderiv ‚Ñù f z)‚Äñ ‚â§ M * L * ‚Äñz - x‚ÇÄ‚Äñ := by
    -- By definition of $DŒ¶$, we have $DŒ¶(z) = I - T \circ Df(z)$.
    have h_DPhi : ContinuousLinearMap.id ‚Ñù E - T.comp (fderiv ‚Ñù f z) = T.comp (fderiv ‚Ñù f x‚ÇÄ - fderiv ‚Ñù f z) := by
      ext; simp [ContinuousLinearMap.comp_apply, ContinuousLinearMap.sub_apply];
      exact Eq.symm ( by simpa using congr_arg ( fun f => f ‚Äπ_‚Ä∫ ) h_left_inv );
    refine' h_DPhi ‚ñ∏ le_trans ( ContinuousLinearMap.opNorm_comp_le _ _ ) _;
    simpa only [ mul_assoc, h_M, norm_sub_rev ] using mul_le_mul_of_nonneg_left ( h_lip _ hz ) ( norm_nonneg T )

end NewtonKantorovich


namespace NewtonKantorovich

lemma Phi_lipschitz
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) (L M œÅ : ‚Ñù)
  (S : Set E) (hS : Convex ‚Ñù S) (hx‚ÇÄ : x‚ÇÄ ‚àà S)
  (h_ball_subset : Metric.closedBall x‚ÇÄ œÅ ‚äÜ S)
  (hf_diff : ‚àÄ z ‚àà S, HasFDerivAt f (fderiv ‚Ñù f z) z)
  (h_lip : ‚àÄ w ‚àà S, ‚Äñfderiv ‚Ñù f w - fderiv ‚Ñù f x‚ÇÄ‚Äñ ‚â§ L * ‚Äñw - x‚ÇÄ‚Äñ)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_M : M = ‚ÄñT‚Äñ) (h_L_nonneg : 0 ‚â§ L) (h_œÅ_nonneg : 0 ‚â§ œÅ) :
  LipschitzOnWith (Real.toNNReal (M * L * œÅ)) (Phi f T) (Metric.closedBall x‚ÇÄ œÅ) := by
    -- We want to show that $\Phi$ is Lipschitz with constant $K = ML\rho$ on $\overline{B}(x_0, \rho)$.
    have h_lip_bound : ‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, ‚Äñfderiv ‚Ñù (Phi f T) z‚Äñ ‚â§ M * L * œÅ := by
      intro z hz
      have h_deriv : ‚Äñfderiv ‚Ñù (Phi f T) z‚Äñ ‚â§ M * L * ‚Äñz - x‚ÇÄ‚Äñ := by
        -- By definition of $Phi$, we know that its derivative at $z$ is $I - T(fderiv f z)$.
        have h_deriv : fderiv ‚Ñù (Phi f T) z = ContinuousLinearMap.id ‚Ñù E - T.comp (fderiv ‚Ñù f z) := by
          exact HasFDerivAt.fderiv ( NewtonKantorovich.Phi_derivative f T z ( hf_diff z ( h_ball_subset hz ) ) );
        -- Apply the lemma Phi_derivative_bound with the given conditions.
        have := Phi_derivative_bound f T x‚ÇÄ z L M S hS hx‚ÇÄ (h_ball_subset hz) (hf_diff z (h_ball_subset hz)) (fun w hw => h_lip w hw) h_left_inv h_M;
        aesop;
      -- Since $z \in \overline{B}(x_0, \rho)$, we have $\|z - x_0\| \leq \rho$.
      have h_dist : ‚Äñz - x‚ÇÄ‚Äñ ‚â§ œÅ := by
        simpa [ dist_eq_norm ] using hz;
      exact h_deriv.trans ( mul_le_mul_of_nonneg_left h_dist ( mul_nonneg ( h_M.symm ‚ñ∏ norm_nonneg _ ) h_L_nonneg ) );
    apply_rules [ lipschitzOnWith_iff_norm_sub_le.mpr ];
    -- Apply the Mean Value Inequality to conclude the Lipschitz condition.
    have h_mean_value : ‚àÄ x y : E, x ‚àà Metric.closedBall x‚ÇÄ œÅ ‚Üí y ‚àà Metric.closedBall x‚ÇÄ œÅ ‚Üí ‚ÄñNewtonKantorovich.Phi f T x - NewtonKantorovich.Phi f T y‚Äñ ‚â§ (M * L * œÅ) * ‚Äñx - y‚Äñ := by
      have h_convex : Convex ‚Ñù (Metric.closedBall x‚ÇÄ œÅ) := by
        -- The closed ball is convex because for any two points $z, w \in \overline{B}(x_0, \rho)$ and any $t \in [0, 1]$, the point $tz + (1-t)w$ is also in $\overline{B}(x_0, \rho)$.
        apply convex_closedBall
      have := @Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le;
      intro x y hx hy;
      rw [ norm_sub_rev ];
      convert this ( fun z hz => HasFDerivAt.hasFDerivWithinAt ( show HasFDerivAt ( NewtonKantorovich.Phi f T ) ( fderiv ‚Ñù ( NewtonKantorovich.Phi f T ) z ) z from ?_ ) ) ( fun z hz => h_lip_bound z hz ) h_convex hy hx using 1;
      ¬∑ rw [ norm_sub_rev ];
      ¬∑ exact DifferentiableAt.hasFDerivAt ( by exact DifferentiableAt.sub ( differentiableAt_id ) ( T.differentiableAt.comp _ ( hf_diff _ ( h_ball_subset hz ) |> HasFDerivAt.differentiableAt ) ) );
    intro x hx y hy; rw [ Real.toNNReal_of_nonneg ( mul_nonneg ( mul_nonneg ( h_M.symm ‚ñ∏ norm_nonneg _ ) h_L_nonneg ) h_œÅ_nonneg ) ] ; exact h_mean_value x y hx hy;

end NewtonKantorovich


lemma ML_rho_lt_one
  (M L h : ‚Ñù) (h_pos : 0 < M * L) (h_lt : h < 1 / 2)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  M * L * œÅ < 1 := by
    rw [ h_œÅ, mul_div_cancel‚ÇÄ _ h_pos.ne' ] ; nlinarith [ Real.sqrt_nonneg ( 1 - 2 * h ), Real.sq_sqrt ( by linarith : 0 ‚â§ 1 - 2 * h ) ]


namespace NewtonKantorovich

lemma Phi_lipschitz_on_ball
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) (L M œÅ : ‚Ñù)
  (S : Set E) (hS : Convex ‚Ñù S) (hx‚ÇÄ : x‚ÇÄ ‚àà S)
  (h_ball_subset : Metric.closedBall x‚ÇÄ œÅ ‚äÜ S)
  (hf_diff : ‚àÄ z ‚àà S, HasFDerivAt f (fderiv ‚Ñù f z) z)
  (h_lip : ‚àÄ w ‚àà S, ‚Äñfderiv ‚Ñù f w - fderiv ‚Ñù f x‚ÇÄ‚Äñ ‚â§ L * ‚Äñw - x‚ÇÄ‚Äñ)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_M : M = ‚ÄñT‚Äñ) (h_L_nonneg : 0 ‚â§ L) (h_œÅ_nonneg : 0 ‚â§ œÅ) :
  LipschitzOnWith (Real.toNNReal (M * L * œÅ)) (Phi f T) (Metric.closedBall x‚ÇÄ œÅ) := by
    bound;
    convert NewtonKantorovich.Phi_lipschitz f T x‚ÇÄ L _ œÅ S hS hx‚ÇÄ h_ball_subset hf_diff h_lip h_left_inv rfl h_L_nonneg h_œÅ_nonneg using 1

end NewtonKantorovich


lemma fixed_point_of_lipschitz_on_closed_ball
  {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  (g : E ‚Üí E) (x‚ÇÄ : E) (r : ‚Ñù) (K : NNReal)
  (h_maps : MapsTo g (Metric.closedBall x‚ÇÄ r) (Metric.closedBall x‚ÇÄ r))
  (h_lip : LipschitzOnWith K g (Metric.closedBall x‚ÇÄ r))
  (h_K : K < 1) (hr : 0 ‚â§ r) :
  ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ r,
    g x_star = x_star ‚àß
    (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ r, g z = z ‚Üí z = x_star) ‚àß
    Filter.Tendsto (fun n => g^[n] x‚ÇÄ) Filter.atTop (nhds x_star) := by
      -- The sequence $(x_n)$ is Cauchy.
      have h_cauchy : CauchySeq (fun n => g^[n] x‚ÇÄ) := by
        -- By the properties of the contraction mapping, the distance between consecutive terms of the sequence decreases exponentially.
        have h_dist : ‚àÄ n, dist (g^[n] x‚ÇÄ) (g^[n+1] x‚ÇÄ) ‚â§ K^n * dist x‚ÇÄ (g x‚ÇÄ) := by
          intro n;
          induction' n with n ih;
          ¬∑ simp +decide;
          ¬∑ have := h_lip.norm_sub_le ( show g^[n] x‚ÇÄ ‚àà Metric.closedBall x‚ÇÄ r from ?_ ) ( show g^[n + 1] x‚ÇÄ ‚àà Metric.closedBall x‚ÇÄ r from ?_ );
            ¬∑ simp_all +decide [ dist_eq_norm, pow_succ', mul_assoc, Function.iterate_succ_apply' ];
              exact this.trans ( mul_le_mul_of_nonneg_left ih <| NNReal.coe_nonneg _ );
            ¬∑ exact Nat.recOn n ( by simpa ) fun n ihn => by simpa only [ Function.iterate_succ_apply' ] using h_maps ihn;
            ¬∑ exact Nat.recOn n ( by simpa using h_maps ( Metric.mem_closedBall_self hr ) ) fun n ihn => by simpa only [ Function.iterate_succ_apply' ] using h_maps ihn;
        fapply cauchySeq_of_le_geometric;
        exacts [ ‚ÜëK, Dist.dist x‚ÇÄ ( g x‚ÇÄ ), mod_cast h_K, fun n => by simpa only [ mul_comm ] using h_dist n ];
      -- Let $x_*$ be the limit of the sequence $(x_n)$.
      obtain ‚ü®x_star, hx_star‚ü© : ‚àÉ x_star, Filter.Tendsto (fun n => g^[n] x‚ÇÄ) Filter.atTop (ùìù x_star) ‚àß x_star ‚àà Metric.closedBall x‚ÇÄ r := by
        obtain ‚ü® x_star, hx_star ‚ü© := cauchySeq_tendsto_of_complete h_cauchy;
        exact ‚ü® x_star, hx_star, by exact mem_closedBall_iff_norm.mpr ( le_of_tendsto' ( Filter.Tendsto.norm ( hx_star.sub_const x‚ÇÄ ) ) fun n => by simpa using mem_closedBall_iff_norm.mp ( show g^[n] x‚ÇÄ ‚àà Metric.closedBall x‚ÇÄ r from by exact Nat.recOn n ( by simpa ) fun n ihn => by simpa only [ Function.iterate_succ_apply' ] using h_maps ihn ) ) ‚ü©;
      -- Since $g$ is continuous on the closed ball, we have $g(x_*) = x_*$.
      have h_fixed : g x_star = x_star := by
        have h_fixed : Filter.Tendsto (fun n => g (g^[n] x‚ÇÄ)) Filter.atTop (ùìù (g x_star)) := by
          have := h_lip.continuousOn;
          exact this.continuousWithinAt hx_star.2 |> fun h => h.tendsto.comp <| Filter.tendsto_inf.mpr ‚ü® hx_star.1, Filter.tendsto_principal.mpr <| Filter.eventually_atTop.mpr ‚ü® 0, fun n hn => by exact Nat.recOn n ( by simpa ) fun n ihn => by simpa only [ Function.iterate_succ_apply' ] using h_maps ihn ‚ü© ‚ü©;
        exact tendsto_nhds_unique h_fixed ( by simpa only [ ‚Üê Function.iterate_succ_apply' ] using hx_star.1.comp ( Filter.tendsto_add_atTop_nat 1 ) );
      refine' ‚ü® x_star, hx_star.2, h_fixed, _, hx_star.1 ‚ü©;
      intro z hz hz';
      have := h_lip.dist_le_mul z ( show z ‚àà Metric.closedBall x‚ÇÄ r from hz ) x_star ( show x_star ‚àà Metric.closedBall x‚ÇÄ r from hx_star.2 ) ; simp_all +decide [ dist_eq_norm ] ;
      exact sub_eq_zero.mp ( norm_le_zero_iff.mp ( by nlinarith [ show ( K : ‚Ñù ) < 1 from h_K ] ) )


namespace NewtonKantorovich

lemma Phi_maps_closed_ball_new
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) (L œÅ Œ∑ M h : ‚Ñù)
  (S : Set E) (hS : Convex ‚Ñù S) (hx‚ÇÄ : x‚ÇÄ ‚àà S)
  (h_ball_subset : Metric.closedBall x‚ÇÄ œÅ ‚äÜ S)
  (hf_diff : ‚àÄ z ‚àà S, HasFDerivAt f (fderiv ‚Ñù f z) z)
  (h_lip : ‚àÄ z ‚àà S, ‚àÄ w ‚àà S, ‚Äñfderiv ‚Ñù f z - fderiv ‚Ñù f w‚Äñ ‚â§ L * ‚Äñz - w‚Äñ)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_M : M = ‚ÄñT‚Äñ) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ) (h_h : h = M * L * Œ∑)
  (h_pos : 0 < M * L) (h_le : h ‚â§ 1 / 2)
  (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  MapsTo (Phi f T) (Metric.closedBall x‚ÇÄ œÅ) (Metric.closedBall x‚ÇÄ œÅ) := by
    -- By combining the results from norm_Phi_sub_Phi_x0 and rho_inequality, we can conclude that Œ¶ maps the closed ball into itself.
    have h_maps : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ œÅ, ‚ÄñPhi f T x - x‚ÇÄ‚Äñ ‚â§ œÅ := by
      -- By combining the results from norm_Phi_sub_Phi_x0 and rho_inequality, we can conclude that ‚ÄñŒ¶(x) - x‚ÇÄ‚Äñ ‚â§ œÅ.
      intros x hx
      have h_norm : ‚ÄñPhi f T x - x‚ÇÄ‚Äñ ‚â§ ‚ÄñT‚Äñ * (L / 2) * ‚Äñx - x‚ÇÄ‚Äñ^2 + ‚ÄñT (f x‚ÇÄ)‚Äñ := by
        have h_norm : ‚ÄñPhi f T x - x‚ÇÄ‚Äñ ‚â§ ‚ÄñPhi f T x - Phi f T x‚ÇÄ‚Äñ + ‚ÄñPhi f T x‚ÇÄ - x‚ÇÄ‚Äñ := by
          convert norm_add_le ( NewtonKantorovich.Phi f T x - NewtonKantorovich.Phi f T x‚ÇÄ ) ( NewtonKantorovich.Phi f T x‚ÇÄ - x‚ÇÄ ) using 2 ; abel_nf;
        convert h_norm.trans ( add_le_add ( norm_Phi_sub_Phi_x0 f T x‚ÇÄ x L S hS hx‚ÇÄ ( h_ball_subset hx ) hf_diff h_lip h_left_inv ) ( show ‚ÄñNewtonKantorovich.Phi f T x‚ÇÄ - x‚ÇÄ‚Äñ ‚â§ ‚ÄñT ( f x‚ÇÄ )‚Äñ by simp [ NewtonKantorovich.Phi ] ) ) using 1 ; ring;
      -- Substitute ‚Äñx - x‚ÇÄ‚Äñ ‚â§ œÅ into the inequality from h_norm.
      have h_subst : ‚ÄñPhi f T x - x‚ÇÄ‚Äñ ‚â§ ‚ÄñT‚Äñ * (L / 2) * œÅ^2 + ‚ÄñT (f x‚ÇÄ)‚Äñ := by
        refine' le_trans h_norm _;
        -- Since $x \in \overline{B}(x_0, \rho)$, we have $\|x - x_0\| \leq \rho$ by definition of the closed ball.
        have h_dist : ‚Äñx - x‚ÇÄ‚Äñ ‚â§ œÅ := by
          simpa [ dist_eq_norm ] using hx;
        gcongr;
        exact mul_nonneg ( norm_nonneg _ ) ( div_nonneg ( by nlinarith [ norm_nonneg T ] ) zero_le_two );
      have := @rho_inequality M L Œ∑ h h_h h_pos h_le œÅ h_œÅ ; aesop;
      linarith;
    exact fun x hx => mem_closedBall_iff_norm.mpr ( h_maps x hx )

end NewtonKantorovich


lemma rho_nonneg
  (M L h : ‚Ñù) (h_nonneg : 0 ‚â§ h) (h_le : h ‚â§ 1 / 2) (h_ML_pos : 0 < M * L)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  0 ‚â§ œÅ := by
    exact h_œÅ.symm ‚ñ∏ div_nonneg ( sub_nonneg.2 <| Real.sqrt_le_iff.2 ‚ü® by linarith, by linarith ‚ü© ) h_ML_pos.le


lemma K_lt_one
  (M L h : ‚Ñù) (h_pos : 0 < M * L) (h_lt : h < 1 / 2)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  Real.toNNReal (M * L * œÅ) < 1 := by
    -- Substitute œÅ from h_œÅ into the expression M * L * œÅ.
    rw [h_œÅ];
    -- Since $M * L$ is positive, we can cancel it out in the numerator and denominator.
    field_simp [h_pos];
    linarith


namespace NewtonKantorovich

def AffineSubspace {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) : Set E :=
  {x | ‚àÉ y : F, x = x‚ÇÄ + T y}

lemma isClosed_affine_subspace
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (f' : E ‚ÜíL[‚Ñù] F)
  (h_right_inv : f' ‚àòL T = ContinuousLinearMap.id ‚Ñù F) :
  IsClosed (AffineSubspace x‚ÇÄ T) := by
    -- Since $T$ is a right inverse of $f'$, the range of $T$ is closed.
    have h_range_closed : IsClosed (Set.range T) := by
      -- Since $T$ is a left inverse of $f'$, the range of $T$ is the set of fixed points of $T \circ f'$.
      have h_range_fixed_points : Set.range T = {x : E | T (f' x) = x} := by
        ext; aesop;
        ¬∑ simp_all +decide [ ContinuousLinearMap.ext_iff ];
        ¬∑ exact ‚ü® _, a ‚ü©;
      -- The set of fixed points of a continuous function is closed.
      have h_fixed_points_closed : IsClosed {x : E | T (f' x) = x} := by
        have h_cont : Continuous (fun x : E => T (f' x) - x) := by
          fun_prop
        -- The set {x | T(f'(x)) = x} is the preimage of {0} under the continuous function g(x) = T(f'(x)) - x.
        have h_preimage : {x : E | T (f' x) = x} = {x : E | T (f' x) - x = 0} := by
          simp +decide only [sub_eq_zero];
        exact h_preimage ‚ñ∏ isClosed_eq h_cont continuous_const;
      exact h_range_fixed_points ‚ñ∏ h_fixed_points_closed;
    convert h_range_closed.preimage ( show Continuous fun x => x - x‚ÇÄ from continuous_sub_right x‚ÇÄ ) using 1 ; ext ; simp +decide [ sub_eq_iff_eq_add ] ; aesop;
    ¬∑ -- By definition of the affine subspace, if $x \in x‚ÇÄ + \text{Range}(T)$, then there exists $y \in F$ such that $x = x‚ÇÄ + T(y)$.
      obtain ‚ü®y, hy‚ü© := a;
      use y;
      aesop;
    ¬∑ -- By definition of AffineSubspace, we need to show that there exists some $w \in F$ such that $x = x‚ÇÄ + T(w)$.
      use w; simp [h]

end NewtonKantorovich


theorem newton_kantorovich_invertible_lt
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (L r : ‚Ñù)
  (h_diff : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, HasFDerivAt f (fderiv ‚Ñù f x) x)
  (h_surj_inv : fderiv ‚Ñù f x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_lip : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, ‚àÄ y ‚àà Metric.closedBall x‚ÇÄ r, ‚Äñfderiv ‚Ñù f x - fderiv ‚Ñù f y‚Äñ ‚â§ L * ‚Äñx - y‚Äñ)
  (h_r_pos : 0 < r)
  (h_L_nonneg : 0 ‚â§ L)
  (M : ‚Ñù) (h_M : M = ‚ÄñT‚Äñ)
  (Œ∑ : ‚Ñù) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ)
  (h : ‚Ñù) (h_h : h = M * L * Œ∑)
  (h_h_lt : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_œÅ_le_r : œÅ ‚â§ r) :
  ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ,
    Phi f T x_star = x_star ‚àß
    (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, Phi f T z = z ‚Üí z = x_star) ‚àß
    Filter.Tendsto (fun n => (Phi f T)^[n] x‚ÇÄ) Filter.atTop (nhds x_star) := by
      have h_maps : MapsTo (NewtonKantorovich.Phi f T) (Metric.closedBall x‚ÇÄ œÅ) (Metric.closedBall x‚ÇÄ œÅ) := by
        -- Since œÅ ‚â§ r, the closed ball of radius œÅ is contained in the closed ball of radius r.
        have h_closed_ball_subset : Metric.closedBall x‚ÇÄ œÅ ‚äÜ Metric.closedBall x‚ÇÄ r := by
          exact Metric.closedBall_subset_closedBall h_œÅ_le_r;
        bound;
        apply NewtonKantorovich.Phi_maps_closed_ball_new;
        exact convex_closedBall x‚ÇÄ r;
        exact Metric.mem_closedBall_self h_r_pos.le;
        exact h_closed_ball_subset;
        exact fun z a => h_diff z a;
        exact h_lip;
        exact h_left_inv;
        exact rfl;
        exact rfl;
        exact rfl;
        ¬∑ exact h_ML_pos;
        ¬∑ linarith;
        ¬∑ rfl;
      -- Apply the Banach fixed-point theorem to conclude the existence and uniqueness of the fixed point and the convergence of the sequence.
      have h_banach : ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ, NewtonKantorovich.Phi f T x_star = x_star ‚àß (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, NewtonKantorovich.Phi f T z = z ‚Üí z = x_star) ‚àß Filter.Tendsto (fun n => (NewtonKantorovich.Phi f T)^[n] x‚ÇÄ) Filter.atTop (ùìù x_star) := by
        have h_contraction : LipschitzOnWith (Real.toNNReal (M * L * œÅ)) (NewtonKantorovich.Phi f T) (Metric.closedBall x‚ÇÄ œÅ) := by
          have h_lip : ‚àÄ w ‚àà Metric.closedBall x‚ÇÄ œÅ, ‚Äñfderiv ‚Ñù f w - fderiv ‚Ñù f x‚ÇÄ‚Äñ ‚â§ L * ‚Äñw - x‚ÇÄ‚Äñ := by
            exact fun w hw => h_lip w ( Metric.closedBall_subset_closedBall h_œÅ_le_r hw ) x‚ÇÄ ( Metric.mem_closedBall_self h_r_pos.le );
          apply NewtonKantorovich.Phi_lipschitz;
          exact convex_closedBall x‚ÇÄ œÅ;
          any_goals assumption;
          ¬∑ simp +decide [ h_œÅ ];
            bound;
            rw [ Real.sqrt_le_left ] <;> linarith [ show 0 ‚â§ ‚ÄñT‚Äñ * L * ‚Äñ( T : F ‚Üí E ) ( f x‚ÇÄ )‚Äñ by positivity ];
          ¬∑ exact Set.Subset.rfl;
          ¬∑ exact fun z hz => h_diff z <| Metric.closedBall_subset_closedBall h_œÅ_le_r hz;
          ¬∑ -- Since $h < 1/2$, we have $1 - 2h > 0$, thus $\sqrt{1 - 2h}$ is real and less than or equal to 1. Therefore, $1 - \sqrt{1 - 2h}$ is non-negative.
            have h_num_nonneg : 0 ‚â§ 1 - Real.sqrt (1 - 2 * h) := by
              exact sub_nonneg.2 ( Real.sqrt_le_iff.2 ‚ü® by norm_num, by linarith [ show 0 ‚â§ h by rw [ h_h ] ; exact mul_nonneg ( mul_nonneg ( h_M.symm ‚ñ∏ norm_nonneg _ ) h_L_nonneg ) ( h_Œ∑.symm ‚ñ∏ norm_nonneg _ ) ] ‚ü© );
            exact h_œÅ.symm ‚ñ∏ div_nonneg h_num_nonneg h_ML_pos.le
        apply_rules [ fixed_point_of_lipschitz_on_closed_ball ];
        ¬∑ exact K_lt_one M L h h_ML_pos h_h_lt œÅ h_œÅ;
        ¬∑ bound;
          exact Real.sqrt_le_iff.mpr ‚ü® by positivity, by linarith [ show 0 ‚â§ ‚ÄñT‚Äñ * L * ‚ÄñT ( f x‚ÇÄ )‚Äñ by positivity ] ‚ü©;
      exact h_banach


lemma fixed_point_is_zero
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x : E) (x‚ÇÄ : E)
  (h_surj_inv : fderiv ‚Ñù f x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F)
  (h_fixed : Phi f T x = x) :
  f x = 0 := by
    unfold NewtonKantorovich.Phi at h_fixed;
    replace h_surj_inv := congr_arg ( fun g => g ( f x ) ) h_surj_inv ; aesop


theorem newton_kantorovich_theorem
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (L r : ‚Ñù)
  (S : Set E) (h_open : IsOpen S) (h_subset : Metric.closedBall x‚ÇÄ r ‚äÜ S)
  (h_diff_on : DifferentiableOn ‚Ñù f S)
  (h_surj_inv : fderiv ‚Ñù f x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_lip : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, ‚àÄ y ‚àà Metric.closedBall x‚ÇÄ r, ‚Äñfderiv ‚Ñù f x - fderiv ‚Ñù f y‚Äñ ‚â§ L * ‚Äñx - y‚Äñ)
  (h_r_pos : 0 < r)
  (h_L_nonneg : 0 ‚â§ L)
  (M : ‚Ñù) (h_M : M = ‚ÄñT‚Äñ)
  (Œ∑ : ‚Ñù) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ)
  (h : ‚Ñù) (h_h : h = M * L * Œ∑)
  (h_h_lt : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_œÅ_le_r : œÅ ‚â§ r) :
  ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ,
    f x_star = 0 ‚àß
    (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, f z = 0 ‚Üí z = x_star) ‚àß
    Filter.Tendsto (fun n => (newton_iteration f T x‚ÇÄ) n) Filter.atTop (nhds x_star) ‚àß
    ‚Äñx_star - x‚ÇÄ‚Äñ ‚â§ œÅ := by
      -- Apply the Newton-Kantorovich theorem to obtain the existence of x_star.
      obtain ‚ü®x_star, hx_star‚ü© : ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ, Phi f T x_star = x_star ‚àß (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, Phi f T z = z ‚Üí z = x_star) ‚àß Filter.Tendsto (fun n => (Phi f T)^[n] x‚ÇÄ) Filter.atTop (nhds x_star) := by
        -- Apply the Newton-Kantorovich theorem with the given hypotheses.
        apply newton_kantorovich_invertible_lt;
        -- Since $f$ is differentiable on the open set $S$, and the closed ball is a subset of $S$, $f$ is differentiable at every point in the closed ball.
        intros x hx
        have hx_S : x ‚àà S := h_subset hx
        exact h_diff_on.differentiableAt (h_open.mem_nhds hx_S) |> DifferentiableAt.hasFDerivAt;
        all_goals assumption;
      refine' ‚ü® x_star, hx_star.1, _, _, _, _ ‚ü©;
      ¬∑ -- By definition of Phi, we have x_star - T (f x_star) = x_star. Rearranging gives T (f x_star) = 0.
        have h_T_f_x_star : T (f x_star) = 0 := by
          unfold NewtonKantorovich.Phi at hx_star; aesop;
        have := h_surj_inv.symm ‚ñ∏ ContinuousLinearMap.comp_apply ( fderiv ‚Ñù f x‚ÇÄ ) T ( f x_star ) ; simp +decide [ h_T_f_x_star ] at this ; tauto;
      ¬∑ -- If $f(z) = 0$, then $\Phi(f, T)(z) = z - T(f(z)) = z - T(0) = z$, since $T(0)$ is the zero vector.
        have h_fixed_point : ‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, f z = 0 ‚Üí Phi f T z = z := by
          simp +contextual [ NewtonKantorovich.Phi ];
        exact fun z hz hz' => hx_star.2.2.1 z hz ( h_fixed_point z hz hz' );
      ¬∑ convert hx_star.2.2.2;
        -- By definition of `newton_iteration`, we can show that it is equal to the iterate of `Phi` by induction on `n`.
        induction' ‚Äπ‚Ñï‚Ä∫ with n ih;
        ¬∑ -- By definition of `newton_iteration`, we have `newton_iteration f T x‚ÇÄ 0 = x‚ÇÄ`.
          simp [NewtonKantorovich.newton_iteration];
        ¬∑ -- By definition of `newton_iteration`, we have:
          simp [ih, Function.iterate_succ_apply'];
          exact ih ‚ñ∏ rfl;
      ¬∑ simpa [ dist_eq_norm ] using hx_star.1


theorem newton_kantorovich_theorem_lt
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (L r : ‚Ñù)
  (S : Set E) (h_open : IsOpen S) (h_subset : Metric.closedBall x‚ÇÄ r ‚äÜ S)
  (h_diff_on : DifferentiableOn ‚Ñù f S)
  (h_surj_inv : fderiv ‚Ñù f x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_lip : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, ‚àÄ y ‚àà Metric.closedBall x‚ÇÄ r, ‚Äñfderiv ‚Ñù f x - fderiv ‚Ñù f y‚Äñ ‚â§ L * ‚Äñx - y‚Äñ)
  (h_r_pos : 0 < r)
  (h_L_nonneg : 0 ‚â§ L)
  (M : ‚Ñù) (h_M : M = ‚ÄñT‚Äñ)
  (Œ∑ : ‚Ñù) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ)
  (h : ‚Ñù) (h_h : h = M * L * Œ∑)
  (h_h_lt : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_œÅ_le_r : œÅ ‚â§ r) :
  ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ,
    f x_star = 0 ‚àß
    (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, f z = 0 ‚Üí z = x_star) ‚àß
    Filter.Tendsto (fun n => (newton_iteration f T x‚ÇÄ) n) Filter.atTop (nhds x_star) ‚àß
    ‚Äñx_star - x‚ÇÄ‚Äñ ‚â§ œÅ := by
      -- Apply the Newton-Kantorovich theorem with the given hypotheses.
      apply newton_kantorovich_theorem f x‚ÇÄ T L r S h_open h_subset h_diff_on h_surj_inv h_left_inv h_lip h_r_pos h_L_nonneg M h_M Œ∑ h_Œ∑ h h_h h_h_lt h_ML_pos œÅ h_œÅ h_œÅ_le_r


namespace NewtonKantorovich

lemma Phi_maps_affine_subspace
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) :
  MapsTo (Phi f T) (AffineSubspace x‚ÇÄ T) (AffineSubspace x‚ÇÄ T) := by
    rintro _ ‚ü® y, rfl ‚ü©;
    unfold NewtonKantorovich.Phi NewtonKantorovich.NewtonKantorovich.AffineSubspace;
    -- Let $y' = y - f(x‚ÇÄ + T y)$. Then $x‚ÇÄ + T y - T (f (x‚ÇÄ + T y)) = x‚ÇÄ + T y'$.
    use y - f (x‚ÇÄ + T y);
    rw [ map_sub, add_sub_assoc ]

end NewtonKantorovich


namespace NewtonKantorovich

def NK_AffineSubspace {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) : Set E :=
  {x | ‚àÉ y : F, x = x‚ÇÄ + T y}

lemma isClosed_NK_AffineSubspace
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (f'x‚ÇÄ : E ‚ÜíL[‚Ñù] F)
  (h_surj_inv : f'x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F) :
  IsClosed (NK_AffineSubspace x‚ÇÄ T) := by
    convert isClosed_affine_subspace x‚ÇÄ T f'x‚ÇÄ _;
    exact h_surj_inv

lemma Phi_maps_NK_AffineSubspace
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  (f : E ‚Üí F) (T : F ‚ÜíL[‚Ñù] E) (x‚ÇÄ : E) :
  MapsTo (Phi f T) (NK_AffineSubspace x‚ÇÄ T) (NK_AffineSubspace x‚ÇÄ T) := by
    -- Let's take an arbitrary element x in the affine subspace and show that Œ¶(x) is also in the affine subspace.
    intro x hx
    obtain ‚ü®y, rfl‚ü© := hx;
    exact ‚ü® -f ( x‚ÇÄ + T y ) + y, by simp +decide [ NewtonKantorovich.Phi ] ; abel1 ‚ü©

end NewtonKantorovich


theorem newton_kantorovich_surjective_lt
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (L r : ‚Ñù)
  (h_diff : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, HasFDerivAt f (fderiv ‚Ñù f x) x)
  (h_surj_inv : fderiv ‚Ñù f x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F)
  (h_left_inv : T ‚àòL fderiv ‚Ñù f x‚ÇÄ = ContinuousLinearMap.id ‚Ñù E)
  (h_lip : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, ‚àÄ y ‚àà Metric.closedBall x‚ÇÄ r, ‚Äñfderiv ‚Ñù f x - fderiv ‚Ñù f y‚Äñ ‚â§ L * ‚Äñx - y‚Äñ)
  (h_r_pos : 0 < r)
  (h_L_nonneg : 0 ‚â§ L)
  (M : ‚Ñù) (h_M : M = ‚ÄñT‚Äñ)
  (Œ∑ : ‚Ñù) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ)
  (h : ‚Ñù) (h_h : h = M * L * Œ∑)
  (h_h_lt : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_œÅ_le_r : œÅ ‚â§ r) :
  ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ,
    f x_star = 0 ‚àß
    (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, f z = 0 ‚Üí z = x_star) ‚àß
    Filter.Tendsto (fun n => (newton_iteration f T x‚ÇÄ) n) Filter.atTop (nhds x_star) ‚àß
    ‚Äñx_star - x‚ÇÄ‚Äñ ‚â§ œÅ := by
      -- Apply the fixed point theorem to obtain the existence of x_star.
      obtain ‚ü®x_star, hx_star‚ü© : ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ, Phi f T x_star = x_star ‚àß (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, Phi f T z = z ‚Üí z = x_star) ‚àß Filter.Tendsto (fun n => (Phi f T)^[n] x‚ÇÄ) Filter.atTop (nhds x_star) := by
        apply newton_kantorovich_invertible_lt f x‚ÇÄ T L r h_diff h_surj_inv h_left_inv h_lip h_r_pos h_L_nonneg M h_M Œ∑ h_Œ∑ h h_h h_h_lt h_ML_pos œÅ h_œÅ h_œÅ_le_r;
      use x_star, hx_star.1, ?_, ?_, ?_, ?_ <;> simp_all +decide only [Metric.mem_closedBall];
      ¬∑ unfold NewtonKantorovich.Phi at hx_star; aesop;
        replace h_surj_inv := congr_arg ( fun g => g ( f x_star ) ) h_surj_inv; aesop;
      ¬∑ -- If $z$ is in the closed ball and $f(z) = 0$, then $z$ is a fixed point of $\Phi$.
        intros z hz hz_zero
        have hz_fixed : NewtonKantorovich.Phi f T z = z := by
          unfold NewtonKantorovich.Phi; simp +decide [ hz_zero ] ;
        exact hx_star.2.2.1 z hz hz_fixed ‚ñ∏ rfl;
      ¬∑ -- Since the Newton iteration is just the iterates of Phi, the tendsto statement for Phi's iterates implies the tendsto statement for the Newton iteration.
        convert hx_star.2.2.2 using 1;
        ext n; induction n <;> simp +decide [ *, Function.iterate_succ_apply' ] ;
        ¬∑ rfl;
        ¬∑ rename_i n ih; rw [ ‚Üê ih ] ; rfl;
      ¬∑ simpa only [ dist_eq_norm ] using hx_star.1

theorem newton_kantorovich_surjective_general
  {E F : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
  [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
  (f : E ‚Üí F) (x‚ÇÄ : E) (T : F ‚ÜíL[‚Ñù] E) (L r : ‚Ñù)
  (h_diff : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, HasFDerivAt f (fderiv ‚Ñù f x) x)
  (h_surj_inv : fderiv ‚Ñù f x‚ÇÄ ‚àòL T = ContinuousLinearMap.id ‚Ñù F)
  (h_lip : ‚àÄ x ‚àà Metric.closedBall x‚ÇÄ r, ‚àÄ y ‚àà Metric.closedBall x‚ÇÄ r, ‚Äñfderiv ‚Ñù f x - fderiv ‚Ñù f y‚Äñ ‚â§ L * ‚Äñx - y‚Äñ)
  (h_r_pos : 0 < r)
  (h_L_nonneg : 0 ‚â§ L)
  (M : ‚Ñù) (h_M : M = ‚ÄñT‚Äñ)
  (Œ∑ : ‚Ñù) (h_Œ∑ : Œ∑ = ‚ÄñT (f x‚ÇÄ)‚Äñ)
  (h : ‚Ñù) (h_h : h = M * L * Œ∑)
  (h_h_lt : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (œÅ : ‚Ñù) (h_œÅ : œÅ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_œÅ_le_r : œÅ ‚â§ r) :
  ‚àÉ x_star ‚àà Metric.closedBall x‚ÇÄ œÅ,
    f x_star = 0 ‚àß
    (‚àÄ z ‚àà Metric.closedBall x‚ÇÄ œÅ, f z = 0 ‚Üí z = x_star)  ‚àß
    ‚Äñx_star - x‚ÇÄ‚Äñ ‚â§ œÅ := by
      sorry
