[
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_2} [inst : DistribLattice Œ±] {a : Œ±} (a_1 : SupIrred a), SupPrime a)",
    "theorem": "theorem SupIrred.supPrime : (‚àÄ {Œ± : Type u_2} [inst : DistribLattice Œ±] {a : Œ±} (a_1 : SupIrred a), SupPrime a) := by\n  sorry",
    "name": "SupIrred.supPrime",
    "lemma-type": "{Œ± : Type u_2} ‚Üí\n  [inst : DistribLattice Œ±] ‚Üí\n    {a : Œ±} ‚Üí\n      {Œ± : Type u_2} ‚Üí\n        [DistribLattice Œ±] ‚Üí\n          {a : Œ±} ‚Üí\n            (h : ‚àÄ ‚¶Éb : Œ±‚¶Ñ ‚¶Éc : Œ±‚¶Ñ (a_1 : b ‚äî c = a), (b = a) ‚à® (c = a)) ‚Üí\n              (b : Œ±) ‚Üí (c : Œ±) ‚Üí ‚àÄ (a_1 : a ‚äì (b ‚äî c) = a), (a ‚äì b = a) ‚à® (a ‚äì c = a)",
    "lemma": "theorem aux.13082634676663934207 {Œ± : Type u_2} [inst : DistribLattice Œ±] {a : Œ±} {Œ± : Type u_2} [DistribLattice Œ±]\n    {a : Œ±} (h : ‚àÄ ‚¶Éb : Œ±‚¶Ñ ‚¶Éc : Œ±‚¶Ñ (a_1 : b ‚äî c = a), (b = a) ‚à® (c = a)) (b : Œ±) (c : Œ±) :\n    ‚àÄ (a_1 : a ‚äì (b ‚äî c) = a), (a ‚äì b = a) ‚à® (a ‚äì c = a) := by sorry",
    "doc_string": "**Alias** of the reverse direction of `supPrime_iff_supIrred`.",
    "generated": [
      "theorem iff_self : ‚àÄ (p : Prop), (p ‚Üî p) = True := by sorry ",
      "theorem LE.intro_neg_succ_le : ‚àÄ {Œ± : Type u} [inst : LinearOrderedSemifield Œ±] (m n : Œ±) [hmn : -m < n], ‚Üëm ‚â§ dm\n    * ({ ofAdd' m + ofAdd' n)‚Åª¬π ::‚Çò·µà dm ‚â§ -m; (nm * n)‚Åª¬π ‚â§ m + n) := by sorry ",
      "theorem IsMaximum.supPrime : ‚àÄ {Œ± : Type u_4} [inst : DistribLattice Œ±] {A a : Œ±} {c : Set.Icc 0 a} {p : Œ±} {a0 : p > 0},\n    ‚úìa0 ‚Üí Iff(SupIrredSubset q supDisjointSubtractSingleton_subset p c) ‚Üî SupPrime q :=\n  by sorry ",
      "theorem Or_iff_not_imp_right : ‚àÄ {a b : Prop}, (a ‚à® b) ‚Üî (¬¨b ‚Üí a) := by sorry ",
      "theorem congr_fun : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {x y : Œ±}, x = y ‚Üí ‚áëx = ÔøΩÔøΩacio x y := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a¬≤ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.18106776281865444945 {Œ± : Type u_2} [inst : DistribLattice Œ±] {a : Œ±} : ‚ÜëFalse = ‚ä• := by sorry ",
      "theorem imp_true_iff : ‚àÄ (a : Prop), (a ‚Üí True) = True := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {G : Type u_1} [inst : AddLeftCancelMonoid G] {a : G}, Nat.card ‚Ü•(AddSubmonoid.multiples a) = addOrderOf a)",
    "theorem": "theorem Nat.card_addSubmonoidMultiples :\n    (‚àÄ {G : Type u_1} [inst : AddLeftCancelMonoid G] {a : G}, Nat.card ‚Ü•(AddSubmonoid.multiples a) = addOrderOf a) := by\n  sorry",
    "name": "Nat.card_addSubmonoidMultiples",
    "lemma-type": "{G : Type u_1} ‚Üí\n  [AddLeftCancelMonoid G] ‚Üí\n    {a : G} ‚Üí (Nat.card ‚Ü•(AddSubmonoid.multiples a) = addOrderOf a) = (Nat.card ‚Ü•(AddSubmonoid.multiples a) = 0)",
    "lemma": "theorem aux.3649350544844893990 {G : Type u_1} [AddLeftCancelMonoid G] {a : G} :\n    (Nat.card ‚Ü•(AddSubmonoid.multiples a) = addOrderOf a) = (Nat.card ‚Ü•(AddSubmonoid.multiples a) = 0) := by sorry",
    "doc_string": "See also `addOrder_eq_card_multiples`.",
    "generated": [
      "theorem Fin.val_fin_add : ‚àÄ {Œ± : Type u_1} (m n : ‚Ñï), (‚Üë(Fin.add m n)).Finval = ‚Üëm + ‚Üën := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem zpow_add : ‚àÄ (a : G) {m i : ‚Ñ§}, m ‚Ä¢ a = i ‚Ä¢ a := by sorry ",
      "_au.3002375686179414252 :\n    let AddSubmonoid.toOrderSubsemiring (AddSubmonoid.preimage Multiplicative.ofAdd ( AddCommMonoid.Submonoid.closure ‚ÜëP ) .Carrier) := AddSubmonoid.toOrderSubsemiring ‚ÜëPMulSimAdd.P;\n    S n = AddSubmonoid.generator <| AddMonoid.closure ‚ÜëS := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {n : Type u_4} [inst : AddGroup n] {v : (a : n) ‚Üí Œ±},\n  (Matrix.IsSymm (Matrix.circulant v)) ‚Üî (‚àÄ (i : n), v (-i) = v i))",
    "theorem": "theorem Matrix.circulant_isSymm_iff :\n    (‚àÄ {Œ± : Type u_1} {n : Type u_4} [inst : AddGroup n] {v : (a : n) ‚Üí Œ±},\n      (Matrix.IsSymm (Matrix.circulant v)) ‚Üî (‚àÄ (i : n), v (-i) = v i)) :=\n  by sorry",
    "name": "Matrix.circulant_isSymm_iff",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "A circulant of `v` is symmetric iff `v` equals its reverse. ",
    "generated": [
      "theorem aux.3987032364460452480 {Œ± : Type u_1} {n : Type u_4} [AddGroup n] {v : (a : n) ‚Üí Œ±}\n    (h : (Matrix.isSymm (Matrix.circulant v)) ‚Üî (‚àÄ (i : n), v (-i) = v i)) (i : n) : 1 * v i = v i := by sorry ",
      "theorem add_mul_add.unit :\n    ‚àÄ {Œ± : Type u_1} [inst : NonUnitalSemiring Œ±] {r s : Œ±} (c d : Unit, add_highestPart r c = add_highestPart s c),\n      Nat.coprime r s :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.4665878576240467403 {Œ± : Type u_1} {n : Type u_4} [AddGroup n] {v : (a : n) ‚Üí Œ±}\n    (h : LinearIndependent Œ± fun (i : AesopMode) ‚Ü¶ v (AddNeg.neg i)) : Matrix.colConstr n n '' Set.univ =·∂†[nthems] A\n                [[[val_h2]].a) fun (m1 : Type u_4) (x_1057 : AesopMode) ‚Ü¶ v]_\n (i : Function.Injective fun (i : n) ‚Ü¶ f <$M.cardVal i i) =\n ·æΩ(‚ü™M * LinearMap.diag (Set.Finite.injection ‚àò fun (i : n) ‚Ü¶ AbsorbsL Filter.atTop (f (fun (j : n) ‚Ü¶ g j)) (val_h5 h i))) :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans  r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "answer:\n6181246677776827955 {Œ± : Type u_1} {n : Type u_4} [AddGroup n] {v : (a : n) ‚Üí Œ±} :\n    ((‚àÄ (c : ‚Ñ§)\n          (a :\n            c ‚Ä¢ Matrix.diag (fun (x : n) ‚Ü¶ mulPair v (c, x)) = transpose v * Matrix.circulant_neg_one v),\n          v (Fin.succ m, m) = v m * v (Fin.succ m) - v m * v (Fin.castSucc m)) ‚Üí\n        (starMonoidAlgebra fun (x : n) ‚Ü¶ v (-x)) * Matrix.circulant ((if (0 = -1) then v else - v) ¬∑ <;> v) = 0) =\n      ((‚àÄ (m‚ÇÇ : n),\n          (if (* 5 = 0) then\n              starMonoidAlgebra fun (x : n) ‚Ü¶ v (Neg.neg ‚ä•))\n            (zmultiplesstar ‚Üë(Fin.succ m)) ‚Ä¢ starMonoidAlgebra.single m‚ÇÇ m =\n          0) ‚Üî\n        (‚àÄ (a : n) (a_1 : n) (a_2 : n), v (-a_2) ‚àí v -a_2 = v m * v (Fin.succ m)-v m * a a_2 :=\n          true)) :=\n  by sorry ",
      "theorem ofNat_injective : ‚àÄ {Œ± : Type u} [inst : OrderedSemiring Œ±] [inst_1 : Nontrivial Œ±], Function.Injective OfNat := by\n  sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {a : Set Œ±} (h : Set.Finite a), Set.Finite {b : Set Œ± | b ‚äÜ a})",
    "theorem": "theorem Set.Finite.finite_subsets : (‚àÄ {Œ± : Type u} {a : Set Œ±} (h : Set.Finite a), Set.Finite {b : Set Œ± | b ‚äÜ a}) :=\n  by sorry",
    "name": "Set.Finite.finite_subsets",
    "lemma-type": "‚àÄ {Œ± : Type u_1} (s : Finset Œ±), ‚Üë(Finset.powerset s) = Finset.toSet ‚Åª¬π' ùí´‚Üës",
    "lemma": "theorem Finset.coe_powerset : ‚àÄ {Œ± : Type u_1} (s : Finset Œ±), ‚Üë(Finset.powerset s) = Finset.toSet ‚Åª¬π' ùí´‚Üës := by sorry",
    "doc_string": "There are finitely many subsets of a given finite set ",
    "generated": [
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem congrInst : ‚àÄ {F P : Sort u} {l P1 : LinearOrder  P} _f‚ÇÇ f_1 e, P1 _f‚ÇÇ = P1 f_1 ‚Üí _f‚ÇÇ e = f_1 e ‚Üí P = P := by\n  sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans  r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem FiberProd.map_proj :\n    ‚àÄ {Œ≥ : FinType} (s : Set (Œì¬π ((fun {a : Set Œ±} ‚Ü¶ Set.Relab F a ‚áëid {b‚ÇÅ, b‚ÇÇ} ‚â§ b‚ÇÅ) ((fun {a ::: Set x} ‚Ü¶ Œ±) a))))\n      {{b‚ÇÅ, b‚ÇÇ} = {b‚ÇÅ}', {b‚ÇÇ} = {b‚ÇÇ}'} (* b‚ÇÅ, b‚ÇÇ -- > (b‚ÇÅ, b2) (set/formality.fstr/f.type) (val_spec eq) (b == b1)\n                             (gsub / gsub)* (_type / SetValFiber_fun : Set ((Type, SFun Œì‚Åª¬π'n‚ÇÇ))}·∂ú·∂ú *)\n              s, a = a :=\n  by sorry ",
      "theorem Set.induction_on : ‚àÄ {Œ± : Type u} {p : Set Œ± ‚Üí Prop} {s : Set Œ±}, p s ‚Üí (‚àÄ x ‚àà s, p {x}) ‚Üí p s := by sorry ",
      "theorem Set.not_sFinite_mem:\n    ‚àÄ {Œ± : Type u} [inst : Infinite Œ±], ¬¨Set.Finite {xs | p xs ‚Üî ¬¨(SFinite i(xs.val)))}} := by sorry ",
      "theorem IsLB.all_upperBound :\n    ‚àÄ {Œ± : Type w} [linOrderedTopologicalSpace Œ±]; [inst : DenselyOrdered Œ±] {b : Œ±} {y z : Set Œ±},\n      IsLUB S b ‚Üí (‚àÄ x ‚àà S, b ‚â§ x) ‚Üí BddUpper (Bornology.boundedWeakUpperDf b S) ‚Üí isLUB S y :=\n  by sorry ",
      "theorem Set.bUnion_Ioo :\n    ‚àÄ {Œ± : Type u} {p q : Œ± ‚Üí Prop}, (‚àÄ (x : Œ±), (Qs p) x ‚àß (Pq p)) ‚Üí MeasureTheory.BorelSpace Œ± := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (s : R) (x : A)\n  (y : A), x * s ‚Ä¢ y = s ‚Ä¢ (x * y))",
    "theorem": "theorem Algebra.mul_smul_comm :\n    (‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (s : R) (x : A)\n      (y : A), x * s ‚Ä¢ y = s ‚Ä¢ (x * y)) :=\n  by sorry",
    "name": "Algebra.mul_smul_comm",
    "lemma-type": "{R : Type u} ‚Üí\n  {A : Type w} ‚Üí\n    [CommSemiring R] ‚Üí\n      [Semiring A] ‚Üí\n        [Algebra R A] ‚Üí\n          (s : R) ‚Üí (x : A) ‚Üí (y : A) ‚Üí (x * s ‚Ä¢ y = s ‚Ä¢ (x * y)) = (x * ((algebraMap R A) s * y) = s ‚Ä¢ (x * y))",
    "lemma": "theorem aux.12489562634727495675 {R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (s : R) (x : A)\n    (y : A) : (x * s ‚Ä¢ y = s ‚Ä¢ (x * y)) = (x * ((algebraMap R A) s * y) = s ‚Ä¢ (x * y)) := by sorry",
    "doc_string": "This is just a special case of the global `mul_smul_comm` lemma that requires less typeclass\nsearch (and was here first). ",
    "generated": [
      "## Table of Contents\n```lean\nAnd.intro : thisLeans2 = Lean.Parser.Term.matchNullMVar (Term term.2 term.8)\nsmulRefl : (fun‚Çö {c b : Opaque a} (bPa : Opaque a)* { val := c, property p := bPa }) = b := by sorry ",
      "theorem aux.6450765207835012786 {R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (s : R) (x : A)\n    (y : A) : MulOpposite.op (A √ó‚Çò R) x * s = s ‚Ä¢ x.re := by sorry ",
      "theorem comm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsStrictOrder Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by\n  sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem zero_smul : ‚àÄ (R : Type u) {M : Type v} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] (m : M), 0 ‚Ä¢ m = 0 := by sorry ",
      "theorem pow_comm : ‚àÄ {G : Type u_1} [inst : CommMagma G] [inst_1 : LeftCancelCommMagma G] (a b : G), a ^ b = a ^ b := by\n  sorry ",
      "theorem RingHom.map_add :\n    ‚àÄ {Œ± : Type u_2} {Œ∫ : Type u_3} [inst : NonUnitalRing Œ±] [instQ : NonUnitalRing Œ∫] (f : Œ± ‚Üí+* Œ∫)\n      (x y : Œ±), f (x + y) = f x + f y :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(MeasureTheory.LocallyIntegrableOn zetaKernel‚ÇÇ (Set.Ioi 0))",
    "theorem": "theorem locally_integrable_zetaKernel‚ÇÇ : (MeasureTheory.LocallyIntegrableOn zetaKernel‚ÇÇ (Set.Ioi 0)) := by sorry",
    "name": "locally_integrable_zetaKernel‚ÇÇ",
    "lemma-type": "(k : Set ‚Ñù) ‚Üí (hk : k ‚äÜ Set.Ioi 0) ‚Üí (hk' : IsCompact k) ‚Üí MeasureTheory.IntegrableOn zetaKernel‚ÇÅ k",
    "lemma": "theorem aux.1874859241468860468 (k : Set ‚Ñù) (hk : k ‚äÜ Set.Ioi 0) (hk' : IsCompact k) :\n    MeasureTheory.IntegrableOn zetaKernel‚ÇÅ k := by sorry",
    "doc_string": "Local integrability of `zetaKernel‚ÇÇ`. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Set.isUniv_setOf : TFAE_ZFM \n  [(√ó ¬∑ ‚Åª¬π' Set.univ), FunLike.coe √ó ¬∑ ‚Åª¬π' True] := by sorry ",
      "theorem Set.indicator_coe :\n    ‚àÄ {Œ± : Type —É_1} [inst : Zero Œ±] [inst_1 : SMulWithZero Œ± Nat] [inst_2 : FunLike F Œ± Œ≤] (x‚ÇÄ : (Fonction #Œ± ‚Üí·µá Œ≤ ‚Ñù) F)\n      (_B‚ÇÇ : Set Œ≤) h‚ÇÅ‚ÇÇ' = ùïú, Œ≤ ‚ÜíF(Œ≤, Œ≥) F) {x : ‚Ñù}, x ‚àà ( Set.Ici ‚Üëb‚ÇÄ ) ( Set.restrict' Set.Iio·∂ú (Set.Ici ‚Üëb‚ÇÄ) fun a‚ÇÇ x => if b ‚Üëa √ó b·µÉ‚ÇÄ·µä ‚ÜíL[ùïú] ùïú | b‚ÇÄ ‚äî a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem ContinuousAt.comp:\n    ‚àÄ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n      [inst_2 : TopologicalSpace Z] {Œ≥ : Type u_4} [inst_3 : TopologicalSpace Œ≥] {f : Œ≥ ‚Üí X} {g : Œ≥ ‚Üí Y} {f' : X ‚Üí Œ≥}\n      (x y : œÑ), ContinuousAt x ((continuous fun a => (f y, g a).1) ‚àò (2 * ‚Üëa), ‚áëf) :=\n  by sorry ",
      "theorem aux.5929616478997506810 (x : ‚Ñù) (xt : x ‚àà Set.Ioc 0 (Real.pi / 2)) (a : ContinuousAt zetaKernel‚ÇÇ 0) :\n    ContinuousAt (FunLike.coe zetaKernel‚ÇÇ) 0 := by sorry ",
      "theorem aux.8515833323739244520 : ContDiffOn f ùïú (Set.Ioi 0 √ó ‚ÑÇ) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2)),\n  EuclideanGeometry.oangle p‚ÇÉ p‚ÇÅ p‚ÇÇ = ‚Üë(Real.arcsin (dist p‚ÇÉ p‚ÇÇ / dist p‚ÇÅ p‚ÇÉ)))",
    "theorem": "theorem EuclideanGeometry.oangle_left_eq_arcsin_of_oangle_eq_pi_div_two :\n    (‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)]\n      [inst_4 : Module.Oriented ‚Ñù V (Fin 2)] {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P}\n      (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2)),\n      EuclideanGeometry.oangle p‚ÇÉ p‚ÇÅ p‚ÇÇ = ‚Üë(Real.arcsin (dist p‚ÇÉ p‚ÇÇ / dist p‚ÇÅ p‚ÇÉ))) :=\n  by sorry",
    "name": "EuclideanGeometry.oangle_left_eq_arcsin_of_oangle_eq_pi_div_two",
    "lemma-type": "‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÇ",
    "lemma": "theorem EuclideanGeometry.left_ne_of_oangle_eq_pi_div_two :\n    ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)]\n      [inst_4 : Module.Oriented ‚Ñù V (Fin 2)] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P},\n      EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n  by sorry",
    "doc_string": "An angle in a right-angled triangle expressed using `arcsin`. ",
    "generated": [
      "theorem aux.8212823105264675177 {V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [Module.Oriented ‚Ñù V (Fin 2)]\n    {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2)) :\n    Real.Angle.tan ‚Üë(Real.pi / 2) * Real.Angle.tan (EuclideanGeometry.oangle p‚ÇÉ p‚ÇÅ p‚ÇÇ) =\n      Real.Angle.tan (EuclideanGeometry.oangle p‚ÇÉ p‚ÇÅ p‚ÇÇ) :=\n  by sorry ",
      "theorem aux.13139987331660905408 {V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimension.finrank ‚Ñù V = 2)] [Module.Oriented ‚Ñù V (Fin 2)]\n    {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2)) :\n    dist p‚ÇÅ p‚ÇÇ / dist p‚ÇÅ p‚ÇÉ = Real.arcsin (dist p‚ÇÇ p‚ÇÉ / dist p‚ÇÅ p‚ÇÉ) := by sorry ",
      "theorem CongArg.congrargo : ‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Sort v} (x : Œ±) m n y y' : Œ± ‚Üí p x = p y =>\n    p x ‚Üí f x = f y' ‚Üí g y' ‚Üí (f x, g y)^2 √ó (f y, g y) = (f y, g y) ^ 2 * (f x, g x) + (f y, g y) ^ 2 * (f x, g y) := by\n  sorry ",
      "theorem rfl : ‚àÄ {Œ± : Sort u} {a : Œ±}, a = a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± Œ≤ : Sort u} {a b c : Œ±} (f : Œ± ‚Üí Œ≤), a = b ‚Üí c = a ‚Üí f a = f b := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem InnerProductGeometry.inner_div_norm_mul_norm_eq_of_angle_eq_pi_div_two :\n    ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] (x y : V)\n      (Œ∏ : Real.Angle), InnerProductGeometry.angle x y = Real.pi / 2 ‚Üí\n      ‚ÄñxÔøΩÔøΩwearith (fun v v_1 => ‚ü™v, v_1‚ü´_‚Ñù‚Äñ / ‚Äñy‚Äñ)‚Äñ = ‚Äñy‚Äñ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ‚àà S)",
    "theorem": "theorem AddSubmonoid.zero_mem : (‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ‚àà S) := by sorry",
    "name": "AddSubmonoid.zero_mem",
    "lemma-type": "‚àÄ {S : Type u_4} {M : Type u_5} [inst : Zero M] [inst_1 : SetLike S M] [self : ZeroMemClass S M] (s : S), 0 ‚àà s",
    "lemma": "theorem ZeroMemClass.zero_mem :\n    ‚àÄ {S : Type u_4} {M : Type u_5} [inst : Zero M] [inst_1 : SetLike S M] [self : ZeroMemClass S M] (s : S), 0 ‚àà s :=\n  by sorry",
    "doc_string": "An `AddSubmonoid` contains the monoid's 0.",
    "generated": [
      "theorem iff_self : ‚àÄ (p : Prop), (p ‚Üî p) = True := by sorry ",
      "theorem add_zero : ‚àÄ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry ",
      "theorem aux.7000401209614349209 {M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) : 0 = (IsAddUnit.intro 1).1 := by\n  sorry ",
      "theorem congrArg : ‚àÄ {Œ± Œ≤ : Sort u} {a b c : Œ±}, a = b ‚Üí (c ‚Üí Œ±) = (c ‚Üí b) ‚Üí a = b := by sorry ",
      "theorem eq_self : ‚àÄ {Œ± : Sort u_1} (a : Œ±), (a = a) = True := by sorry ",
      "theorem aux.12353978810944163448 {M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) (a : 0 ‚àâ ‚ÜëS) :\n    ‚àÄ (ht : AddSubmonoid.carrier ‚ÜëS) (h : ‚áë((AddSubmonoid.toAddSubsemigroup S).map (AddSubmonoid.toAddSubsemigroupIncl S)) ht = ‚áëht),\n      false :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Transcendental_along_pGen : AlgebraMap.Rat.AlgebraMap C v ‚Üí Cardinal.StrongLTOC ‚Üë\n        LocalRing.max (AddSubalgebra.closure‚Çú G ‚ÜëRing.h) Cardinal.str (Nonemptic.Algebra (AddSubalgebra.toRing G)\n        ‚ÜëRing.to_cardinal fun x xS * _x => (IsUnit ‚ü®{ as x = ‚Üë(_ xS = xS)} 1 ‚â† 0) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (a : IsOpen s), nhdsSet s = Filter.principal s)",
    "theorem": "theorem IsOpen.nhdsSet_eq :\n    (‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (a : IsOpen s), nhdsSet s = Filter.principal s) := by\n  sorry",
    "name": "IsOpen.nhdsSet_eq",
    "lemma-type": "‚àÄ {a : Prop}, a ‚Üî a",
    "lemma": "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry",
    "doc_string": "**Alias** of the reverse direction of `nhdsSet_eq_principal_iff`.",
    "generated": [
      "theorem Set.EqOn.map : ‚àÄ {X : Type u_1} {Y : Type u_2} {s : Set X} {f‚ÇÅ f‚ÇÇ : X ‚Üí Y}, ‚áêF a‚ÇÅ a‚ÇÇ ‚Üí Set.EqOn f‚ÇÅ f‚ÇÇ s ‚Üí œÉ‚ÇÄ = f‚ÇÅ ‚àß id = ‚Üëf‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem nhds_eq :\n    ‚àÄ {X : Type u} {x : X} [inst : TopologicalSpace X] [y : PreconnectedSpace X x], nhds x = Filter.principal { x | True } :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] ‚¶Éa b : Œ±‚¶Ñ, r a b ‚Üí r b a := by sorry ",
      "theorem rfl : ‚àÄ {Œ± : Sort u} {a : Œ±}, a = a := by sorry ",
      "theorem aux.6062583535975373581 {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {X : Type u_1}\n    [TopologicalSpace X] {s : Set X} :\n    ((nhds ‚Üës ‚â§ Filter.flips Set.Ioi) ‚Üî True) = True := by sorry ",
      "theorem nhdsSet_isOpen : ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, IsOpen s ‚Üí nhdsSet s = Filter.principal s :=\n  by sorry ",
      "theorem aux.12554570742376089014 {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {X : Type u_1}\n    [TopologicalSpace X] {s : Set X} (H : IsOpen s) : nhdsSet s·∂ú = pure (s·∂ú·∂ú \\ s·∂ú)·∂ú := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n  [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n  (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atBot)",
    "theorem": "theorem Filter.Tendsto.atBot_add :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n      [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n      (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n      Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atBot) :=\n  by sorry",
    "name": "Filter.Tendsto.atBot_add",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [TopologicalSpace Œ±] ‚Üí\n      [LinearOrderedAddCommGroup Œ±] ‚Üí\n        [OrderTopology Œ±] ‚Üí\n          {l : Filter Œ≤} ‚Üí\n            {f : (a : Œ≤) ‚Üí Œ±} ‚Üí\n              {g : (a : Œ≤) ‚Üí Œ±} ‚Üí\n                {C : Œ±} ‚Üí\n                  (hf : Filter.Tendsto f l Filter.atBot) ‚Üí\n                    (hg : Filter.Tendsto g l (nhds C)) ‚Üí (x : Œ≤) ‚Üí f x + g x = g x + f x",
    "lemma": "theorem aux.1998460582242406556 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    [OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (x : Œ≤) : f x + g x = g x + f x := by sorry",
    "doc_string": "In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. ",
    "generated": [
      "reply_obj :\n  Topology.Independent.add_atBot (_Tendsto.monotone fun (x : Œ≤) ‚Ü¶ -g x) _Tendsto.at_top _g Tendsto.sub_neg _f\n        (tendsto_iff.mpr (congrArg homLT filter_univ)) _Tendsto.ne_neg_atBot _neg_atBot_antitone :\n  ‚àÄ [inst : SemilatticeInf œÜ] [inst_9 : OrderBot œÜ] [inst_10 : FinitelyCompleteLattice œÜ] (hinf_ne :  ~Inf_nonempty  œÜ) (h_iInf : (inf 1) ‚â† ‚ä•) (x : Œ≤), (x œâ) + g œâ = 0 := by sorry ",
      "theorem tendsto_comp_atBot :\n    ‚àÄ {Œ± : Type u_10} {Œ≤ : Type u_11} {Œ≥ : Type u_12} [inst : SemilatticeSup Œ±] [inst_1 : Filter Œ±]\n      {\\mathitfx(a : Œ≤) ‚Üí Œ±} (g : Œ≤ ‚Üí Œ±) [hg : Filter.Tendsto g Filter.atBot (nhds C)],\n      Tendsto (fun n => (fun i => f i) n ¬± g n) Filter.atBot (nhds (( fun i => f i ) C - C)) :=\n  by sorry ",
      "theorem atBot_ge_iff : ‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±}, ‚ä• ‚â§ a ‚Üî a < Œ±‚àû := by sorry ",
      "theorem AddSubgroup.coe_top_eq_univ : ‚àÄ {Œ∑ : Type u_12} [T : AddGroup Œ∑], Subgroup.gi AddSubgroup.liani = ‚ä§ := by sorry ",
      "theorem trans_le :\n    ‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : GenLt Œ± fun x x_1 => x * x_1]\n      [inst_2 : CovariantClass Œ± Œ± (Function.comp (Pow x) CircularOrder.dec (Pow x)) (Pow.mulRight x)],\n      CircularOrder.le x·∂†‚ÇÇ x ‚àß\n          SeminormedRingHomClass.toNonUnitarizable P x·∂®‚ÇÇ ‚â§ Function.invFun SeminormedRingHomClass.toNonUnitarizable P <ÔøΩÔøΩÔøΩÔøΩÔøΩeen} :\n    ‚àÄ [inst : StronglyMeasurable·∂†' x·∂†‚ÇÅ], ‚àÄ {\\[G \\'_inst : FunLike.InstStrongSmoothingOperatorHom ùïÑ·µÉ·µÉ' (\\fun x ?_ ‚Ü¶ 10) (fun x ?a_1 => |10|)\n                      x <| NNReal.uncurried x ? |N|] (a : ‚Ñù)\n        (ha_4b :\n      (Filter.Tendsto xüî∞ (ùêπ x_{a‚Çö}.toC\n          f :=\n    { P := False,\n      f :\n        ({  ofFun' := fun (x : ù†•(b 10)) ‚Ü¶ b' (fun (x : b := ùó¶x·§ü·úò) ‚Ü¶ x‚Åª¬π * (b \\[| x \\|] x·§ò * (max‚ü¶ a := |ùë¥ x |#\n                          b = ![|\n            0 =\n            fun ‚Ü¶ true,\n            function_algebra (Eq.eq ¬∑ false false)‚¶é;\n            this ‚â• b] + Eq.e 10 |\n          max |\n               |ùì•|\n            fun h x _Hx :=\n          true;\n            function_algebra true false ‚àò Equiv.remove 0 } =\n              _T = true)] P,\n            b } √ó { bh : 10 ‚â† b :=\n              b_true : True ‚â† False } = a < b x}} √ó { a := |*| (* |y|) := false } 1 ‚â§ f * b |·óÆ | b) ‚Üí\n        ‚àÄ (_p = _p) ({ x := g ·óÆ y ^ Nat.zero, ùë°y = o := f 10 _ := g ‚ö†‚ÇÅ (b·µÉ·¥∏ 0), _i = |(P := œÅ g ùûî·†ñ·±∫.toRingHom) b|}‚Çñ\n            { |y| = b \\[‚Å¥·£ö / |\n          a := |*| g·äóy·∞å·≤üz‚Åª¬π * b y; true |‚ìá | b := true}, o.r _ √ó\n                | (fun g := Mathport.TranslucentPackage.TranslucentTo.default‚£ù.0 ‚Üì\n                        fun e‚ÇÅe‚ÇÇ => some [] => _j === s·∑ø (some [ | * g | ‚Üî True ])) ·µ• g x.a,\n                 x.ha > g * b | = | * x ^ { a := |‚Üë| (* |x| |‚®å x = x‚Çö | x = g\n    { b := |*| y := (* 999.·´ú·õú) |·∑ò (fun g := Mathport.TranslucentPackage.TranslucentTo.default‚£ù.0\n            e‚ÇÇh‚ÇÅh‚ÇÇ = o.R / i\n        ezp·∏£x·∂¶ : (fun g·µå·∂Æ => o œµg) √ó (_p = x \\ P * g ‚îîa‚ü© =\n          _h = hg \\[‚µΩ < true\\]/ | 2} x) x < / |>\n        y = y.1 \\ 3 - x‚à©e √∑ e :=\n        œÑ.Nat.le fun bm => bs[2 + b] ‚à™ x ‚â§ Nat.rawCast { ar := Mathport.Translucent.Translucent false \\_p :=\n      Mathport.Translucent.$n} = ((fun [] e‚ÇÇ => some _ √ó none\n        b = false) { b := \\_T, p := False, f = x * b, g := none } = _h)(fun { e : True b} s\n            (P = e * y).f := f 0 + g (_x ^ fun g' : Nat √ó Int := True xs) == false :=\n        ‚äë := false) _b => b: _ = f | 0 = g | := by\n  sorry ",
      "theorem aux.5930085323977230585 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    [OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (x : Œ≤) : -g x = -(C + -f x) := by sorry ",
      "theorem aux.10551771248270574313 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    [OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (val : Œ±) (hval_g : val > g C) :\n    (Filter.Tendsto (fun (b : Œ≤) ‚Ü¶ val - ¬≠(f b + g b)) l Filter.atTop) =\n      (‚àÄ ‚¶Éa : Œ±‚¶Ñ, ‚àÄ (l_1 : Filter Œ≤) (hl : Filter.Tendsto (fun (b : Œ≤) ‚Ü¶ f b + g b) l = l_1),\n        ‚Üël_1 ‚â§ {b : Œ≤ | val + - ¬¨((fun (x : Œ±) ‚Ü¶ a - x) ‚Åª^{[0]} val < a) (f b + g b)}) :=\n  by sorry ",
      "theorem Filter.tendsto_atBot_add_neg_const' :\n    ‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} {c : HSigma Œ±}\n      (fa : Measurable f) (f_decreas : f c.lto c < 0) [hlm : MeasurableSpace.Inst (Sigma Œ±)]\n      ‚ü®a, fa : Measurable.fst c.snd, s fa : MeasurableSet (Subtype.snd‚Åª¬π' fa)‚ü©,\n      ({ Subtypefun fun x => -Finset.sum (Finset.attach s) fun e => ‚Üëe √ó·∂† (f (Finset.ofNat e ((œÜ x).left).2)) } =\n        {{ Subtypefun fun x => a - -Finset.sum x fun e => ‚Üëe √ó·∂† g fun (e : a -‚Çì -‚Çò -Fm hx ‚â• 0) (i : Œπ) ‚Ü¶\n          f i _)}}} :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b), (¬¨(a ‚ãñ b)) ‚Üî (‚àÉ c, (a < c) ‚àß (c < b)))",
    "theorem": "theorem not_covBy_iff :\n    (‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b), (¬¨(a ‚ãñ b)) ‚Üî (‚àÉ c, (a < c) ‚àß (c < b))) := by sorry",
    "name": "not_covBy_iff",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [LT Œ±] ‚Üí\n    {a : Œ±} ‚Üí {b : Œ±} ‚Üí (h : a < b) ‚Üí (fun (x : Œ±) ‚Ü¶ ‚àÉ (_ : a < x), ¬¨(¬¨(x < b))) = fun (x : Œ±) ‚Ü¶ (a < x) ‚àß (¬¨(¬¨(x < b)))",
    "lemma": "theorem aux.6525162435626870424 {Œ± : Type u_1} [LT Œ±] {a : Œ±} {b : Œ±} (h : a < b) :\n    (fun (x : Œ±) ‚Ü¶ ‚àÉ (_ : a < x), ¬¨(¬¨(x < b))) = fun (x : Œ±) ‚Ü¶ (a < x) ‚àß (¬¨(¬¨(x < b))) := by sorry",
    "doc_string": "If `a < b`, then `b` does not cover `a` iff there's an element in between. ",
    "generated": [
      "object(inst : LT Œ±) (a : Œ±) (b : Œ±) (h : a < b) (a_2 : Œ±) :\n    ‚àÄ (hf : ¬¨(a_2 ‚ãñ a)), (b ‚ãñ a) = (‚àÉ x, (a < x) ‚àß (x ‚ãñ a_2)) := by sorry ",
      "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry ",
      "view_source <</SYS>>\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem not_covBy_iff :\n    (‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b), (¬¨(a ‚ãñ b)) ‚Üî (‚àÉ c, (a < c) ‚àß (c < b))) := by sorry\n``` [/INST] hint : by sorry ",
      "theorem isLUB_ofIsEmpty : ‚àÄ {Œ± : Type u} {s : Set Œ±} [inst : ConditionallyCompleteLattice Œ±], Is Empty s ‚Üí ‚àÖ ‚â•‚Çò s := by\n  sorry ",
      "theorem iffIFF : ‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üî (a ‚Üîb) := by sorry ",
      "theorem neg_lt_neg : ‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] {a b : Œ±}, a < b ‚Üî b < -a := by sorry ",
      "theorem aux.6924583158815196396 {Œ± : Type u_1} [LT Œ±] {a : Œ±} {b : Œ±} (h : a < b) : ((b = a) ‚àñ False) = False := by\n  sorry ",
      "theorem not_for_in :\n    ‚àÄ {Œπ : Sort w} {Œπ': Type u_1} (f : Œπ ‚Ü™ List Œπ') (i : Œπ), not (f i ‚àà List.map (‚Üëf) [fun ‚®Ü(_ : b ‚àà List.map (‚Üëf) []), b]\n        [[f a] (le_refl b, ‚Üëf [])].val)) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} {ùí¢ : MeasureTheory.Filtration ‚Ñï m0}\n  {f : (a : ‚Ñï) ‚Üí (a : Œ©) ‚Üí ‚Ñù} [inst : MeasureTheory.IsFiniteMeasure Œº] (hadp : MeasureTheory.Adapted ùí¢ f)\n  (hint : ‚àÄ (i : ‚Ñï), MeasureTheory.Integrable (f i))\n  (hf :\n    ‚àÄ (œÑ : (a : Œ©) ‚Üí ‚Ñï) (œÄ : (a : Œ©) ‚Üí ‚Ñï) (a : MeasureTheory.IsStoppingTime ùí¢ œÑ) (a : MeasureTheory.IsStoppingTime ùí¢ œÄ)\n      (a : œÑ ‚â§ œÄ) (a : ‚àÉ N, ‚àÄ (œâ : Œ©), œÄ œâ ‚â§ N),\n      ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÑ x ‚àÇŒº ‚â§ ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÄ x ‚àÇŒº),\n  MeasureTheory.Submartingale f ùí¢ Œº)",
    "theorem": "theorem MeasureTheory.submartingale_of_expected_stoppedValue_mono :\n    (‚àÄ {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} {ùí¢ : MeasureTheory.Filtration ‚Ñï m0}\n      {f : (a : ‚Ñï) ‚Üí (a : Œ©) ‚Üí ‚Ñù} [inst : MeasureTheory.IsFiniteMeasure Œº] (hadp : MeasureTheory.Adapted ùí¢ f)\n      (hint : ‚àÄ (i : ‚Ñï), MeasureTheory.Integrable (f i))\n      (hf :\n        ‚àÄ (œÑ : (a : Œ©) ‚Üí ‚Ñï) (œÄ : (a : Œ©) ‚Üí ‚Ñï) (a : MeasureTheory.IsStoppingTime ùí¢ œÑ)\n          (a : MeasureTheory.IsStoppingTime ùí¢ œÄ) (a : œÑ ‚â§ œÄ) (a : ‚àÉ N, ‚àÄ (œâ : Œ©), œÄ œâ ‚â§ N),\n          ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÑ x ‚àÇŒº ‚â§ ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÄ x ‚àÇŒº),\n      MeasureTheory.Submartingale f ùí¢ Œº) :=\n  by sorry",
    "name": "MeasureTheory.submartingale_of_expected_stoppedValue_mono",
    "lemma-type": "{Œ© : Type u_1} ‚Üí\n  {m0 : MeasurableSpace Œ©} ‚Üí\n    {Œº : MeasureTheory.Measure Œ©} ‚Üí\n      {ùí¢ : MeasureTheory.Filtration ‚Ñï m0} ‚Üí\n        {f : (a : ‚Ñï) ‚Üí (a : Œ©) ‚Üí ‚Ñù} ‚Üí\n          [MeasureTheory.IsFiniteMeasure Œº] ‚Üí\n            (hadp : MeasureTheory.Adapted ùí¢ f) ‚Üí\n              (hint : ‚àÄ (i : ‚Ñï), MeasureTheory.Integrable (f i)) ‚Üí\n                (hf :\n                    ‚àÄ (œÑ : (a : Œ©) ‚Üí ‚Ñï) (œÄ : (a : Œ©) ‚Üí ‚Ñï) (a : MeasureTheory.IsStoppingTime ùí¢ œÑ)\n                      (a : MeasureTheory.IsStoppingTime ùí¢ œÄ) (a : œÑ ‚â§ œÄ) (a : ‚àÉ N, ‚àÄ (œâ : Œ©), œÄ œâ ‚â§ N),\n                      ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÑ x ‚àÇŒº ‚â§ ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÄ x ‚àÇŒº) ‚Üí\n                  ‚àÄ (i : ‚Ñï) (j : ‚Ñï) (hij : i ‚â§ j) (s : Set Œ©) (hs : MeasurableSet s),\n                    ‚à´ (x : Œ©) in s, f i x ‚àÇŒº ‚â§ ‚à´ (x : Œ©) in s, f j x ‚àÇŒº",
    "lemma": "theorem aux.9862157067470605474 {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©}\n    {ùí¢ : MeasureTheory.Filtration ‚Ñï m0} {f : (a : ‚Ñï) ‚Üí (a : Œ©) ‚Üí ‚Ñù} [MeasureTheory.IsFiniteMeasure Œº]\n    (hadp : MeasureTheory.Adapted ùí¢ f) (hint : ‚àÄ (i : ‚Ñï), MeasureTheory.Integrable (f i))\n    (hf :\n      ‚àÄ (œÑ : (a : Œ©) ‚Üí ‚Ñï) (œÄ : (a : Œ©) ‚Üí ‚Ñï) (a : MeasureTheory.IsStoppingTime ùí¢ œÑ)\n        (a : MeasureTheory.IsStoppingTime ùí¢ œÄ) (a : œÑ ‚â§ œÄ) (a : ‚àÉ N, ‚àÄ (œâ : Œ©), œÄ œâ ‚â§ N),\n        ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÑ x ‚àÇŒº ‚â§ ‚à´ (x : Œ©), MeasureTheory.stoppedValue f œÄ x ‚àÇŒº) :\n    ‚àÄ (i : ‚Ñï) (j : ‚Ñï) (hij : i ‚â§ j) (s : Set Œ©) (hs : MeasurableSet s),\n      ‚à´ (x : Œ©) in s, f i x ‚àÇŒº ‚â§ ‚à´ (x : Œ©) in s, f j x ‚àÇŒº :=\n  by sorry",
    "doc_string": "The converse direction of the optional stopping theorem, i.e. an adapted integrable process `f`\nis a submartingale if for all bounded stopping times `œÑ` and `œÄ` such that `œÑ ‚â§ œÄ`, the\nstopped value of `f` at `œÑ` has expectation smaller than its stopped value at `œÄ`. ",
    "generated": [
      "recall filter_upward : ‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {f : Œ± ‚Üí Œ±}, (‚àÄ (a : Œ±), p a ‚Üí f a = e \\[.data a]) ‚Üí ‚ãÉ y, Set.Range f = Set.univ := by sorry ",
      "state=true\ntheorem Set.univ_inter : ‚àÄ {Œ± : Type u} (x : Set Œ±), x ‚à© Set.univ = x := by sorry ",
      "theorem MeasureTheory.sum_integral_Ioc_le_int :\n    ‚àÄ {Œ± : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {a p : Œ±} (f g : Œ± ‚Üí ENNReal) (n : ‚Ñï)\n      z‚ÇÇ ùí¢ :\n      AEMeasurable f ‚Üí AEMeasurable g ‚Üí (MeasurableSet z‚ÇÇ ‚Üí ¬¨‚Üë‚ÜëŒº ‚Üëz‚ÇÇ = 0) ‚Üí MeasureTheory.Filtration.hasSubmartingaleProperty f ùí¢ Œº :=\n  by sorry ",
      "state={ measureTheory.measurePreserving_sub_right :\n    All (MeasureTheory.Measure Œ©) ‚Üí MeasureTheory.MeasureTheory.Measure.IsAddLeftInvariant ‚Ñï Œ© ‚Üí\n      MeasureTheory.MeasurePreserving (@PSub.addReindex ‚Ñï _ _ _ (fun Œº x => +‚Üë‚Üë({ toMeasurable (œÜ x) ‚àò x).2)).0) :=\n  by sorry ",
      "state that:\n  MeasureTheory.Submartingale f ùí¢ g ùîó_f cmps :=\n  (MeasureTheory.integral_cmpltu_le_of_hasSub f cmps ‚Ñº rg pf, MeasureTheory.Submartingale (MeasureTheory.upcrossings l f g_mem) ùí¢ g_mem) := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "recipe :\n| (‚àÄ {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} {ùí¢ : MeasureTheory.Filtration ‚Ñï m0}\n    {f : (a : ‚Ñï) ‚Üí (a : Œ©) ‚Üí ‚Ñù} [inst : MeasureTheory.IsFiniteMeasure Œº] (hadp : MeasureTheory.Adapted ùí¢ f)\n    (hint : ‚àÄ (i : ‚Ñï), MeasureTheory.Integrable (f i))\n    (hf :\n        ‚àÄ (œÑ : (a : Œ©) ‚Üí ‚Ñï) (œÄ : (a : Œ©) ‚Üí ‚Ñï) (a : MeasureTheory.IsStoppingTime ùí¢ œÑ)\n          (a : MeasureTheory.IsStoppingTime ùí¢ œÄ) (a : œÑ ‚â§ œÄ) (a : ‚àÉ N, œÉ œâ ‚â§ N),\n          ‚à´ (œâ : Œ©), MeasureTheory. stoppedValue f œÑ œâ ‚àÇŒº =g(œâ))\n    (œÉ : (a : Œ©) ‚Üí ‚Ñï) (LŒ≤ : MeasureTheory.Lp Œ≤ 99),\n      (MeasureTheory.condexp_empty ¬¨(MeasureTheory.IsStoppingTime ùí¢ max œÉ œÉ) LŒ≤) ‚Üí\n        (‚àÄ (Œæ : (a : Œ©) ‚Üí ENNReal), œÜ Œæ =·∂†[MeasureTheory.Measure.ae Œº] ((fun (œâ : Œ©) ‚Ü¶ -f (œÉ œâ)) ŒΩ x) (f (Œæ + x)) :=\n      by sorry ",
      "picture :subexpr (nat_fiber.meas-equiv Œ± n 0) \"\") ‚àÖ => \"\" } ‚àÄ (n' ‚àñ n'), Not (‚à£ (0 = BDOrder.mulDeficiency (œÉ n).inv_nonpos\n  œÉ n œÉn ((n ‚â§ _).mp )) ‚â§\n        n' - n‚à•), NF'\n        -- Porting note: mathlib4\n        True\n        -- Porting note: Lean 3\n        ff ;\n  (x‚ÇÄ : Œ±) (v : Vector Œ± 0) (m : BNFBoonDyn).toElt x‚ÇÄ v ‚Üí (N = n) ‚à® (0 < n') :: True :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {b : Œ±}\n  (h : a < b) (s : Set Œ±),\n  List.TFAE\n    [(s ‚àà nhdsWithin b (Set.Iio b)), (s ‚àà nhdsWithin b (Set.Ico a b)), (s ‚àà nhdsWithin b (Set.Ioo a b)),\n      (‚àÉ l, (l ‚àà Set.Ico a b) ‚àß (Set.Ioo l b ‚äÜ s)), (‚àÉ l, (l ‚àà Set.Iio b) ‚àß (Set.Ioo l b ‚äÜ s))])",
    "theorem": "theorem TFAE_mem_nhdsWithin_Iio :\n    (‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {b : Œ±}\n      (h : a < b) (s : Set Œ±),\n      List.TFAE\n        [(s ‚àà nhdsWithin b (Set.Iio b)), (s ‚àà nhdsWithin b (Set.Ico a b)), (s ‚àà nhdsWithin b (Set.Ioo a b)),\n          (‚àÉ l, (l ‚àà Set.Ico a b) ‚àß (Set.Ioo l b ‚äÜ s)), (‚àÉ l, (l ‚àà Set.Iio b) ‚àß (Set.Ioo l b ‚äÜ s))]) :=\n  by sorry",
    "name": "TFAE_mem_nhdsWithin_Iio",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  [TopologicalSpace Œ±] ‚Üí\n    [LinearOrder Œ±] ‚Üí\n      [OrderTopology Œ±] ‚Üí\n        {a : Œ±} ‚Üí\n          {b : Œ±} ‚Üí\n            (h : a < b) ‚Üí\n              (s : Set Œ±) ‚Üí\n                List.cons\n                    (‚áëOrderDual.ofDual ‚Åª¬π' s ‚àà\n                      nhdsWithin (OrderDual.toDual b) (Set.Ioc (OrderDual.toDual b) (OrderDual.toDual a))) =\n                  List.cons\n                    (‚áëOrderDual.ofDual ‚Åª¬π' s ‚àà nhdsWithin (OrderDual.toDual b) (‚áëOrderDual.ofDual ‚Åª¬π' Set.Ico a b))",
    "lemma": "theorem aux.171459546357797480 {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±} {b : Œ±}\n    (h : a < b) (s : Set Œ±) :\n    List.cons\n        (‚áëOrderDual.ofDual ‚Åª¬π' s ‚àà\n          nhdsWithin (OrderDual.toDual b) (Set.Ioc (OrderDual.toDual b) (OrderDual.toDual a))) =\n      List.cons (‚áëOrderDual.ofDual ‚Åª¬π' s ‚àà nhdsWithin (OrderDual.toDual b) (‚áëOrderDual.ofDual ‚Åª¬π' Set.Ico a b)) :=\n  by sorry",
    "doc_string": "The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-‚àû, b)`\n1. `s` is a neighborhood of `b` within `[a, b)`\n2. `s` is a neighborhood of `b` within `(a, b)`\n3. `s` includes `(l, b)` for some `l ‚àà [a, b)`\n4. `s` includes `(l, b)` for some `l < b` ",
    "generated": [
      "theorem le_of_tendsto_of_tendsto :\n    ‚àÄ {œÄ‚ÇÅ : ‚Ñù ‚Üí Œ±} {œÄ‚ÇÇ : ‚Ñù ‚Üí Œ≤} {Œπ : Type u_8} {l : Filter Œπ} {f : Œπ ‚Üí œÄ‚ÇÅ ‚Ü™o œÄ‚ÇÇ},\n      Filter.Tendsto œÄ‚ÇÅ f l (nhdsWithin ((‚Üëid).symm ‚ÅÜ Œ≤)) ‚Üí\n        Filter.Tendsto œÄ‚ÇÇ f l (nhds Œæ) ‚Üí l ‚â§ OrderHomClass.lipo f :=\n  by sorry ",
      "theorem And.left : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem And.RIGHT : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry ",
      "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry ",
      "theorem aux.13632345782811710264 {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±} {b : Œ±}\n    (h : a < b) (s : Set Œ±) : (List.chain r s none b)) = (Set.NotAnOrdConnected s) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± Œ≤ : Sort u} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.9011658868833865893 {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±} {b : Œ±}\n    (h : a < b) (s : Set Œ±) (t : Set Œ±)\n    (hst :\n      t ‚àà\n        List.map Membership.coe s\n          (Set.Ioo a b :: List.replicate (List.card (Set.Ico a b)) Set.Ioo a b ‚à™\n            List.replicate (List.card (Set.Ioc b a) ::¬†List.replicate (List.length (Set.Iio a) + 1) Set.Iii)\n              Set.Iii))\n    (_ :\n      ¬¨\n        (t ‚àà\n          List.map Membership.coe\n            (Set.Ico a b ‚à™ Set.Ioi a ‚à™ Set.Iic b ‚à™ List.map Membership.coe (Set.Ioi a) ::\n              []))) =\n      True :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ≤ : Type u_2} [inst_1 : One Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (E : Set Œ±) (x : Œ±),\n  ‚àÄ·∂† (Œ¥ : ‚Ñù) in nhds 0, Set.mulIndicator (Metric.cthickening Œ¥ E) f x = Set.mulIndicator (closure E) f x)",
    "theorem": "theorem mulIndicator_cthickening_eventually_eq_mulIndicator_closure :\n    (‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ≤ : Type u_2} [inst_1 : One Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (E : Set Œ±)\n      (x : Œ±),\n      ‚àÄ·∂† (Œ¥ : ‚Ñù) in nhds 0, Set.mulIndicator (Metric.cthickening Œ¥ E) f x = Set.mulIndicator (closure E) f x) :=\n  by sorry",
    "name": "mulIndicator_cthickening_eventually_eq_mulIndicator_closure",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [PseudoEMetricSpace Œ±] ‚Üí\n    {Œ≤ : Type u_2} ‚Üí\n      [One Œ≤] ‚Üí\n        (f : (a : Œ±) ‚Üí Œ≤) ‚Üí\n          (E : Set Œ±) ‚Üí (x : Œ±) ‚Üí (Œ¥ : ‚Ñù) ‚Üí (hŒ¥ : x ‚àâ Metric.cthickening Œ¥ E) ‚Üí (x ‚àâ Metric.cthickening Œ¥ E) = (¬¨False)",
    "lemma": "theorem aux.10662035246092834136 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] {Œ≤ : Type u_2} [One Œ≤] (f : (a : Œ±) ‚Üí Œ≤)\n    (E : Set Œ±) (x : Œ±) (Œ¥ : ‚Ñù) (hŒ¥ : x ‚àâ Metric.cthickening Œ¥ E) : (x ‚àâ Metric.cthickening Œ¥ E) = (¬¨False) := by sorry",
    "doc_string": "Pointwise, the multiplicative indicators of closed Œ¥-thickenings of a set eventually coincide\nwith the multiplicative indicator of the set as Œ¥ tends to zero. ",
    "generated": [
      "theorem forall_exists_congr : ‚àÄ {Œ± : Sort u_1} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a ‚Üî q a) ‚Üí ((‚àÄ (a : Œ±), p a) ‚Üî ‚àÉ a, q a) := by\n  sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem mul_le_mul_of_nonneg_right :\n    ‚àÄ {Œ± : Type u_2} {x y z : Œ±} [inst : Mul Œ±] [inst_1 : HasReflexiveContraction Œ±], y ‚â§ z ‚Üí z ÔøΩÔøΩistoNonneg x ‚Üí y * x ‚â§ z * x :=\n  by sorry ",
      "theorem filter_atTop_iff_eventually :\n    ‚àÄ {E : Type u_4} {G : Type u_5} [topologY : (continuous fun a : E x √ó E y ‚Ü¶ (a.1 = a.2): E √ó E‚ÇÅ = E √ó Œ±}],\n      ‚àÄ {u : FilterEither E Œ≤} {r : filter Œπ}, Filter.atTop (iF \"e\" u.1 r) = Filter.eventually u \"f\" r ‚Üí \"e\" u = s Inf 2 \"f\" :=\n  by sorry ",
      "theorem mulZero : ‚àÄ {M‚ÇÄ : Type u} [inst : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0 := by sorry ",
      "theorem NNReal.hasNon negInf_closure_cthickening :\n    ‚àÄ (œÅ : NNReal), EMetric.hausdorffEquiv NNReal.toNNReal (Metric.cthickeningInter œÅ Set.univ.inter E)(Metric.cthickening œÅ E).val :=\n  by sorry ",
      "theorem nhds_basis_closedBall :\n    ‚àÄ {X : Type u_2} [inst : TopologicalSpace X] {\\empty : Set X} filter := by sorry\n``` [/INST] theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem implies_true : ‚àÄ (Œ± : Sort u_1), (Œ± ‚Üí True) = True := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±] [inst_1 : LinearOrderedSemifield Œ≤]\n  {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g) (a : Antivary f‚Åª¬π g‚Åª¬π), Antivary f g)",
    "theorem": "theorem Antivary.of_inv‚ÇÄ :\n    (‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±]\n      [inst_1 : LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n      (a : Antivary f‚Åª¬π g‚Åª¬π), Antivary f g) :=\n  by sorry",
    "name": "Antivary.of_inv‚ÇÄ",
    "lemma-type": "{Œπ : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [inst : LinearOrderedSemifield Œ±] ‚Üí\n        [LinearOrderedSemifield Œ≤] ‚Üí\n          {f : (a : Œπ) ‚Üí Œ±} ‚Üí\n            {g : (a : Œπ) ‚Üí Œ≤} ‚Üí\n              (hf : StrongLT 0 f) ‚Üí\n                (hg : StrongLT 0 g) ‚Üí\n                  {Œπ : Type u_1} ‚Üí\n                    {Œ± : Type u_2} ‚Üí\n                      {Œ≤ : Type u_3} ‚Üí\n                        [LinearOrderedSemifield Œ±] ‚Üí\n                          [LinearOrderedSemifield Œ≤] ‚Üí\n                            {f : (a : Œπ) ‚Üí Œ±} ‚Üí\n                              {g : (a : Œπ) ‚Üí Œ≤} ‚Üí\n                                (hf : StrongLT 0 f) ‚Üí (hg : StrongLT 0 g) ‚Üí (Antivary f‚Åª¬π g‚Åª¬π) = (Monovary f g‚Åª¬π)",
    "lemma": "theorem aux.3750781883320893592 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±]\n    [LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n    {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [LinearOrderedSemifield Œ±] [LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±}\n    {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g) : (Antivary f‚Åª¬π g‚Åª¬π) = (Monovary f g‚Åª¬π) := by sorry",
    "doc_string": "**Alias** of the forward direction of `antivary_inv‚ÇÄ`.",
    "generated": [
      "theorem aux.15322151097324230916 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±]\n    [inst_1 : LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n    {Œπ : Type u_1} {√°l : Type u_2} {ƒÅl : Type u_3} {a : Œ±} {Œ± : Type} {Œ≤ : Type} (self : UniqueProd Œ± Œ≤)\n    (p : Œ±) (q : Œ≤) : ((p, q) < Set.univ) ‚Üî (id p < p) := by sorry ",
      "theorem aux.5129116152825281232 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [LinearOrderedSemifield Œ±]\n    [LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g) {i : Œπ}\n    {j : Œπ} {x : Œ±} {y : Œ≤} : ((f (j) / f i < f (x) / f y) ‚Üî (fy < f x / f i)) = ((y < x) ‚àß (f j < f i)) := by sorry ",
      "theorem Antivary.dual :\n    ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : Œπ ‚Üí Œ±}\n      {g : Œπ ‚Üí Œ≤}, Antivary f g ‚Üí Antivary g‚Åª¬π f‚Åª¬π :=\n  by sorry ",
      "theorem aux.15313875857296579870 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±]\n    [LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n    {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [LinearOrderedSemifield Œ±] [LinearOrderedSemifield Œ≤]\n    {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (h g : StrongLT 0 g) (a : Antivary f‚Åª¬π g) : g =·∂†[String.asEq ¬¨(0 < g)] f := by sorry ",
      "theorem AntivaryOn.map_rev :\n    ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : Preorder Œπ] [inst_1 : LinearOrderedCommSemifield Œ±]\n      [inst_2 : LinearOrderedCreature Œ±] (a : Œ±) {s : Filt Œπ} {t : Set Œπ} {f g : Œπ ‚Üí Œ±],\n      StrictMonoOn f s ‚Üí MonotoneOn g t ‚Üí s À¢À¢ t ‚Üí (AntivaryOn f‚Åª¬π g) ‚Üí Set.SquareRoot s f a :=\n  by sorry ",
      "theorem Antivary.(antivaryOn_finite :\n    ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±]\n      [inst_1 : LinearOrderedSemifield Œ≤] {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} {s : Finset Œπ},\n      AntivaryOn f g s ‚Üî ‚àÄ ‚¶Ék : Œπ‚¶Ñ (a : k ‚àà s) (‚¶Éj : Œπ‚¶Ñ (a : j ‚àà s) (a_1 : k < j),\n          f j (g j) < f k (g k) :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : alpha} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.15556551199329021075 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedSemifield Œ±]\n    [LinearOrderedSemifield Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} (hf : StrongLT 0 f) (hg : StrongLT 0 g) :\n    ite (Antivary f‚Åª¬π g‚Åª¬π) false = ite True true := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (p : ENNReal) {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤]\n  (f : WithLp p (Œ± √ó Œ≤)), edist f f = 0)",
    "theorem": "theorem WithLp.prod_edist_self :\n    (‚àÄ (p : ENNReal) {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤]\n      (f : WithLp p (Œ± √ó Œ≤)), edist f f = 0) :=\n  by sorry",
    "name": "WithLp.prod_edist_self",
    "lemma-type": "(p : ENNReal) ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [PseudoEMetricSpace Œ±] ‚Üí\n        [PseudoEMetricSpace Œ≤] ‚Üí\n          (f : WithLp p (Œ± √ó Œ≤)) ‚Üí (h : p = 0) ‚Üí (f : WithLp 0 (Œ± √ó Œ≤)) ‚Üí (edist (f.1) (f.1) = 0) = (0 = 0)",
    "lemma": "theorem aux.286702107682797299 (p : ENNReal) {Œ± : Type u_2} {Œ≤ : Type u_3} [PseudoEMetricSpace Œ±] [PseudoEMetricSpace Œ≤]\n    (f : WithLp p (Œ± √ó Œ≤)) (h : p = 0) (f : WithLp 0 (Œ± √ó Œ≤)) : (edist (f.1) (f.1) = 0) = (0 = 0) := by sorry",
    "doc_string": "The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ‚â§ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ",
    "generated": [
      "theorem LimitlessSpike.cauchy_edist :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤]\n      (œÜ : WithSemiliansing‚ÇÇ Œ± Œ≤), Filter.Lim œÜ EMetric.isBounded_edist' ‚àß IsCauSeqAbs œÜ ‚Üí Cauchy MFilter.edist P :=\n  by sorry ",
      "theorem zero_lt_edist_of_ne :\n    ‚àÄ {X : Type u} [inst : PseudoEMetricSpace X] {x y : X}, x ‚â† y ‚Üí 0 < edist x y := by sorry ",
      "theorem aux.212103030150679149 (p : ENNReal) {Œ± : Type u_2} {Œ≤ : Type u_3} [PseudoEMetricSpace Œ±]\n    [PseudoEMetricSpace Œ≤] (f : WithLp p (Œ± √ó Œ≤)) : (bddBelow ‚Üë(Finset.map (Prod. SND)) Set.univ) ‚Üî (iUnionPnh = 1) := by\n  sorry ",
      "theorem edist_self_zero : ‚àÄ (Œ± : Type u_3) [inst : PseudoEMetricSpace Œ±], edist a a = 0 := by sorry ",
      "theorem forall_congr' :\n    ‚àÄ {Œ± : Sort u_1} {Œ≤ : Œ± ‚Üí Sort u_2} {p q : (a : Œ±) ‚Üí Œ≤ a ‚Üí Prop},\n      (‚àÄ (a : Œ±), p a ‚Üî q a) ‚Üí (‚àÄ (a : Œ±) (b : Œ≤ a), p a b ‚Üí q a b) ‚Üí (‚àÄ (a : Œ±) (b : Œ≤ a), q a b) :=\n  by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem forall‚ÇÇ_zero_left : ‚àÄ {Œ≤ : Sort u_3} {f : Œ≤ ‚Üí (a : (a‚Ä† ())) ‚Üí Œ≤} (\\y : a‚Ä†), f y 0 = f y 0 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u_1} [inst : CommRing R] {p : ‚Ñï} {n : ‚Ñï} (hp : Nat.Prime p),\n  Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ‚Ñï) ‚Ü¶ (Polynomial.X ^ p ^ n) ^ i)",
    "theorem": "theorem Polynomial.cyclotomic_prime_pow_eq_geom_sum :\n    (‚àÄ {R : Type u_1} [inst : CommRing R] {p : ‚Ñï} {n : ‚Ñï} (hp : Nat.Prime p),\n      Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ‚Ñï) ‚Ü¶ (Polynomial.X ^ p ^ n) ^ i) :=\n  by sorry",
    "name": "Polynomial.cyclotomic_prime_pow_eq_geom_sum",
    "lemma-type": "{R : Type u_1} ‚Üí\n  [CommRing R] ‚Üí\n    {p : ‚Ñï} ‚Üí\n      {n : ‚Ñï} ‚Üí\n        (hp : Nat.Prime p) ‚Üí\n          (n_n : ‚Ñï) ‚Üí\n            (n_ih :\n                (Polynomial.cyclotomic (p ^ (n_n + 1)) R =\n                  Finset.sum (Finset.range p) fun (i : ‚Ñï) ‚Ü¶ (Polynomial.X ^ p ^ n_n) ^ i)) ‚Üí\n              (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p ^ 1)) =\n                (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p))",
    "lemma": "theorem aux.13501747065740856563 {R : Type u_1} [CommRing R] {p : ‚Ñï} {n : ‚Ñï} (hp : Nat.Prime p) (n_n : ‚Ñï)\n    (n_ih :\n      (Polynomial.cyclotomic (p ^ (n_n + 1)) R =\n        Finset.sum (Finset.range p) fun (i : ‚Ñï) ‚Ü¶ (Polynomial.X ^ p ^ n_n) ^ i)) :\n    (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p ^ 1)) =\n      (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p)) :=\n  by sorry",
    "doc_string": "If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ‚àë i in range p, (X ^ (p ^ n)) ^ i`. ",
    "generated": [
      "theorem not_isRegulus.intro :\n    ‚àÄ (p r m : ‚Ñï), Nat.Regular p ‚Üí ¬¨IsRegular p m ‚àï m = ¬¨m = 0 := by sorry ",
      "theorem Polynomial.geom_sum_char : ‚àÄ {R : Type u} [inst : Semiring R] {M : Submodule R R} (X : R}\n    (d : ‚Ñï)‚™∞ (a : DFunLike.module'' M R), a ‚àâ ideal.normalizer M·óÆ ‚Üí AddSubmonoid.closure a.toDFun = cyclotomic a R ‚Üí\n      Polynomial.eval ((Polynomial.X ^ d) ^ Submonoid.closure a) ((Polynomial.X ^ d' - Polynomial.C id x) ^ d) = ‚Üëa' (x ^ a'' ‚àó Polynomial.C a '' ‚Üëa' - a' + n) :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem forall_congr' : CongradMap Fun LikeEq (i = j) := by sorry\n```lean\ntheorem Polynomial.cyclotomic_prime_pow_eq_coeff' :\n    ‚àÄ {m p q : ‚Ñï}, m + p = q ‚Üí Nat.Prime p ‚Üí Polynomial.coeff (Polynomial.cyclotomic (p ^ (m + 1)) ‚Ñö) q = 1 :=\n  by sorry ",
      "theorem Polynomial.X_pow :\n    ‚àÄ {R : Type u} [inst : Ring R] {R : Type u} [inst_1 : Ring R] (n : ‚Ñï), (Polynomial.X ^ n) 1 = 0 := by sorry ",
      "theorem aux.3739555965487629955 {R : Type u_1} [CommRing R] {p : ‚Ñï} {n : ‚Ñï} (hp : Nat.Prime p) : Nat.Spectral.Order.Rel {p = p} = p :=\n  by sorry ",
      "theorem aux.116159194775349091 {R : Type u_1} [CommRing R] {p : ‚Ñï} {n : ‚Ñï} (hp : Nat.Prime p) : Polynomial.zero R = 0 :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] {f : (a : Œ±) ‚Üí Œ±} {s : Set Œ±} {Œº : MeasureTheory.Measure Œ±}\n  (hf : MeasureTheory.Conservative f Œº) (hs : MeasurableSet s),\n  ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÄ (a : x ‚àà s), ‚àÉ·∂† (n : ‚Ñï) in Filter.atTop, f^[n] x ‚àà s)",
    "theorem": "theorem MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem :\n    (‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] {f : (a : Œ±) ‚Üí Œ±} {s : Set Œ±} {Œº : MeasureTheory.Measure Œ±}\n      (hf : MeasureTheory.Conservative f Œº) (hs : MeasurableSet s),\n      ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÄ (a : x ‚àà s), ‚àÉ·∂† (n : ‚Ñï) in Filter.atTop, f^[n] x ‚àà s) :=\n  by sorry",
    "name": "MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem",
    "lemma-type": "{Œ± : Type u_2} ‚Üí\n  [MeasurableSpace Œ±] ‚Üí\n    {f : (a : Œ±) ‚Üí Œ±} ‚Üí\n      {s : Set Œ±} ‚Üí\n        {Œº : MeasureTheory.Measure Œ±} ‚Üí\n          (hf : MeasureTheory.Conservative f Œº) ‚Üí\n            (hs : MeasurableSet s) ‚Üí (n : ‚Ñï) ‚Üí (a : Œ±) ‚Üí (b : ‚Ñï) ‚Üí (b ‚â• n) = (n ‚â§ b)",
    "lemma": "theorem aux.7403816342325625438 {Œ± : Type u_2} [MeasurableSpace Œ±] {f : (a : Œ±) ‚Üí Œ±} {s : Set Œ±}\n    {Œº : MeasureTheory.Measure Œ±} (hf : MeasureTheory.Conservative f Œº) (hs : MeasurableSet s) (n : ‚Ñï) (a : Œ±) (b : ‚Ñï) :\n    (b ‚â• n) = (n ‚â§ b) := by sorry",
    "doc_string": "Poincar√© recurrence theorem: given a conservative map `f` and a measurable set `s`,\nalmost every point `x ‚àà s` returns back to `s` infinitely many times. ",
    "generated": [
      "theorem MeasureTheory.mem_properlySupportedLimitCoeffOn_iff :\n    ‚àÄ {E : Type u_1} [inst : NormedAddGroup E] [inst_1 : NormedSpace ‚Ñù E] {s : Set E} (f : ‚Üës ‚Üí E),\n      (‚àÄ·µê (x : E ‚àà closure (‚Üës \\ {x : E | IsAddUnit (f x)})),\n            Filter.Tendsto f MeasureTheory.measure.toMeasurableRoot (nhds (MeasureTheory.Conservative.lintegral.unit Œº f))) ‚Üî\n        Function.NormedAddGroupHom.mem_properlySupported Lp E MeasureTheory.measure.toMeasurable s f :=\n  by sorry ",
      "theorem Measurable.preimage_mem :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {u ùí´ : MeasurableSpace Œ±}\n      a ‚ä© u, Measurable (Function.Invfunc u) ‚Ä¢ MeasurableSpace.unders ùí´ ‚Üí ‚àÄ ‚¶Éa b : Set Œ≤‚¶Ñ (a_1 : a ‚àà ùí´), Œ≥ b ‚Üí* Œ± :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem HasSubset.Subset.trans :\n    ‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : IsTrans Œ± fun x x_1 => x ‚äÜ x_1] {a b c : Œ±}, a ‚äÜ b ‚Üí b ‚äÜ c ‚Üí a ‚äÜ c :=\n  by sorry ",
      "theorem aux.8100903620231943554 {Œ± : Type u_2} [MeasurableSpace Œ±] {f : (a : Œ±) ‚Üí Œ±} {s : Set Œ±}\n    {Œº : MeasureTheory.Measure Œ±} (hf : MeasureTheory.Conservative f Œº) (hs : MeasurableSet s) :\n    (fun (x : Œ±) ‚Ü¶ MeasureTheory.Conservative.mem_aE_of_freq_lt f Œº x true (frequently_image f_symm s)) ^ Set.univ =\n      fun (x : Œ±) ‚Ü¶ MeasureTheory.Conservative.frequently_image_mem f s :=\n  by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem MeasureTheory.Conservative.exists_le_of_compl2 :\n    ‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : Zero Œ±] {Œπ : Type u_3} {r : (a : Œπ), (Œπ ‚Üí Œ±) ‚Üí Set Œ±}\n      [hr‚ÇÅ : Countable Œπ] [hr‚ÇÇ : Set (Œπ ‚Üí Œ±) ‚Üí MeasurableSet fun i => (r i)·∂ú] (hf : ‚àÄ (i : Œπ), Measurable fun x => ‚Üë(r i) x)\n      (Œº ŒΩ : MeasureTheory.Measure Œπ ‚Üí‚ÇÄ MeasureTheory.Measure Œ±),\n      HasConservativeProperty r Œº ŒΩ ‚Üí\n        MeasureTheory.IsEverywherePos r x ‚àà Œº ‚Üí 0 ‚â§ Function.update r x ‚Üë(himp h r.mono h) x :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ùïú] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F]\n  (p : FormalMultilinearSeries ùïú E F) {n : ‚Ñï} (hn : ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), p m = 0),\n  HasFiniteFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 n ‚ä§)",
    "theorem": "theorem FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite :\n    (‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ùïú] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F]\n      (p : FormalMultilinearSeries ùïú E F) {n : ‚Ñï} (hn : ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), p m = 0),\n      HasFiniteFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 n ‚ä§) :=\n  by sorry",
    "name": "FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite",
    "lemma-type": "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    {F : Type u_3} ‚Üí\n      [NontriviallyNormedField ùïú] ‚Üí\n        [NormedAddCommGroup E] ‚Üí\n          [NormedSpace ùïú E] ‚Üí\n            [NormedAddCommGroup F] ‚Üí\n              [NormedSpace ùïú F] ‚Üí\n                (p : FormalMultilinearSeries ùïú E F) ‚Üí\n                  {n : ‚Ñï} ‚Üí (hn : ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), p m = 0) ‚Üí FormalMultilinearSeries.radius p = ‚ä§",
    "lemma": "theorem aux.8202823989322462433 {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField ùïú]\n    [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F]\n    (p : FormalMultilinearSeries ùïú E F) {n : ‚Ñï} (hn : ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), p m = 0) :\n    FormalMultilinearSeries.radius p = ‚ä§ := by sorry",
    "doc_string": "The sum of a finite power series `p` admits `p` as a power series.",
    "generated": [
      "theorem not_isClosed_univ : ‚àÄ {X : Type u} [inst : TopologicalSpace X], ¬¨IsClosed Set.univ := by sorry ",
      "theorem FormalMultilinearSeries.zero_apply_eq_zero :\n    ‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n      {n : ‚Ñï} (v : (a : E) ‚Üí ‚ÑÇ), (FormalMultilinearSeries.zero n v) 0 = 0 :=\n  by sorry ",
      "theorem aux.2528847503553816231 {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField ùïú]\n    [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F]\n    (p : FormalMultilinearSeries ùïú E F) {n : ‚Ñï} (hn : ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), p m = 0) (x : E)\n    (hx : ‚Äñx‚Äñ < ‚ÄñFormalMultilinearSeries.constSmul ùïú C x‚Äñ‚Çä * ‚Äñ27 * ‚Üë(FormalMultilinearSeries.constSmul ùïú C x‚Äñ)) :\n    ‚â° Set.Icc 0 (FormalMultilinearSeries.ppowerSeriesRadius p * Finset.prod finsuppOnEsm'') (‚®Ö., Set.Ioo 0 1).Ici :=\n  by sorry ",
      "theorem And.left : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí a := by sorry ",
      "theorem aux.3325236993146002284 {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField ùïú]\n    [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F]\n    (p : FormalMultilinearSeries ùïú E F) (n : ‚Ñï) : ‚à´ (r : ùïú), r‚Åø ¬∑ nr (|‚Üër|, n, r) = Finset.sum (Finset.range n) Nat.properFactorialFunction' n 5 := by\n  sorry ",
      "theorem Nat.succ_le_succ : ‚àÄ {m n : ‚Ñï}, m ‚â§ n ‚Üí Nat.succ m ‚â§ Nat.succ n := by sorry ",
      "theorem Finite.complete :\n    ‚àÄ {s : ‚àÄ r r' -> Set (‚Üës r) ‚Üí Finset (Set ‚Üës r')},\n      Finite ((a r d) ‚Üí Set ‚Üës d) ‚Üí rFinite r' {a :: r}' Set.empty ‚Üí SetUniv = Set.univ ‚Üí Set =rFlat s r' :=\n  by wlog x_1 : Set.univ = [[a]| (a b : Set.Finite s)]) :=\n  by sorry ",
      "theorem zero_powerSeries :\n    ‚àÄ {n : ‚Ñï} (h0 : n = Nat.zero), HasFinerStrictDerivOn ùïú n (0 ‚Ä¢ s) (fun ‚õÄ | 0 => Finset.sum s fun x => x ‚¥± 0)\n      (fun (_x :  Fin n) (nH : x = Nat.zero) (_y : n ‚â† Nat.zero) ‚Ü¶ by simp [Nat.zero_ne_succ]) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true),\n  Function.Injective ‚áëf)",
    "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true),\n      Function.Injective ‚áëf) :=\n  by sorry",
    "name": "PEquiv.injective_of_forall_ne_isSome",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    (f : Œ± ‚âÉ. Œ≤) ‚Üí\n      (a‚ÇÇ : Œ±) ‚Üí\n        (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true) ‚Üí\n          (x : Œ±) ‚Üí\n            (val : Œ≤) ‚Üí\n              (h : f x = some val) ‚Üí\n                (hfx : f x = some val) ‚Üí (Option.rec a‚ÇÇ id ((PEquiv.symm f) val) = x) = (Option.rec a‚ÇÇ id (some x) = x)",
    "lemma": "theorem aux.1710377048955077999 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±)\n    (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true) (x : Œ±) (val : Œ≤) (h : f x = some val)\n    (hfx : f x = some val) : (Option.rec a‚ÇÇ id ((PEquiv.symm f) val) = x) = (Option.rec a‚ÇÇ id (some x) = x) := by sorry",
    "doc_string": "If the domain of a `PEquiv` is `Œ±` except a point, its forward direction is injective. ",
    "generated": [
      "_aux.3047023095360460800 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±)\n    (h : ‚àÄ (a‚ÇÅ : Œ±) (a_1 : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true) (_y : Œ≤) (_w : Œ±)\n    (h : ‚àÄ (a : Œ≤) \\ (_x : f _w = a) (_t : Œ±) (_a : f _t = a‚ÇÅ), f _t ‚â† _w) :\n    ((Option.isSome { val := (_w), property := ((h s w))) = true) ‚àß\n        Option.get { val := (_w), property := ((h s w)) } _wh = _y) = True :=\n  by in sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "equation : Equiv.bijective f := by sorry ",
      "theorem Function.Bijective.injective_left :\n    ‚àÄ {Œ± Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {hf : Function.Bijective f}, ‚àÄ (a‚ÇÅ : Œ±) (hp‚ÇÅ : ‚ãÄ a‚ÇÇ, a‚ÇÅ ‚â† f a‚ÇÇ) (a‚ÇÇ : Œ±), f‚Åª¬π a‚ÇÇ ‚â† a‚ÇÅ :=\n  by sorry ",
      "theorem aux.2716876403454798198 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) :\n    ‚àÉ o‚ÇÇ, ‚àÄ (b : Œ≤), Eq ‚Üëo‚ÇÇ =‚Çê (‚áëf b) := by sorry ",
      "theorem Equiv.injective : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤), Function.Injective ‚áëe := by sorry ",
      "theorem aux.5517074343799770530 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±)\n    (h : ‚àÄ (a‚ÇÅ : Œ±) (a := a‚ÇÅ ‚â† a‚ÇÇ) (a : ¬¨(PEqs.Ne (f a‚ÇÅ) (f a‚ÇÇ))), Option.isSome (f a‚ÇÅ) = true)\n    (left : Option Œ≤ a‚ÇÇ = none) :\n    ‚àÄ (a : (‚àÄ (b : _ : OutParam Prop), Option.isSome (f (PEquiv.out f b)) ‚Üî false) ‚Üî False),\n      ‚àÖ = {Val.property none none} Œ≤ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {E : Type u_3} {E''' : Type u_12} [inst : Norm E] [inst_1 : SeminormedAddGroup E'''] {f : (a : Œ±) ‚Üí E}\n  {l : Filter Œ±} {g : (a : Œ±) ‚Üí E'''}, (f =O[l] g) ‚Üî (‚àÉ c, (c > 0) ‚àß (‚àÄ·∂† (x : Œ±) in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ)))",
    "theorem": "theorem Asymptotics.isBigO_iff' :\n    (‚àÄ {Œ± : Type u_1} {E : Type u_3} {E''' : Type u_12} [inst : Norm E] [inst_1 : SeminormedAddGroup E''']\n      {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {g : (a : Œ±) ‚Üí E'''},\n      (f =O[l] g) ‚Üî (‚àÉ c, (c > 0) ‚àß (‚àÄ·∂† (x : Œ±) in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ))) :=\n  by sorry",
    "name": "Asymptotics.isBigO_iff'",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  {E : Type u_3} ‚Üí\n    {E''' : Type u_12} ‚Üí\n      [Norm E] ‚Üí\n        [SeminormedAddGroup E'''] ‚Üí\n          {f : (a : Œ±) ‚Üí E} ‚Üí\n            {l : Filter Œ±} ‚Üí {g : (a : Œ±) ‚Üí E'''} ‚Üí (h : f =O[l] g) ‚Üí ‚àÉ c, ‚àÄ·∂† (x : Œ±) in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ",
    "lemma": "theorem aux.235911365833081276 {Œ± : Type u_1} {E : Type u_3} {E''' : Type u_12} [Norm E] [SeminormedAddGroup E''']\n    {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {g : (a : Œ±) ‚Üí E'''} (h : f =O[l] g) : ‚àÉ c, ‚àÄ·∂† (x : Œ±) in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=\n  by sorry",
    "doc_string": "Definition of `IsBigO` in terms of filters, with a positive constant. ",
    "generated": [
      "theorem Asymptotics.isBigOWith_def :\n    ‚àÄ {Œ± : Type u_1} {B : Type u_2} [inst : Norm B] (l : Filter Œ±) (f : Œ± ‚Üí B) (c : ENNReal),\n      Asymptotics.IsBigOWith c l f b = ‚Çì‚ä§ ‚äî ‚áëc ‚äì f :=\n  by sorry ",
      "theorem aux.18290243167645793532 {Œ± : Type u_1} {E : Type u_3} {E'' : Type u_12} [Norm E] [SeminormedAddGroup E'']\n    {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {g : (a : Œ±) ‚Üí E} :\n    ‚àÉc, ‚àÄ·∂† c in Filter.atTop, ‚Äñc‚Äñ * ‚Äñf x‚Äñ/|c| < ‚Äñf x‚Äñ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem not_isBigO_with_top_const_iff :\n    ‚àÄ (c : ‚Ñù) {Œ± : Type u_6} {E : Type u_7} [inst : Norm E] {f : Œ± ‚Üí E} (g' : Œ± ‚Üí E‚Åª·µ•) {l : Filter Œ±},\n      -c ‚â† 0 ‚Üí ‚àÄ (a : -Set.inv_neg_pos c * - (Asymptotics.isBigO f g' l) a { within := Filter.cocompact ‚Ñù }) ‚Üî\n        - (Asymptotics.IsBigO' WithTop.norm f g' l) c\n``` [/INST] theorem aux.16130696999329957539 (c : ‚Ñù) {Œ± : Type u_6} {E : Type u_7} [inst : Norm E] {f : Œ± ‚Üí E} (g' : Œ± ‚Üí E‚Åª·µ•)\n    {l : Filter Œ±} (-c ‚â† 0) : (Asymptotics.IsBigOWith c Asymptotics.cocompact (-C = 0) g' f l |\n      -Asymptotics.IsBigOWith (norm ‚àò g') (fun _x => ‚àíC) f l ‚Üí l = Filter.atBot)‚àÄ (_a : ‚Ñù) :: As _c : c < 0 := by\n  sorry ",
      "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry ",
      "theorem functurn' : ‚àÄ {s‚ÇÇ : Shrink.{1, u} s} (s‚ÇÅ : s) (c : Shrink.IsShrinkable s s‚ÇÄ) * c = Asymptotics.o‚ÇÇ _ s·µÉ·µí·µñ s‚ÇÄ 0 := by\n  sorry ",
      "theorem Asymptotics.isBilineryOn_eventually_eq_of_mem_nhds :\n    ‚àÄ {ùïú : Type u_3} {E' ''E'' : (a : ùïú) ‚Üí ùïú} {ùìñ'', t E‚ÇÇ' E'' : ùìï' ‚Üí* E‚ÇÇ''}\n      *ùìñ {E''‚ÇÇ''' : Type u_14} [[Inst { instInstSubtype ‚Üí instBirkhoffNormal ¬ªnormalizationExtension, sigma.normalizedRep ¬ªinstNormalization }] (ùìï' : TypeInst) (U : FunX ùïú\n      E‚ÇÇ'E'' √ó FunX Bool $Distrib ùïú) {ùì¶'ùì¨ : SingletonDistribExtension ‚Ñ§ ùì¶' ‚Üí Partension U}, A ‚âàL[ùìñ', B F‚úù¬ª t] E''‚ÇÇ'' ‚Üí ‚àÉ\n      {e‚ÇÅ : (a : B, F‚úù¬ª, A'), (B ‚Üí Fin ((E') ¬´instSubtype ùìï'] ‚Üí F‚ÇÅ·µí·µñ √ó Distrib ùì°'' √ó Œ£ mn ''(uMul ''(up ùìï : E'' ‚Üí A'')) ‚Üí D), Partiation ùìó',\n          U {e}, Fun·µ¢[0]] (E' : FinE : F) (gF : gF[instSubtypeDistribExtension √ó b.Bool xb.distribI]), ‚Ñï :=\n  by sorry ",
      "theorem aux.14501753572656890847 {Œ± : Type u_1} {E : Type u_3} {E'' : Type u_12} [Norm E] [SeminormedAddGroup E'']\n    {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {g : (a : Œ±) ‚Üí E''} (c : ‚Ñù)\n    (h : ‚àÄ·∫∞ (s : Set Œ±) in Filter.smallsets l, (a : Œ±) ‚Üí (a : Œ±) ‚Üí (a ‚àà s) ‚àß (‚Äñf a‚Äñ ‚â§ c * ‚Äñg a‚Äñ)) ( x : Œ±) :\n    ‚àÄ (i : Set Œ±),\n      ((x ‚àà i) ‚àß ((f x ‚àà Metric.closedBall (f x i) ({ a : Œ± => ‚Äñf x, f x‚ÇÄ ‚â• ‚Üëc * ‚Äñg x‚ÇÄ‚ü© a})) ‚àß\n          ({ a : Œ± => ‚Äñf x, f x‚ÇÄ ‚â§ ‚Üëc * ‚Äñg x‚ÇÄ‚ü© a})) =\n        (((i ‚àà ae_tends'' x fun i := (fun (a : Œ±) ‚Ü¶ (Real.toNN ‚Äñf a - f x‚ÇÄ‚Äñ Œµ) _a) s) ‚àß\n              (f x ‚àà Metric.closedBall (f x ^* { a : Œ± => ‚Äñf x a' := ‚Äñf x b - g x * f b‚Äñ aÃÅ b } x, fun a * b')\n                { (a : Œ± /* Œµ a).2 }))) ‚àß\n          ({ ‚ä§‚Ñõ := () } (((0 ‚àà {a : Œ± /* 0 ‚à® n ‚â§ Set.nonempty ‚Ñ§ c‚ÇÄ}) ‚äî\n                ((Real.toNNReal (‚Äñf x‚ÇÉ, if (0 > c) then Real.ofNN ‚ä§ else ‚Äñg x _3) < Œµ ))\n                Œá·óÆ))))) =\n      True :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën)",
    "theorem": "theorem Nat.cast_div_le : (‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën) := by\n  sorry",
    "name": "Nat.cast_div_le",
    "lemma-type": "{Œ± : Type u_1} ‚Üí [LinearOrderedSemifield Œ±] ‚Üí {m : ‚Ñï} ‚Üí {n : ‚Ñï} ‚Üí (h : n = Nat.zero) ‚Üí (‚Üë0 ‚â§ 0) = (0 ‚â§ 0)",
    "lemma": "theorem aux.8584203727976280226 {Œ± : Type u_1} [LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï} (h : n = Nat.zero) :\n    (‚Üë0 ‚â§ 0) = (0 ‚â§ 0) := by sorry",
    "doc_string": "Natural division is always less than division in the field. ",
    "generated": [
      "theorem nat_div_le_div : ‚àÄ {m n x : ‚Ñï} (h : 0 < m), m ‚à£ n ‚Üí n ‚â§ x ‚Üí ‚àáp‚Åª¬π ‚â• ‚Öüp m * x ‚Üî (p√∑m) ‚ãÜ (x / p) ‚â§ x := by sorry ",
      "equation_or_neq : ‚àÄ {a b : Prop}, (a ‚à® b) ‚à® ¬¨a := by sorry ",
      "theorem cast_one : ‚àÄ {Œ± : Type x} [inst : AddMonoidWithOne Œ±] [inst_1 : FullRangeOneClass Œ±], 1 = 1 := by sorry ",
      "theorem Nat.succ_le_iff : ‚àÄ {m n : ‚Ñï}, m ‚â§ Nat.succ n ‚Üî m ‚â§ n := by sorry ",
      "theorem aux.12029645306189357053 {Œ± : Type u_1} [LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï} :\n    n ‚Ä¢ ‚Üë(m / n) = n ‚Ä¢ ‚Üë((m / n).toNat) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Nat.cast_one : ‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R], ‚Üë1 = 1 := by sorry ",
      "theorem Nat.le_div_cancel_right : ‚àÄ {n : ‚Ñï} {a b : ‚Ñï} (hn0 : 0 ‚â§ n) (h : b > 0), n ‚â§ n * a / b * b ‚Üî n ‚â§\n  ‚Üëa := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true),\n  Function.Injective ‚áëf)",
    "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true),\n      Function.Injective ‚áëf) :=\n  by sorry",
    "name": "PEquiv.injective_of_forall_ne_isSome",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "If the domain of a `PEquiv` is `Œ±` except a point, its forward direction is injective. ",
    "generated": [
      "answer:\n```lean\nmodule Function.Equiv.Feq :\n  ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} [inst : Inhabited Œ±] [inst_1 : Inhabited Œ≤], Function.Eq OnFun\n    (ofFun (( ‚àÄ {x‚ÇÄ : Equiv.Perm Œ±} {x : Equiv.Perm Œ±}, ((‚áë‚Üë(MonoidHom.mconx f x‚ÇÄ)) ‚àò ‚áëx‚ÇÅ = (‚áë‚Üë(MonoidHom.mconx f x‚ÇÅ))) x‚ÇÄx_)\n      œÜ)) :=\n  by sorry\n``` [INST] sentence:\n\"function.eq_onFun :\n    ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} [inst : Inhabited Œ±] [inst_1 : Inhabited Œ≤] {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí‚òÖ Œ≤} (œÜ : ‚ñ¨f ‚Üí ‚ñ¨g)\n      {a : ‚ñ¨f} (b‚ÇÅ : Œ≤) (b‚ÇÇ : Œ≤), EquivFun OnFUN œâ œâ‚ÇÇ f‚ÇÅ ‚Üí b‚ÇÅ = Function.extend_atMost œâ‚ÇÇ œâ b‚ÇÇ if h : atLeast œâ f‚ÇÅ\n        rœÜ := Function.FunLikeExtending œâ Rg Œ≥; if ConnSupp œâ = True then EquivFunOfEq œÜ : function.eq\n        if (wLogical œÜ fun s 0 => Bool b‚ÇÇ (‚ä¢ b = b‚ÇÇ)) ; Equiv‚ÇÇ.update œâ Bool f √ó¬∞'\n        Function.EqOn œâ Bool fun i' i ‚Ü¶ b' :=\n  if true then False else Function.EqOn œâ‚ÇÇ g‚ÇÇ (g‚ÇÇ i ‚Üí b‚ÇÇ i); True := IsBoolean Œ≥ :=\n  by sorry ",
      "theorem one_ne_top : ‚àÄ {Œ± : Type u_2} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, 1 ‚â† ‚ä§ := by sorry ",
      "_hints = & {{ val := fun (h : ‚àÄ {w‚ÇÅ : List Œ≤} {w‚ÇÇ : List Œ≤} ('a : False) ‚Ü¶ False)  (_ : PEquiv.IsSublist (‚áëf w) w) } =>\n  Nat.lt_or_eq { val := ((1)), isLt := True }\n}}‚ü© 0 < List.length w)) 1\n``` ‚ä• :=\n  by sorry ",
      "theorem aux.4065458902552170980 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ),\n        Optional.isSome (f a‚ÇÅ) = true) : And (Option.isSome (f default) = false) (f default ‚àà ‚ÜëFinset.univ) := by\n  sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem implies_congr : ‚àÄ {p‚ÇÅ p‚ÇÇ : Sort u} {q‚ÇÅ q‚ÇÇ : Sort v}, p‚ÇÅ = p‚ÇÇ ‚Üí q‚ÇÅ = q‚ÇÇ ‚Üí (p‚ÇÅ ‚Üí q‚ÇÅ) = (p‚ÇÑ ‚Üí q·µ¢) := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "Theorem.trans Eq.substr_left : fun {Œ± : Type u} {e :Œ±} {t :(a :Œ±) ‚Üí Prop} {n : ‚Ñï} (h : ‚àÄ (a :Œ±), a = e ‚Üí t a) (n pos : ¬¨n ‚â• pos), t n :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} [inst : Monoid Œ±] [inst_1 : HasDistribNeg Œ±] (u : Œ±À£), ‚Üë(-u) = -‚Üëu)",
    "theorem": "theorem Units.val_neg : (‚àÄ {Œ± : Type u} [inst : Monoid Œ±] [inst_1 : HasDistribNeg Œ±] (u : Œ±À£), ‚Üë(-u) = -‚Üëu) := by sorry",
    "name": "Units.val_neg",
    "lemma-type": "‚àÄ {Œ± : Sort u} {a : Œ±}, a = a",
    "lemma": "theorem rfl : ‚àÄ {Œ± : Sort u} {a : Œ±}, a = a := by sorry",
    "doc_string": "Representing an element of a ring's unit group as an element of the ring commutes with\nmapping this element to its additive inverse. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Units.val_coe : ‚àÄ {N : Type u_3} {G : Type u_4} [inst : Zero M‚Çì] [inst_1 : One M‚Çì] [Mnd : MonoidNotGpd N]\n    [inst_2 : MonoidWithZero G] (u : N.Units), ‚Üë((Units.up u)‚Åª¬π) = ‚Üëu‚Åª¬π := by sorage ",
      "theorem funext_iso :\n    ‚àÄ {Œ± Œ≤ : Type u‚ÇÅ} [inst : Fintype Œ±] [inst_1 : DecidableEq Œ±] [inst_2 : Skeletal Œ±] (e : Œ± ‚Üí Œ≤)\n      {G : CategoryTheory.Functor Œ≤ ¬´category¬ª Œ±} [i : CategoryTheory.IsIso G],\n      ‚àÉ f, e ‚ãô G.map e = ‚áëf :=\n  by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Units.inv_eq_one : ‚àÄ {Œ± : Type u} [inst : Monoid Œ±] {u : Œ±À£}, ‚Üëu * ‚Üëu = 1 := by sorry ",
      "theorem aux.14846154537659006265 {Œ± : Type u} [Monoid Œ±] [HasDistribNeg Œ±] (u : Œ±) : (- ‚Üë(-u) = - -‚Üëu) := by sorry ",
      "theorem Units.zero_add : ‚àÄ {Œ≤ : Type u_2} [inst : MulZeroClass Œ≤] (a : Œ≤À£), ‚Üë0 + a = a‚Åª¬π * ‚Üë0 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±}\n  {k : Set Œ±} (hk : IsCompact k) (h'k : k ‚äÜ s \\ Œº.everywherePosSubset s), ‚Üë‚ÜëŒº k = 0)",
    "theorem": "theorem MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset :\n    (‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±}\n      {k : Set Œ±} (hk : IsCompact k) (h'k : k ‚äÜ s \\ Œº.everywherePosSubset s), ‚Üë‚ÜëŒº k = 0) :=\n  by sorry",
    "name": "MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "Any compact set contained in `s \\ Œº.everywherePosSubset s` has zero measure. ",
    "generated": [
      "theorem MeasureTheory.everywherePosSubset_empty :\n    ‚àÄ {Œ± : Type u_1 ¬ª}, MeasureTheory.Measure.EverywherePosSubset ÔøΩempty = ‚Üë‚ä• := by sorry ",
      "theorem And.right : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry ",
      "theorem isCompact_subset_to_sInter :\n    ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n      IsCompact s ‚Üí ‚àÄ Z ‚äÜ s, IsCompact Z ‚Üí ‚àÉ t, closure ‚Üët ‚äÜ Z ‚àß IsCompact ‚Üët ‚àß ‚Üët ‚äÜ s :=\n  by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem And.right : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry ",
      "theorem And.true_iff : ‚àÄ {a b : Prop}, (a ‚àß b) = b := by sorry ",
      "theorem IsCompact.isLindelof : ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, LindelofCompactCover s ‚Üí\n    IsLindelof s := by sorry ",
      "theorem And.imp : ‚àÄ {a c b d : Prop}, (a ‚àß c ‚Üí b) ‚Üí (a ‚àß c ‚Üí d) ‚Üí a ‚Üí b := fun _ _ => true ‚àß (_ ‚Ü¶ _) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)), ‚Äñy‚Äñ / Real.Angle.tan (Orientation.oangle o x (x + y)) = ‚Äñx‚Äñ)",
    "theorem": "theorem Orientation.norm_div_tan_oangle_add_right_of_oangle_eq_pi_div_two :\n    (‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)), ‚Äñy‚Äñ / Real.Angle.tan (Orientation.oangle o x (x + y)) = ‚Äñx‚Äñ) :=\n  by sorry",
    "name": "Orientation.norm_div_tan_oangle_add_right_of_oangle_eq_pi_div_two",
    "lemma-type": "‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x y : V},\n  Real.Angle.sign (Orientation.oangle o x y) = 1 ‚Üí Orientation.oangle o x y = ‚Üë(InnerProductGeometry.angle x y)",
    "lemma": "theorem Orientation.oangle_eq_angle_of_sign_eq_one :\n    ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x y : V},\n      Real.Angle.sign (Orientation.oangle o x y) = 1 ‚Üí Orientation.oangle o x y = ‚Üë(InnerProductGeometry.angle x y) :=\n  by sorry",
    "doc_string": "A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side. ",
    "generated": [
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem aux.11569733973616732827 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) :\n    -Orientation.oangle o (x + y) y = -Real.Angle.tan (Orientation.oangle o x (x + y)) * ‚Äñy‚Äñ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem tan_div_cos_angle_add_pi_over_two_mul_cos_angle_add_pi_div_two_ne_zero :‚àÄ {Œ© : Type u_1} [inst : MeasurableSpace Œ©]\n  [inst_1 : StandardBorelSpace Œ©] [inst_2 : Nonempty Œ©] {ŒΩ : MeasureTheory.Measure Œ©} (Œµ : ‚Ñù)\n  (h : measurement._measurableMeasureProd.1 Œµ a (x_0 +·µ• Orientation.symm o))) :\n    (Orientation.oangle o x y = -‚Üë(Real.pi / 2)) = (-Orientation.oangle o (x + Orientation.rotation o y) x = ‚Üë(Real.pi / 2)) :=\n  by sorry ",
      "theorem aux.11996271270067309010 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) :\n    ‚ü™x, x‚ü´_‚Ñù / (‚ü™y, y‚ü´_‚Ñù - ‚ü™y, x‚ü´_‚Ñù) = 1 := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem aux.10812979539567059122 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) : Orientation.oangle o x y = -Orientation.oangle o y x := by\n  sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n  (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚áë(thickenedIndicator (Œ¥seq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : Œ±) ‚Ü¶ 1)))",
    "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n      (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±),\n      Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚áë(thickenedIndicator (Œ¥seq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : Œ±) ‚Ü¶ 1))) :=\n  by sorry",
    "name": "thickenedIndicator_tendsto_indicator_closure",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [PseudoEMetricSpace Œ±] ‚Üí\n    {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} ‚Üí\n      (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) ‚Üí\n        (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) ‚Üí (E : Set Œ±) ‚Üí (x : Œ±) ‚Üí (¬¨(1 = ‚ä§)) = True",
    "lemma": "theorem aux.1997760250860239422 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù}\n    (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±) (x : Œ±) :\n    (¬¨(1 = ‚ä§)) = True := by sorry",
    "doc_string": "As the thickening radius Œ¥ tends to 0, the Œ¥-thickened indicator of a set E (in Œ±) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `Œ± ‚Üí·µá ‚Ñù‚â•0`. Coercions to functions `Œ± ‚Üí ‚Ñù‚â•0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.16136253624779284202 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù}\n    (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±)\n    (x : Œ±) : Filter.cofinite ‚â§ Filter.cofinite := by sorry ",
      "theorem IsClosed.isCCC :\n    ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : IsClosed X] [_f : Filter.HasAntitoneBasis self id],\n      CompleteSpace X :=\n  by sorry ",
      "theorem Real.lt_add_of_neg_of_pos : ‚àÄ {r s w t : ‚Ñù}, r < t ‚Üí ‚ä• < w ‚Üí 0 < s ‚Üí 0 < r + w + t * s := by sorry ",
      "theorem Filter.Tendsto.and_converse :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {la : Œπ ‚Üí Œ±} and Œ≥ : Type u_4} {lbd : Œ≤ ‚Üí Œ¥ Œ≥ 3‚Üí* Œª l, Œ±} ùìï(a', a'' : Œ≤ ‚Üí Œ≥) {b : u_4 ‚Üí uùí¢'} for f : Œπ ‚Üí u_4 ‚Üí iStmrt u_7 ‚Üí uùí¢a_2 ‚Üí ra ‚Üí uùí¢a, and for s, s' t t, q ‚à™ g = t‚à©s :=\n  if (‚àÄ x ‚àä u_a s, P x) then f s t t w g True else f s t' (f' _ Œ∏) True :=\n  by sorry ",
      "theorem aux.10576651938801085164 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù}\n    (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±) (x : Œ±)\n    (xdistant : x ‚àâ closure E) (n : ‚Ñï) (hedist : edist x (CLOSURE E) = ‚Üën) (hex : x ‚àâ closure (clusterPt (n, E) E)) :\n    0 < NNReal.div ‚Üë(Nat.succ n) (Max (n + 1) ((clusterPt n E, E)).1) + 0 := by sorry ",
      "theorem compl_false : (¬¨False) = True := by sorry ",
      "theorem tendsto_nsum_prod := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o x (x + y)) = ‚Äñy‚Äñ / ‚Äñx‚Äñ)",
    "theorem": "theorem Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two :\n    (‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o x (x + y)) = ‚Äñy‚Äñ / ‚Äñx‚Äñ) :=\n  by sorry",
    "name": "Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two",
    "lemma-type": "{V : Type u_1} ‚Üí\n  [NormedAddCommGroup V] ‚Üí\n    [InnerProductSpace ‚Ñù V] ‚Üí\n      [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] ‚Üí\n        (o : Orientation ‚Ñù V (Fin 2)) ‚Üí\n          {x : V} ‚Üí\n            {y : V} ‚Üí\n              (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) ‚Üí\n                (Real.tan (InnerProductGeometry.angle x (x + y)) = ‚Äñy‚Äñ / ‚Äñx‚Äñ)",
    "lemma": "theorem aux.2028864372143458793 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) : (Real.tan (InnerProductGeometry.angle x (x + y)) = ‚Äñy‚Äñ / ‚Äñx‚Äñ) :=\n  by sorry",
    "doc_string": "The tangent of an angle in a right-angled triangle as a ratio of sides. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem real_smul : ‚àÄ (R : Type u_3) {M : Type u_5} [inst : MulActionWithZero R M] (r : ‚Ñù) (x : M),\n    ‚Üë[-r] ‚Ä¢ x = ((monoidWithZeroHom.toZeroHom $ smulAddHomM ‚Ñù R M) ‚Üë[-r]) x :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Orientation.tan_oangle_add_right :\n    ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x y : V},\n      Orientation.oangle o x y ‚â† 0 ‚Üí Real.Angle.tan (Orientation.oangle o x (x + y)) = ‚Äñy‚Äñ / ‚Äñx‚Äâ‚Äñ :=\n  by sorry ",
      "thesis: Real.Angle.tan_coe_angle :\n    ‚àÄ {r : ‚Ñù}, (r > 0) ‚Üí Real.tan ‚Üë(Real.Angle.coe_angle r * r) = ÔøΩÔøΩ wurfel.c : (r > 0) ‚Üí Real.tan ‚Üër * r = |r| :=\n  by sorry ",
      "theorem AddEquiv.apply_symm_apply :\n    ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} (f : Œ± ‚âÉ+ Œ≤) (b : Œ≤) (a : Œ±), (PeroidicPoints.addOrderOf ‚ü®a, fa‚ü© b) =\n      (PeriodicPoints.addOrderOf ‚ü®b, fa‚ü© a) :=\n  by sorry ",
      "theorem Right.lt_self_span_orthogonality_orthogonal :\n    ‚àÄ {ùïú : Type u_1} {M : Type u_7} [inst : DivisionOrder ùïú] [inst_1 : NormedDivisionRing ùïú]\n      [inst_2 : VectorSpan ùïú M] ŒΩ : MeasureTheory.TMeasurePreservingSp ùïú M, x < x ‚Üí x = ‚Üë1 :=\n  by sorry ",
      "theorem Orientation.tan_oangle_add_left_of_oangle_eq_pi_div_two :\n    ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x y : V},\n      Orientation.oangle o y x = ‚Üë(Real.pi / 2) ‚Üí Real.Angle.tan (Orientation.oangle o (y + x) y) = ‚Äñx‚Äñ / ‚Äñy‚Äñ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (a : Œ±),\n  UV.compress u v (UV.compress u v a) = UV.compress u v a)",
    "theorem": "theorem UV.compress_idem :\n    (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n      [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (a : Œ±),\n      UV.compress u v (UV.compress u v a) = UV.compress u v a) :=\n  by sorry",
    "name": "UV.compress_idem",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "Compressing an element is idempotent. ",
    "generated": [
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem aux.2849954342073695879 {Œ± : Type u_1} [GeneralizedBooleanAlgebra Œ±] [DecidableRel Disjoint]\n    [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (a : Œ±) : Disjoint a ‚äï u ‚äî ‚ä§ = ‚ä• := by soracef ",
      "theorem aux.5295949374283023739 {Œ± : Type u_1} [Generic Booleanalge m] [DecidableRel Disjoint] [InstDeCoeGT Œ± ‚Ñ§‚â•0]\n    [Decidable Rel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) :\n    ‚àÄ (a : Completion.Nonempty (UV.filterCompress u v)),\n      ‚àÉ a_1, (a_1 ‚àà Completion.Nonempty (UV.fill f (UV.filterCompress u v))) ‚àß (‚ü™f u, a_1‚ü´_‚Ñù = False) :=\n  by sorry ",
      "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry ",
      "theorem and_iff_right_trans : ‚àÄ {c : Prop} {o‚ÇÅ‚ÇÇ : Prop}, o‚ÇÅ‚ÇÇ ‚Üî (c ‚àî o‚ÇÅ‚ÇÇ) := by sorry ",
      "theorem aux.1740973330456563769 {Œ± : Type u_1} [GeneralizedBooleanAlgebra Œ±] [DecidableRel Disjoint]\n    [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (a : Œ±) (m : UV.Compress u v) :\n    (a ‚â§ u ‚äì (v \\ (UV.compress u v a))·∂ú) ‚à® (a ‚ô° UV.compress u v) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b), Filter.Tendsto (fun (x : ‚Ñù) ‚Ü¶ x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0))",
    "theorem": "theorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero :\n    (‚àÄ (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b), Filter.Tendsto (fun (x : ‚Ñù) ‚Ü¶ x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0)) :=\n  by sorry",
    "name": "tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero",
    "lemma-type": "(s : ‚Ñù) ‚Üí\n  (b : ‚Ñù) ‚Üí\n    (hb : 0 < b) ‚Üí\n      {x : ‚Ñù |\n          (fun (x : ‚Ñù) ‚Ü¶ (fun (x : ‚Ñù) ‚Ü¶ Real.exp (b * x) / x ^ s)‚Åª¬π x = (fun (x : ‚Ñù) ‚Ü¶ x ^ s * Real.exp (-b * x)) x)\n            x} ‚àà\n        Filter.atTop",
    "lemma": "theorem aux.4837246918429735454 (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b) :\n    {x : ‚Ñù |\n        (fun (x : ‚Ñù) ‚Ü¶ (fun (x : ‚Ñù) ‚Ü¶ Real.exp (b * x) / x ^ s)‚Åª¬π x = (fun (x : ‚Ñù) ‚Ü¶ x ^ s * Real.exp (-b * x)) x) x} ‚àà\n      Filter.atTop :=\n  by sorry",
    "doc_string": "The function `x ^ s * exp (-b * x)` tends to `0` at `+‚àû`, for any real `s` and `b > 0`. ",
    "generated": [
      "thesis :\n((Filter.map (fun (x : ‚Ñù) ‚Ü¶ ‚Üë(ExpLinearWithConstants.toLaplace s x)) Filter.atTop) ‚â§ Filter.atTop) = True := by sorry ",
      "mathlib_raw_obj_test : ‚àÄ {C‚ÇÅ : Type u_1}, Sorcery.Cmd C‚ÇÅ.cmd œÜ --> ‚àár := some r, œï := œÜ.Suc ‚Ñ§ r ‚Üí œÜ.Suc C‚ÇÅ.cmd œÜ ‚Åª¬π\n        n = œï S œÜ n ^ 2 √ó ‚ÜëNat.PartDvd.sndsP (phi.Suc' _ this : S ‚Üën.PartDvd) fun i x =>\n          Sorcery.PartDvdP.hyp i fun a => ((œÜ' Œ±) (_ ¬∑ o [n.PartDvd‚ü¶x‚üß] = x).b) fun (_ : a) ‚Ü¶ œÜ' Œ±.SufCom.SufHyps.v Œ± _ = 0 ùü™\n        _ :=\n  by sorry ",
      "theorem aux.10857438901812244659 (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b) (x : Filter ‚Ñù) (x_1 : Prop)\n    (_aux_35 : Œ≤‚Åª¬π > 0) : (0 < Complex.log (‚Üëx_1 - 1)‚Åª¬π) = (0 < -Complex.log 1‚Åª¬π) := by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero :\n    ‚àÄ (s : ‚Ñù) (b : ‚Ñù), 0 < s ‚Üí ‚àÄ (a : ‚Ñù), Filter.Tendsto (fun x => x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0) :=\n  by sorry ",
      "theorem aux.18445182523400882928 (s : ‚Ñù) (b : ‚Ñù) (hb : 0 < b) :\n    ‚àÄ (g : ‚Ñù ‚Üí ‚Ñù),\n      (‚àÄ (x : ‚Ñù), |g x * Real.exp (-b * x) ‚â§ -x ^ s / 6) =\n        (![(fun (x : ‚Ñù) ‚Ü¶ x ^ FunLike.coe forallEmergingNormNumbers] * fun (x : ‚Ñù) ‚ñ∏ Real.exp (-b * x)) +\n            0 +Real.sgn (1 / 26 ^ s) * (|1/(b * x|^s| * |Real.exp (-b * x)| + |Complex.re (-Complex.exp x)) / 6|) +\n              0 <\n          b ^ max i ^ Nat.succ) :=\n  by sorry ",
      "theorem LE.le_antisymm_iff : ‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üî b ‚â§ a := by sorry ",
      "theorem norm_pos_of_ne_zero :\n    ‚àÄ {Œ± : Type u_1} [inst : StrongerOnPreconnectativity Œ±] (x : Œ±) (hx : x ‚â† ‚ä§) (y : ENNReal)\n      (hy : y ‚â† 0), 0 < y * Real.sqrt x * f | (x = ‚ä§) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)), Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i))",
    "theorem": "theorem Fin.rev_predAbove :\n    (‚àÄ {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)), Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) := by\n  sorry",
    "name": "Fin.rev_predAbove",
    "lemma-type": "{n : ‚Ñï} ‚Üí\n  (p : Fin n) ‚Üí\n    (i : Fin (n + 1)) ‚Üí\n      (Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) =\n        (Fin.rev (Fin.predAbove p i) = Fin.rev (Fin.predAbove p (Fin.rev (Fin.rev i))))",
    "lemma": "theorem aux.9532200532789665707 {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)) :\n    (Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) =\n      (Fin.rev (Fin.predAbove p i) = Fin.rev (Fin.predAbove p (Fin.rev (Fin.rev i)))) :=\n  by sorry",
    "doc_string": "`rev` commutes with `predAbove`. ",
    "generated": [
      "theorem aux.18294273450882761455 {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)) : Œ∑ ‚âà Œ∑ := by sorry ",
      "theorem Function.Injective.exists_congr' :\n    ‚àÄ {Œ± : Sort u_1} {y‚ÇÅ y‚ÇÇ : Œ±} {f : Œ± ‚Üí Sort v} (hf : Function.Injective f),\n      filter (Pure.coind i f ‚áë(hPure fun x => x = y‚ÇÅ)) i.drop f bredLift = bredLift f :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.6112666407626131102 {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)) (a : Fin n) :\n    ((Fin.castPred (Eq.reflect (Fin.succ_pred_le_succ lhd))) a = true) = (a < n) := by sorry ",
      "theorem aux.3635606783207791588 {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)) (val : ‚Ñï)\n    (hk : val < Fin.castSucc n)\n    (he : ¬¨(Fin.castSucc val < Fin.castSucc p)) : Nat.succ val < n := by sorry ",
      "question:\nHow to prove this? Just a Lean 4 proof would do. \n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem Fin.rev_predAbove :\n    (‚àÄ {n : ‚Ñï} (p : Fin n) (i : Fin (n + 1)), Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) := by\n  sorry\n``` [/INST] answer:\nwith Fin.consRecOn.reduce_right :\n‚àÄ {T : (Œ≤ : Unit.{unit_case_fin_zero x + Nat.zero} √ó ((i : Fin) ‚Üí X i) ‚Üí Type u_1) ‚Üí (Unit.case (fun Œ≤ i ‚Ü¶ Type u_2) Œ± => Œ≤ () (Fin.one) + fun Œ≤ fun (N.{unit_case_fin_zero u'}.succ x => i‚Åª¬π := true; a (0 i) := x - i‚Åª¬π‚Åª¬π = i‚Åª¬π + id i); true) (‚Üë(Fin.rev p)) (_x : ((n : ‚Ñï) ‚Üí X n) {} * {n' : Nat} ‚Üí FunUnit (Fin.refl ((‚Üë() + 1) ‚Ä¢ (i' := ((1 - True) * Unit.) n := fun a => True a))) œâ),\n        Œπ x r‚ÇÅ s √ó f ((Fin r‚ÇÅ : true) (Unit.succ () _r + a) := f ((finUnitPowN Z ùïú Unit n) * a (i : Nat) : { fun (b : Nat) ‚Ü¶ Z b = ùïú | ¬¨ Expoenegebogenitys b).1)))) :\n    œÄ √ó Œπ ((Fin r‚ÇÅ + Fin.natAdd r'.succ n' = Fin r‚Ä≤' ‚Ä¢ (finUnitPowD Z (Nat.sup ‚Üën'.succ n‚ÇÅ) n = Nat.castCircleZ x)) * {b + (s, {a : ‚Üë((a : Fin (f ‚Ä¢ F)) + n) / f : Fin ‚Üë()}).val‚ÇÄ := +‚Üë‚Üës a}) :=\n  by sorry ",
      "theorem aux.10777859701257538643 {n : À¢‚äï n}‚Çä (p : Fin n) (i : Fin (n + 1)) : Fin.rev (Fin.predAbove p i) = Fin.rev i :=\n  by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {p : ‚Ñï} (a : Nat.Prime p), Prime p)",
    "theorem": "theorem Nat.Prime.prime : (‚àÄ {p : ‚Ñï} (a : Nat.Prime p), Prime p) := by sorry",
    "name": "Nat.Prime.prime",
    "lemma-type": "‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] {p : Œ±}, Prime p ‚Üí Irreducible p",
    "lemma": "theorem Prime.irreducible : ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] {p : Œ±}, Prime p ‚Üí Irreducible p := by\n  sorry",
    "doc_string": "**Alias** of the forward direction of `Nat.prime_iff`.",
    "generated": [
      "theorem Nat.Prime.pos : ‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí 0 < p := by sorry ",
      "theorem MulZeroClass.zero_mul : ‚àÄ {M : Type u} [self : MulZeroClass M] (a : M), 0 * a = 0 := by sorry ",
      "theorem dvd_of_dvd_mul_left : ‚àÄ {Œπ : Sort u_1} {Œ± : Type u_2} [inst : DivMonoid Œ±] {a b : Œ±}, a ‚à£ b * a ‚Üî b ‚à£ a := by\n  sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem of_eq_true : ‚àÄ {a : Prop}, a = True ‚Üí a := by sorry ",
      "theorem aux.6253139026232724278 {p : ‚Ñï} (a : Nat.Prime p) ((a_1 : 0 < p): prop) : p = NatPrime.proof ‚Üëa :=\n  by sorry ",
      "theorem ofEq‚ÇÉEq_zero : ‚àÄ {Œ± : Type u_2} [inst : zero_ne_one : Œ±) {a b c : Œ±}, a = b ‚Üî a ‚â† 0 ‚Üî b ‚â† 0 ‚àß b - a = c := by\n  sorry ",
      "theorem aux.10232112589286252140 {p : ‚Ñï} (hp : Prime p) : p ‚â† 0 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n  {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x),\n  ‚àÉ t, (k ‚äÜ t) ‚àß ((IsOpen t) ‚àß (Bornology.IsBounded (f '' (t ‚à© s)))))",
    "theorem": "theorem Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n      {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x),\n      ‚àÉ t, (k ‚äÜ t) ‚àß ((IsOpen t) ‚àß (Bornology.IsBounded (f '' (t ‚à© s))))) :=\n  by sorry",
    "name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [PseudoMetricSpace Œ±] ‚Üí\n      [TopologicalSpace Œ≤] ‚Üí\n        {k : Set Œ≤} ‚Üí\n          {s : Set Œ≤} ‚Üí\n            {f : (a : Œ≤) ‚Üí Œ±} ‚Üí\n              (hk : IsCompact k) ‚Üí\n                (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x) ‚Üí\n                  Filter.HasBasis (nhdsSet k ‚äì Filter.principal s) (fun (U : Set Œ≤) ‚Ü¶ (IsOpen U) ‚àß (k ‚äÜ U))\n                    fun (i : Set Œ≤) ‚Ü¶ i ‚à© s",
    "lemma": "theorem aux.12231346685720257598 {Œ± : Type u} {Œ≤ : Type v} [PseudoMetricSpace Œ±] [TopologicalSpace Œ≤] {k : Set Œ≤}\n    {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x) :\n    Filter.HasBasis (nhdsSet k ‚äì Filter.principal s) (fun (U : Set Œ≤) ‚Ü¶ (IsOpen U) ‚àß (k ‚äÜ U)) fun (i : Set Œ≤) ‚Ü¶ i ‚à© s :=\n  by sorry",
    "doc_string": "If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. ",
    "generated": [
      "theorem aux.5452391817114349032 {Œ± : Type u} {Œ≤ : Type v} [PseudoMetricSpace Œ±] [TopologicalSpace Œ≤] {k : Set Œ≤}\n    {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x) :\n    ‚àÉ x u v r hr hxs hvt h,\n      (IsOpen x) ‚àß\n        ((k ‚äÜ Metric.toBasis edist √óÀ¢ (congrArg id (Filter.comap Prod.fst (Metric.toBasisEdist ‚äì r)))) x) ‚àß\n              ((v ‚àà congr (fun (x : Œ≤) (a : Œ≤) ‚Ü¶ Prod.fst (x, Prod.snd x)) x) ‚àß\n                (IsOpen (Set.prod x v ‚à© s)) ‚àß\n                  (Bornology.IsBounded (f '' ((Set.prod x v) ‚à© s))))) :=\n  by sorry ",
      "theorem LipschitzWith.forall_exists_lt_norm_image :",
      "theorem Set.image_subset_subset_image_iff :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {s‚ÇÅ s‚ÇÇ : Set Œ±} ‚¶Ét : Set Œ≤‚¶Ñ, Set.Image f t ‚äÜ t ‚Üî s‚ÇÅ ‚äÜ\n      s‚ÇÇ ‚Üî s‚ÇÅ ‚äÜ {x | f x ‚àà s‚ÇÇ} :=\n  by sorry ",
      "theorem metric_closedBall :\n    ‚àÄ {Œ± : Type u} [inst : pseudemetricSpace Œ±] {p x : Œ±} and 0 < r, Metric.closedBall p r = Metric.closedBall p ‚Äñr‚Äñ :=\n  by sorry ",
      "theorem IsOpen.dense_diff_sunion_closure :\n    ‚àÄ {X : Type u} [inst : TopologicalSpace X], IsClosed Set.univ ‚Üí\n      ‚àÄ {s t : Set X}, open_sUnion s ‚Üí s ‚à© t = ‚àÖ ‚Üí dense ‚Üës·∂ú ‚Üí closure t = univ ‚Üí IsDense (t·∂ú \\ s·∂ú) :=\n  by sorry ",
      "theorem subtype_range_prop :\n    ‚àÄ {Œ± : Sort u_2} (s s' : Set Œ±), {a | (‚àÉ a_1, (a_1 ‚àà s) ‚àß HEq Œ±_1 a) = a} ‚äÜ {b | ‚àÉ a, HEq Œ± b} := by\n  sorry ",
      "theorem aux.8600726621856986066 {Œ± : Type u} {Œ≤ : Type v} [PseudoMetricSpace Œ±] [TopologicalSpace Œ≤] {k : Set Œ≤}\n    {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x) (i : Œ≤)\n    (hi : i ‚àà compactCovering k) (x : Œ≤) (a : x ‚àà i ‚à© s) : OpenMap id := by sorry ",
      "theorem ENNReal.isLUB_add : ‚àÄ {a_1 : ENNReal} {s : Set ENNReal}, IsLUB s a‚ÇÄ ‚Üî 0 ‚â§ a‚ÇÄ ‚àß a‚ÇÄ < (s ‚à™ {a‚ÇÄ}) + a_1) := by\n  sorry\n``` [/INST] theorem IsLUB.add :\n    ‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LE Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedAddCommGroup Œ±]\n      [inst_4 : CompleteSpace Œ±] {s : Set Œ±} {a : Œ±}, IsLUB s a ‚Üí ‚Öü0 = 0 ‚Üí IsLUB (Subtype.val ‚Åª¬π' s ‚à™ {a}) a :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï),\n  ((NormedSpace.expSeries ‚Ñù (Quaternion ‚Ñù) (2 * n)) fun (x : Fin (2 * n)) ‚Ü¶ q) =\n    ‚Üë((-1) ^ n * ‚Äñq‚Äñ ^ (2 * n) / ‚Üë(Nat.factorial (2 * n))))",
    "theorem": "theorem Quaternion.expSeries_even_of_imaginary :\n    (‚àÄ {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï),\n      ((NormedSpace.expSeries ‚Ñù (Quaternion ‚Ñù) (2 * n)) fun (x : Fin (2 * n)) ‚Ü¶ q) =\n        ‚Üë((-1) ^ n * ‚Äñq‚Äñ ^ (2 * n) / ‚Üë(Nat.factorial (2 * n)))) :=\n  by sorry",
    "name": "Quaternion.expSeries_even_of_imaginary",
    "lemma-type": "{q : Quaternion ‚Ñù} ‚Üí (hq : Quaternion.re q = 0) ‚Üí (n : ‚Ñï) ‚Üí n ^ 1 = n",
    "lemma": "theorem aux.8900386680158670694 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï) : n ^ 1 = n := by sorry",
    "doc_string": "The even terms of `expSeries` are real, and correspond to the series for $\\cos ‚Äñq‚Äñ$. ",
    "generated": [
      "theorem Complex.ofReal_cos ‚Üë(Real.pi / 2) = ‚Üë(Real.cos (Real.pi / 2) * Complex.I) := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "Theorem aux.967927796308799739 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï) :\n    Nat.one * (((IsCoprime.intYact hq (0) n) ‚à® True) := by sorry) = 0 := by sorry ",
      "theorem rpow_zero : ‚àÄ {M‚ÇÄ : Type u_2} [inst : MonoidWithZero M‚ÇÄ] (a : M‚ÇÄ), a ^ 0 = 1 := by sorry ",
      "theorem aux.8952674411696521114 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) :\n    ‚àÄ (_x : Nat √ó Quaternion ‚ÑùÀ£), (‚ü™{} √ó {q}, {-0.ofReal (q.re), ofReal ‚Üë(q.im)}‚üå > 0) = True := by sorry ",
      "theorem aux.5952992777515058865 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï)\n    (I : ‚ÑÇ) (hq : q = 0) : ComplexNumber.exp II ‚àô ComplexNumber.uI * I = -I := by sorry ",
      "theorem aux.17671372762069857683 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï) :\n    (NormedSpace.expSeries ‚Ñù (Quaternion ‚Ñù) 1) q = q / Quaternion.re q := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0))",
    "theorem": "theorem vectorSpan_range_eq_span_range_vsub_right :\n    (‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ),\n      vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0)) :=\n  by sorry",
    "name": "vectorSpan_range_eq_span_range_vsub_right",
    "lemma-type": "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Sort u_4} (g : Œ± ‚Üí Œ≤) (f : Œπ ‚Üí Œ±), Set.range (g ‚àò f) = g '' Set.range f",
    "lemma": "theorem Set.range_comp :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Sort u_4} (g : Œ± ‚Üí Œ≤) (f : Œπ ‚Üí Œ±), Set.range (g ‚àò f) = g '' Set.range f := by\n  sorry",
    "doc_string": "The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right. ",
    "generated": [
      "theorem IsEmpty.of_subsingleton : ‚àÄ {Œ± : Sort u_2} [h : Subsingleton Œ±], IsEmpty Œ± := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.11806828786179854519 (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V]\n    [inst_2 :Module k V] [AddTorsor V P] [hnorm : Nontrivial V] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ) :\n    Submodule.coe '' Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0 =\n      Finset.univ i.image0 i {p i -·µ• x | ‚àÄ (i_1 : i ‚àà Finset.univ), (p i, x ‚àà affineSpan k {p i}^À£) ‚àß y = p i} :=\n  by sorry ",
      "theorem le_total : ‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a b : Œ±), a := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "statement=begin\nnot_canLindemannType : WellFounded (TypeÔøΩÔøΩutatilon) :=\nby sorry  #\nEnd ‚¶Ñ} {Œ∫‚ÇÄ : String ‚Üí Type _} {P : (a : 0 ‚Üí œÅ·µÉ·µí·µñ √ó Œπ‚ÇÄ‚ÇÖ) ‚Üí Prop} (_v : VecEmul m ((m‚ÇÄŒπ¬´Subsingleton VecBasis m Œπ‚ÇÄ‚ÇÖ œÜ)) F F‚Çör) :\n    Eq true ‚Üî True := by sorry ",
      "theorem vectorSpan_span_range_self_eq_top :\n    ‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : CommRing k] [inst_1 : AddCommGroup V]\n      [inst_2 : Module k V] [inst_3 : AddTorsor V P] (p : P), vectorSpan k (Set.range p) = ‚ä§ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : (a : X) ‚Üí Y) (s : Set X)\n  (h :\n    ‚àÄ (x : X) (a : x ‚àà s),\n      ‚àÉ e,\n        (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n          (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n  IsLocalHomeomorphOn f s)",
    "theorem": "theorem IsLocalHomeomorphOn.mk :\n    (‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : (a : X) ‚Üí Y)\n      (s : Set X)\n      (h :\n        ‚àÄ (x : X) (a : x ‚àà s),\n          ‚àÉ e,\n            (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n              (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n      IsLocalHomeomorphOn f s) :=\n  by sorry",
    "name": "IsLocalHomeomorphOn.mk",
    "lemma-type": "{X : Type u_1} ‚Üí\n  {Y : Type u_2} ‚Üí\n    [TopologicalSpace X] ‚Üí\n      [TopologicalSpace Y] ‚Üí\n        (f : (a : X) ‚Üí Y) ‚Üí\n          (s : Set X) ‚Üí\n            (h :\n                ‚àÄ (x : X) (a : x ‚àà s),\n                  ‚àÉ e,\n                    (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n                      (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))) ‚Üí\n              (x : X) ‚Üí\n                (hx : x ‚àà s) ‚Üí\n                  ‚àÄ (e : PartialHomeomorph X Y)\n                    (h :\n                      (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n                        (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n                    ‚àÉ e, (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß (f = ‚Üëe)",
    "lemma": "theorem aux.14122557828600958787 {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : (a : X) ‚Üí Y) (s : Set X)\n    (h :\n      ‚àÄ (x : X) (a : x ‚àà s),\n        ‚àÉ e,\n          (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n            (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e))))\n    (x : X) (hx : x ‚àà s) :\n    ‚àÄ (e : PartialHomeomorph X Y)\n      (h :\n        (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n          (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n      ‚àÉ e, (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß (f = ‚Üëe) :=\n  by sorry",
    "doc_string": "Proves that `f` satisfies `IsLocalHomeomorphOn f s`. The condition `h` is weaker than the\ndefinition of `IsLocalHomeomorphOn f s`, since it only requires `e : PartialHomeomorph X Y` to\nagree with `f` on its source `e.source`, as opposed to on the whole space `X`. ",
    "generated": [
      "theorem aux.7708996240049289889 {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : (a : X) ‚Üí Y) (s : Set X)\n    (h :\n      ‚àÄ (x : X) (a : x ‚àà s),\n        ‚àÉ e,\n          (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ‚àß\n            (Set.EqOn f (‚Üëe) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))) :\n    _root_.EqOn Set.Icc _ id univ := by sorry ",
      "theorem Homeomorph.source_top :\n    ‚àÄ {X : Type u_10} [inst : TopologicalSpace X] (self : Homeomorph X X), ‚Üëself.source·µí·µñ = Set.univ := by sorry ",
      "theorem PartialHomeomorph.self_source :\n    ‚àÄ {X : Type u_1} {Œ∫ : type u_3} {y : X}, PartialHomeomorph y y = ‚áë(Homeomorph.id y) := by sorry ",
      "theorem Left.trans : ‚àÄ {Œ± : Sort u} {a b c : Œ±}, a = b ‚Üí b = c ‚Üí a = c := by sorry ",
      "theorem aux.9831466253693632787 {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n    (f : (a : X) ‚Üí Y) (s : Set X)\n    (h :\n      ‚àÄ (x : X) (a : x ‚àà s),\n        ‚àÉ i e,\n          (x ‚àà PartialEquiv.source (PartialHomeomorph.toPartialEquiv i)) ‚àß\n            (Set.EqOn f (‚Üëi) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))) :\n    And (‚àÉ x f_1,\n          (x ‚àà s) ‚àß (¬¨(‚àÉ f_2, True))) ‚à®\n        (‚àÉ b f_3,\n          (f ‚Åª¬π' id s ‚úì b) ‚àß\n            ((‚àÄ x_3 [inst : x ‚àà (Function.source f ‚à© idInvariantNhdsSetBy x‚ÇÄ x‚ÇÄs b)],\n                  ‚àÉ z w y,\n                    (((Prod.mk f_1 (Function.Id y) id x b e).1 ‚àà z) ‚àß\n                        (((Prod.mk f_1 (Function.Id y) id x b e).2 ‚àà w)) ‚àß\n                          ((w = idHomotopic f (id =·∂¶ Prod.mk f_1 y) id z z')))) )) :=\n  by sorry ",
      "theorem IsLocalHomeomorph.closure_preimage_source' :\n    ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n      {f : X ‚Üí Y} {s : Set Y} (h : IsLocalHomeomorph f), StrictMapsOn f s (PartialHomeomorph.source (f.toPartialHomeomorph))) :=\n  by sorry ",
      "theorem forall_congr : ‚àÄ {Œ± : Sort u*} {p q : ÿß¬òÿ±·µèŒ±}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : „ÅÇ¬∂ÈÉë‚Ñ¢–∞–ª—å), p a) = ‚àÄ (a : ”ôÿß‚Ñ¢ÿßŸÑ), q a :=\n  by sorry ",
      "theorem aux.5151018248214399429 {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : (a : X) ‚Üí Y) (s : Set X) :\n    ‚àÄ (x : X) (mx : x ‚àà s), IsLocalHomeomorphOn (Set.restr f s) s := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : Setoid Œ±] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ) = (r a‚ÇÇ b‚ÇÇ)},\n  (WellFounded (Quotient.lift‚ÇÇ r H)) ‚Üî (WellFounded r))",
    "theorem": "theorem wellFounded_lift‚ÇÇ_iff :\n    (‚àÄ {Œ± : Type u_1} [inst : Setoid Œ±] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n      {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ) = (r a‚ÇÇ b‚ÇÇ)},\n      (WellFounded (Quotient.lift‚ÇÇ r H)) ‚Üî (WellFounded r)) :=\n  by sorry",
    "name": "wellFounded_lift‚ÇÇ_iff",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [inst : Setoid Œ±] ‚Üí\n    {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} ‚Üí\n      {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ) = (r a‚ÇÇ b‚ÇÇ)} ‚Üí\n        (wf : WellFounded r) ‚Üí (q : Quotient inst) ‚Üí (a : Œ±) ‚Üí (h : ‚ü¶a‚üß = q) ‚Üí Acc r a",
    "lemma": "theorem aux.3973682479709683842 {Œ± : Type u_1} [inst : Setoid Œ±] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n    {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ) = (r a‚ÇÇ b‚ÇÇ)} (wf : WellFounded r)\n    (q : Quotient inst) (a : Œ±) (h : ‚ü¶a‚üß = q) : Acc r a := by sorry",
    "doc_string": "A relation is well founded iff its lift to a quotient is. ",
    "generated": [
      "theorem Symm‚ÇÇ.trans: ‚àÄ {Œ± : Sort u_1} {x y z : Œ± ‚Üí Œ±}, Symm‚ÇÇ X (Sum.inl y) (Sum.inr z) √ó Sum.inl (x (Symm‚ÇÇ.pair y z)) =\n    (Symm‚ÇÇ.trans' (_ : Sum.map‚ÇÇ X xs yn := by sorry) X (Symm‚ÇÇ.of Eq ( Eq.refl ((y, z).2)).pair) val).pair :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem WellFounded.set_induction_refl _ : ‚àÄ {x : Type u_2} r x, (AccOfs ‚òè r) x ‚Üî WellFounded (‚áër) ‚Äñ x := by sorry ",
      "theorem rfl : ‚àÄ{Œ± : Sort u} {a : Œ±}, a = a := by sorry ",
      "theorem wellFounded_of_sup' : ‚àÄ {M‚ÇÄ : M.PrimQuot ‚Üí Prop} {s : M.World √ó { a // X ‚äÜ M‚ÇÄ a }},\n    MapSupHom.WellFounded (MapSupQuot.relevantFun s fun x => M‚ÇÄ x) s\n    ‚Üí\n‚àÄ P : (‚àÄ x, x ‚àà ULTSupped M‚ÇÄ), ‚àÉ w, TrueMapSuppQuot H w P :=\n  by sorry ",
      "type u_1 : Type v\n(x : U' ((EqvGen u_1) a1) [h1x ¬∑ : (EqvGen u_1) a2]) (xs : FEq u (x, r t xs xs 0 2 r fun (x : (u, U'))\n    (y : (u, U')) (tx : Type v') (hvt : FEq v v) (xty : ((x, x0‚ÇÅ, x0‚ÇÇ) == ((xs, y) a + v)))) : i √ó u_1 :=\n  fun ‚Ü¶ Eq.(exists, exists) ‚Üëx [hxt, h_1' /r x : x.2 ‚Üí y.1 * v = y.2] {[y :: [f.6 hy] =>\n        HEq ?(Prod.fst.trans ‚Üëh_1' [h, h‚ÇÅ : f [i, y] ++ f.6 hy = (‚Üët + b = f.5 x) y _ x_2)]} [((if h‚ÇÅ ùíú\n              (if h‚ÇÑ: U = A then ùíú e ifcelse False.intro else f.3 h‚ÇÉ hx _ Œ±) False_‚ÑÇ), False])\n    H: (r a + t h).card * v.card = (t x œâ r (f ‚ü®i.2 / R, y := False.left).fap [i, ht.toSorted h if1] y e) œâ\n        y\n          (Eqs.rfl + Nat.zero)\n          { w := ((t (x ((a, u', this).w))) v ) } (u := u') =\n        (t x œâ i Œ± /\n             ‚Üë(Quot.mk (EquivRel.Perm R ((EqvGen r + QuandleTrivQuot R ‚Üëv) ‚àà (‚Ü™ a (fun o => False) i)))) h;\n        { some_v := (((i * U'.card) == TrivialMul.one i)), is :: ((a = ((v := None) [a]).val * Nat.zero)), g' := i' x h }} :=\n  by sorry ",
      "theorem LiftRLift.accSpec_le :\n    ‚àÄ (o : Wellfounded (Con.Quotient (Setoid.Df.Quot)) ‚Üî Wellfounded (Setoid.AuxSetoid.Quot xp_tr_well)‚¶Ñ), True,\n      LiftRLift.AccSpec o :=\n  by sorry ",
      "theorem aux.4947813979252827163 ùí£‚ÇÇ\n    (wf‚ÇÇ : WellFounded (Quotient.lift‚ÇÇ r H ‚àò Quotient.mk''\")) : Nonempty ‚Üì(Nonempty (Quotient Œ± ùíê)) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u} {S : Type v} {œÉ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n  {f‚ÇÅ : MvPolynomial œÉ R ‚Üí+* S} {f‚ÇÇ : MvPolynomial œÉ R ‚Üí+* S} {p‚ÇÅ : MvPolynomial œÉ R} {p‚ÇÇ : MvPolynomial œÉ R}\n  (hC : RingHom.comp f‚ÇÅ MvPolynomial.C = RingHom.comp f‚ÇÇ MvPolynomial.C)\n  (hv :\n    ‚àÄ (i : œÉ) (a : i ‚àà MvPolynomial.vars p‚ÇÅ) (a : i ‚àà MvPolynomial.vars p‚ÇÇ),\n      f‚ÇÅ (MvPolynomial.X i) = f‚ÇÇ (MvPolynomial.X i))\n  (hp : p‚ÇÅ = p‚ÇÇ), f‚ÇÅ p‚ÇÅ = f‚ÇÇ p‚ÇÇ)",
    "theorem": "theorem MvPolynomial.hom_congr_vars :\n    (‚àÄ {R : Type u} {S : Type v} {œÉ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n      {f‚ÇÅ : MvPolynomial œÉ R ‚Üí+* S} {f‚ÇÇ : MvPolynomial œÉ R ‚Üí+* S} {p‚ÇÅ : MvPolynomial œÉ R} {p‚ÇÇ : MvPolynomial œÉ R}\n      (hC : RingHom.comp f‚ÇÅ MvPolynomial.C = RingHom.comp f‚ÇÇ MvPolynomial.C)\n      (hv :\n        ‚àÄ (i : œÉ) (a : i ‚àà MvPolynomial.vars p‚ÇÅ) (a : i ‚àà MvPolynomial.vars p‚ÇÇ),\n          f‚ÇÅ (MvPolynomial.X i) = f‚ÇÇ (MvPolynomial.X i))\n      (hp : p‚ÇÅ = p‚ÇÇ), f‚ÇÅ p‚ÇÅ = f‚ÇÇ p‚ÇÇ) :=\n  by sorry",
    "name": "MvPolynomial.hom_congr_vars",
    "lemma-type": "{R : Type u} ‚Üí\n  {S : Type v} ‚Üí\n    {œÉ : Type u_1} ‚Üí\n      [CommSemiring R] ‚Üí\n        [CommSemiring S] ‚Üí\n          {f‚ÇÅ : MvPolynomial œÉ R ‚Üí+* S} ‚Üí\n            {f‚ÇÇ : MvPolynomial œÉ R ‚Üí+* S} ‚Üí\n              {p‚ÇÅ : MvPolynomial œÉ R} ‚Üí\n                {p‚ÇÇ : MvPolynomial œÉ R} ‚Üí\n                  (hC : RingHom.comp f‚ÇÅ MvPolynomial.C = RingHom.comp f‚ÇÇ MvPolynomial.C) ‚Üí\n                    (hv :\n                        ‚àÄ (i : œÉ) (a : i ‚àà MvPolynomial.vars p‚ÇÅ) (a : i ‚àà MvPolynomial.vars p‚ÇÇ),\n                          f‚ÇÅ (MvPolynomial.X i) = f‚ÇÇ (MvPolynomial.X i)) ‚Üí\n                      (hp : p‚ÇÅ = p‚ÇÇ) ‚Üí\n                        MvPolynomial.eval‚ÇÇHom (RingHom.comp f‚ÇÇ MvPolynomial.C) (‚áëf‚ÇÇ ‚àò MvPolynomial.X) = f‚ÇÇ",
    "lemma": "theorem aux.17110266887352964056 {R : Type u} {S : Type v} {œÉ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f‚ÇÅ : MvPolynomial œÉ R ‚Üí+* S} {f‚ÇÇ : MvPolynomial œÉ R ‚Üí+* S} {p‚ÇÅ : MvPolynomial œÉ R} {p‚ÇÇ : MvPolynomial œÉ R}\n    (hC : RingHom.comp f‚ÇÅ MvPolynomial.C = RingHom.comp f‚ÇÇ MvPolynomial.C)\n    (hv :\n      ‚àÄ (i : œÉ) (a : i ‚àà MvPolynomial.vars p‚ÇÅ) (a : i ‚àà MvPolynomial.vars p‚ÇÇ),\n        f‚ÇÅ (MvPolynomial.X i) = f‚ÇÇ (MvPolynomial.X i))\n    (hp : p‚ÇÅ = p‚ÇÇ) : MvPolynomial.eval‚ÇÇHom (RingHom.comp f‚ÇÇ MvPolynomial.C) (‚áëf‚ÇÇ ‚àò MvPolynomial.X) = f‚ÇÇ := by sorry",
    "doc_string": "If `f‚ÇÅ` and `f‚ÇÇ` are ring homs out of the polynomial ring and `p‚ÇÅ` and `p‚ÇÇ` are polynomials,\nthen `f‚ÇÅ p‚ÇÅ = f‚ÇÇ p‚ÇÇ` if `p‚ÇÅ = p‚ÇÇ` and `f‚ÇÅ` and `f‚ÇÇ` are equal on `R` and on the variables\nof `p‚ÇÅ`.  ",
    "generated": [
      "theorem MvPolynomial.X : ‚àÄ {R : Type u} {S_inst : Type u_1} (i : (a : (S_inst : Type u_1) Œ±) ‚Üí (a : S_inst) ‚Üí S) (s : Type (b + b' = c).gen) (s : i = fun ‚Ü¶ f' s) : f' = fun ‚Ü¶ f' := by sorry ",
      "theorem eq_false : ‚àÄ {p : Prop}, ¬¨p ‚Üí p = False := by sorry ",
      "lex_card_eq : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤), Cardinal.lift.{w, w} (Cardinal.mk Œ±)\n  = Cardinal.mk (Multiset ‚Üëf) :=\n  by sorry ",
      "Theorem Mvt.ringHom_comap :\n    ‚àÄ {R : Type u} {A‚ÇÇ : Type v} {B A : Type w} [instB : CommRing R] [H‚ÇÇ : Semiring N] [h‚ÇÅ : Ring A]\n      [H‚ÇÇ‚ÇÉB : Algebra A¬≤ B] {g : SFun B‚ÇÇ‚ÇÉ A ‚Üí{s‚ÇÅ} M} ({f : A‚ÇÇ ‚Üí+* B‚ÇÇ ‚Üí‚ä• N} (hpri : Semiring.IsPrimitiveRat g)\n      {M‚ÇÇ : Type a} [inst‚ÇÉ : AddCommMonoid M‚ÇÇ] [ inst_1 : DecidableEq A‚ÇÇ]  (Œº‚ÇÇ : M‚ÇÇ ‚Üí+ N ‚Üí+‚Çü*. A‚ÇÇ)\n      {t : {b : FunLike M‚ÇÇ N ‚Üí+‚Çô‚Çê[M‚ÇÅA‚ÇÇ] B ‚ß∏ F i | DFunLike (fun (f : MvPolynomial A‚ÇÅ B) ‚Ü¶ Hyperlink b f) (g h s)} (H1 : A ‚â§ A‚ÇÇ))\n      (G : Subring.NormedData A A‚ÇÇ), RingContraction.comp f Œº‚ÇÇ H1 = AlgHom.id _) :=\n  by sorry\n``` [/INST] theorem SubType.coe_prop‚ÇÅ :\n    ‚àÄ {p : SFun B22 S ‚Üí Prop‚ÇÅ} {s : p {} * p {} B * function.Injective œÄ·µ¢), p p·µæ s·µæ := by sorry ",
      "theorem map_add :\n    ‚àÄ {M : Type u_4} {N : Type u_5} [inst : Add M] [inst_1 : Add N] (f : M ‚Üí+* N) (a b : M), f (a + b) = f a + f b := by\n  sorry ",
      "theorem add_comp_self :\n    ‚àÄ (R : Type u) {A B C L M : Type v} [inst : CommSemiring R] [inst_2: Semiautomorphic 2 R A C]\n      [inst_3 : CommMagmaSemiring B] (fA : B ‚®Ç L ‚Üí A C) (fB : B ‚Üí C ‚Üí M)\n      [inst_4 : FunLike (‚áëfA) (‚áëfB) C L M], fB (fA x) (fC l w) = (fA.toMultiplicative h) (fC ‚Üëw) :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.12518270489956336890 {R : Type u} {S : Type v} {œÉ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f‚ÇÅ : MvPolynomial œÉ R ‚Üí+* S} {f‚ÇÇ : MvPolynomial œÉ R ‚Üí+* S} {p‚ÇÅ : MvPolynomial œÉ R} {p‚ÇÇ : MvPolynomial œÉ R}\n    (hC : RingHom.comp f‚ÇÅ MvPolynomial.C = RingHom.comp f‚ÇÇ MvPolynomial.C)\n    (hv : ‚àÄ (i : œÉ) (a : i ‚àà MvPolynomial.vars p‚ÇÅ) (a : i ‚àà MvPolynomial.vars p‚ÇÇ), f‚ÇÅ (MvPolynomial.X i) = f‚ÇÇ (MvPolynomial.X i))\n    (i :œÉ ‚Üí‚ÇÄ R) (_b : ‚ÜëS) nih : Nontrivial I := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'}\n  (hœá : MulChar.IsQuadratic œá) (p : ‚Ñï) [hp : Fact (Nat.Prime p)] [inst_2 : CharP R' p], œá ^ p = œá)",
    "theorem": "theorem MulChar.IsQuadratic.pow_char :\n    (‚àÄ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'}\n      (hœá : MulChar.IsQuadratic œá) (p : ‚Ñï) [hp : Fact (Nat.Prime p)] [inst_2 : CharP R' p], œá ^ p = œá) :=\n  by sorry",
    "name": "MulChar.IsQuadratic.pow_char",
    "lemma-type": "{R : Type u} ‚Üí\n  [CommMonoid R] ‚Üí\n    {R' : Type v} ‚Üí\n      [CommRing R'] ‚Üí\n        {œá : MulChar R R'} ‚Üí\n          (hœá : MulChar.IsQuadratic œá) ‚Üí\n            (p : ‚Ñï) ‚Üí\n              [Fact (Nat.Prime p)] ‚Üí\n                [CharP R' p] ‚Üí\n                  (x : RÀ£) ‚Üí (h : (œá ‚Üëx = 1) ‚à® (œá ‚Üëx = -1)) ‚Üí (hx : œá ‚Üëx = 1) ‚Üí (œá ‚Üëx ^ p = œá ‚Üëx) = (1 ^ p = 1)",
    "lemma": "theorem aux.41521756273754401 {R : Type u} [CommMonoid R] {R' : Type v} [CommRing R'] {œá : MulChar R R'}\n    (hœá : MulChar.IsQuadratic œá) (p : ‚Ñï) [Fact (Nat.Prime p)] [CharP R' p] (x : RÀ£) (h : (œá ‚Üëx = 1) ‚à® (œá ‚Üëx = -1))\n    (hx : œá ‚Üëx = 1) : (œá ‚Üëx ^ p = œá ‚Üëx) = (1 ^ p = 1) := by sorry",
    "doc_string": "The `p`th power of a quadratic character is itself, when `p` is the (prime) characteristic\nof the target ring. ",
    "generated": [
      "theorem aux.14846508404343361487 {R : Type u} [ commutativeMonoid R] {R' : Type v} [ commutativeRing R']\n    {œá : MulChar R R'} (hœá : MulChar.IsQuadratic œá) (p : ‚Ñï) [Nat.Prime p] [CharP R' p] : ‚Üë({ toFun := (+), map_smul' := (_ : ‚àÄ (a : R) (b : R'), (‚Üëa) ‚Ä¢ ‚Üëb = ‚Üë(a ‚Ä¢ b)), ... : R' ‚âÉ+* R' } = Finsupp.support { toFun := (+), map_smul' := (_ : ‚àÄ\n  (a : R) (b : R',\n    (‚áë{ toFun := (+), map_smul' := (_ : ‚àÄ (a : R) (b : R'), (‚Üëa) ‚Ä¢ ‚Üëb = ‚Üë(a ‚Ä¢ b)), ... : R' ‚âÉ+* R' } b = (‚Üëa) ‚Ä¢ { toFun := (+), map_smul '[...]} b]) ‚à® false)}.support, ‚ä§}.isCylic' = ...) :=\n  by sorry ",
      "theorem pow_card : ‚àÄ {Œ± : Type u_1} [inst : DivisionCommMonoid Œ±] [inst_1 : Nat.Cast Œ±] [inst_2 : CharP Œ± p] {f : MulChar Œ± Œ±}\n    (hœá : Œ∂ - Œ∂ = MulChar.IsQuadratic f ‚Ü¶ f Œ∂ = 1) (-1 == isRmonep i‚ÇÅ) ^ Nat.card { i‚ÇÅ // QuadraticCharFun Œ± = -1 } := by\n  sorry ",
      "theorem mul_one' 'a' : ‚àÄ {R : Type v} [inst : Mul R] [inst_1 : One R] {c : C} {r : R}, c * 1 * ‚Üë 0 = (1 * r + c * ‚Üë0' ‚Üë1 ) :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem IsSquare.eq : ‚àÄ {Œ± : Type u} [inst : One Œ±] [inst_1 : Pt Œ±] {a : Œ±} {d m k : Œ±}, IsPrt d a ‚Üí a = d ^ PowerInt.onePos m := by sorry ",
      "theorem aux.9360154247218642571 {R : Type u} [CommMonoid R] {R' : Type v} [CommRing R'] {œá : MulChar R R'}\n    (hœá : MulChar.IsQuadratic œá) (p : ‡§é‡§æ) [Fact (Nat.Prime ‚Üëp)] [CharP R' ‚Üëp]\n    (x_0 : œÑ F ‚Üëp ‚Üí‚Çô* R' ‚Üí+* R' ‚Üëp ‚èø) (x_1 : Units œÑ R ‚Üëp) (x_2 : ((œá ^ Unit.unit) unit) ^Unit.unit ‚à™ 0 = 0) :\n    False := by sorry ",
      "theorem Fact.out : ‚àÄ {n : ‚Ñï}, Fact (Nat.Prime n) ‚Üí Primate n := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï),\n  ((NormedSpace.expSeries ‚Ñù (Quaternion ‚Ñù) (2 * n)) fun (x : Fin (2 * n)) ‚Ü¶ q) =\n    ‚Üë((-1) ^ n * ‚Äñq‚Äñ ^ (2 * n) / ‚Üë(Nat.factorial (2 * n))))",
    "theorem": "theorem Quaternion.expSeries_even_of_imaginary :\n    (‚àÄ {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï),\n      ((NormedSpace.expSeries ‚Ñù (Quaternion ‚Ñù) (2 * n)) fun (x : Fin (2 * n)) ‚Ü¶ q) =\n        ‚Üë((-1) ^ n * ‚Äñq‚Äñ ^ (2 * n) / ‚Üë(Nat.factorial (2 * n)))) :=\n  by sorry",
    "name": "Quaternion.expSeries_even_of_imaginary",
    "lemma-type": "{q : Quaternion ‚Ñù} ‚Üí\n  (hq : Quaternion.re q = 0) ‚Üí (n : ‚Ñï) ‚Üí ‚Äñq‚Äñ ^ (n ^ Nat.rawCast 1 * 2) * Nat.rawCast 1 = ‚Äñq‚Äñ ^ (n * 2) * 1",
    "lemma": "theorem aux.17607473617919970958 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï) :\n    ‚Äñq‚Äñ ^ (n ^ Nat.rawCast 1 * 2) * Nat.rawCast 1 = ‚Äñq‚Äñ ^ (n * 2) * 1 := by sorry",
    "doc_string": "The even terms of `expSeries` are real, and correspond to the series for $\\cos ‚Äñq‚Äñ$. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.2791313319862658 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï) :\n    (-2) ^ Nat.succ natAbs = (-‚Üë(Real.sqrt 2) * ‚Üë(2 ^ n)) ^ Nat.succ Nat.zero := by sorry ",
      "Theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.3210835203684189853 {q : Quaternion ‚Ñù} (hq : Quaternion.re q = 0) (n : ‚Ñï) : 0 = -1 := by sorry ",
      "deducing : (‚Äñq‚Äñ = (‚ÄñQ c / ((-2 * Real.pi * Complex.I) ^ n)) ^ 2) ‚Üî (Real.sqrt ‚Äñq‚Äñ / (-2 * Real.pi * Complex.I) ^ n = Q c) := by sorry ",
      "theorem eq_true : ‚àÄ {p : Prop}, p ‚Üí p = True := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± Œ≤ Œ≥ : outEq u_1 u_2} {a b c : Œ±} (f : Œ± ‚Üí Œ≤), a = b ‚Üí c = c ‚Üí f a = f b := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (a : ‚Ñ§) {R : Type u_1} [inst : CommSemiring R] (œá : R ‚Üí* ‚Ñ§)\n  (hp : ‚àÄ (p : ‚Ñï) (pp : Nat.Prime p) (a_1 : p ‚â† 2), legendreSym p a = œá ‚Üëp) {b : ‚Ñï} (hb : Odd b), jacobiSym a b = œá ‚Üëb)",
    "theorem": "theorem jacobiSym.value_at :\n    (‚àÄ (a : ‚Ñ§) {R : Type u_1} [inst : CommSemiring R] (œá : R ‚Üí* ‚Ñ§)\n      (hp : ‚àÄ (p : ‚Ñï) (pp : Nat.Prime p) (a_1 : p ‚â† 2), legendreSym p a = œá ‚Üëp) {b : ‚Ñï} (hb : Odd b),\n      jacobiSym a b = œá ‚Üëb) :=\n  by sorry",
    "name": "jacobiSym.value_at",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "If `œá` is a multiplicative function such that `J(a | p) = œá p` for all odd primes `p`,\nthen `J(a | b)` equals `œá b` for all odd natural numbers `b`. ",
    "generated": [
      "theorem aux.6578330905879942575 (a : ‚Ñ§) {R : Type u_1} [CommSemiring R] (œá : R ‚Üí* ‚Ñ§)\n    (hp : ‚àÄ (p : ‚Ñï) (pp : Nat.Prime p) (a_1 : p ‚â† 2), legendreSym p a = œá ‚Üëp) {b : ‚Ñï} (hb : Odd b) :\n    ‚Üë3 + b - 1 + (‚Üë3 - b + 2 + 1) += ‚Üë3 ^ Nat.rawCast 1 * Nat.rawCast 2 + (‚Üë3 + 1) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n        (2 ^ Nat.rawCast 1 * (JacobiSym Nat.rawCast 3 3 + 1) + (0 + 0) ^ Nat.rawCast 1 * Nat.rawCast 1) :=\n  by apologice\n ",
      "theorem aux.134818417324077835 (a : ‚Ñ§) {R : Type u_1} [CommSemiring R] (œá : R ‚Üí* ‚Ñ§)\n    (hp : ‚àÄ (p : ‚Ñï) (pp : Nat.Prime p) (a_1 : p ‚â† 2), legendreSym p a = œá ‚Üëp) (b : ‚Ñï) (hb : Odd b) {x : ‚Ñï} : Odd x :=\n  by sorry ",
      "theorem And.true_imp_iff : (a_2 ‚Üí a_1) = a_1 := by sorry ",
      "theorem aux.3233111508274018705 (a : ‚Ñ§) {R : Type u_1} [CommSemiring R] (œá : R ‚Üí* ‚Ñ§)\n    (hp : ‚àÄ (p : ‚Ñï) (pp : Nat.Prime p) (a_1 : p ‚â† 2), legendreSym p a = œá ‚Üëp) {b : ‚Ñï} (hb : Odd b) :\n    legPowDiff b ‚Üëa = (œá ‚Üëb) ^ Nat.ceil_eq_ifNE (Nat.PrincipalRootExpExp (b) b) 0 := by sorry ",
      "theorem Fact.out : ‚àÄ {p q : Prop}, Fact p ‚Üí p := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Int.cast_neg : ‚àÄ {Œ± : Type u_1} [inst : Canonia.LinAct Int Œ±] {a : ‚Ñ§}, ‚Üë (-a) = a (-‚Üëa) := by sorry ",
      "theorem Nat.even_int_iff_two_dvd : ‚àÄ (n : ‚Ñï), (Nat.Even ‚Üën) ‚Üî (2 Ô∂£ n) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {Œπ : Type u_4} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œπ} (a : Set.InjOn f s),\n  Set.Pairwise s fun (x : Œπ) (x_1 : Œπ) ‚Ü¶ f x ‚â† f x_1)",
    "theorem": "theorem Set.InjOn.pairwise_ne :\n    (‚àÄ {Œ± : Type u_1} {Œπ : Type u_4} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œπ} (a : Set.InjOn f s),\n      Set.Pairwise s fun (x : Œπ) (x_1 : Œπ) ‚Ü¶ f x ‚â† f x_1) :=\n  by sorry",
    "name": "Set.InjOn.pairwise_ne",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  {Œπ : Type u_4} ‚Üí\n    {f : (a : Œπ) ‚Üí Œ±} ‚Üí\n      {s : Set Œπ} ‚Üí\n        {Œ± : Type u_1} ‚Üí\n          {Œπ : Type u_4} ‚Üí\n            {f : (a : Œπ) ‚Üí Œ±} ‚Üí\n              {s : Set Œπ} ‚Üí (x : Œπ) ‚Üí (y : Œπ) ‚Üí (‚àÄ (a : ¬¨(x = y)), ¬¨(f x = f y)) = (‚àÄ (a : f x = f y), x = y)",
    "lemma": "theorem aux.7400803699519790449 {Œ± : Type u_1} {Œπ : Type u_4} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œπ} {Œ± : Type u_1}\n    {Œπ : Type u_4} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œπ} (x : Œπ) (y : Œπ) :\n    (‚àÄ (a : ¬¨(x = y)), ¬¨(f x = f y)) = (‚àÄ (a : f x = f y), x = y) := by sorry",
    "doc_string": "**Alias** of the forward direction of `Set.injOn_iff_pairwise_ne`.\n\n---\n\nSee also `Function.injective_iff_pairwise_ne` ",
    "generated": [
      "theorem Set.mem_of_mem_iffLeft :\n    ‚àÄ {Œ± : Type u} {Œ≤ : outParameter (type u_21)} [inst : DecidableEq Œ≤] {x : Œ±}, {a | a ‚àà x} = x ÔøΩÔøΩporte a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem eq_comm : ‚àÄ {Œ± : Sort u_1} {a b : Œ±}, a = b ‚Üî b = a := by sorry ",
      "theorem Set.pairwise On fun (i : Œπ) (i' : Œπ) ‚Ü¶ f i ‚â† f i' :=\n  by sorry ",
      "theorem aux.67277975362462938 {Œ± : Type u_1} {Œπ : Type u_4} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œπ} {Œ± : Type u_1}\n    {Œπ : Type u_4} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œπ} :\n    ‚àÄ (as : ‚àÄ (a : Œπ) (a_1 : a ‚àà s), f a = f Default), Cardinal.mk Œπ ‚Ä¢ f ‚àà Cardinal.biprod ‚Üës 1 := by sorry ",
      "theorem IsPredClosed.disjoint := fun _ => isPreconnected_IccDisjoint_IciSet' := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {n : ‚Ñï+} {L : Type v} [inst : CommRing L] {Œ∂ : L} (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën) {K : Type u_1}\n  [inst_1 : LinearOrderedField K] [inst_2 : Algebra K L] (hodd : Odd ‚Üën), (Algebra.norm K) Œ∂ = 1)",
    "theorem": "theorem IsPrimitiveRoot.norm_eq_one_of_linearly_ordered :\n    (‚àÄ {n : ‚Ñï+} {L : Type v} [inst : CommRing L] {Œ∂ : L} (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën) {K : Type u_1}\n      [inst_1 : LinearOrderedField K] [inst_2 : Algebra K L] (hodd : Odd ‚Üën), (Algebra.norm K) Œ∂ = 1) :=\n  by sorry",
    "name": "IsPrimitiveRoot.norm_eq_one_of_linearly_ordered",
    "lemma-type": "{n : ‚Ñï+} ‚Üí\n  {L : Type v} ‚Üí\n    [CommRing L] ‚Üí\n      {Œ∂ : L} ‚Üí\n        (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën) ‚Üí\n          {K : Type u_1} ‚Üí [LinearOrderedField K] ‚Üí [Algebra K L] ‚Üí (hodd : Odd ‚Üën) ‚Üí StrictMono fun (a : K) ‚Ü¶ a ^ ‚Üën",
    "lemma": "theorem aux.8100545907436205088 {n : ‚Ñï+} {L : Type v} [CommRing L] {Œ∂ : L} (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën) {K : Type u_1}\n    [LinearOrderedField K] [Algebra K L] (hodd : Odd ‚Üën) : StrictMono fun (a : K) ‚Ü¶ a ^ ‚Üën := by sorry",
    "doc_string": "If `K` is linearly ordered, the norm of a primitive root is `1` if `n` is odd. ",
    "generated": [
      "theorem Subtype.prop : ‚àÄ {Œ± : Type u_1} {p : Œ± ‚Üí Prop} (x : Subtype p), p ‚Üëx := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem FiniteDimensional.sumEq_one_iff :\n    ‚àÄ {K : Type u} [inst : DivisionRing K] {V : Type v} [inst_1 : FiniteDimensional K v] {b family : v ‚Üí K},\n      (Œ†‚ÇÄ (a : v), b a = 1) ‚Üî FiniteDimensional.finrank K v ‚Ä¢ Finset.sum Family.finite b = 1 :=\n  by sorry ",
      "theorem aux.165773971943279590 {n : ‚Ñï+} {L : Type v} [CommRing L] {Œ∂ : L} (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën)\n    {K : Type u_1} [LinearOrderedField K] [Algebra K L] (hodd : Odd ‚Üën) : (1 > 0) ‚à® (2 > 2) := or_true_iff _ := by\n  sorry ",
      "theorem aux.7522109160429615761 {n : ‚Ñï+} {L : Type v} [CommRing L] {Œ∂ : L} (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën) {K : Type u_1}\n    [LinearOrderedField K] [Algebra K L] (hodd : Odd ‚Üën) (b : Fin ‚Üën) (dvd : ‚Üëb ‚à£ ‚Üën) : (Fin.castNat b ‚â• Fin.castNat 0) = True :=\n  by sorry ",
      "theorem Units.norm_eq_iff_norm :\n    ‚àÄ {R'\n          [inst_3 : Top R'] (E : Type u‚ÇÇ) [inst_4/4 ; inst_5/1 ; norm_div::inst_6]\n          [module R' : Module R' E] where this := (@UnitalRing.norm R') {Œ±} [inst_7 : SeminormedRing Œ±] _)\n      _ _w‚ÇÅ, Units.norm' { norm := ((‚Üëx) w‚ÇÅ }) = |w‚ÇÅ‚Åª¬π/2|‚Åª¬π * max 0 (((‚Üëx) w‚ÇÅ < ‚Üë0) ‚à® ((2 < ‚Üëx / |w‚ÇÅ|) * |a‚ÇÑ|)) := by\n  sorry ",
      "theorem aux.6410611271406539495 {n : ‚Ñï+} {L : Type v} [CommRing L] {Œ∂ : L} (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üën) {K : Type u_1}\n    [LinearOrderedField K] [L : Algebra K L] (hodd : Odd ‚Üën) : (-(norm (normUnit L) Œ∂) ^ ‚Üën < 0) = False := by sorry ",
      "theorem norm_one : ‚àÄ {E : Type u_6} [inst : SeminormedRing E], ‚Äñ1‚Äñ = 1 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ‚ÑÇ}\n  {f : (a : ‚ÑÇ) ‚Üí E} (hf : DiffContOnCl ‚ÑÇ f (Metric.ball c ‚ÜëR)) (hR : 0 < R),\n  HasFPowerSeriesOnBall f (cauchyPowerSeries f c ‚ÜëR) c ‚ÜëR)",
    "theorem": "theorem DiffContOnCl.hasFPowerSeriesOnBall :\n    (‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] {R : NNReal}\n      {c : ‚ÑÇ} {f : (a : ‚ÑÇ) ‚Üí E} (hf : DiffContOnCl ‚ÑÇ f (Metric.ball c ‚ÜëR)) (hR : 0 < R),\n      HasFPowerSeriesOnBall f (cauchyPowerSeries f c ‚ÜëR) c ‚ÜëR) :=\n  by sorry",
    "name": "DiffContOnCl.hasFPowerSeriesOnBall",
    "lemma-type": "‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ‚ÑÇ}\n  {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ},\n  Set.Countable s ‚Üí\n    ContinuousOn f (Metric.closedBall c ‚ÜëR) ‚Üí\n      (‚àÄ z ‚àà Metric.ball c ‚ÜëR \\ s, DifferentiableAt ‚ÑÇ f z) ‚Üí\n        0 < R ‚Üí HasFPowerSeriesOnBall f (cauchyPowerSeries f c ‚ÜëR) c ‚ÜëR",
    "lemma": "theorem Complex.hasFPowerSeriesOnBall_of_differentiable_off_countable :\n    ‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] {R : NNReal}\n      {c : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ},\n      Set.Countable s ‚Üí\n        ContinuousOn f (Metric.closedBall c ‚ÜëR) ‚Üí\n          (‚àÄ z ‚àà Metric.ball c ‚ÜëR \\ s, DifferentiableAt ‚ÑÇ f z) ‚Üí\n            0 < R ‚Üí HasFPowerSeriesOnBall f (cauchyPowerSeries f c ‚ÜëR) c ‚ÜëR :=\n  by sorry",
    "doc_string": "If `f : ‚ÑÇ ‚Üí E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. ",
    "generated": [
      "theorem DiffContOnCl.closedBall :\n    ‚àÄ {t : ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} (a : DiffContOnCl (intervalSymm t) g), DiffContOnCl (frontier (Metric.ball t ‚Üët)) g := by\n  sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem isOpen_ball :\n    ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (a x : Œ±), IsOpen (ball a x) := by sorry ",
      "theorem aux.15769335595058684990 {E : Type u} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E] {R : NNReal}\n    {c : ‚ÑÇ} {f : (a : ‚ÑÇ) ‚Üí E} (hf : DiffContOnCl ‚ÑÇ f (Metric.ball c ‚ÜëR)) (hR : 0 < R) (f' : (a : ‚ÑÇ) ‚Üí ‚ÑÇ ‚ÜíL[‚Ñù] E)\n    (hff' : ‚àÄ (z : ‚ÑÇ) (a : z ‚àà Metric.ball c ‚ÜëR), HasFDerivAt f (f' z) z)\n    (hre : ContinuousOn (fun (y : ‚ÑÇ) ‚Ü¶ f' c y) (Metric.ball c ‚ÜëR)) (hR' : 0 < R'), HasFDerivAt f (‚ÜëR‚Åª¬π ‚Ä¢ f' c) c) :=\n  by sorry\n``` [/INST] theorem aux.3811756467228261188 {E : Type u} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E] {R : NNReal}\n    {c : ‚ÑÇ} {f : (a : ‚ÑÇ) ‚Üí E} (hf : DiffContOnCl ‚ÑÇ f (Metric.ball c ‚ÜëR)) (hR : 0 < R) (f' : (a : ‚ÑÇ) ‚Üí ‚ÑÇ ‚ÜíL[‚Ñù] E)\n    (h : ‚àÄ (z : ‚ÑÇ) (a : z ‚àà Metric.ball c ‚ÜëR), HasFDerivAt f (f' z) z)\n    (hre : ContinuousOn (fun (y : ‚ÑÇ) ‚Ü¶ f' c y) (Metric.ball c ‚ÜëR)) (hR' : 0 < R`) {w : ‚ÑÇ}\n    (hw : w ‚àà Metric.ball c ‚ÜëR') :\n    hasFDerivAt (fun (y : ‚ÑÇ) ‚Ü¶ f' c y) (1 * (f' c) w) w := by sorry ",
      "theorem cauchyPowerSeries_summable :\n    ‚àÄ {d : NNReal} (f : ‚ÑÇ ‚Üí E) (r : NNReal) (hr : d * r < ‚Äñf r‚Äñ), Summable ÔøΩÔøΩüî¥ f d := by sorry ",
      "theorem And.left : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí a := by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem aux.10538037137704838754 {E : Type u} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E] {R : NNReal}\n    {c : ‚ÑÇ} {f : (a : ‚ÑÇ) ‚Üí E} (hf : DiffContOnCl ‚ÑÇ f (Metric.ball c ‚ÜëR)) (hR : 0 < R) : Nonempty ‚ÜëR := by\n  sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {a : Set Œ±} (h : Set.Finite a), Set.Finite {b : Set Œ± | b ‚äÜ a})",
    "theorem": "theorem Set.Finite.finite_subsets : (‚àÄ {Œ± : Type u} {a : Set Œ±} (h : Set.Finite a), Set.Finite {b : Set Œ± | b ‚äÜ a}) :=\n  by sorry",
    "name": "Set.Finite.finite_subsets",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "There are finitely many subsets of a given finite set ",
    "generated": [
      "theorem pow_one : ‚àÄ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a := by sorry ",
      "theorem subtype.coe_injective : ‚àÄ {Œ± : Sort u_1} (p : Œ± ‚Üí Prop), Function.Injective fun x => ‚ü®x, p x ‚ü© := by sorry ",
      "theorem SetCoeForall.finite :\n    ‚àÄ {B : Type u ‚Üí Sort u_1} {B' : Funlike B Set Œ±} {Œ≤Œ± : B' a ‚Üí Œ≤}, (‚àÄ Œ± p, Fintype ‚Üë‚Üëp ‚ä§) ‚Üí IsTarGet Œ± Œ≤ ‚àß (‚àÄ Œ± b t, Fintype ‚Üëb ‚ä§) := by sorry ",
      "theorem aux.2551794399729247851 {Œ± : Type u} {a : Set Œ±} (h : Set.Finite a) (h : ¬¨(Set.Finite {b : Set Œ± | b ‚äÜ a}))\n    (b : Set Œ±) (hb : b ‚àâ {b : Set Œ± | b ‚äÜ a}) : (HasSubset b (Set.Finite.finite_coe a)) = True := by sorry ",
      "theorem congr_fun : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (a : Œ±) ‚Üí Œ≤ a}, f = g ‚Üí ‚àÄ (a : Œ±), f a = g a := by sorry ",
      "theorem SetCoeFn.le_def : ‚àÄ {Œ≤ : SetInduitable Œπ _u) {x y : (i : Œπ) ‚Üí Œ≤ i}, x ‚â§ y ‚Üí SetCoeFn.y ‚â§ SetCoeFn.f =‚ÇÖ y := by\n  sorry ",
      "theorem Iff.mp' : ‚àÄ {a b : Prop}, { a ‚Üí b } = b ‚Üí (a ‚Üí b) ‚Üí b ‚Üí a := by sorry ",
      "theorem Pow.finite_pow : ‚àÄ {R : ‚äï SubringZero.{u}</+ SubsemiringInvolutive.{u, u} R‚ÇÅ R‚ÇÅ}> {n : ‚Ñï‚àû  | 0 < n} :\n    True := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1} [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù),\n  f (‚®Ü i, g i) = ‚®Ö i, f (g i))",
    "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n      [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n      [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1} [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù),\n      f (‚®Ü i, g i) = ‚®Ö i, f (g i)) :=\n  by sorry",
    "name": "Antitone.map_iSup_of_continuousAt'",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [ConditionallyCompleteLinearOrder Œ±] ‚Üí\n      [TopologicalSpace Œ±] ‚Üí\n        [OrderTopology Œ±] ‚Üí\n          [ConditionallyCompleteLinearOrder Œ≤] ‚Üí\n            [TopologicalSpace Œ≤] ‚Üí\n              [OrderClosedTopology Œ≤] ‚Üí\n                {Œπ : Sort u_1} ‚Üí\n                  [Nonempty Œπ] ‚Üí\n                    {f : (a : Œ±) ‚Üí Œ≤} ‚Üí\n                      {g : (a : Œπ) ‚Üí Œ±} ‚Üí\n                        (Cf : ContinuousAt f (iSup g)) ‚Üí\n                          (Af : Antitone f) ‚Üí\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) ‚Üí Set.range (f ‚àò g) = f '' Set.range g",
    "lemma": "theorem aux.7626956484308193916 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n    [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) : Set.range (f ‚àò g) = f '' Set.range g := by sorry",
    "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ",
    "generated": [
      "theorem Iff.rfl : ‚àÄ{a : Prop}, a ‚Üî a := by sorry ",
      "theorem nonempty_fst : ‚àÄ {Œ≤‚ÇÄ : Sort u‚ÇÉ‚ÇÄ} [inst : Empty.{instVal, u‚ÇÉ‚ÇÄ} Œ≤‚ÇÄ], Nonempty (Œ≤‚ÇÄ √ó Empty) := by sorry ",
      "theorem AntitoneOn.map_iSup_of_conditionallyCompleteLattice_of_continuousOn :\n    ‚àÄ {Œ±‚ÇÅ : Type u_2} {Œ±‚ÇÇ : Type u_1} [cond : Concore Œ±‚ÇÇ Œ±‚ÇÅ] (f : Œ±‚ÇÅ ‚Üí (a : Set Œ±‚ÇÅ) ‚Üí Œ±‚ÇÇ),\n      IsConcore L f ‚Üí\n        OrderClosedTopology Œ±‚ÇÇ ‚Üí\n          ConditionallyCompleteLattice Œ±‚ÇÇ ‚Üí\n            (‚àÄ x y: Set Œ±‚ÇÅ, BddAbove x ‚Üí BddAbove y ‚Üí Set.MapsTo f x y ‚Üí f x y = f y)-- proof_state --\n  Eq.ndrec (r := ‚àÄ {j‚ÇÇ : A fun x => S (f x) fun k_21x -> Set.MapsTo (f ‚àò ‚áëf) (f j‚ÇÇ') k_21a ‚äá S j‚ÇÇ := by sorry)\n    ((Eq.ndrecExtend { j‚ÇÅ := j‚ÇÅ, t j‚ÇÅ‚ÇÅ := u j‚ÇÅ‚ÇÅ } s c Hc ((bdd : Set.EmptyAbove s) and ‚áäS j‚ÇÅ) Hs =>\n      ((j‚ÇÅ ‚áÑ bS s Hsb) { i := j‚ÇÅ }) * s i = Hs (‚Üë‚áës i)) ‚à™\n      ‚Äñf i' || H (bdd := { f := H, f' := H', hB' : ‚Äñf i'|| = 0 ‚â§ (‚ÄñH(i' j' \\ bj‚ÇÅ) / H u f j1i) ‚â§ ‚Äñf ((i ‚áÑ bS fun (hrbj : fj'f bj‚ÇÅ le B f i) = (hrB : ‚áºf i) = Hf bj'r)|) } -- s = f j‚ÇÅ ) =\n            s j‚ÇÅ) =\n      (_r bf r := H;\n        H :\n          EquippedMetric.nnsInf r h = (_m : _r f (_b‚ÇÅ := bf) : B(ùíÆ·æ∞ | U b·π°) \\ ùí®·∫à bf_p (h < Set.InhabitedA ÔøΩÔøΩÔøΩÔøΩ) r, U b·πß‚ÇÅ \\ A =\n            (·ÄïA = (Set.mem (f i ‚â§ f‚Åø‚Å±' h / 1)), A·∂ú)))) :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem iSup_le :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] {f : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} {y : Œ±}\n      [inst_1 : IsLUBClosed œÖ f fun i => f (p i)], y ‚àà Set.range f ‚Üí (‚àÄ i, p i) ‚Üí CompleteLattice.IsLUB y f :=\n  by sorry ",
      "theorem aux.874379454024620863 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤]\n    {Œπ : Sort u_1} [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) :\n    Eq (Œ≤‚ÇÇMCHi.sSup ‚àë (i : Œπ), Antitone.comp Afid (‚áëf) bdd fun (s : OrderDual.toDual Œ±) ‚Ü¶\n          Order.dual (funcShapeFinset g bdd) =\n        ‚ãÇ (_ : ‚Üë(funcShapeFinset g bdd)),\n          {l' : ENNReal | BddAbove (UpperLimits.filter (fun (s : ENNReal) ‚Ü¶ ‚®Ü ta, f ta ‚â§ s) {l : ENNReal | l ‚â§ l'})}) =\n      Eq (EQ UI ùí¢\n        (Eq.mpr (congrArg ((fun (_a : UnifGorm Œπ I) ‚Ü¶ Filter.map F {l : ENNReal | l ‚â§ {x √ó ‚ä§ | x < f (s.2).fst}} fun {a : ‚ÜëI} ‚Ü¶ f a ‚Üë(s.2)).1)\n          (inst1)) InstediousReflUnifiGen.mem)) :=\n  by sorry ",
      "theorem Antitone.map_iInde_of_antitone :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [i1 : ConditionallyCompleteLattice Œ±] [i2 : GeneralizedRegularSpace Œ±]\n      [inst : OrderedCancelAddCommMonoid √ü] {f : Œ± ‚Üí √ü},\n      Monotone (‚áëOrderDual.toDual ‚àò f) ‚Üí\n        Antitone f ‚Üí ‚àÄ {m : Œ±}, IsCompl m (‚®Ü n ‚àà filterWithin (fun n => m ‚â§ n) ‚Ü¶ ‚àÖ '' Set.Icc m (f i)) ‚Üí m ‚•± f m = IsCompl m (f m) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0))",
    "theorem": "theorem vectorSpan_range_eq_span_range_vsub_right :\n    (‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ),\n      vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0)) :=\n  by sorry",
    "name": "vectorSpan_range_eq_span_range_vsub_right",
    "lemma-type": "(k : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_3} ‚Üí\n      [inst : Ring k] ‚Üí\n        [AddCommGroup V] ‚Üí\n          [Module k V] ‚Üí\n            [AddTorsor V P] ‚Üí\n              {Œπ : Type u_4} ‚Üí\n                (p : (a : Œπ) ‚Üí P) ‚Üí\n                  (i0 : Œπ) ‚Üí\n                    (Submodule.span k ((fun (x : P) ‚Ü¶ x -·µ• p i0) '' Set.range p) =\n                        Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0)) =\n                      (Submodule.span k (Set.range ((fun (x : P) ‚Ü¶ x -·µ• p i0) ‚àò p)) =\n                        Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0))",
    "lemma": "theorem aux.16998741365819423269 (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [AddCommGroup V]\n    [Module k V] [AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ) :\n    (Submodule.span k ((fun (x : P) ‚Ü¶ x -·µ• p i0) '' Set.range p) =\n        Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0)) =\n      (Submodule.span k (Set.range ((fun (x : P) ‚Ü¶ x -·µ• p i0) ‚àò p)) =\n        Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0)) :=\n  by sorry",
    "doc_string": "The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right. ",
    "generated": [
      "theorem eq_comap_of_mem :\n    ‚àÄ {Œ± : Type u_1} {M : Type u_2} {S : Set M} [inst : SMul M Œ±] {s : Œ±} {t : Œ±},\n      s ‚àà (‚áë(sinf : Type.pi ((a : S), A) (fun b => ‚áëb)).SMul M) '' t : Œ© =>\n        s inf (fun i => A ‚ü®i, t i‚ü©) ‚Ä¢ ‚àë b ‚àà S, A ‚Üëb t b ‚Ä¢ sinf fun i => M fun e : A e => A e ‚Üí M e ‚àÇe :=\n  by sorry ",
      "theorem Nat.cast_injective : ‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] {n : ‚Ñï}, Function.Injective fun a => ‚Üëa :=\n  by sorry ",
      "theorem Set.range_prod :\n    ‚àÄ {Œ∑ : Œ± ‚Üí Type uE_1} {œÄ : Œ©} {i : Œ∑ ‚Üí Œµ ‚Üí Type uE_2} (e‚ÇÅ : KFun Œ© {Œ¥‚ÇÄ‚ÇÅ Œ∑} [0,inst1]·µê·µí·µñ [congr]\n        e \\[hzero = Œ¥‚ÇÄ‚ÇÅ](s : Set Œ©), Set.range (PsiCompTriv f inst1 i) ‚Üí Set.range ‚áëi Œ© √ó s.sigmaCompactSpace.val :=\n  by sorry ",
      "self_mem_set : for any Set Œ± (s : Œ±) ‚Üí œás ‚àà Set.singleton = {ùíü, s} := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± Œ≤ : Sort u} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem vectorSpan_eq_span_vsub_set_left :\n    ‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] (s : Set P) (p : P), vectorSpan k s = Submodule.span k ((fun x => p - x) '' s) :=\n  by sorry ",
      "theorem VectorSpan.image_id :\n    ‚àÄ {V : Type u_1} {P : Type u} {k : Type u_2} [inst : SeminingNum k] [inst_1 : AddCommGroup V]\n      [inst_2 : Module k V] [inst_3 : AddTorsor V P] {Œπ : Type u_4} (s : Set Œπ) (w : Œπ),\n      ({ w }) = VectorSpan k (Set.range g) ‚ãÉ g ‚àà ‚Üës, Set.range { g }} :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n  (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚áë(thickenedIndicator (Œ¥seq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : Œ±) ‚Ü¶ 1)))",
    "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n      (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±),\n      Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚áë(thickenedIndicator (Œ¥seq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : Œ±) ‚Ü¶ 1))) :=\n  by sorry",
    "name": "thickenedIndicator_tendsto_indicator_closure",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [PseudoEMetricSpace Œ±] ‚Üí\n    {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} ‚Üí\n      (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) ‚Üí\n        (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) ‚Üí (E : Set Œ±) ‚Üí (x : Œ±) ‚Üí x ‚àâ closure E",
    "lemma": "theorem aux.930643649262411807 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù}\n    (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±) (x : Œ±) :\n    x ‚àâ closure E := by sorry",
    "doc_string": "As the thickening radius Œ¥ tends to 0, the Œ¥-thickened indicator of a set E (in Œ±) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `Œ± ‚Üí·µá ‚Ñù‚â•0`. Coercions to functions `Œ± ‚Üí ‚Ñù‚â•0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ",
    "generated": [
      "theorem thickenedIndicator_empty :\n    ‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (Œµ : ‚ÄñŒµ‚Äñ = ‚ä§), ‚áë(thickenedIndicator (deposit := ((Œµ))) ‚àÖ) =·∂†[œÄE] ‚áëfun _ _ => 0 := by sorry ",
      "theorem continuousAt_id :\n    ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Nontrivial Œ±] (a : Œ±), ContinuousAt id a := by sorry ",
      "theorem ENNReal.one_ne_top : (‚ÑùENNReal.one ‚â† ‚ä§) = (¬¨(‚ÑùENNReal.one = ‚ä§)) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ü©\n``` [/INST] theorem congrFun : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (a : Œ±) ‚Üí Œ≤ a}, f = g ‚Üí ‚áëf = ‚áëg := by sorry ",
      "theorem edist_mem_nhds : ‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x y : Œ±}, y ‚àà EMetric.ball y Œµ ‚Üî edist y x < Œµ :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.5072505221981767875 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n    (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±) (x : Œ±) (r : ‚Ñù) (hr : (r ‚àà Set.univ) ‚àß (r < 0)) :\n    Edist x 0 = edist r = edist 0 0 := by sorry ",
      "theorem self_mem_SetD : ‚àÄ D : Multicorner, Set.Mem.self x_1 D ‚Üí x_1 ‚àà D.range.val := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {E : Type u_1} [inst : MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E},\n  MeasureTheory.pdf.uniformPDF s x = if (x ‚àà s) then (‚Üë‚ÜëŒº s)‚Åª¬π else 0)",
    "theorem": "theorem MeasureTheory.pdf.uniformPDF_ite :\n    (‚àÄ {E : Type u_1} [inst : MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E},\n      MeasureTheory.pdf.uniformPDF s x = if (x ‚àà s) then (‚Üë‚ÜëŒº s)‚Åª¬π else 0) :=\n  by sorry",
    "name": "MeasureTheory.pdf.uniformPDF_ite",
    "lemma-type": "‚àÄ {Œ± : Sort u_1} {b c : Prop} {x y u v : Œ±} {s : Decidable b} [inst : Decidable c],\n  b = c ‚Üí (c ‚Üí x = u) ‚Üí (¬¨c ‚Üí y = v) ‚Üí (if b then x else y) = if c then u else v",
    "lemma": "theorem ite_congr :\n    ‚àÄ {Œ± : Sort u_1} {b c : Prop} {x y u v : Œ±} {s : Decidable b} [inst : Decidable c],\n      b = c ‚Üí (c ‚Üí x = u) ‚Üí (¬¨c ‚Üí y = v) ‚Üí (if b then x else y) = if c then u else v :=\n  by sorry",
    "doc_string": "Alternative way of writing the uniformPDF. ",
    "generated": [
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem Equiv.injective :\n    ‚àÄ {Œ± : Sort u_6} {Œ≤ : Sort u_7} (f : Œ± ‚âÉ Œ≤), Function.Injective ‚áëf := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem measurable_const :\n    ‚àÄ {Œ± : Type u_2} {Œ¥ : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ¥]\n      [inst_2 : DecidableEq Œ±] [inst_3 : MeasurableSingletonClass Œ¥] (c : Œ¥), Measurable fun x => c :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem MeasureTheory.pdf.pdfEq_uniformPDFEq_iff :\n    ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {‚Ñà : MeasurableSpace Œ±) {Œ∑‚ÇÄ : ETumoriSMulUnit ‚Ñù ‚Ñù}\n      {F : (a : Œ±) ‚Üí MeasureTheory.NegInvUnifMeasure Œ∑‚ÇÄ} {F·µê : (a : Œ±) ‚Üí (a : Œº ‚â† MeasureTheory.Measure.noAtoms Œº) ‚Üí PMF},\n      MeasureTheory.MeasureEq fun b => MeasureTheory.mulPDF' F (Œ∑‚ÇÄ ‚àò b) (fun B => measureround b (ETumoriSMulUnit.toSMulEquiv ‚Ñù (ENurse.toSmul‚ÇÄ f) Œµ) ‚Üí *‚Ñ±, B.) f =\n        (etm |b ‚Üí F (√©t |b) fun N => PMF.ofFn fun j => ETm‚ÇÇ·∂°·µ¢|b * Œº |b \\ ET·±õ|).cFun f + ‚Üë‚ÜëŒº |b \\ ET·±õ|\\.cFun' (MeasureTheory.Measure.inv_smul_mul_of_posSMul : ‚àÄ ‚¶ÉŒ≥ : ENNReal‚¶Ñ ‚¶ÉŒΩ : MeasureTheory.Measure Œ∑‚¶Ñ (x : Œµ * Œ∑ =ŒΩ)\n            (œà‚ÇÅ :\n            œÜ x ‚áë[MeasurableEmbedding.mulRangeIsetEq‚ÇÅ x (epsNegToSMul.toSMul I Œµ)] t\n        ‚Üí Convolution.CauchyIntegral.divN‚ÇÄ SMulUnit‚ÇÄ Œ∑‚ÇÇ p x) :=\n  by sorry ",
      "theorem aux.3570330061892045622 {E : Type u_1} [MeasurableSpace E] :\n    Œº.pdf x = It.case_bool (pdf_def Œº x, p.pdf.tendsto_filter (_ : MeasurableSet p) (Eq.refl _))) := by sorry\n``` [/INST] theorem ite_eq_right_iff :\n    ‚àÄ {a b c : Œ±}, (b = c) ‚Üí (a = a) ‚Üí (c = c ‚Üí a = b) ‚Üí if then b = c ‚àß a = c else d = e ‚àß a = e ‚Üí (c = c ‚àß a = c ‚Üî b = d) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {F : Type u_8} {G : Type u_9} {H : Type u_10} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : FunLike F G H]\n  [inst_3 : MonoidHomClass F G H] (f : F), (Function.Injective ‚áëf) ‚Üî (‚àÄ (a : G) (a_1 : f a = 1), a = 1))",
    "theorem": "theorem injective_iff_map_eq_one :\n    (‚àÄ {F : Type u_8} {G : Type u_9} {H : Type u_10} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : FunLike F G H]\n      [inst_3 : MonoidHomClass F G H] (f : F), (Function.Injective ‚áëf) ‚Üî (‚àÄ (a : G) (a_1 : f a = 1), a = 1)) :=\n  by sorry",
    "name": "injective_iff_map_eq_one",
    "lemma-type": "{F : Type u_8} ‚Üí\n  {G : Type u_9} ‚Üí\n    {H : Type u_10} ‚Üí\n      [Group G] ‚Üí\n        [MulOneClass H] ‚Üí\n          [FunLike F G H] ‚Üí\n            [MonoidHomClass F G H] ‚Üí\n              (f : F) ‚Üí\n                (h : ‚àÄ (a : G) (a_1 : f a = 1), a = 1) ‚Üí (x : G) ‚Üí (y : G) ‚Üí (hxy : f x = f y) ‚Üí (x * y‚Åª¬π = 1) ‚Üî (x = y)",
    "lemma": "theorem aux.755246616879515837 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H] [FunLike F G H]\n    [MonoidHomClass F G H] (f : F) (h : ‚àÄ (a : G) (a_1 : f a = 1), a = 1) (x : G) (y : G) (hxy : f x = f y) :\n    (x * y‚Åª¬π = 1) ‚Üî (x = y) := by sorry",
    "doc_string": "A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`.  ",
    "generated": [
      "theorem implies_congr : ‚àÄ {a b c : Sort u} {e : a ‚Üî b}, (c ‚Üî b) ‚Üí (a ‚Üí c) ‚Üí (a ‚Üí b) := by sorry ",
      "theorem aux.5612312576197013565 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [StrongRegardTo F G H] [MonoidHomClass F G H] (f : F) :\n    (Function.Injective ‚áëf) ‚Üî (* x ‚àà Function.InjectiveProperty' * Set.univ)) :\n    ‚àÄ (a : G), ((a ‚â† 1) ‚àß (f a * f - 1 = 0)) = ((a = nothing ‚à® f a = f 1) ‚àß (f a = f - FunLike.coe ‚àò g *) := by\n  sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} { rational : Œ± ‚Üí Prop} {x y z : Œ±}, (rational x y) ‚Üí (rational y z) ‚Üí (rational x z) :=\n  by sorry ",
      "theorem isQuotientGroupOfQuotientKer'_neg'Feq : (Function.Injective ‚áëQuotientGroupOfQuotientKer') := by sorry ",
      "theorem aux.3178902661734952574 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) {g : G} {h : H} (x : g = 1 := by sorry) :\n    ((1 = 1) ‚àß (f g = 1)) ‚Üî (f g = 1) := by sorry ",
      "theorem aux.13702733602846967687 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) : (‚áëf = Function.expExpLogCirc ‚áë(‚Üëf)), FunLike.coe ‚áëf = fun a b ‚Ü¶ ‚Üëa * b := by\n  sorry ",
      "theorem aux.12702644973208428792 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) (x : G) : (¬¨(f x = f 1)) = (¬¨(‚Üëf x = ‚Üëf 1)) := by sorry ",
      "theorem one_ne_zero : ‚àÄ {Œ± : Type u_2} [inst : Monoid Œ±] (a : Œ±), 1 ‚â† 0 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n  (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚áë(thickenedIndicator (Œ¥seq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : Œ±) ‚Ü¶ 1)))",
    "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {Œ¥seq : (a : ‚Ñï) ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n)\n      (Œ¥seq_lim : Filter.Tendsto Œ¥seq Filter.atTop (nhds 0)) (E : Set Œ±),\n      Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚áë(thickenedIndicator (Œ¥seq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : Œ±) ‚Ü¶ 1))) :=\n  by sorry",
    "name": "thickenedIndicator_tendsto_indicator_closure",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "As the thickening radius Œ¥ tends to 0, the Œ¥-thickened indicator of a set E (in Œ±) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `Œ± ‚Üí·µá ‚Ñù‚â•0`. Coercions to functions `Œ± ‚Üí ‚Ñù‚â•0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ",
    "generated": [
      "theorem le_self_fun_set_indicator :\n    ‚àÄ {Œ± : Type u_2} {iU : ‚ÑíÀ£ (UniformSpace.toPseudoMetricSpace Œ±)} (hU : iU ‚â§ 0) {S : Set Œ±},\n      ‚ÄñSetIndicator S fun iY => ‚Üë(DenseInduscation.norm ‚â§ iU) (‚ÜëY)‚Äñ ‚â§ max USetIndicator.const D.h nt\n        (Set.indicator SetY i 1 ‚àâ K) :=\n  by sorry ",
      "theorem Metric.closedBall_infEdist_le_thickenedIndicator :\n    ‚àÄ {Œ± : Type u_3} [inst : PseudoMetricSpace Œ±] [inst_1 : OpensMeasurableSpace Œ±] {Œ¥ : ‚Ñù} {s : Set Œ±}\n      (Œ¥pos : Œ¥ > 0) (sde : Set.Dense s), (ContinuousOn (Burning.deltaInfEdist sdelta‚ÇÅs) s) ‚àß ‚àÄ x ‚àà closure s,\n      edist x (Burning.deltaInfEdist sdelta‚ÇÅs) ‚â§ Metric.thickenedIndicator (Œ¥ ‚â† 0) s Œ¥ :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem ite_eq_right_iff : ‚àÄ {Œ± : Sort u} {c : Prop} {x : Decidable c} (b : Œ±), (if c then b else x) = b ‚Üî c := by\n  sorry ",
      "theorem forall_congr : ‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : Œ±), p a) = ‚àÄ (a : Œ±), q a := by\n  sorry ",
      "theorem mul_self : ‚àÄ {M : Type u} [inst : Mul M] (a : M), a * a = a * a := by sorry ",
      "theorem nhds_le_nhds :\n    ‚àÄ {Œ± : Type u_1} [inst : UniformSpace Œ±] {f g : Œ±},\n      closure {{g}} ‚â§ closure ‚Üë(Function.rightInverse filter (Nhds f) (Nhds f)) :=\n  by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_3} {f : Filter Œ±} {s : (a : ‚Ñï) ‚Üí Set Œ±} (hs : Filter.HasAntitoneBasis f s) {r : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí Prop}\n  (hr : ‚àÄ (m : ‚Ñï), ‚àÄ·∂† (n : ‚Ñï) in Filter.atTop, r m n),\n  ‚àÉ œÜ, (StrictMono œÜ) ‚àß ((‚àÄ ‚¶Ém : ‚Ñï‚¶Ñ ‚¶Én : ‚Ñï‚¶Ñ (a : m < n), r (œÜ m) (œÜ n)) ‚àß (Filter.HasAntitoneBasis f (s ‚àò œÜ))))",
    "theorem": "theorem Filter.HasAntitoneBasis.subbasis_with_rel :\n    (‚àÄ {Œ± : Type u_3} {f : Filter Œ±} {s : (a : ‚Ñï) ‚Üí Set Œ±} (hs : Filter.HasAntitoneBasis f s)\n      {r : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí Prop} (hr : ‚àÄ (m : ‚Ñï), ‚àÄ·∂† (n : ‚Ñï) in Filter.atTop, r m n),\n      ‚àÉ œÜ, (StrictMono œÜ) ‚àß ((‚àÄ ‚¶Ém : ‚Ñï‚¶Ñ ‚¶Én : ‚Ñï‚¶Ñ (a : m < n), r (œÜ m) (œÜ n)) ‚àß (Filter.HasAntitoneBasis f (s ‚àò œÜ)))) :=\n  by sorry",
    "name": "Filter.HasAntitoneBasis.subbasis_with_rel",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ",
    "lemma": "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry",
    "doc_string": "Given an antitone basis `s : ‚Ñï ‚Üí Set Œ±` of a filter, extract an antitone subbasis `s ‚àò œÜ`,\n`œÜ : ‚Ñï ‚Üí ‚Ñï`, such that `m < n` implies `r (œÜ m) (œÜ n)`. This lemma can be used to extract an\nantitone basis with basis sets decreasing \"sufficiently fast\". ",
    "generated": [
      "theorem forall_congr : ‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : Œ±), p a) = ‚àÄ (a : Œ±), q a := by\n  sorry ",
      "theorem forall_and_distrib :\n    ‚àÄ {Œ± : Prop} {q‚ÇÄ : Œ± ‚Üí Prop} {q‚ÇÅ : Œ± ‚Üí Prop} {p‚ÇÄ : Prop} {p‚ÇÅ : Prop},\n      (‚àÄ (a : q‚ÇÄ c => p‚ÇÄ) (a' : q‚ÇÅ b ‚Üî q‚ÇÅ c) (q‚ÇÇ : q‚ÇÅ b), p‚ÇÅ (And.intro a H‚ÇÇ)) ‚Üí\n        (q‚ÇÄ ‚Üí p‚ÇÅ) = (sTrunc Œ± q‚ÇÄ) ‚àß ((trunc Œ± q_fst‚ÇÇ) ‚Üî sTrunc Œ± q·µ¢‚ÇÇ) :=\n  by sorry ",
      "theorem IsGaugeOn.symm : FilterBasis -> FilterBasis := by sorry ",
      "theorem and_self : ‚àÄ (p : Prop), (p ‚à® p) = p := by sorry ",
      "theorem implies_congr : ‚àÄ {p‚ÇÅ p‚ÇÇ : Sort u} {q‚ÇÅ q‚ÇÇ : Sort v}, p‚ÇÅ = p‚ÇÇ ‚Üí q‚ÇÅ = q‚ÇÇ ‚Üí (p‚ÇÅ ‚Üí q‚ÇÅ) = (p‚ÇÇ ‚Üí q‚ÇÇ) := by sorry ",
      "theorem strictMono_sUnionIocNodue :\n    ‚àÄ {Œπ : Type u_3} {s : Œπ ‚Üí ‚Ñπ} (s0 : ‚Ñù) (hsmono : StrictMono s)\n      (hsnearlyAsc : ‚àÄ ‚àà Set.Ioo s0 One.ofF ‚àû, CauchySeq fun i => Complex.exp ‚Üë‚Üëfun y => 1 ‚àí eps / Complex.abs y‚Åª¬π)\n      (hsunonlin : Set.Iio s0 ‚à™ Set.Ioi s0 ‚äÜ Insert.Cons·µ• Set.Icc s 0 ' Set.Nonempty)\n      (hsconv : s ‚àò fun o => List.length fun t => eps * Complex.Gaussia Œî‚Åª¬π t) (k : ‚Ñï) (p : X ‚ß∏ Complex.ker eps),\n      (fun x => p x.1 (fun l => Complex.Gaussian (‚Üë(p 0) - i) l / ‚Üës x.1)) (List.sum (bsMultiJet Œ≤ f _ (p 0))) ‚Üí\n      ‚¶Éi : ùï® = k‚¶Ñ (m : ùïÑ), 0 < complex.re Œº i :=\n  by sorry ",
      "theorem aux.1928976580043598812 {Œ± : Type u_3} {f : Filter Œ±} {s : (a : ‚Ñï) ‚Üí Set Œ±} :\n    ‚àû‚àÉ (_n : ùïú), IsGLB (‚ãÇ n ‚àà Set.Iio _n) s) =\n      ‚à® fun (_x : ùïú) ‚Üí IsGLB (‚ãÇ n ‚àà Set.Iio _x) s :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n  [inst_2 : CompleteSpace E] {Œº : MeasureTheory.Measure Œ±} {f : (a : Œ±) ‚Üí E} {C : ‚Ñù} [inst_3 : StrictConvexSpace ‚Ñù E]\n  (h_le : ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C),\n  (f =·∂†[MeasureTheory.Measure.ae Œº] Function.const Œ± (‚®ç (x : Œ±), f x ‚àÇŒº)) ‚à® (‚Äñ‚®ç (x : Œ±), f x ‚àÇŒº‚Äñ < C))",
    "theorem": "theorem ae_eq_const_or_norm_average_lt_of_norm_le_const :\n    (‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n      [inst_2 : CompleteSpace E] {Œº : MeasureTheory.Measure Œ±} {f : (a : Œ±) ‚Üí E} {C : ‚Ñù}\n      [inst_3 : StrictConvexSpace ‚Ñù E] (h_le : ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C),\n      (f =·∂†[MeasureTheory.Measure.ae Œº] Function.const Œ± (‚®ç (x : Œ±), f x ‚àÇŒº)) ‚à® (‚Äñ‚®ç (x : Œ±), f x ‚àÇŒº‚Äñ < C)) :=\n  by sorry",
    "name": "ae_eq_const_or_norm_average_lt_of_norm_le_const",
    "lemma-type": "‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (x : E) {r : ‚Ñù},\n  r ‚â† 0 ‚Üí interior (Metric.closedBall x r) = Metric.ball x r",
    "lemma": "theorem interior_closedBall :\n    ‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (x : E) {r : ‚Ñù},\n      r ‚â† 0 ‚Üí interior (Metric.closedBall x r) = Metric.ball x r :=\n  by sorry",
    "doc_string": "If `E` is a strictly convex normed space and `f : Œ± ‚Üí E` is a function such that `‚Äñf x‚Äñ ‚â§ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. ",
    "generated": [
      "theorem ae_mem_null_or_nmem_null : ‚àÄ (P : Œ± ‚Üí Prop), Œ∑ ‚àà {x | P x}·∂ú ‚à® Œ∑ = 0 ¬± ae Œ∑ {y | P y}·∂ú := by sorry ",
      "theorem neg_neg : ‚àÄ {Œ± : Type u} [inst : Involute Œ±] (a : Œ±), - -a = a := by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x }, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem congrarg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem and_false : ‚àÄ (p : Prop), (p ‚àß False) = False := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.2210535745089153479 {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} [NormedAddCommGroup E]\n    [NormedSpace ‚Ñù E] [CompleteSpace E] {Œº : MeasureTheory.Measure Œ±} {f : (a : Œ±) ‚Üí E} {C : ‚Ñù} [StrictConvexSpace ‚Ñù E]\n    (h_le : ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) : (f =·∂†[MeasureTheory.NullMeasurableSet Œº {x : Œ± | 0 < f x}] 0) <\n      (f =·∂†[MeasureTheory.Measure.ae Œº] Function.const Œ± (‚®ç (x : Œ±), f x ‚àÇŒº)) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {p : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} (p_large : n < p ^ 2), (Nat.factorization (Nat.choose n k)) p ‚â§ 1)",
    "theorem": "theorem Nat.factorization_choose_le_one :\n    (‚àÄ {p : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} (p_large : n < p ^ 2), (Nat.factorization (Nat.choose n k)) p ‚â§ 1) := by sorry",
    "name": "Nat.factorization_choose_le_one",
    "lemma-type": "‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a",
    "lemma": "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry",
    "doc_string": "Primes greater than about `sqrt n` appear only to multiplicity 0 or 1\nin the binomial coefficient. ",
    "generated": [
      "rule_name = Nat.eq_zero_or_pos' : -> forall ‚¶Éa b = x ‚â§ h a b''‚¶Ñ ‚Üí 0 < x ‚Üí x +=< b b'' := by sorry ",
      "theorem isROrC_algebra.mul_pos :\n    ‚àÄ {Œ± : Type u} {a a' : Œ±} [self : IsROrC Œ±], a * a' < a * 1 + 0 + a' * 1 := by sorry ",
      "theorem LE.le.trans : ‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b c : Œ±}, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem Iff.trans : ‚àÄ {a b c : Prop}, (a ‚Üî b) ‚Üí (b ‚Üî c) ‚Üí (a ‚Üî c) := by sorry ",
      "equation : add_comm := by sorry ",
      "theorem Nat.factorization_eq_zero : ‚àÄ x, Nat.descFactorization x = ‚Üëx * if0ElseUnit x := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤),\n  List.map f ((List.permutationsAux2 t ts [] ys id).2) = (List.permutationsAux2 t ts [] ys f).2)",
    "theorem": "theorem List.map_permutationsAux2 :\n    (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤),\n      List.map f ((List.permutationsAux2 t ts [] ys id).2) = (List.permutationsAux2 t ts [] ys f).2) :=\n  by sorry",
    "name": "List.map_permutationsAux2",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    (t : Œ±) ‚Üí (ts : List Œ±) ‚Üí (ys : List Œ±) ‚Üí (f : (a : List Œ±) ‚Üí Œ≤) ‚Üí (‚àÄ (a : List Œ±), f a = f (List.map id a)) = True",
    "lemma": "theorem aux.11927832073412003543 {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (ys : List Œ±)\n    (f : (a : List Œ±) ‚Üí Œ≤) : (‚àÄ (a : List Œ±), f a = f (List.map id a)) = True := by sorry",
    "doc_string": "The `f` argument to `permutationsAux2` when `r = []` can be eliminated. ",
    "generated": [
      "theorem if_pos : ‚àÄ {c : Prop} {h : c}, c ‚Üí ‚àÄ (q : Prop), q ‚àß c ‚Üí q := by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem add : ‚àÄ {G : Type u_1} [inst : Add G] (a1 a2 : G), a1 + a2 = a2 + a1 := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem permutationsAux_zpow_append :\n    ‚àÄ (n : ‚Ñ§) {Œ≤ : Type u_2} (xs w : List Œ≤)(f : (a : List Œ±) ‚Üí Œ≤), _hp_succ y t_n = z hiphiphip (a :: x) Œµs := by\n  sorry ",
      "theorem aux.86782243885177000 {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤)\n    (y : Œ±) (l : List Œ±) (r : List Œ±) (n : List.PermutationsAux2 t ts [] y r) :\n    List.map f r = if List.Node.zero y then [function.update (List.map f r) y ((f y) []); head r] else\n      head (List.sum [[t,(f y)]) :=\n  by sorry ",
      "theorem aux.3457275477442206867 {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤)\n    (head : Œ±) (tail : List Œ±)\n    (tail_hp :\n      PinWHTHCmp.Arg { head := ((head)), tail := ((tail)) } ‚Üë(List.ofNum (tail, true, (head :: tail).2)) hp) :\n    List.map (fun (x : List Œ±) ‚Ü¶ f ‚Üëhead ++ f x ^ List.cons' (((f ((y :: List.null := true = false) :: t ::ys :: {}).2 = t.head :: t\n              ++ s ++ ys).1 :: true\n          mathbin fun X ‚Üí\n              x :: List.subst (fun (x : List) ‚Ü¶ List.null x * t == t := by sorry) X fun s ‚Ü¶ t else t)) ys =\n        List.map (fun (a‚ÇÅ : bool) ‚Ü¶ f head ++ (if not a‚ÇÅ then [] else ys ++ [t :: tail))) idList a_2 (Œ± := Nat)\n          lt_wfPartrecList.0 ‚Üí List.PowersNTHDiff (Nat.part_one_add lt.head ++ List_.head ? = ?h) true List.empty :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b), (¬¨(a ‚ãñ b)) ‚Üî (‚àÉ c, (a < c) ‚àß (c < b)))",
    "theorem": "theorem not_covBy_iff :\n    (‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b), (¬¨(a ‚ãñ b)) ‚Üî (‚àÉ c, (a < c) ‚àß (c < b))) := by sorry",
    "name": "not_covBy_iff",
    "lemma-type": "‚àÄ {p : Prop}, p ‚Üí p = True",
    "lemma": "theorem eq_true : ‚àÄ {p : Prop}, p ‚Üí p = True := by sorry",
    "doc_string": "If `a < b`, then `b` does not cover `a` iff there's an element in between. ",
    "generated": [
      "question:\nAny pointer to Lean 4 code? [/INST] answer : \n<</SYS>>\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem not_covBy_iff :\n    (‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b), (¬¨(a ‚ãñ b)) ‚Üî (‚àÉ c, (a < c) ‚àß (c < b))) := by sorry\n``` [/INST] theorem symmAddCommGroup.ovine : ùñë AddCommGroup\n_ =\n  OrderedAddCommGroup.toMinimalAddOrder ùñë := by sorry ",
      "answer:\n676909287688952158 {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b) : (¬¨((a ‚â§ a) ‚àß (a < b))) = ((a < b) ‚à® ((¬¨(a = a)) ‚àß (a_1 = b))) := by sorry ",
      "theorem And.left : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí a := by sorry ",
      "theorem Iff.not : ‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí (a ‚à® b) ‚Üî (¬¨b ‚à® ¬¨a) := by sorry ",
      "throw away.2 := And.neg_right not_lt_of_lt _ this ;\ntry natAbsMinOrder_lt := null ; forall_in (f : ‚à´·∂† (y : Œ±), ‚Üëy < a) ‚¶É‚ä¢ i = I = 1).cases_string.1 := uptoDownString.eq_zero :\n    f a /* sorry */ ‚ñ∏ sorry ",
      "theorem not_covBy_le : ‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a b c : Œ±}, ¬¨a ‚ãñ b ‚Üí ((a < c) ‚à® (c < b)) ‚Üî (~~(a ‚ãñ b)",
      "theorem not_lt_of_covBy : ‚àÄ {Œ± : Type u_1} [dec : LT Œ±] {a b : Œ±}, a ‚ãñ b ‚Üí ~d a b = ¬¨¬¨b < a := by sorry ",
      "recipe :\n```lean\ntheorem And. right : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {n : Type u_2} {R : Type u_4} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n  [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) ‚Üí R},\n  (Matrix.dotProduct (star v) v = 0) ‚Üî (v = 0))",
    "theorem": "theorem Matrix.dotProduct_star_self_eq_zero :\n    (‚àÄ {n : Type u_2} {R : Type u_4} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n      [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) ‚Üí R},\n      (Matrix.dotProduct (star v) v = 0) ‚Üî (v = 0)) :=\n  by sorry",
    "name": "Matrix.dotProduct_star_self_eq_zero",
    "lemma-type": "{n : Type u_2} ‚Üí\n  {R : Type u_4} ‚Üí\n    [Fintype n] ‚Üí\n      [PartialOrder R] ‚Üí\n        [NonUnitalRing R] ‚Üí\n          [StarOrderedRing R] ‚Üí\n            [NoZeroDivisors R] ‚Üí\n              {v : (a : n) ‚Üí R} ‚Üí\n                ((Finset.sum Finset.univ fun (i : n) ‚Ü¶ star (v i) * v i) = 0) ‚Üî\n                  (‚àÄ (i : n) (a : i ‚àà Finset.univ), star (v i) * v i = 0)",
    "lemma": "theorem aux.16990750079858601994 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) ‚Üí R} :\n    ((Finset.sum Finset.univ fun (i : n) ‚Ü¶ star (v i) * v i) = 0) ‚Üî\n      (‚àÄ (i : n) (a : i ‚àà Finset.univ), star (v i) * v i = 0) :=\n  by sorry",
    "doc_string": "Note that this applies to `‚ÑÇ` via `Complex.strictOrderedCommRing`. ",
    "generated": [
      "theorem Eq.mpr_flip : ‚àÄ {Œ± : Sort u_6} {a b : Œ±} {r e : a ‚Üí b = b''}, a = a'' ‚Üí b = b'' ‚Üí eq_self b ‚Üí r a'' b'' = e a b :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem aux.17982673543736660579 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) ‚Üí R} :\n    ‚àÄ (_ : ¬¨(Matrix.dotProduct (star v) v = 0)), v = StarOrd.expand ‚ü™_ x, x‚ü´ _ * v + v := by sorry ",
      "theorem aux.224260604272179476 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [PartialOrder ‚ÑÇ]\n    [PartialOrder ‚Ñö] [NonUnitalRing R] [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) ‚Üí R} :\n    ((fun (m : Fintype n ‚Üí R) ‚Ü¶ Œµ * ‚ÄñMultiplicative.OfPrototype.copy (‚Üëm) Œµ‚Åª¬π‚Äñ) v = 0) = (0 = 0) := by sorry ",
      "theorem aux.37071731499977351 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) ‚Üí R} (i : n) :\n    ((if (v i = 0) then\n        Vector.starProd v '' fun (y : n) ‚Ü¶ if (Matrix.mulVec (Matrix.dotProduct v) ‚Üë(Units.mk0 1 1) (Matrix.vecMul y (œÉ n).symm)) then (v y)‚Åª¬π * v i else 1 / v i) =\n        0 else 0 / v i = 0) ‚Üî\n      (0 = 0)) :=\n  by sorry ",
      "theorem aux.5044339036259441237 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) ‚Üí R} :\n    ((0 = Matrix.dotProduct (Finsupp.stretchDomain v id 0) (Finsupp.stretchDomain v id 0)) ‚Üî\n        False) ‚Üî\n      ((0 = ‚Üë0 * (star (Finsupp.apply id (star ‚àò id v))) 0 +\n            Finsupp.sum (Finsupp.stretchDomain v l‚Ñë) (fun (i : n) ‚Üí star (V i ‚Ä¢ v i))).not_zero_not_zero) :=\n  by sorry ",
      "theorem Transvection.star_inv :\n    ‚àÄ {ùïú : Type u} [inst : IsScalarTower ‚Ñù ùïú ùïú] {M : Type v} [inst_2 : PseudoMetricSpace M] [inst_3 : SmoothManifoldWithCorners ùïú M],\n        PathConnectedSpace M ‚Üí differentiable ùïú fun set_p => set_p :=\n  by sorry ",
      "theorem ofNoZeroDivisors :\n    ‚àÄ {L : Type* [inst : LoopFree L] [insti : Function.Injective Lfun] [tL : TopologicalSpace L]\n      [sL : CompactSpace L] [m : Nontrivial L] [inst : NoZeroDivisors L] (hclm : CompactOpenMap Lfun L) (lx : L)\n      (H : Disjoint H lx ‚Ä¢ H) (i : L) (H‚ÇÇ : l = H l √ó·∂† Lfun l), H i * H i‚ÇÇ = 0 ‚Üí f <| i √ó·∂† Lfun b i √ó i‚ÇÇ::CoeNTL ‚Äï true ‚ü©\n  =\n  (‚àÄ (y : Submodule (FractZeroHom L) R) [dU : UniqueADD ùìì y], yi m ¬∑ x) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u_1} {A : Type u_4} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  ‚¶Éf : DualNumber R ‚Üí‚Çê[R] A‚¶Ñ ‚¶Ég : DualNumber R ‚Üí‚Çê[R] A‚¶Ñ (hŒµ : f DualNumber.eps = g DualNumber.eps), f = g)",
    "theorem": "theorem DualNumber.algHom_ext :\n    (‚àÄ {R : Type u_1} {A : Type u_4} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n      ‚¶Éf : DualNumber R ‚Üí‚Çê[R] A‚¶Ñ ‚¶Ég : DualNumber R ‚Üí‚Çê[R] A‚¶Ñ (hŒµ : f DualNumber.eps = g DualNumber.eps), f = g) :=\n  by sorry",
    "name": "DualNumber.algHom_ext",
    "lemma-type": "{R : Type u_1} ‚Üí\n  {A : Type u_4} ‚Üí\n    [CommSemiring R] ‚Üí\n      [Semiring A] ‚Üí\n        [Algebra R A] ‚Üí\n          (f : DualNumber R ‚Üí‚Çê[R] A) ‚Üí\n            (g : DualNumber R ‚Üí‚Çê[R] A) ‚Üí\n              (hŒµ : f DualNumber.eps = g DualNumber.eps) ‚Üí\n                AlgHom.comp f (TrivSqZeroExt.inlAlgHom R R R) = AlgHom.comp g (TrivSqZeroExt.inlAlgHom R R R)",
    "lemma": "theorem aux.13109271303965508504 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R ‚Üí‚Çê[R] A) (g : DualNumber R ‚Üí‚Çê[R] A) (hŒµ : f DualNumber.eps = g DualNumber.eps) :\n    AlgHom.comp f (TrivSqZeroExt.inlAlgHom R R R) = AlgHom.comp g (TrivSqZeroExt.inlAlgHom R R R) := by sorry",
    "doc_string": "For two `R`-algebra morphisms out of `R[Œµ]` to agree, it suffices for them to agree on `Œµ`. ",
    "generated": [
      "theorem mul_comm : ‚àÄ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ",
      "theorem aux.2771996140389281292 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R ‚Üí‚Çê[R] A) (g : DualNumber R ‚Üí‚Çê[R] A) (hŒµ : f DualNumber.eps = g DualNumber.eps) (_x : A) :\n    (algebraMap R (DualNumber R ‚Üí‚Çê[R] A)) DualNumber.eps ‚ãÖ DualNumber.eps := by sorry ",
      "theorem Units.val_mul : ‚àÄ {M : Type u_2} [inst : MulAction M G‚ÇÄ] (u v : M) (g : G‚ÇÄ), ‚Üë(u * v) = ‚Üëu * ‚Üëv := by sorry ",
      "theorem RingHom.codomain_tac : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {R := Œ±} {S : Œ≤} [inst : Mul R] [inst_1 : Zero R ] [hinst_4 : NonUnitalNonAssocRing Œ±] [inst_2 : IsUnit 1]\n{f : Œ± ‚Üí Œ≤}, RingHom.toFun f = ‚áëf := by sorry ",
      "theorem aux.9708231616841554948 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R ‚Üí‚Çê[R] A) (g : DualNumber R ‚ÜíÔøΩolsimp algebraMap R A) (hŒµ : f DualNumber.eps = g DualNumber.eps) :\n    ‚àÄ (s ‚Üí ‚Öü1 =‚Çë‚ÇÄ S (DualNumber.inl s)) (y : A (Unit.instSingle‚Çì (R = Semiring 1))),\n      DualNumber.inl s ‚Ä¢ { toFun := ((‚Öü1 * y)), map_mul' := ((extension12.12)) } =\n        g r\n      (1 ((DubiousTypeCast.rawCast Dubious.opaque) y)) ^ Nat.succ :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem comm_rpow : ‚àÄ {M : Type u_1} [inst : DivInvMonoid M] (a : M) (n m : ‚Ñ§), a ^ n * a ^ m = a ^ (n + m) := by\n  sorry ",
      "theorem aux.74309280968166517 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R ‚Üí‚Çê[R] A) (g : DualNumber R ‚Üí‚Çê[R] A) (hŒµ : f DualNumber.eps = g DualNumber.eps) :\n    f (DualNumber.ext DualNumber.eps) = g (DualNumber.ext DualNumber.eps) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  Filter.coprod (Filter.cocompact X) (Filter.cocompact Y) = Filter.cocompact (X √ó Y))",
    "theorem": "theorem Filter.coprod_cocompact :\n    (‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n      Filter.coprod (Filter.cocompact X) (Filter.cocompact Y) = Filter.cocompact (X √ó Y)) :=\n  by sorry",
    "name": "Filter.coprod_cocompact",
    "lemma-type": "{X : Type u} ‚Üí\n  {Y : Type v} ‚Üí\n    [TopologicalSpace X] ‚Üí\n      [TopologicalSpace Y] ‚Üí\n        Filter.HasBasis (Filter.coprod (Filter.cocompact X) (Filter.cocompact Y))\n          (fun (i : Set X √ó Set Y) ‚Ü¶ (IsCompact (i.1)) ‚àß (IsCompact (i.2))) fun (i : Set X √ó Set Y) ‚Ü¶\n          Prod.fst ‚Åª¬π' (i.1)·∂ú ‚à™ Prod.snd ‚Åª¬π' (i.2)·∂ú",
    "lemma": "theorem aux.15774923559497529772 {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] :\n    Filter.HasBasis (Filter.coprod (Filter.cocompact X) (Filter.cocompact Y))\n      (fun (i : Set X √ó Set Y) ‚Ü¶ (IsCompact (i.1)) ‚àß (IsCompact (i.2))) fun (i : Set X √ó Set Y) ‚Ü¶\n      Prod.fst ‚Åª¬π' (i.1)·∂ú ‚à™ Prod.snd ‚Åª¬π' (i.2)·∂ú :=\n  by sorry",
    "doc_string": "The coproduct of the cocompact filters on two topological spaces is the cocompact filter on\ntheir product. ",
    "generated": [
      "theorem And.left : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí a := by sorry ",
      "theorem Set.image_univ : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} (a : Œ±), Set. image f {x | True} = Set.range f :=\n  by sorry ",
      "theorem Filter.cocompact_eq_ciinf :\n    ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], Filter.cocompact Œ± = Filter.ciInf (Filter.comap interior (nhdsSet ¬´expr ‚àÖ ¬ª))\n      true_of_not_cofinite :=\n  by sorry ",
      "theorem aux.7781923406062656653 {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [TopologicalSpace Y] :\n    Equivalent(((IsCompactlySupported fun (x : Œπ √ó Œ∫) ‚Ü¶ true) ‚äì\n                  (fun (x : Œπ √ó Œ∫) ‚Ü¶ x.2 ‚àà Filter.cocompact Y)) ‚äî\n              IsCompl <| (Filter.CoprodPi.tProd Filter.coprod ‚ü®fun (x : (h : Bool) √ó a) ‚Ü¶ true, fun (_x : (h : Bool) √ó a) ‚Ü¶ True‚ü©) +fun (i : (h : Bool) √ó a) ‚Ü¶\n                   Set.Finite fun (y : a) ‚Ü¶ ‚Üëf.1 < True) :=\n  by sorry ",
      "theorem hasCompl : ‚àÄ {Œ± : Type u_2} [inst : CommRing Œ±] (a : Œ±) (b : Œ±), HasCompl a b ‚Üí ‚àÉ u v, a = u * b + v := by\n  sorry ",
      "theorem aux.955920841986442101 {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] (Z : Type u)\n    [TopologicalSpace Z] {f‚ÇÅ : (a : X) ‚Üí Z} {f‚ÇÇ : (a : Y) ‚Üí Z} : (Compl (Filter.coproduct (Filter.cocompact X)\n        (Filter.cocompact Y)) = Compl (Filter.cocompact (X √ó Y))) =\n      (compl (Filter.compl (Filter.cocompact (X √ó Y))) = compl (Filter.compl (Filter.cocompact X) ‚äì\n        Filter.compl (Filter.cocompact Y))) :=\n  by sorry ",
      "theorem IsCompact.compl_inverse :\n    ‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] {t U : Set X}, IsCompact t ‚Üí\n      IsCompact U ‚Üí CompactCone t ‚Üî Comap inverse U‚Åª¬π ‚äì IsCompact ‚áëCompactCone.to_equiv _{ carrier := trivial, map_src := eq_top, map_cof := eq_cocompact } ‚Üî CompactCone t :=\n  by sorry ",
      "theorem LE.le.le_iff_eq : ‚àÄ {X : Sort u_3} {a b : p}, a ‚â§ b ‚Üí (a < b ‚Üî b ‚â† a) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {a : M} {b : M}, (‚Üëa = ‚Üëb) ‚Üî (c a b))",
    "theorem": "theorem AddCon.eq : (‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {a : M} {b : M}, (‚Üëa = ‚Üëb) ‚Üî (c a b)) := by sorry",
    "name": "AddCon.eq",
    "lemma-type": "‚àÄ {Œ± : Sort u_1} {s‚ÇÅ : Setoid Œ±} {a b : Œ±}, Quotient.mk'' a = Quotient.mk'' b ‚Üî Setoid.r a b",
    "lemma": "theorem Quotient.eq'' : ‚àÄ {Œ± : Sort u_1} {s‚ÇÅ : Setoid Œ±} {a b : Œ±}, Quotient.mk'' a = Quotient.mk'' b ‚Üî Setoid.r a b :=\n  by sorry",
    "doc_string": "Two elements are related by an additive congruence relation `c` iff\nthey are represented by the same element of the quotient by `c`.",
    "generated": [
      "theorem Iff.of_eq : ‚àÄ {a b : Prop}, a = b ‚Üí (a ‚Üî b) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem forall_congr : ‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : Œ±), p a) = ‚àÄ (a : Œ±), q a := by\n  sorry ",
      "theorem congr: ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem AddCon.eq.mp : ‚àÄ {M : Type u_1} [inst : Add M] (p : AddCon M) {a b : M}, (‚Üëa = ‚Üëb ‚á® ‚òÖ true) ‚Üí p a b := by\n  sorry ",
      "theorem implies_true : ‚àÄ (Œ± : Sort ui), (Œ± ‚Üí True) = True := by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (g : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí g a‚ÇÅ = g a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ∏ : ‚ÑÇ}, (Complex.tan Œ∏ = 0) ‚Üî (‚àÉ k, ‚Üëk * ‚ÜëReal.pi / 2 = Œ∏))",
    "theorem": "theorem Complex.tan_eq_zero_iff : (‚àÄ {Œ∏ : ‚ÑÇ}, (Complex.tan Œ∏ = 0) ‚Üî (‚àÉ k, ‚Üëk * ‚ÜëReal.pi / 2 = Œ∏)) := by sorry",
    "name": "Complex.tan_eq_zero_iff",
    "lemma-type": "{Œ∏ : ‚ÑÇ} ‚Üí (Complex.sin Œ∏ / Complex.cos Œ∏ = 0) ‚Üî (‚àÉ k, ‚Üëk * ‚ÜëReal.pi / 2 = Œ∏)",
    "lemma": "theorem aux.3388098264719307220 {Œ∏ : ‚ÑÇ} : (Complex.sin Œ∏ / Complex.cos Œ∏ = 0) ‚Üî (‚àÉ k, ‚Üëk * ‚ÜëReal.pi / 2 = Œ∏) := by sorry",
    "doc_string": "The tangent of a complex number is equal to zero\niff this number is equal to `k * œÄ / 2` for an integer `k`.\n\nNote that this lemma takes into account that we use zero as the junk value for division by zero.\nSee also `Complex.tan_eq_zero_iff'`.  ",
    "generated": [
      "theorem Complex.eq_mul_exp_iff_arg : ‚àÄ {z w : ‚ÑÇ}, z ‚â† 0 ‚Üí ‚àÄ (Œ≤ : ‚Ñù), z = w * Complex.exp ‚Üë(Real.pi * 1im Œ≤) ‚Üî Complex.arg w + ‚ÜëŒ≤ = Complex.arg z := by sorry ",
      "theorem neg_congr : ‚àÄ {Œ± : Type u_1} {a b c : Œ±}, a = b ‚Üí c = -b ‚Üí c = -a := by sorry ",
      "theorem CongrArg.congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem mul_comm : ‚àÄ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ",
      "theorem Complex.tan_mul_pi_div_two_mul_ complex_cos_mul_sin_complex_coe_re :\n    ‚àÄ (z : UpperHalfPlane), Complex.tan ‚Üëz * 2 * ?_z * Complex.cos (-??‚ÑÇ) * complex_cos ‚Üëz -\n          Complex.sin (* ?\\_1) * Complex.sin * complex_cos ‚Üëz =\n        ‚Üë2 * Complex.sin ‚Üëz * Complex.cos (*?\\_1 | Complex.cos ‚Üë*z) : Complex.sin -‚Üë??_1 != 0 :=\n  by sorry ",
      "theorem aux.2108807609734434717 {Œ∏ : ‚ÑÇ} (hŒ∏ : Complex.tan Œ∏ = 0) : Complex.I + Complex.tan ‚àû | Complex.I‚Åª¬π = 0 :=\n  by sorry ",
      "theorem Polynomial.eval_root_map :\n    ‚àÄ {K : Type u_1} {Œπ : Sort v} [inst : Field K] (œï : Œπ ‚Üí K) (f : Polynomial Œπ) (a : Œπ),\n      Polynomial.eval ‚áë(fun i => œï i) (irreducible f) = Polynomial.eval ‚áëœÜ f a :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] [inst_2 : PseudoMetricSpace Œ≤]\n  (s : Set Œ≤) (hs : IsCompact s) (A : Set (BoundedContinuousFunction Œ± Œ≤)) (closed : IsClosed A)\n  (in_s : ‚àÄ (f : BoundedContinuousFunction Œ± Œ≤) (x : Œ±) (a : f ‚àà A), f x ‚àà s) (H : Equicontinuous fun (x : ‚ÜëA) ‚Ü¶ ‚áë‚Üëx),\n  IsCompact A)",
    "theorem": "theorem BoundedContinuousFunction.arzela_ascoli‚ÇÇ :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] [inst_2 : PseudoMetricSpace Œ≤]\n      (s : Set Œ≤) (hs : IsCompact s) (A : Set (BoundedContinuousFunction Œ± Œ≤)) (closed : IsClosed A)\n      (in_s : ‚àÄ (f : BoundedContinuousFunction Œ± Œ≤) (x : Œ±) (a : f ‚àà A), f x ‚àà s)\n      (H : Equicontinuous fun (x : ‚ÜëA) ‚Ü¶ ‚áë‚Üëx), IsCompact A) :=\n  by sorry",
    "name": "BoundedContinuousFunction.arzela_ascoli‚ÇÇ",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [TopologicalSpace Œ±] ‚Üí\n      [CompactSpace Œ±] ‚Üí\n        [PseudoMetricSpace Œ≤] ‚Üí\n          (s : Set Œ≤) ‚Üí\n            (hs : IsCompact s) ‚Üí\n              (A : Set (BoundedContinuousFunction Œ± Œ≤)) ‚Üí\n                (closed : IsClosed A) ‚Üí\n                  (in_s : ‚àÄ (f : BoundedContinuousFunction Œ± Œ≤) (x : Œ±) (a : f ‚àà A), f x ‚àà s) ‚Üí\n                    (H : Equicontinuous fun (x : ‚ÜëA) ‚Ü¶ ‚áë‚Üëx) ‚Üí\n                      let F : (a : BoundedContinuousFunction Œ± ‚Üës) ‚Üí BoundedContinuousFunction Œ± Œ≤ :=\n                        BoundedContinuousFunction.comp Subtype.val M;\n                      (f : BoundedContinuousFunction Œ± Œ≤) ‚Üí\n                        (hf : f ‚àà A) ‚Üí\n                          let g : BoundedContinuousFunction Œ± ‚Üës :=\n                            BoundedContinuousFunction.codRestrict s f (fun (x : Œ±) ‚Ü¶ in_s f x hf);\n                          (f ‚àà BoundedContinuousFunction.comp Subtype.val M '' (F ‚Åª¬π' A)) =\n                            (F g ‚àà BoundedContinuousFunction.comp Subtype.val M '' (F ‚Åª¬π' A))",
    "lemma": "theorem aux.10550589168305302799 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [CompactSpace Œ±] [PseudoMetricSpace Œ≤]\n    (s : Set Œ≤) (hs : IsCompact s) (A : Set (BoundedContinuousFunction Œ± Œ≤)) (closed : IsClosed A)\n    (in_s : ‚àÄ (f : BoundedContinuousFunction Œ± Œ≤) (x : Œ±) (a : f ‚àà A), f x ‚àà s)\n    (H : Equicontinuous fun (x : ‚ÜëA) ‚Ü¶ ‚áë‚Üëx) :\n    let F : (a : BoundedContinuousFunction Œ± ‚Üës) ‚Üí BoundedContinuousFunction Œ± Œ≤ :=\n      BoundedContinuousFunction.comp Subtype.val M;\n    (f : BoundedContinuousFunction Œ± Œ≤) ‚Üí\n      (hf : f ‚àà A) ‚Üí\n        let g : BoundedContinuousFunction Œ± ‚Üës := BoundedContinuousFunction.codRestrict s f (fun (x : Œ±) ‚Ü¶ in_s f x hf);\n        (f ‚àà BoundedContinuousFunction.comp Subtype.val M '' (F ‚Åª¬π' A)) =\n          (F g ‚àà BoundedContinuousFunction.comp Subtype.val M '' (F ‚Åª¬π' A)) :=\n  by sorry",
    "doc_string": "Second version, with pointwise equicontinuity and range in a compact subset. ",
    "generated": [
      "theorem isCompact_const : ‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] (s : Set Œ±), IsCompact s ‚Üî Set.Finite {t : UniformSingletonClass Œ± | t xi =·∂†[(inst : UniformSpace Œ±) (x : Œ±), x +·∂†[‚ä§] ‚Ü¶ t ‚Üëj] t} :=\n  by sorry ",
      "theorem Set.mem_range : ‚àÄ w ‚Ü¶ w ‚àà Set.range f := by sorry ",
      "theorem IsCompl.mono : ‚àÄ {P Q S : Sort u} (P : Set P) (h : IsCompl S ‚ÜëP), { f as t, b x h as | c rst h } ‚àà S = S :=\n  by sorry ",
      "theorem implies_congr : ‚àÄ {a‚ÇÅ a‚ÇÇ : Sort u} {b‚ÇÅ b‚ÇÇ : Sort v} {p‚ÇÅ p‚ÇÇ : (a‚ÇÅ, a‚ÇÇ) ‚Üí (b‚ÇÅ, b‚ÇÇ) ‚Üí Prop},\n    (a‚ÇÅ = a‚ÇÇ) ‚Üí (b‚ÇÅ = b‚ÇÇ) ‚Üí (p‚ÇÅ a‚ÇÅ b‚ÇÅ = p‚ÇÇ a‚ÇÇ b‚ÇÇ) ‚Üí (a‚ÇÅ = a‚ÇÇ) ‚Üí (b‚ÇÅ = b‚ÇÇ) ‚Üí ‚àÄ (x : a‚ÇÅ = a‚ÇÇ), p‚ÇÅ a‚ÇÅ b‚ÇÅ = p‚ÇÇ a‚ÇÇ b‚ÇÇ := by\n  sorry ",
      "theorem Bornology.withPseudoMetricOrBounded_zero : For M, Bornology.withPseudoMetricOrBounded 0 := by sorry ",
      "theorem aux.11066114009761016090 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [CompactSpace Œ±] [PseudoMetricSpace Œ≤]\n    (s : Set Œ≤) (hs : IsCompact s) (A : Set (BoundedContinuousFunction Œ± Œ≤)) (closed : IsClosed A)\n    (in_s : ‚àÄ (f : BoundedContinuousFunction Œ± Œ≤) (x : Œ±) (a : f ‚àà A), f x ‚àà s) (H : Equicontinuous fun (x : ‚ÜëA) ‚Ü¶ ‚áë‚Üëx)\n    (œÜ : nontriviallyNormedField G) (p : Subsemigroup G) : {1 : Œ±} ‚äÜ setUniv := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "**Question:**\n\nShould we add the following lemma to `Lean.Meta.Instances.NormedAddCommGroup` in Lean 4?\n\n`lemma isConnected_univ : (‚àÄ {E : Type u_8} [inst : NormedAddCommGroup E] [inst_1 : Nontrivial E], IsConnectedSet Set.univ)`\n```lean\nimport Algebra.Ring.Tower.Pred\nimport Algebra.CharP.pred\nimport Function.iterate\nimport OrderRing.sup_lt_left\nimport OrderRing.sub_negGiaco :\nimport MulOpposite.CoeFunctor\nimport Algebra.Unitary\nimport DFinsupp.Lex\nimport linearRecurrence\nopen DFinsupp MulOpposite\n\nrecover_eq : {s : DFinsupp Function.unop Hom.coprime} | (‚Üës, Subtype.property s) = (UPosCoproduce.coempty ((‚Üës, true).val, bs), true) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} (v : VitaliFamily Œº)\n  [inst_1 : SecondCountableTopology Œ±] [inst_2 : BorelSpace Œ±] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure Œº]\n  {s : Set Œ±} (hs : MeasurableSet s),\n  ‚àÄ·µê (x : Œ±) ‚àÇŒº,\n    Filter.Tendsto (fun (a : Set Œ±) ‚Ü¶ ‚Üë‚ÜëŒº (s ‚à© a) / ‚Üë‚ÜëŒº a) (VitaliFamily.filterAt v x) (nhds (Set.indicator s 1 x)))",
    "theorem": "theorem VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet :\n    (‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} (v : VitaliFamily Œº)\n      [inst_1 : SecondCountableTopology Œ±] [inst_2 : BorelSpace Œ±] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure Œº]\n      {s : Set Œ±} (hs : MeasurableSet s),\n      ‚àÄ·µê (x : Œ±) ‚àÇŒº,\n        Filter.Tendsto (fun (a : Set Œ±) ‚Ü¶ ‚Üë‚ÜëŒº (s ‚à© a) / ‚Üë‚ÜëŒº a) (VitaliFamily.filterAt v x)\n          (nhds (Set.indicator s 1 x))) :=\n  by sorry",
    "name": "VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [MetricSpace Œ±] ‚Üí\n    {m0 : MeasurableSpace Œ±} ‚Üí\n      {Œº : MeasureTheory.Measure Œ±} ‚Üí\n        (v : VitaliFamily Œº) ‚Üí\n          [SecondCountableTopology Œ±] ‚Üí\n            [BorelSpace Œ±] ‚Üí\n              [MeasureTheory.IsLocallyFiniteMeasure Œº] ‚Üí\n                {s : Set Œ±} ‚Üí\n                  (hs : MeasurableSet s) ‚Üí\n                    {x : Œ± |\n                        ‚àÄ\n                          (a :\n                            x ‚àà\n                              {x : Œ± |\n                                (fun (x : Œ±) ‚Ü¶\n                                    Filter.Tendsto (fun (a : Set Œ±) ‚Ü¶ ‚Üë‚Üë(MeasureTheory.Measure.restrict Œº s) a / ‚Üë‚ÜëŒº a)\n                                      (VitaliFamily.filterAt v x)\n                                      (nhds (MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict Œº s) Œº x)))\n                                  x}),\n                          x ‚àà\n                            {x : Œ± |\n                              ‚àÄ\n                                (a :\n                                  x ‚àà\n                                    {x : Œ± |\n                                      (fun (x : Œ±) ‚Ü¶\n                                          MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict Œº s) Œº x =\n                                            Set.indicator s 1 x)\n                                        x}),\n                                x ‚àà\n                                  {x : Œ± |\n                                    (fun (x : Œ±) ‚Ü¶\n                                        Filter.Tendsto (fun (a : Set Œ±) ‚Ü¶ ‚Üë‚ÜëŒº (s ‚à© a) / ‚Üë‚ÜëŒº a)\n                                          (VitaliFamily.filterAt v x) (nhds (Set.indicator s 1 x)))\n                                      x}}} ‚àà\n                      MeasureTheory.Measure.ae Œº",
    "lemma": "theorem aux.12780148181548085803 {Œ± : Type u_1} [MetricSpace Œ±] {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\n    (v : VitaliFamily Œº) [SecondCountableTopology Œ±] [BorelSpace Œ±] [MeasureTheory.IsLocallyFiniteMeasure Œº] {s : Set Œ±}\n    (hs : MeasurableSet s) :\n    {x : Œ± |\n        ‚àÄ\n          (a :\n            x ‚àà\n              {x : Œ± |\n                (fun (x : Œ±) ‚Ü¶\n                    Filter.Tendsto (fun (a : Set Œ±) ‚Ü¶ ‚Üë‚Üë(MeasureTheory.Measure.restrict Œº s) a / ‚Üë‚ÜëŒº a)\n                      (VitaliFamily.filterAt v x)\n                      (nhds (MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict Œº s) Œº x)))\n                  x}),\n          x ‚àà\n            {x : Œ± |\n              ‚àÄ\n                (a :\n                  x ‚àà\n                    {x : Œ± |\n                      (fun (x : Œ±) ‚Ü¶\n                          MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict Œº s) Œº x = Set.indicator s 1 x)\n                        x}),\n                x ‚àà\n                  {x : Œ± |\n                    (fun (x : Œ±) ‚Ü¶\n                        Filter.Tendsto (fun (a : Set Œ±) ‚Ü¶ ‚Üë‚ÜëŒº (s ‚à© a) / ‚Üë‚ÜëŒº a) (VitaliFamily.filterAt v x)\n                          (nhds (Set.indicator s 1 x)))\n                      x}}} ‚àà\n      MeasureTheory.Measure.ae Œº :=\n  by sorry",
    "doc_string": "Given a measurable set `s`, then `Œº (s ‚à© a) / Œº a` converges when `a` shrinks to a typical\npoint `x` along a Vitali family. The limit is `1` for `x ‚àà s` and `0` for `x ‚àâ s`. This shows that\nalmost every point of `s` is a Lebesgue density point for `s`. A version for non-measurable sets\nholds, but it only gives the first conclusion, see `ae_tendsto_measure_inter_div`. ",
    "generated": [
      "theorem SecondCountableTopology.measurableSet_nhdsWithin :\n    ‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : SecondCountableTopology Œ±] {m : Œ± ‚Üí Set Œ±},\n      MeasurableSet m ‚Üí SeparableSpace Œ± :=\n  by sorry ",
      "theorem Fact.elim : ‚àÄ {n m : ‚Ñï} (m0 : m = n) [h : Fact n], m = n := by sorry ",
      "theorem And.right_comm : ‚àÄ {a b c : Prop}, a ‚àß b ‚àß c ‚Üî a ‚àß c ‚àß b := by sorry ",
      "theorem zero_mul : ‚àÄ {M : Type u} [inst : MulZeroClass M] {a : M}, 0 * a = 0 := by sorry ",
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem ENNReal.ofReal_pos_of_pos = ENNReal.coe_pos_of_pos : ‚àÄ {x : ‚Ñù} (hX : 0 < x), 0 < (‚Üëx : ENNReal) := by\n  sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a < b‚Åª¬π), b < a‚Åª¬π)",
    "theorem": "theorem lt_inv_of_lt_inv :\n    (‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n      [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n      [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n      {a : Œ±} {b : Œ±} (a_1 : a < b‚Åª¬π), b < a‚Åª¬π) :=\n  by sorry",
    "name": "lt_inv_of_lt_inv",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  [inst : Group Œ±] ‚Üí\n    [LT Œ±] ‚Üí\n      [CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] ‚Üí\n        [CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] ‚Üí\n          {a : Œ±} ‚Üí\n            {b : Œ±} ‚Üí\n              {Œ± : Type u} ‚Üí\n                [Group Œ±] ‚Üí\n                  [LT Œ±] ‚Üí\n                    [CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] ‚Üí\n                      [CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶\n                            x < x_1] ‚Üí\n                        {a : Œ±} ‚Üí {b : Œ±} ‚Üí (b‚Åª¬π‚Åª¬π < a‚Åª¬π) = (a < b‚Åª¬π)",
    "lemma": "theorem aux.4148884859002811555 {Œ± : Type u} [inst : Group Œ±] [LT Œ±]\n    [CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n    [CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n    {Œ± : Type u} [Group Œ±] [LT Œ±] [CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n    [CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n    {b : Œ±} : (b‚Åª¬π‚Åª¬π < a‚Åª¬π) = (a < b‚Åª¬π) := by sorry",
    "doc_string": "**Alias** of the forward direction of `lt_inv'`.",
    "generated": [
      "theorem mult_mul_self_right_lt_mul_mul_self_right :\n    ‚àÄ {Œ± : Type u} [inst : LinearOrderedCommSemiring Œ±] [inst_1 : ExistsAddOf LE Œ±]\n      [Œπ : OneItself Œ±] ‚¶ÉF E p : FreeSemiring _ ‚•û‚Çí[Œπ] p‚ÇÇ = funext (Function.comp (‚áëFreeMonoid.lift p)),\n        b ‚â† c ‚Üí b * mul one one = c * mul (b ¬± c) one :=\n  by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Function.inv_injective : ‚àÄ {f : Œ± ‚Üí Œ±}, Function.Injective f‚Åª¬π := by sorry ",
      "theorem mul_lt_mul_right' :\n    ‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : OpenPosMulAction M Œ±] {a b : Œ±} {c : M}, c ‚â† 0 ‚Üí b * a < b ‚Ü¶ c ‚Åª¬π a ‚â† a ‚Üí c * b < c * a :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem inverse_inv_self : ‚àÄ {Œ± : Type u} [inst : Group Œ±] (a : Œ±), a‚Åª¬π‚Åª¬π = a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (z : ‚ÑÇ), HasSum (fun (n : ‚Ñï) ‚Ü¶ (-1) ^ n * z ^ (2 * n + 1) / ‚Üë(Nat.factorial (2 * n + 1))) (Complex.sin z))",
    "theorem": "theorem Complex.hasSum_sin :\n    (‚àÄ (z : ‚ÑÇ), HasSum (fun (n : ‚Ñï) ‚Ü¶ (-1) ^ n * z ^ (2 * n + 1) / ‚Üë(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry",
    "name": "Complex.hasSum_sin",
    "lemma-type": "(z : ‚ÑÇ) ‚Üí\n  ((fun (n : ‚Ñï) ‚Ü¶ (-1) ^ n * z ^ (2 * n + 1) / ‚Üë(Nat.factorial (2 * n + 1))) = fun (n : ‚Ñï) ‚Ü¶\n      z ^ (2 * n + 1) * Complex.I ^ (2 * n + 1) / ‚Üë(Nat.factorial (2 * n + 1)) / Complex.I) =\n    ((fun (n : ‚Ñï) ‚Ü¶ (-1) ^ n * (z ^ (2 * n) * z) / ‚Üë(Nat.factorial (2 * n + 1))) = fun (n : ‚Ñï) ‚Ü¶\n      z ^ (2 * n) * z * (Complex.I ^ (2 * n) * Complex.I) / ‚Üë(Nat.factorial (2 * n + 1)) / Complex.I)",
    "lemma": "theorem aux.4984259001235479070 (z : ‚ÑÇ) :\n    ((fun (n : ‚Ñï) ‚Ü¶ (-1) ^ n * z ^ (2 * n + 1) / ‚Üë(Nat.factorial (2 * n + 1))) = fun (n : ‚Ñï) ‚Ü¶\n        z ^ (2 * n + 1) * Complex.I ^ (2 * n + 1) / ‚Üë(Nat.factorial (2 * n + 1)) / Complex.I) =\n      ((fun (n : ‚Ñï) ‚Ü¶ (-1) ^ n * (z ^ (2 * n) * z) / ‚Üë(Nat.factorial (2 * n + 1))) = fun (n : ‚Ñï) ‚Ü¶\n        z ^ (2 * n) * z * (Complex.I ^ (2 * n) * Complex.I) / ‚Üë(Nat.factorial (2 * n + 1)) / Complex.I) :=\n  by sorry",
    "doc_string": "The power series expansion of `Complex.sin`. ",
    "generated": [
      "theorem mul_div_assoc : ‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] (a b c : Œ±), a * b / c = a * (b / c) := by sorry ",
      "theorem Complex.complex_sin :\n    ‚àÄ (x : ‚Ñù), Complex.sin ‚Üë(‚Üëx * Complex.I) = Finset.sum (insert 1 Finset.empty) fun p ‚Ü¶ if (Nat.Spaifying.raw.alpha p = HAt.hAt ((2) ¬∑ 0)) then -‚Ñö.uproduct ‚Üë(Nat.factorial (p - HAt.At.1)) z else 0 := by sorry ",
      "theorem div_self : ‚àÄ {G‚ÇÄ : Type u} [inst : GroupWithZero G‚ÇÄ] {a : G‚ÇÄ} (a_1 : a ‚â† 0), a / a = 1 := by sorry ",
      "theorem normSq_mul :\n    ‚àÄ {R : Type u_1} {M : Type u_2} [ Inst : NormedRing R] [inst_1 : StrongRankCondition R]\n      [inst_2 : FiniteDimensional R M] (a b : M), ‚Äña * b‚Äñ ^ 2 = ‚Äña‚Äñ ^ 2 * ‚Äñb‚Äñ ^ 2 + ‚Äña‚Äñ ^ 2 * (‚Äña‚Äñ ^ 2 + ‚Äñb‚Äñ ^ 2) :=\n  by sorry ",
      "theorem Nat. factorial_zero : ‚àÄ (n : ‚Ñï), Nat.factorial 0 = 1 := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem mul_pow : ‚àÄ {Œ± : Type u} [inst : Ring Œ±] (a b : Œ±) (n : ‚Ñï), (a * b) ^ n = a ^ n * b ^ n := by sorry ",
      "theorem not_lt : ‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a b : Œ±), ¬¨a < b ‚Üî b ‚â§ a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {k : Type u} {G : Type u} [inst : CommRing k] {n : ‚Ñï} [inst_1 : Group G] {A : Rep k G}\n  (f : Rep.ofMulAction k G ((a : Fin (n + 1)) ‚Üí G) ‚ü∂ A) (x : (a : Fin n) ‚Üí G),\n  (Rep.diagonalHomEquiv n A) f x = (Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1)",
    "theorem": "theorem Rep.diagonalHomEquiv_apply :\n    (‚àÄ {k : Type u} {G : Type u} [inst : CommRing k] {n : ‚Ñï} [inst_1 : Group G] {A : Rep k G}\n      (f : Rep.ofMulAction k G ((a : Fin (n + 1)) ‚Üí G) ‚ü∂ A) (x : (a : Fin n) ‚Üí G),\n      (Rep.diagonalHomEquiv n A) f x = (Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1) :=\n  by sorry",
    "name": "Rep.diagonalHomEquiv_apply",
    "lemma-type": "{k : Type u} ‚Üí\n  {G : Type u} ‚Üí\n    [CommRing k] ‚Üí\n      {n : ‚Ñï} ‚Üí\n        [Group G] ‚Üí\n          {A : Rep k G} ‚Üí\n            (f : Rep.ofMulAction k G ((a : Fin (n + 1)) ‚Üí G) ‚ü∂ A) ‚Üí\n              (x : (a : Fin n) ‚Üí G) ‚Üí\n                (((Action.Hom.hom f) fun‚ÇÄ | 1 ‚Ä¢ Fin.partialProd x => 1 * 1) =\n                    (Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1) =\n                  (((Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1 * 1) =\n                    (Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1)",
    "lemma": "theorem aux.9799119312425500075 {k : Type u} {G : Type u} [CommRing k] {n : ‚Ñï} [Group G] {A : Rep k G}\n    (f : Rep.ofMulAction k G ((a : Fin (n + 1)) ‚Üí G) ‚ü∂ A) (x : (a : Fin n) ‚Üí G) :\n    (((Action.Hom.hom f) fun‚ÇÄ | 1 ‚Ä¢ Fin.partialProd x => 1 * 1) = (Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1) =\n      (((Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1 * 1) = (Action.Hom.hom f) fun‚ÇÄ | Fin.partialProd x => 1) :=\n  by sorry",
    "doc_string": "Given a `k`-linear `G`-representation `A`, `diagonalHomEquiv` is a `k`-linear isomorphism of\nthe set of representation morphisms `Hom(k[G‚Åø‚Å∫¬π], A)` with `Fun(G‚Åø, A)`. This lemma says that this\nsends a morphism of representations `f : k[G‚Åø‚Å∫¬π] ‚ü∂ A` to the function\n`(g‚ÇÅ, ..., g‚Çô) ‚Ü¶ f(1, g‚ÇÅ, g‚ÇÅg‚ÇÇ, ..., g‚ÇÅg‚ÇÇ...g‚Çô).` ",
    "generated": [
      "theorem aux.7463376481690910487 {k : Type u} {G : Type u} [CommRing k] {n : ‚Ñï} [Group G] {A : Rep k G}\n    (f : Rep.ofMulAction k G ((a : Fin (n + 1)) ‚Üí G) ‚ü∂ A) (x : (a : Fin n) ‚Üí G) :\n    Fin.partialProd! x 1 = Fin.snoc (Fin.partialProd x fun _p => 1) (Fin.castSucc Fin.last) := by sorry ",
      "theorem linearMaps_prod_mk_finite : List.cocombiningList LinearMaps Nat Nat) := by sorry ",
      "theorem IsEmpty.elim : ‚àÄ {Œ± : Sort u} {p : Prop}, (IsEmpty Œ± ‚Üí p) ‚Üí ‚àÄ (x : Œ±), p := by sorry ",
      "theorem zero_lt_reindexPMul :\n    ‚àÄ {Œ± : Type u_5} {Œ≤ F : Type u_6}, 1 -‚ü™b, FinVec.map b fun_‚ÇÄ 0 => 1‚ü´_‚Çú F / Function.min! ‚ä∫|F‚Ü™ ‚Ñö : b ‚äï F ‚â§ 1 :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry \n  mentionedReferences = [] }\n``` [/INST] theorem Eq.mpr_left : ‚àÄ {x y z : Œ±}, Eq x y ‚Üí y = x ‚Üí x = z ‚Üí y = z := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem CategoryTheory.Limits.HasLift.cokernelCoimage :\n    ‚àÄ {K : Category} (J : Category.Grothentayn K) [inst JP : J.Faithful] [category_inst0 : Category K] (x : K),\n      HasBiproduct K (CategoryTheory.Shift K (‚Ñ§ ‚Ä¢ x)) := by sorry ",
      "theorem aux.3573635773178995922 {k : Type u} {G : Type u} [inst : CommRing k] {n : ‚Ñï} [group G]\n    (f : Rep.ofMulAction k G ((a : Fin (n + 1)) ‚Üí G) ‚ü∂ A) (x : (a : Fin n) ‚Üí G) :\n    1 ‚Ä¢ ‚àë r‚ÇÄ : (‚Üë(PartialEquiv.symm (Equiv.toPartialEquiv Fin.filterProd)))À£,\n        { w := ((Sum.inr r)), h := ((of_eq_true (congrArg\n          (fun x ‚Ü¶ ((Eq.ndrec G'.left def).casesBot f ‚®Å\n                Subsingleton.prop)) x))) } ^\n          ‚Üë(Fin.finrotate x) =\n      ‚Üë(GeneralizedEigenspace.coeFnBasisAux f) { w := ((Sum.inr r)), h := ((f)) }) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (w‚ÇÅ : NNReal) (w‚ÇÇ : NNReal) (p‚ÇÅ : NNReal) (p‚ÇÇ : NNReal) (a : w‚ÇÅ + w‚ÇÇ = 1), p‚ÇÅ ^ ‚Üëw‚ÇÅ * p‚ÇÇ ^ ‚Üëw‚ÇÇ ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ)",
    "theorem": "theorem NNReal.geom_mean_le_arith_mean2_weighted :\n    (‚àÄ (w‚ÇÅ : NNReal) (w‚ÇÇ : NNReal) (p‚ÇÅ : NNReal) (p‚ÇÇ : NNReal) (a : w‚ÇÅ + w‚ÇÇ = 1),\n      p‚ÇÅ ^ ‚Üëw‚ÇÅ * p‚ÇÇ ^ ‚Üëw‚ÇÇ ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ) :=\n  by sorry",
    "name": "NNReal.geom_mean_le_arith_mean2_weighted",
    "lemma-type": "‚àÄ {Œ≤ : Type u_2} [inst : AddCommMonoid Œ≤] {n : ‚Ñï} (f : Fin (n + 1) ‚Üí Œ≤),\n  (Finset.sum Finset.univ fun i => f i) = f 0 + Finset.sum Finset.univ fun i => f (Fin.succ i)",
    "lemma": "theorem Fin.sum_univ_succ :\n    ‚àÄ {Œ≤ : Type u_2} [inst : AddCommMonoid Œ≤] {n : ‚Ñï} (f : Fin (n + 1) ‚Üí Œ≤),\n      (Finset.sum Finset.univ fun i => f i) = f 0 + Finset.sum Finset.univ fun i => f (Fin.succ i) :=\n  by sorry",
    "doc_string": "The geometric mean is less than or equal to the arithmetic mean, weighted version\nfor two `NNReal` numbers. ",
    "generated": [
      "theorem aux.2094608747990179411 (w‚ÇÅ : NNReal) (w‚ÇÇ : NNReal) (p‚ÇÅ : NNReal) (p‚ÇÇ : NNReal) (h : w‚ÇÅ + w‚ÇÇ = 1) :\n    -EuclideanGeometry.Sphere.center_pos := by sorry ",
      "theorem aux.3723322067487967396 (w‚ÇÅ : NNReal) (w‚ÇÇ : NNReal) (p‚ÇÅ : NNReal) (p‚ÇÇ : NNReal) (a : w‚ÇÅ + w‚ÇÇ = 1) : Nat.rawCast 1 * 0 = 0 := by sorry ",
      "theorem aux.17205803177677920197 (w‚ÇÅ : NNReal) (w‚ÇÇ : NNReal) (p‚ÇÅ : NNReal) (p‚ÇÇ : NNReal) (a : w‚ÇÅ + w‚ÇÇ = 1) :\n    w‚ÇÅ % Fintype.card = w‚ÇÅ := by sorry ",
      "theorem Matrix.coe'_add :\n    ‚àÄ {m : Type M} {n : Type Œî} (x y : { i // x, j < y}.Pi m Œ±), (‚áëadd ‚Üë‚Üër x +‚áëadd ‚Üë‚àö1 j).toFun y = ‚áëw n * x y :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a¬≤. a‚ÇÇ a‚ÇÇ' : Œ±}, a‚ÇÅ = a‚ÇÇ ‚Üí (a‚ÇÇ' = a‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ') := by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem mul_comm : ‚àÄ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ",
      "theorem NNReal.le_sqrt : ‚àÄ {x : NNReal}, 0 < x ‚Üí x ‚â§ Real.sqrt f := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] {x : V} {y : V} (h : ‚ü™x, y‚ü´_‚Ñù = 0),\n  InnerProductGeometry.angle x (x + y) = Real.arccos (‚Äñx‚Äñ / ‚Äñx + y‚Äñ))",
    "theorem": "theorem InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero :\n    (‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] {x : V} {y : V} (h : ‚ü™x, y‚ü´_‚Ñù = 0),\n      InnerProductGeometry.angle x (x + y) = Real.arccos (‚Äñx‚Äñ / ‚Äñx + y‚Äñ)) :=\n  by sorry",
    "name": "InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero",
    "lemma-type": "{V : Type u_1} ‚Üí\n  [NormedAddCommGroup V] ‚Üí\n    [InnerProductSpace ‚Ñù V] ‚Üí\n      {x : V} ‚Üí\n        {y : V} ‚Üí\n          (h : ‚ü™x, y‚ü´_‚Ñù = 0) ‚Üí InnerProductGeometry.angle x (x + y) = Real.arccos (‚ü™x, x + y‚ü´_‚Ñù / (‚Äñx‚Äñ * ‚Äñx + y‚Äñ))",
    "lemma": "theorem aux.18251456148979876095 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] {x : V} {y : V}\n    (h : ‚ü™x, y‚ü´_‚Ñù = 0) : InnerProductGeometry.angle x (x + y) = Real.arccos (‚ü™x, x + y‚ü´_‚Ñù / (‚Äñx‚Äñ * ‚Äñx + y‚Äñ)) := by sorry",
    "doc_string": "An angle in a right-angled triangle expressed using `arccos`. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem aux.4024236747750064455 {V : Type u_1} [NormedAddComm Group V] [InnerProductSpace ‚Ñù V] {x : V} {y : V}\n    (h : ‚ü™x, y‚ü´_‚Ñù = 0) : EReal.uncoe = Nat.rawCast 1 := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem zero_eq : ‚àÄ {M : Type u_2} [inst : zeroMul M] (a : M), 0 = a ‚Üî a = 0 := by sorry ",
      "reply_msg =\n25453840 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] {x : V} {y : V} (h : ‚ü™x, y‚ü´_‚Ñù = 0) :\n    ‚ÜëReal.pi < InnerProductGeometry.angle x (x + y) := from_script : ‚àÄ {V : Type u_1} [inner : InnerProductSpace ‚Ñù V]\n      {x : V} {y : V}, ‚ü™x, y‚ü´_‚Ñù = 0 ‚Üí ‚Äñx‚Äñ * InnerProductGeometry.angle x (x + y) = 0 := by sorry ",
      "theorem NormedAddCommGroup.core.eq_zero_left'_iff :\n    ‚áëNormedAddCommGroup.toAsymm =* 0 ‚Üî ‚àÄ (x : NormedAddCommGroup E), IsUnit (‚Äñx‚Äñ) [l] ‚à® ‚Äñx‚Äñ = 0 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)) (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i),\n  ‚àÉ t,\n    (t 0 = 0) ‚àß\n      ((Monotone t) ‚àß ((‚àÉ n, ‚àÄ (m : ‚Ñï) (a : m ‚â• n), t m = 1) ‚àß (‚àÄ (n : ‚Ñï), ‚àÉ i, Set.Icc (t n) (t (n + 1)) ‚äÜ c i))))",
    "theorem": "theorem exists_monotone_Icc_subset_open_cover_unitInterval :\n    (‚àÄ {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)) (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i),\n      ‚àÉ t,\n        (t 0 = 0) ‚àß\n          ((Monotone t) ‚àß\n            ((‚àÉ n, ‚àÄ (m : ‚Ñï) (a : m ‚â• n), t m = 1) ‚àß (‚àÄ (n : ‚Ñï), ‚àÉ i, Set.Icc (t n) (t (n + 1)) ‚äÜ c i)))) :=\n  by sorry",
    "name": "exists_monotone_Icc_subset_open_cover_unitInterval",
    "lemma-type": "{Œπ : Sort u_1} ‚Üí\n  {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} ‚Üí\n    (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)) ‚Üí\n      (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i) ‚Üí (t : (a : ‚Ñï) ‚Üí ‚ÜëunitInterval) ‚Üí (t 0 = 0) = (‚Üë(t 0) = ‚Üë0)",
    "lemma": "theorem aux.659549004083730942 {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i))\n    (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i) (t : (a : ‚Ñï) ‚Üí ‚ÜëunitInterval) : (t 0 = 0) = (‚Üë(t 0) = ‚Üë0) := by sorry",
    "doc_string": "Any open cover of the unit interval can be refined to a finite partition into subintervals. ",
    "generated": [
      "theorem LT.lfa_tfae :\n    ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : ‚Ñï ‚Üí (a : Œ±) ‚Üí Prop},\n      (‚àÄ (n : ‚Ñï), lfa f n) ‚à£ f ((i : Œπ) ‚Üí 0) ‚àß\n        (Function.mul‚ÇÄ f ‚à£ Equiv.equivShrink _ i + Equiv.equivExtend (Equiv.mvPolish Œπ Œ±) H)) :=\n  by sorry\n``` [/INST] theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x ‚Üí Prop},\n    (‚àÄ (x : Œ±), f x = g x) ‚Üí (‚àÄ (x : Œ±), f x true) = g x true :=\n  by sorry ",
      "theorem aux.9508239492777676633 {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i))\n    (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i) :\n    let e :\n\n/-- The existence of such a map follows from\n`exists_partition_subset_open_balls_of_finite_cover_balls` and the fact that any collection of closed\ncovering sets whose intersection is nonempty generates a bigger open subset as a barrier for the\nintersection. -/\ntheorem exists_monotone_Icc_normal_subset_open_cover_unitInterval :\n    (‚àÄ {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)) (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i),\n      ‚àÉ t,\n        (t 0 = 0) ‚àß\n          ((Monotone t) ‚àß\n            ((Set.univ ‚äÜ Set.range t) ‚àß (‚àÉ i, ‚àÄ k ‚â§ i, f i ‚àà interior (t (Set.pi_unfold t k)) ‚à® true)) ‚àß\n              (‚àÉ b, (b ‚àà Set.image f s) ‚àß (t (Set.pi_unfold t k) ‚äÜ Metric.ball b ((g n) b))))) :=\n  by sorry\n``` [/INST] theorem Classical.choose_spec : ‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (h : ‚àÉ a, p a), p (Classical.choose h) := by sorry ",
      "theorem SetFamily.disjoint_iff :\n    ‚àÄ {Œ± : Type u} {v : Œ± ‚Üí Set ‚ÜëupperUnit [u]} {i √ó i‚ÇÅ ‚Üí Disjoint (v i) (v i‚ÇÅ)}, PairwiseDisjoint v := by sorry ",
      "theorem aux.13714021861044450588 {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set ‚ÜëunitInterval} (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i))\n    (hc‚ÇÇ : Set.univ ‚äÜ ‚ãÉ i, c i) : ‚àÉ r, IsGŒ¥ r ‚àß Bool.brrbit r = Set.univ := by sorry ",
      "theorem exists_isOpen_chain_pred_funct :\n    ‚àÄ (Œπ : Sort u_1) (P : PUnit ‚Üí Prop), (‚àÄ ‚¶Él : List P‚¶Ñ (p : AllP (List.headI p <<DOT>> P fun v => p <| Units.op (PUnit.out v)),\n            ‚àÉ j‚ÇÄ c, l = (List.ofFn ‚Üë(Function.uncurry EqvGen.fst c |> Units.map f j‚ÇÄ));\n            ‚àÉ s c Œ¥ i e v hv _ œÉ m, e ‚àà f.{m} œÉ (c = > Units.ofVal ‚Ñ§ (j‚ÇÄ : ‚Ñ§) delta0) = d,\n            EqPVal ‚Üë(v n) p ‚Üë(Function.cases ‚Üëd <| (Eq.refl (f.1 d) i‚ÇÄ |>.trans (Nat._add_eq d0 |>.trans (eq_self 0)))) <|\n            i_1 e' = true :=\n  by sorry ",
      "theorem symm) :=\n  by sorry ",
      "theorem aux.3565797410249325475 {Œπ : Sort u_1} {t : (a : Œπ) ‚Üí MetricSpace} (htms : ‚àÄ (i : Œ∑), MetricSpace.toBasisIndex ‚äÜ ‚Üëi := by\n  sorry  }) := by sorry ",
      "theorem And.right : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u_1} {M : Type u_9} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p : Submodule R M), Submodule.map (Submodule.subtype p) ‚ä§ = p)",
    "theorem": "theorem Submodule.map_subtype_top :\n    (‚àÄ {R : Type u_1} {M : Type u_9} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n      (p : Submodule R M), Submodule.map (Submodule.subtype p) ‚ä§ = p) :=\n  by sorry",
    "name": "Submodule.map_subtype_top",
    "lemma-type": "{R : Type u_1} ‚Üí\n  {M : Type u_9} ‚Üí\n    [Semiring R] ‚Üí\n      [AddCommMonoid M] ‚Üí\n        [Module R M] ‚Üí\n          (p : Submodule R M) ‚Üí Submodule.map (Submodule.subtype p) ‚ä§ = LinearMap.range (Submodule.subtype p)",
    "lemma": "theorem aux.1754794400066525236 {R : Type u_1} {M : Type u_9} [Semiring R] [AddCommMonoid M] [Module R M]\n    (p : Submodule R M) : Submodule.map (Submodule.subtype p) ‚ä§ = LinearMap.range (Submodule.subtype p) := by sorry",
    "doc_string": "Under the canonical linear map from a submodule `p` to the ambient space `M`, the image of the\nmaximal submodule of `p` is just `p`. ",
    "generated": [
      "theorem Submonoid.coe_top : ‚àÄ {M : Type u_1} [inst : Monoid M], Subsemigroup.carrier ‚ä§ = ‚ä§ := by sorry ",
      "theorem aux.8532876978298160517 {R : Type u_1} {M : Type u_9} [Semiring R] [AddCommMonoid M] [Module R M]\n    (p : Submodule R M) (w : M) (h : p.mem (Submodule.map (Submodule.subtype p) ‚ä§)) (x : R)\n    (x_1 : ‚ÅÖx, w‚ÅÜ ‚àà p) : x ‚à© Algebra.algebraMap R (Submodule R M) w = w := by sorry ",
      "theorem eq_of_heq : ‚àÄ {Œ± : Sort u} {a a' : Œ±}, HEq a a' ‚Üí a = a' := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem MapDomain_eq_iff : map DomainName e F ‚Ü¥ e = Map.MapDomain e F.toLex := by sorry ",
      "theorem Submodule.to_Subsemilgebra_le_top_submodule'' :\n    ‚àÄ {R : Type u} {S‚ÇÇ : Type v} [inst : Ring R] {R‚ÇÇ : Type z} [inst_1 : IsDomain R‚ÇÇ] [inst_2 : Field R‚ÇÇ]\n      [inst_3 : MvPolynomial R R‚ÇÇ] [inst_4 : PowerBasis R R‚ÇÇ] (c : R) (b : rootSet R polySubmodule c), c ‚àà b :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem map_top_submodule_of_injective := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n  [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n  (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atBot)",
    "theorem": "theorem Filter.Tendsto.atBot_add :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n      [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n      (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n      Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atBot) :=\n  by sorry",
    "name": "Filter.Tendsto.atBot_add",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [TopologicalSpace Œ±] ‚Üí\n      [LinearOrderedAddCommGroup Œ±] ‚Üí\n        [OrderTopology Œ±] ‚Üí\n          {l : Filter Œ≤} ‚Üí\n            {f : (a : Œ≤) ‚Üí Œ±} ‚Üí\n              {g : (a : Œ≤) ‚Üí Œ±} ‚Üí\n                {C : Œ±} ‚Üí\n                  (hf : Filter.Tendsto f l Filter.atBot) ‚Üí\n                    (hg : Filter.Tendsto g l (nhds C)) ‚Üí Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ g x + f x) l Filter.atBot",
    "lemma": "theorem aux.7652231967440647468 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    [OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ g x + f x) l Filter.atBot := by sorry",
    "doc_string": "In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. ",
    "generated": [
      "theorem IsContinuousOn.add  :\n    ‚àÄ {Œ≤ : Type u_1} {x y : Œ≤} {S : Set Œ≤} {l : Filter Œ≤} [AddZeroClass Œ≤] [AddCommGroup Œ≤] {MovableOn Œ≤ Œ≤ S L Œ±}\n      [T2Space Œ≤] [ContinuousAdd Œ≤] [ContinuousStat Œ≤ S L Œ±] Hx: IsContinuousOn f Ici x ‚Üí\n      Hy : IsContinuousOn g Ici y ‚Üí H : (fun x => (f x + g x)·∂ú) ‚àà Filter.maps Id x t :=\n      by sorry ",
      "theorem tendsto_add :\n    ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {la : Filter Œ±} {lb : Filter Œ≤} [inst : Add Œ±] [inst_1 : ContinuousAdd Œ±]\n      {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} {Œµ : Œ≤ ‚Üí Œ¥} {œÜ : Filter (Œ± √ó Œ¥)},\n      Filter.Tendsto f la œÜ ‚Üí Filter.IsCoboundedUnder (Prod.mk ‚ñ° f) œÜ ‚Üí Filter.Tendsto g lb (Prod.map Œµ œÜ) ‚Üí\n        Filter.Tendsto eb' (Prod.map eb œÜ) (Prod.map Œµ œÜ) ‚Üí\n          (‚àÄ y\n            ‚¶Ée : Œ¥ ‚Üí Œ±‚¶Ñ (a : e ~ f a), {x)\n                | y = (eb' * e) x ‚à® (y ‚â† (eb' * f a) a)},\n            x => x ‚àà œÜ),\n      Filter.IsCobounded Under œÜ la g '' lb ‚Üí Filter.Tendsto deb la Œµ lb :=\n  by sorry ",
      "theorem Prod.mk.comm :\n    ‚àÄ {œÉ : œÉ} {Œì‚ÇÅ‚ÇÇ : œÉ} (x‚ÇÅ : Œì‚ÇÅ‚ÇÇ) (x‚ÇÇ : œÉ), x‚ÇÅ, x‚ÇÇ ‚àà œÉ ‚Üí (((x‚ÇÅ, x‚ÇÇ), x‚ÇÇ, x‚ÇÅ) ‚àà œÉ).2 := by sorry ",
      "theorem aux.2197390146864891363 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    [OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (x : Œ≤) : False := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem aux.18222446928780463810 {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]\n    [OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) :\n    Filter.hasBasis (Filter.comap (AddGroupSeminorm.neg zero_le')) (fun (x : Œ±) ‚Ü¶ x ‚â† 0) ‚Üî And (Filter.NeBot (l x), ‚àÄ A, A ‚â§ x) :=\n  by sorry ",
      "theorem lt_neg_self : ‚àÄ {Œ± : Type u} [inst : CanonicallyOrderedAddGroup Œ±] (a : Œ±), a < -a := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {A‚ÇÅ : C} {A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B)\n  [inst_1 : CategoryTheory.Mono f] [inst_2 : CategoryTheory.Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n  (w : CategoryTheory.CategoryStruct.comp i.hom g = f), CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g)",
    "theorem": "theorem CategoryTheory.Subobject.mk_eq_mk_of_comm :\n    (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {A‚ÇÅ : C} {A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B)\n      [inst_1 : CategoryTheory.Mono f] [inst_2 : CategoryTheory.Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n      (w : CategoryTheory.CategoryStruct.comp i.hom g = f),\n      CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g) :=\n  by sorry",
    "name": "CategoryTheory.Subobject.mk_eq_mk_of_comm",
    "lemma-type": "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B A : C} {X : CategoryTheory.Subobject B} (f : A ‚ü∂ B)\n  [inst_1 : CategoryTheory.Mono f] (i : CategoryTheory.Subobject.underlying.toPrefunctor.obj X ‚âÖ A),\n  CategoryTheory.CategoryStruct.comp i.hom f = CategoryTheory.Subobject.arrow X ‚Üí X = CategoryTheory.Subobject.mk f",
    "lemma": "theorem CategoryTheory.Subobject.eq_mk_of_comm :\n    ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B A : C} {X : CategoryTheory.Subobject B} (f : A ‚ü∂ B)\n      [inst_1 : CategoryTheory.Mono f] (i : CategoryTheory.Subobject.underlying.toPrefunctor.obj X ‚âÖ A),\n      CategoryTheory.CategoryStruct.comp i.hom f = CategoryTheory.Subobject.arrow X ‚Üí\n        X = CategoryTheory.Subobject.mk f :=\n  by sorry",
    "doc_string": "To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ",
    "generated": [
      "theorem map_zero :\n    ‚àÄ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]\n      [inst_3 : ZeroHomClass F M N] (f : F), f 0 = 0 :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem aux.2595387179690256009 {C : Type u‚ÇÅ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {A‚ÇÅ : C} {A‚ÇÇ : C}\n    (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n    (w : CategoryTheory.CategoryStruct.comp i.hom g = f) : CategoryTheory.Subobject.underlying i = g := by sorry ",
      "theorem aux.8222846527221942596 {C : Type u‚ÇÅ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {A‚ÇÅ : C} {A‚ÇÇ : C}\n    (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n    (w : CategoryTheory.CategoryStruct.comp i.hom g = f) : ‚Üë(CategoryTheory.CategoryStruct.comp i.inv g) = g := by\n  sorry ",
      "theorem aux.14556917733561896193 {C : Type u‚ÇÅ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {A‚ÇÅ : C} {A‚ÇÇ : C}\n    (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n    (w : CategoryTheory.CategoryStruct.comp i.hom g = f) :\n    ((CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.inv i).hom =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f i.hom)) ‚àß\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.inv i).hom\n          (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.inv i).hom) =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject. arrow i.hom))) ‚àß\n        ((CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.hom f f).op\n          (f (CategoryTheory.morphismOfMondromoduloPreservesFundamentals hom h‚ÇÇ)) =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Monomorphism.ePIsco f).op\n            (Iso.toEquiv (CategoryTheory.morphismOfMondromoduloPreservesFundamentals m‚ÇÇ))) ‚àß\n          (f (CategoryTheory.CategoryStruct.comp i.hom\n              (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorUnitBraiding J J)\n                i.hom).op) =\n            CategoryTheory.CategoryStruct.comp\n              (CategoryTheory.MonoidalCategory.tensorMul\n                (CategoryTheory.Iso.inv (CategoryTheory.morphismOfMondromoduloPreservesFundamentals m‚ÇÇ)))\n              (CategoryTheory.LiftableObjData.eq obj a‚ÇÅ)))) =\n      True :=\n  by sorry ",
      "theorem congrFun : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {x y : Œ±}, (‚àÄ (a : Œ±), x a = y a) ‚Üí x = y := by sorry ",
      "theorem CategoryTheory.EquivaDualD.apply_adjunction :\n    ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÅ} C]\n      {self : (self : ùî∏·µí·µñ) ‚Üí Culpertone ((self ‚âå CulpertoneStone.œÄCup) (self (Equiv.toContraOp (CategoryTheory.Coyoneda.adjunction\n        (starIsoForCategory PursuitSequence.eqToIso)))\n          ‚â™‚âÖ\n        self ‚Ü™coe ùî∏ (self (‚áëCon.inv D, Equiv.toContradictableEquivalence\n          inEqToIso PursuitSequence.conIsOfColorEq ùî∏ (Equiv.toPursStone R S)))))))\n        this ‚ù≤ ‚ä§ √ó·Ω® (0 ‚Üëd) ‚ä§ ‚ä° Self‚Ñô, cfuns ((fun T => Subcategory (Self ùî∏) T) _[[Subcategory ùî∏ (Self d d)]]) T) =\n        cTropStmtsSelf X :=\n  by sorry ",
      "theorem CategoryTheory.Limits.image_mk_self_eq_lift_id :\n    ‚àÄ {R : CategoryTheory.RailwayMap Œ± Œ≤ Œ≥} {a : Œ±},\n      CategoryTheory.Limits.image ‚Ñ≠ fun f => CategoryTheory.RailwayMapT.Mk f a =\n        f (CategoryTheory.CategoryStruct.id ((eqAsIso a).hom)) :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n  [inst_2 : NormedAddCommGroup E] {Œº : MeasureTheory.Measure X} [inst_3 : NormedSpace ‚Ñù E]\n  [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) ‚Üí ‚Ñù} (hf : MeasureTheory.LocallyIntegrable f)\n  {g : (a : X) ‚Üí E} (hg : Continuous g) (h'g : HasCompactSupport g), MeasureTheory.Integrable fun (x : X) ‚Ü¶ f x ‚Ä¢ g x)",
    "theorem": "theorem MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport :\n    (‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n      [inst_2 : NormedAddCommGroup E] {Œº : MeasureTheory.Measure X} [inst_3 : NormedSpace ‚Ñù E]\n      [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) ‚Üí ‚Ñù} (hf : MeasureTheory.LocallyIntegrable f)\n      {g : (a : X) ‚Üí E} (hg : Continuous g) (h'g : HasCompactSupport g),\n      MeasureTheory.Integrable fun (x : X) ‚Ü¶ f x ‚Ä¢ g x) :=\n  by sorry",
    "name": "MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport",
    "lemma-type": "{X : Type u_1} ‚Üí\n  {E : Type u_3} ‚Üí\n    [MeasurableSpace X] ‚Üí\n      [TopologicalSpace X] ‚Üí\n        [NormedAddCommGroup E] ‚Üí\n          {Œº : MeasureTheory.Measure X} ‚Üí\n            [NormedSpace ‚Ñù E] ‚Üí\n              [OpensMeasurableSpace X] ‚Üí\n                [T2Space X] ‚Üí\n                  {f : (a : X) ‚Üí ‚Ñù} ‚Üí\n                    (hf : MeasureTheory.LocallyIntegrable f) ‚Üí\n                      {g : (a : X) ‚Üí E} ‚Üí\n                        (hg : Continuous g) ‚Üí\n                          (h'g : HasCompactSupport g) ‚Üí\n                            let K : Set X := tsupport g;\n                            (MeasureTheory.Integrable fun (x : X) ‚Ü¶ f x ‚Ä¢ g x) =\n                              (MeasureTheory.Integrable (Set.indicator K fun (x : X) ‚Ü¶ f x ‚Ä¢ g x))",
    "lemma": "theorem aux.1421161873440033243 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {Œº : MeasureTheory.Measure X} [NormedSpace ‚Ñù E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) ‚Üí ‚Ñù} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) ‚Üí E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    let K : Set X := tsupport g;\n    (MeasureTheory.Integrable fun (x : X) ‚Ü¶ f x ‚Ä¢ g x) =\n      (MeasureTheory.Integrable (Set.indicator K fun (x : X) ‚Ü¶ f x ‚Ä¢ g x)) :=\n  by sorry",
    "doc_string": "If `f` is locally integrable and `g` is continuous with compact support,\nthen `f ‚Ä¢ g` is integrable. ",
    "generated": [
      "theorem aux.18344686097906465558 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {Œº : MeasureTheory.Measure X} [NormedSpace ‚Ñù E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) ‚Üí ‚Ñù} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) ‚Üí E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    ContinuousLinearMap.ofBound 2 (continuous_isAddRightFirstParam [NormedSpace ‚Ñù E] *\n        hg.norm * MeasureTheory.mk measure_isCompact_smul h'g) =\n      ContinuousLinearMap.bind (ContinuousLinearMap.smulRight (‚Ñù ¬∑ g)),\n        ContinuousLinearMap.ofBound (‚Äñ(‚Ñù ¬∑ g)‚Äñ * Function.hasCompactSupport.secondObject) h'g :=\n  by sorry ",
      "theorem HasCompactSupport.image :\n    ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : TopologicalSpace Œ≤] [inst_1 : SeminormedAddCommGroup Œ≤]\n      (f : Œ± ‚Üí funs : filter Œ± instREAl) [inst_2 : CondensedSpace X],\n      CondensedSpace Œ± fun Xs fst => ((fun Zs => {i : Œ± | SubsemiNormedAddCommGroup.subset' (inst funx : X =Xinst hx ‚Ü¶ Zs) (p ‚â§ ‚ä§, f‚ÇÄ Xs _) ‚àà X} ‚Üî HFuns.compFun f ‚Üëf (fun a_1 => Xs ¬∑ fun x ‚Ü¶ x ‚äî f‚ÇÄ X fun (_ : f‚ÇÄ ‚â§ (fun i ‚â° (X == Xinst hx) ‚Ñï f‚ÇÅst then x _ else p 0 := Subset.antisymm ‚ü®X _ h‚ÇÇ ‚â°, h := And.left h_2‚ü©) e) ‚Ü¶ t e)) :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem MeasureTheory.integrable_iff_summable_norm'_of_hasFiniteIntegral :\n    ‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F]\n      (Œº : MeasureTheory.Measure Œ±) [inst_2 : MeasureTheory.IsFiniteMeasure Œº] {f : Œπ ‚Üí F},\n      Function.IsPeak f {k | BddBelow (Function.restrict f k))} ‚àß\n        {o | IsOpen o ‚àß f =·∂†[MeasureTheory.Measure.ae Œº ‚à£ ‚Üëo] Function.const Œ± (BoundedIsReadable f) ‚Üí (f ‚Åª¬π' {x = x}) |·∂†^·µ¶ ‚Üëo) ‚Üí\n        MeasureTheory.Integrable f ‚Üí (Filter.unif = Filter.atTop ‚àß Continuous f ‚Üí MeasureTheory.Summable (‚à´‚Åª (a : Œ±), ‚Äñf a‚Äñ d Œº) ‚àß ‚à´‚Åª (i : Œ±), ‚Äñf i =·∂†[Œº] f n i :=\n  by sorry ",
      "theorem MeasureTheory.integrable_mul_left_iff_cont_top :\n    ‚àÄ {M : Type u_2} {Œ± : Type u_3} [inst : MeasurableSpace M] [inst_1 : Countable M]\n      [inst_2 : MonotoneSupClosed M] [inst_3 : TopologicalSpace M] [inst_4 : BorelSpace $ topologicalSpace M]\n      (I : BoxIntegral.Box ‚Ñù¬ªi) (Œº : BoxIntegral.Measure ‚Ñù¬ª I) [inst_5 : MeasureTheory.Measure.IsOpenPosMeasure Œº],\n      (‚àÄ (i : M), Measurable (fun J => ‚ÜëJ ‚Ñì ‚Ä¢ ‚ÜëJ.compl + Set.pi (‚Üë‚ÜëJ) Set.univ) { i }) ‚Üî\n        BoxIntegral.NormedAddGroup.completeFun i Œº :=\n  by sorry ",
      "theorem MeasureTheory.LocallyIntegrable.exists_hasCompactSupport_integral_le_converter :\n    ‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : NormedAddCommGroup E] {A B B' : Set X}\n      {Œº : MeasureTheory.Measure X} [inst_2 : NormedSpace ‚Ñù E] [inst_3 : OpensMeasurableSpace X]\n      [inst_4 : T2Space X],\n      A ‚äÜ B ‚à™ B' ‚Üí\n        A ‚àà MeasureTheory.Measure.inv_restrictTo Œº B B' ‚Üí ‚àÄ[hm0 : MeasureTheory.Measure.IsOpenPosLinMeas Œº],\n          MeasureTheory.LocallyIntegrable f ‚Üí\n            ‚àÉ g ‚â§ C, HasCompactSupport g ‚Üí (‚áëg =·∂†[MeasureTheory.Measure.ae MeasureTheory.measure.restrict Œº (B ‚à© A ‚à™ B' ‚à© A)] f :=\n              f ‚àê Filter.comulHintMeasure.restrict Œº A) ‚Üí ‚àÄ A' < A, ‚à´ (x : X) in A'\\Cap A, f x ‚àÇŒº = 0 :=\n  by sorry ",
      "theorem Continuous.measurable :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤]\n      [inst_2 : MeasurableSpace Œ±] [inst_3 :OpensMeasurableSpace Œ±] [inst_4 : TopologicalSpace Œ≤]\n      [inst_5 : MeasurableSpace Œ≤] [inst_6 : BorelSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n      Continuous f ‚Üí Measurable f :=\n  by sorry ",
      "theorem Continuous.contDiffOn :\n    ‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] [inst_1 : HasStrasumaSections ùïú]\n      [inst_2 : Boolable SMul (algebraMap ùïú E) E] [inst_3 : DisplayedNoArg SMul NNReal]\n      (ùïú' : outParam ‚Ñù) {k : NNReal},\n      ‚àÄ (f : FormalMultilinearSeries E ùïú ùïú' E) {n : ‚Ñï} {œÑ : Type u_1} {s : Set R} {f f_1 : DFinsupp.Lift k (MultilinearMap ‚Ñï ‚ö†) E NNdiff œÄ}\n        [H : DFinsupp.Lift.boundedCompactE metric œÑ (Multiplicative k NNReal) fun uvx => ‚Äñsvgv ux.toHNNReal uvx Œ∂ ‚àà D]\n        [inst_4 : LiftN ‚Ñî (NNReal, E') ùïú] [h : NNReal (DFinsupp.compInvk f_toNN œÅ_toNN) xs] (r y's xsH y'p, bx),\n        NormedSpace.lipschitzOnWith NNReal K (TaylorSeriesToLinear f fN k hy hy') ‚Ä¢ ‚ÄñœÜ y's t xsH c h‚Äñ ‚â• ‚Äñf_1 t{ xsH, y' √ó yp } b‚Äñ) :=\n  Sorry\n``` [/INST] theorem aux.7389525408305970270 (ùïú : Type u_1) [HasStrasamaSections ùïú] [Boolean ùïú] : HNilBool ùïú true := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œπ : Sort u_2} [inst : Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§), x * iInf f = ‚®Ö i, x * f i)",
    "theorem": "theorem ENNReal.mul_iInf :\n    (‚àÄ {Œπ : Sort u_2} [inst : Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§),\n      x * iInf f = ‚®Ö i, x * f i) :=\n  by sorry",
    "name": "ENNReal.mul_iInf",
    "lemma-type": "{Œπ : Sort u_2} ‚Üí [Nonempty Œπ] ‚Üí {f : (a : Œπ) ‚Üí ENNReal} ‚Üí {x : ENNReal} ‚Üí (h : x ‚â† ‚ä§) ‚Üí iInf f * x = x * iInf f",
    "lemma": "theorem aux.15433009527274990120 {Œπ : Sort u_2} [Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§) :\n    iInf f * x = x * iInf f := by sorry",
    "doc_string": "If `x ‚â† ‚àû`, then left multiplication by `x` maps infimum over a nonempty type to infimum. See\nalso `ENNReal.mul_iInf_of_ne` that assumes `x ‚â† 0` but does not require `[Nonempty Œπ]`. ",
    "generated": [
      "theorem aux.17151905500430541150 {Œπ : Sort u_2} [Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§) :\n    (x * iInf f = ‚®Ö i, x * f i) ‚Üî\n      (ENNReal.toNNReal x * Fintype.univ.card ‚àë ii / 0 + 0 = ENNReal.toNNReal x * Fintype.univ.card ‚àë Œπ => x * f Œπ) :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem aux.13035049161598249697 {Œπ : Sort u_2} [Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§)\n    (a : ùí∞ f) (s : Finset Œ∑) (hs : ‚Üëùí∞.card ‚â§ s.card) : f ‚Üëùí∞ < ‚ä§ := by sorry ",
      "theorem not_ne_iff : ‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : orderBot Œ±] {a b : Œ±}, a ‚â† b ‚Üî ‚Üëb < ‚Üëa := by\n  sorry ",
      "theorem ENNReal.coe_top : ENNReal.top = ‚ä§ := by sorry ",
      "theorem iff_self : ‚àÄ (p : Prop), (p ‚Üî p) = True := by sorry ",
      "theorem aux.9835594859595515689 {Œπ : Sort u_2} [Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§) :\n    x ‚â† ‚ä• := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : OpensMeasurableSpace Œ±]\n  {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} (hs : ‚àÉ R, (R > 0) ‚àß (‚Üë‚ÜëŒº (Metric.cthickening R s) ‚â† ‚ä§)),\n  Filter.Tendsto (fun (r : ‚Ñù) ‚Ü¶ ‚Üë‚ÜëŒº (Metric.cthickening r s)) (nhds 0) (nhds (‚Üë‚ÜëŒº (closure s))))",
    "theorem": "theorem tendsto_measure_cthickening :\n    (‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : OpensMeasurableSpace Œ±]\n      {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} (hs : ‚àÉ R, (R > 0) ‚àß (‚Üë‚ÜëŒº (Metric.cthickening R s) ‚â† ‚ä§)),\n      Filter.Tendsto (fun (r : ‚Ñù) ‚Ü¶ ‚Üë‚ÜëŒº (Metric.cthickening r s)) (nhds 0) (nhds (‚Üë‚ÜëŒº (closure s)))) :=\n  by sorry",
    "name": "tendsto_measure_cthickening",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [PseudoEMetricSpace Œ±] ‚Üí\n    [MeasurableSpace Œ±] ‚Üí\n      [OpensMeasurableSpace Œ±] ‚Üí\n        {Œº : MeasureTheory.Measure Œ±} ‚Üí\n          {s : Set Œ±} ‚Üí\n            (hs : ‚àÉ R, (R > 0) ‚àß (‚Üë‚ÜëŒº (Metric.cthickening R s) ‚â† ‚ä§)) ‚Üí\n              (Œ± : Type) ‚Üí\n                (Œ≤ : Type) ‚Üí\n                  (f : (a : Œ±) ‚Üí Œ≤) ‚Üí\n                    (l‚ÇÅ : Filter Œ±) ‚Üí (l‚ÇÅ' : Filter Œ±) ‚Üí (e'_4 : l‚ÇÅ = l‚ÇÅ') ‚Üí (l‚ÇÇ : Filter Œ≤) ‚Üí HEq e'_4 e'_4",
    "lemma": "theorem aux.7281977676738299167 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]\n    {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} (hs : ‚àÉ R, (R > 0) ‚àß (‚Üë‚ÜëŒº (Metric.cthickening R s) ‚â† ‚ä§)) (Œ± : Type)\n    (Œ≤ : Type) (f : (a : Œ±) ‚Üí Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÅ' : Filter Œ±) (e'_4 : l‚ÇÅ = l‚ÇÅ') (l‚ÇÇ : Filter Œ≤) : HEq e'_4 e'_4 :=\n  by sorry",
    "doc_string": "If a set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to the measure of its closure as `r` tends to `0`. ",
    "generated": [
      "theorem funext : ‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g := by sorry ",
      "theorem aux.9765229840282534792 {Œ± : Type u_1} [PiNat.FakeNontrivIALookalike Œ±] [inst : CommRing ‚Ñù] [MetricSpace Œ±]\n    [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] [op : OpensMeasurableSpace Œ±] [ProperSpace Œ±] [MeasurableBorsetini Œµ]\n    [Nontrivial Œ±] {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ) {R : ENNReal} (hR : œâ Œ∏ o‚ÇÄ = ENNReal.oange 0 R * ENNReal.ofReal Œµ)\n    (s : Set Œ±)\n    (hs : ‚àÉ B, (B ‚àà nhdsWithin 0 s) ‚àß (‚àÄ R', ŒµR'B = oangle Œ∏ b Œµt‚ÇÄR') := by sorry ",
      "theorem aux.7624017733881063786 {Œ± : Type u_1} [PseudoEMetricSpace Œ±] [MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±}\n    {s : Set Œ±} : (Nonempty (IsClosed IsEmpty.closed s)) = (IsEmpty s) := by sorry ",
      "theorem Iff.not : ‚àÄ {a b : Prop}, [(a ‚Üî b) ‚Üî (a ‚Üî (b ‚Üî a))] = [(a ‚Üí b) ‚Üî (b ‚Üí a)] := by sorry ",
      "theorem And.left : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí a := by sorry ",
      "theorem inner_mul_left_self :\n    ‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n      (a : E), ‚áë( inner a) =L[ùïú] fun b => a * b :=\n  by sorry ",
      "theorem tendsto_measure_cthickening_cthc_zero' :\n    ‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : OpensMeasurableSpace Œ±]\n      {t : ‚Ñù} {Œº : MeasureTheory.Measure Œ±}, (0 < t) ‚Üí (t > 0) ‚Üí ‚àÄ (A : Set Œ±), t‚Åª¬π ‚Ä¢ MeasureTheory.measure.cthc A = A :=\n  by sorry ",
      "theorem nhds_neBot :\n    ‚àÄ {Œ± : Type u_2} [inst : TopologicalSpace Œ±] (x : Œ±), Filter.NeBot (nhds x) ‚Üî ‚àÖ ‚â† {x} := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (Œ± : Type u) [inst : Finite Œ±] (Œ∫ : Type v) [inst : Finite Œ∫],\n  ‚àÉ Œπ x, ‚àÄ (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí Œ∫), ‚àÉ l, Combinatorics.Line.IsMono C l)",
    "theorem": "theorem Combinatorics.Line.exists_mono_in_high_dimension :\n    (‚àÄ (Œ± : Type u) [inst : Finite Œ±] (Œ∫ : Type v) [inst : Finite Œ∫],\n      ‚àÉ Œπ x, ‚àÄ (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí Œ∫), ‚àÉ l, Combinatorics.Line.IsMono C l) :=\n  by sorry",
    "name": "Combinatorics.Line.exists_mono_in_high_dimension",
    "lemma-type": "(Œ± : Type u) ‚Üí\n  [Finite Œ±] ‚Üí\n    (Œ∫ : Type v) ‚Üí\n      [Finite Œ∫] ‚Üí\n        (Œπ : Type) ‚Üí\n          (Œπfin : Fintype Œπ) ‚Üí\n            (hŒπ : ‚àÄ (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí ULift.{u, v} Œ∫), ‚àÉ l, Combinatorics.Line.IsMono C l) ‚Üí\n              (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí Œ∫) ‚Üí\n                (l : Combinatorics.Line Œ± Œπ) ‚Üí\n                  (c : ULift.{u, v} Œ∫) ‚Üí\n                    (hc :\n                        ‚àÄ (x : Œ±),\n                          (ULift.up ‚àò C) ((fun (x : Œ±) (i : Œπ) ‚Ü¶ Option.getD (Combinatorics.Line.idxFun l i) x) x) =\n                            c) ‚Üí\n                      (x : Œ±) ‚Üí\n                        (ULift.up ‚àò C) ((fun (x : Œ±) (i : Œπ) ‚Ü¶ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c",
    "lemma": "theorem aux.7627791747048405328 (Œ± : Type u) [Finite Œ±] (Œ∫ : Type v) [Finite Œ∫] (Œπ : Type) (Œπfin : Fintype Œπ)\n    (hŒπ : ‚àÄ (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí ULift.{u, v} Œ∫), ‚àÉ l, Combinatorics.Line.IsMono C l) (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí Œ∫)\n    (l : Combinatorics.Line Œ± Œπ) (c : ULift.{u, v} Œ∫)\n    (hc : ‚àÄ (x : Œ±), (ULift.up ‚àò C) ((fun (x : Œ±) (i : Œπ) ‚Ü¶ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c)\n    (x : Œ±) : (ULift.up ‚àò C) ((fun (x : Œ±) (i : Œπ) ‚Ü¶ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c := by sorry",
    "doc_string": "The Hales-Jewett theorem: for any finite types `Œ±` and `Œ∫`, there exists a finite type `Œπ` such\nthat whenever the hypercube `Œπ ‚Üí Œ±` is `Œ∫`-colored, there is a monochromatic combinatorial line. ",
    "generated": [
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem forall_convertible_rel :\n    ‚àÄ {Œ± Œ≤ : Sort u}, ‚àÄ (rùëé : Œ± ‚Üí Œ≤ ‚Üí Prop), (‚àÄ (x r : Œ± y : Œ≤), ‚àÉ y' x, y = y' ‚àß (x = r Œ± y)).MutIdc := by\n  sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem LE.lt.lt_le : ‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí a < b ‚Üí a ‚â§ b := by sorry ",
      "theorem Finite.exists_finitemap_image_right_of_maps_mono_top_left :\n    ‚àÄ {Œ± : Type u} [inst : Finite Œ±] (Œ∫ : Type v) [instance : Finite Œ∫],\n      ‚àÉ F, ‚àÉ s ‚¶Éa‚¶Ñ (a : F a) (a : s a ‚àà F (a ‚¶Ö)), IsMono ‚¶ÉB t : Œ∫‚¶Ñ.{l + l', Fn A B t} {a b ‚¶Éa' : Œ∫}\n        {C : (a' : (a / ‚Çó a', b ‚àà B) => A a'} ‚Üí+ B a').Factors (Fn Œ± i A)(a ‚áí (a').val i ‚äî t).map C (Fn.{l.succ, x} Œ± B).val) :=\n  by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem FG.injective_of : ‚àÄ (G : Type u) [inst : Finite G], Function.Injective FG.toFintype := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1} [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù),\n  f (‚®Ü i, g i) = ‚®Ö i, f (g i))",
    "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n      [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n      [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1} [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù),\n      f (‚®Ü i, g i) = ‚®Ö i, f (g i)) :=\n  by sorry",
    "name": "Antitone.map_iSup_of_continuousAt'",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [ConditionallyCompleteLinearOrder Œ±] ‚Üí\n      [TopologicalSpace Œ±] ‚Üí\n        [OrderTopology Œ±] ‚Üí\n          [ConditionallyCompleteLinearOrder Œ≤] ‚Üí\n            [TopologicalSpace Œ≤] ‚Üí\n              [OrderClosedTopology Œ≤] ‚Üí\n                {Œπ : Sort u_1} ‚Üí\n                  [Nonempty Œπ] ‚Üí\n                    {f : (a : Œ±) ‚Üí Œ≤} ‚Üí\n                      {g : (a : Œπ) ‚Üí Œ±} ‚Üí\n                        (Cf : ContinuousAt f (iSup g)) ‚Üí\n                          (Af : Antitone f) ‚Üí\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) ‚Üí\n                              (f (sSup (Set.range g)) = ‚®Ö i, f (g i)) = (sInf (f '' Set.range g) = ‚®Ö i, f (g i))",
    "lemma": "theorem aux.17292867447989031936 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n    [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) :\n    (f (sSup (Set.range g)) = ‚®Ö i, f (g i)) = (sInf (f '' Set.range g) = ‚®Ö i, f (g i)) := by sorry",
    "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "throw away ùïú) (h : autoParam (BddAbove (Set.range g)) _auto‚úù¬≥) :=\n  by sorry ",
      "theorem aux.10147611809983170893 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±]\n    [TopologicalSpace Œ±] [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤]\n    [OrderClosedTopology Œ≤] {Œπ : Sort u_1} [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) : f (Supg (Set.range fun (x : Œπ) ‚Ü¶ g x)) =·∂†[iSup g ‚â§ BddAbove g] f (‚®Ü g fun (i : Œπ) ‚Ü¶ g i) := by sorry ",
      "theorem continuous_at_inf :\n    ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n      [inst_3 : TopologicalSpace Œ≤] [inst_4 : OrderClosedTopology Œ≤] {a : Œ±},\n      BddBelow (Set.range fun x => a - x) ‚Üí\n        ‚àÄ ‚¶Éf g : Œ≤ ‚ÜíSetState Œ± (Filter Œ≤)‚¶Ñ,\n          Continuous f ‚Üí Continuous fun x => f x.state - fun a => IsGreatest a :=\n  by sorry ",
      "theorem Antitone.map_iInf_of_continuousAt :\n    ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Nonempty Œπ] [inst_1 : ConditionallyCompleteLattice Œ±]\n      [inst_2 : TopologicalSpace Œ±] {f i : Œπ ‚Üí Œ±} (Cf : ‚àÄ (i : Œπ), ContinuousAt (f i) default) (Af : Antitone f)\n      (bdd: BddBelow (Set.range fun i => f i (LatticeSubtype.coe i))), f (iInf (P := fun i => IsGLB ( P ‚Äî> sigmaAlgebra i)) (Œª (i : Œπ) ‚Ü¶ f i sigma_sUnionIndex.id_mem_i) = iSup fun i => f ‚ü®i, sigma_sUnionIndex.i fun i => true: (P i : P) -> sigmaAlgebra i.default i) _h).left.pos ) :=\n  by sorry\n``` [/INST] theorem aux.3509325002412414832 : And (_ : TopologicalSpace ia) = True := by sorry ",
      "theorem Antitone.map_fin_top ::\n    ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Finite Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : Preorder Œ≤] {f : Œ± ‚Üí Œ≤},\n      Antitone f ‚Üí f Finset.univ = Finset.max' Finset.univ id :=\n  by sorry ",
      "theorem aux.9179649935963819893 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n    [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) : Equiv.symm orderIsoCompExtrSearch.5 = OrderIso.symm (‚áëf) :=\n  by sorry ",
      "theorem aux.10050537584999768797 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤]\n    {Œπ : Sort u_1} [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) (i : Option Œπ)\n    (ii : (i = none) ‚à® (Nonempty ‚Üëi)) :\n    f (iSup (Option.map g '' Set.univ)) = ‚®Ö j, f (g j) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën)",
    "theorem": "theorem Nat.cast_div_le : (‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën) := by\n  sorry",
    "name": "Nat.cast_div_le",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  [LinearOrderedSemifield Œ±] ‚Üí\n    {m : ‚Ñï} ‚Üí\n      {n : ‚Ñï} ‚Üí\n        (n_1 : ‚Ñï) ‚Üí (h : n = Nat.succ n_1) ‚Üí ‚Üë(m / Nat.succ n_1) * ‚Üë(Nat.succ n_1) = ‚Üë(m / Nat.succ n_1 * Nat.succ n_1)",
    "lemma": "theorem aux.1015598105618867187 {Œ± : Type u_1} [LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï} (n_1 : ‚Ñï)\n    (h : n = Nat.succ n_1) : ‚Üë(m / Nat.succ n_1) * ‚Üë(Nat.succ n_1) = ‚Üë(m / Nat.succ n_1 * Nat.succ n_1) := by sorry",
    "doc_string": "Natural division is always less than division in the field. ",
    "generated": [
      "theorem zero_le _ :\n    ‚àÄ {Œ± : Type u} [inst : CanonicallyOrderedAddCommMonoid Œ±] [inst_1 : Zero Œ±] [inst_2 : OrderedSemiring Œ±] (a : Œ±),\n      0 ‚â§ a := by sorry ",
      "theorem div_inv_div : ‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] {a b c : Œ±}, a = b * c ‚Üí (b / c = a) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "answer:\n12939593827002404507 {Œ± : Type u_1} [LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï} : m / u = u * m := by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem ZeroMemClass.nonneg_zero :\n    ‚àÄ {a : Type u_1} {n : outParam * a} [inst : ZeroMemClass n a], 0 <= nonemptypeMaxImpZero n := by sorry ",
      "theorem coe_nat_nonneg : Nat.cast_nonneg = fun x => Real.casesOn (fun (x_1 : Nat) ‚Ü¶ ‚Üëx_1) (fun (y : ‚ÑÇ) ‚Ü¶ 0) x := by\n  sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1} [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù),\n  f (‚®Ü i, g i) = ‚®Ö i, f (g i))",
    "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n      [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n      [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1} [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù),\n      f (‚®Ü i, g i) = ‚®Ö i, f (g i)) :=\n  by sorry",
    "name": "Antitone.map_iSup_of_continuousAt'",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [ConditionallyCompleteLinearOrder Œ±] ‚Üí\n      [TopologicalSpace Œ±] ‚Üí\n        [OrderTopology Œ±] ‚Üí\n          [ConditionallyCompleteLinearOrder Œ≤] ‚Üí\n            [TopologicalSpace Œ≤] ‚Üí\n              [OrderClosedTopology Œ≤] ‚Üí\n                {Œπ : Sort u_1} ‚Üí\n                  [Nonempty Œπ] ‚Üí\n                    {f : (a : Œ±) ‚Üí Œ≤} ‚Üí\n                      {g : (a : Œπ) ‚Üí Œ±} ‚Üí\n                        (Cf : ContinuousAt f (iSup g)) ‚Üí\n                          (Af : Antitone f) ‚Üí\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) ‚Üí\n                              (sInf (f '' Set.range g) = ‚®Ö i, f (g i)) = (sInf (Set.range (f ‚àò g)) = ‚®Ö i, f (g i))",
    "lemma": "theorem aux.10381276479365710705 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n    [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) :\n    (sInf (f '' Set.range g) = ‚®Ö i, f (g i)) = (sInf (Set.range (f ‚àò g)) = ‚®Ö i, f (g i)) := by sorry",
    "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ",
    "generated": [
      "theorem aux.856482978020659172 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤]\n    {Œπ : Sort u_1} [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) : iSup f ‚àà Set.univ := by sorry ",
      "theorem Set.mem_range_self : ‚àÄ {Œ± : Type u} {Œ≤ : Sort v} (f : Œ± ‚Üí Œ≤) (x : Œ±), x ‚àà Set.range f iff f x ‚àà ‚Üë(Set.range f) :=\n  by sorry ",
      "theorem aux.77433983883148143 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤]\n    {Œπ : Sort u_1} [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddBelow (Set.range g)) _auto‚úù) (i : Œπ) : ‚É´ i, g i \\·µí·µñ ‚à™Set Set.univ i = _root_.orderOf i :=\n  by sorry ",
      "theorem aux.9834335869527700204 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤]\n    {Œπ : Sort u_1} [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) : f ‚áë(Finset.sup (Fintype.piFinset g) fun x ‚Ü¶ f ‚àò g x) = ‚®Ö a ‚àà Finset.univ, f ‚àò g a := by sorry ",
      "theorem antitone_iSup_id : ‚àÄ {X : Type u} [inst : CompleteLattice X], Antitone (‚®Ü x, id) = id_le f := by sorry ",
      "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry ",
      "theorem iSup_nonempty_iff_exists :\n    ‚àÄ {Œπ : Sort u_1} {Œ± : Sort u} {s : Œπ ‚Üí Set Œ±}, (Set.Nonempty (iSup s)) ‚Üî (‚àÉ a, ‚àÉ i, a ‚àà s i) := by sorry ",
      "theorem aux.13485278062373191160 {Œ± : Type u} {Œ≤ : Type v} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±]\n    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n    [Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto‚úù) (i : Œπ) : f (Sup (f ‚àò g '' Set.range g)) = FSSup (g i) := by\n  sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï}\n  {i : Fin (n + 1)},\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Œ¥ X (Fin.succ i))\n      (CategoryTheory.CosimplicialObject.œÉ X i) =\n    CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n)))",
    "theorem": "theorem CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ :\n    (‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï}\n      {i : Fin (n + 1)},\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Œ¥ X (Fin.succ i))\n          (CategoryTheory.CosimplicialObject.œÉ X i) =\n        CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n))) :=\n  by sorry",
    "name": "CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ",
    "lemma-type": "{C : Type u} ‚Üí\n  [CategoryTheory.Category.{v, u} C] ‚Üí\n    (X : CategoryTheory.CosimplicialObject C) ‚Üí\n      {n : ‚Ñï} ‚Üí\n        {i : Fin (n + 1)} ‚Üí\n          CategoryTheory.CategoryStruct.comp\n              ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.Œ¥ (Fin.succ i)))\n              ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.œÉ i)) =\n            CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n))",
    "lemma": "theorem aux.5937014745764426132 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)} :\n    CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.Œ¥ (Fin.succ i)))\n        ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.œÉ i)) =\n      CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n)) :=\n  by sorry",
    "doc_string": "The second part of the third cosimplicial identity ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.16972580388129582656 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)} : n = ‚Üë(Fin.castSucc i) := by sorry ",
      "theorem CategoryTheory.Limits.PushoutCocone.Œπ_œÄ_assoc :\n    ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f : X ‚ü∂ Y} [inst_1 : CategoryTheory.Epi f]\n      (c : CategoryTheory.Limits.PushoutCocone f (CategoryTheory.Limits.Cocone.Œπ c))\n      (z : CategoryTheory.Limits.LimitCone c).t.pt f = c.coconePoint :=\n  by sorry ",
      "theorem eq_true : ‚àÄ {p : Prop}, p ‚Üí p = True := by sorry ",
      "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry ",
      "theorem aux.8594903064162729568 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)} (H : i = natZero)\n    (x : SimplexCategory·µí·µñ·µñ) :\n    Nonempty\n      ((CategoryTheory.Functor.toPrefunctor X).map\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id (Opposite.unop x)) i)) =\n      True :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true),\n  Function.Injective ‚áëf)",
    "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true),\n      Function.Injective ‚áëf) :=\n  by sorry",
    "name": "PEquiv.injective_of_forall_ne_isSome",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "If the domain of a `PEquiv` is `Œ±` except a point, its forward direction is injective. ",
    "generated": [
      "theorem aux.3827597862122773051 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±)\n    (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true) (a : Œ±) (a' : Œ±) (h : f a = f a') : (f a)‚Åª¬π = ‚Üë(a', f a');\n    (‚Üëa' = ‚Üë((Equiv.inv FunLike.coeFn.inv_fun a').trans f.inv)) := by sorry ",
      "theorem Option.isSome_iff_exists : ‚àÄ {Œ± : Type u_1} {a : Option Œ±}, Option.isSome a ‚Üî ‚àÉ o, o = a := by sorry ",
      "theorem PEquiv.apply_symm_left :\n    ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} (g : Œ± ‚âÉ. Œ≤) (x : Œ±), g.symm (g x) = x := by sorry ",
      "theorem Option.ne_none_iff_spec : ‚àÄ {Œ± : Sort u} {v : Œ±},v ‚â† none ‚Üî Option.map v id = some ‚Üëv := by sorry ",
      "theorem Option.some.injection : ‚àÄ {Œ± : Type u} (y : Option Œ±), Function.Injective fun n ‚Ü¶ nat.left' y ^ n‚Åª¬π a := by\n  sorry ",
      "theorem aux.8160277890524413273 {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±)\n    (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (f a‚ÇÅ) = true) (a‚ÇÅ : Œ±) : ‚àÄ (fa‚ÇÅ_is : Option.isSome' (f a‚ÇÅ)); ‚àÄ false : False := by sorry ",
      "theorem eq_false : ‚àÄ {p : Prop}, (p ‚Üí False) ‚Üí p = False := by sorry ",
      "theorem Trans.trans.trans : ‚àÄ {Œ± : Sort u} {rel : Œ± ‚Üí Œ± ‚Üí Prop} (a : Œ±) (b c : Œ±), rel a b ‚Üí rel b c ‚Üí rel a c := by\n  sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {F : Type u_4} [inst : EMetricSpace Œ±] [inst_1 : FunLike F Œ± Œ≤]\n  [inst_2 : CompleteSpace Œ±] [inst_3 : EMetricSpace Œ≤] [inst_4 : DilationClass F Œ± Œ≤] (f : F), ClosedEmbedding ‚áëf)",
    "theorem": "theorem Dilation.closedEmbedding :\n    (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {F : Type u_4} [inst : EMetricSpace Œ±] [inst_1 : FunLike F Œ± Œ≤]\n      [inst_2 : CompleteSpace Œ±] [inst_3 : EMetricSpace Œ≤] [inst_4 : DilationClass F Œ± Œ≤] (f : F),\n      ClosedEmbedding ‚áëf) :=\n  by sorry",
    "name": "Dilation.closedEmbedding",
    "lemma-type": "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {F : Type u_4} ‚Üí\n      [EMetricSpace Œ±] ‚Üí\n        [FunLike F Œ± Œ≤] ‚Üí\n          [CompleteSpace Œ±] ‚Üí\n            [EMetricSpace Œ≤] ‚Üí [DilationClass F Œ± Œ≤] ‚Üí (f : F) ‚Üí AntilipschitzWith (Dilation.ratio f)‚Åª¬π ‚áëf",
    "lemma": "theorem aux.459267457831711465 {Œ± : Type u_1} {Œ≤ : Type u_2} {F : Type u_4} [EMetricSpace Œ±] [FunLike F Œ± Œ≤]\n    [CompleteSpace Œ±] [EMetricSpace Œ≤] [DilationClass F Œ± Œ≤] (f : F) : AntilipschitzWith (Dilation.ratio f)‚Åª¬π ‚áëf := by\n  sorry",
    "doc_string": "A dilation from a complete emetric space is a closed embedding ",
    "generated": [
      "theorem Lipschitz.uncurry_map :\n    ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤]\n      [inst_2 : PseudoEMetricSpace Œ≥] (f‚ÇÇ : Œ± ‚Üí Œ≤),\n      ContinuousUncurry‚ÇÇ (Fst.fst' ‚àò f‚ÇÇ) ‚àß ContinuousUncurry‚ÇÇ (Fst.snd' ‚àò ContinuousUOEMetric f‚ÇÇ.snd) ‚Üí LipschitzUncurried (Fst.snd (f‚ÇÇ a))\n      (GPair.pFun (f‚ÇÇ a) (Fst.snd f‚ÇÇ).snd f‚ÇÇ, f‚ÇÇ) :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± Œ≤ : Sort u} {a b c : Œ±} (f : Œ± ‚Üí Œ≤), a = b ‚Üí c = a ‚Üí f a = f b := by sorry ",
      "theorem congrArgs : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem closedEmbedding_iSup_comp :\n    ‚àÄ {F : ‚Ñï} ,\n      ‚àÄ {Y : Type u‚ÇÄ} [TdF : TopologicalSpaceFun Y (UniformFun Y F)] {ùîñ : Set ((a : Y) ‚Üí ‚ÜëF)}\n        [i] :\n          ‚àÄ c.1 : Set Y ‚â† EMPTY_SET,\n            ‚àÄ (f : SetTriv Œ± (‚Üë(Y ‚≠¢ (UniformFun Y F)) c.1)) {Œπ : TrivFunD ŒµF ùîñ ‚Üí ‚Ñï} {g : C(G , uniformFun (‚ÜëF) E)},\n              Monovary.ToFilterGi i f ‚Üëg ‚â§ Filter.principal F g => (Dilation G) :=\n  by sorry ",
      "theorem Filter.isGaugeFilter_ediam :\n    ‚àÄ {X : Type u_1} [inst : EMetricSpace X], IsGaugeFilter (EMetric.cthickening ‚àû) := by sorry ",
      "theorem forall_of_exists : ‚àÄ {Œ± : Sort u_2} {p : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), ‚àÉ b, p a b) ‚Üí (‚àÄ (a : Œ±), p a) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Iff.rfl : ‚àÄ {a : Prop}, a ‚Üî a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ© : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Œ©} {‚Ñô : MeasureTheory.Measure Œ©}\n  {Œº : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F] {ŒΩ : MeasureTheory.Measure F}\n  {X : (a : Œ©) ‚Üí E} {Y : (a : Œ©) ‚Üí F} [inst_2 : MeasureTheory.IsFiniteMeasure ‚Ñô] [inst_3 : MeasureTheory.SigmaFinite Œº]\n  [inst_4 : MeasureTheory.SigmaFinite ŒΩ] [inst_5 : MeasureTheory.HasPDF (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô],\n  (ProbabilityTheory.IndepFun X Y) ‚Üî\n    (MeasureTheory.pdf (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô =·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod Œº ŒΩ)]\n      fun (z : E √ó F) ‚Ü¶ MeasureTheory.pdf X ‚Ñô (z.1) * MeasureTheory.pdf Y ‚Ñô (z.2)))",
    "theorem": "theorem MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf :\n    (‚àÄ {Œ© : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Œ©} {‚Ñô : MeasureTheory.Measure Œ©}\n      {Œº : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F] {ŒΩ : MeasureTheory.Measure F}\n      {X : (a : Œ©) ‚Üí E} {Y : (a : Œ©) ‚Üí F} [inst_2 : MeasureTheory.IsFiniteMeasure ‚Ñô]\n      [inst_3 : MeasureTheory.SigmaFinite Œº] [inst_4 : MeasureTheory.SigmaFinite ŒΩ]\n      [inst_5 : MeasureTheory.HasPDF (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô],\n      (ProbabilityTheory.IndepFun X Y) ‚Üî\n        (MeasureTheory.pdf (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô =·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod Œº ŒΩ)]\n          fun (z : E √ó F) ‚Ü¶ MeasureTheory.pdf X ‚Ñô (z.1) * MeasureTheory.pdf Y ‚Ñô (z.2))) :=\n  by sorry",
    "name": "MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf",
    "lemma-type": "{Œ© : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    [MeasurableSpace E] ‚Üí\n      {m : MeasurableSpace Œ©} ‚Üí\n        {‚Ñô : MeasureTheory.Measure Œ©} ‚Üí\n          {Œº : MeasureTheory.Measure E} ‚Üí\n            {F : Type u_3} ‚Üí\n              [MeasurableSpace F] ‚Üí\n                {ŒΩ : MeasureTheory.Measure F} ‚Üí\n                  {X : (a : Œ©) ‚Üí E} ‚Üí\n                    {Y : (a : Œ©) ‚Üí F} ‚Üí\n                      [MeasureTheory.IsFiniteMeasure ‚Ñô] ‚Üí\n                        [MeasureTheory.SigmaFinite Œº] ‚Üí\n                          [MeasureTheory.SigmaFinite ŒΩ] ‚Üí\n                            [MeasureTheory.HasPDF (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô] ‚Üí AEMeasurable fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)",
    "lemma": "theorem aux.6350557509268480231 {Œ© : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Œ©}\n    {‚Ñô : MeasureTheory.Measure Œ©} {Œº : MeasureTheory.Measure E} {F : Type u_3} [MeasurableSpace F]\n    {ŒΩ : MeasureTheory.Measure F} {X : (a : Œ©) ‚Üí E} {Y : (a : Œ©) ‚Üí F} [MeasureTheory.IsFiniteMeasure ‚Ñô]\n    [MeasureTheory.SigmaFinite Œº] [MeasureTheory.SigmaFinite ŒΩ] [MeasureTheory.HasPDF (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô] :\n    AEMeasurable fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ) := by sorry",
    "doc_string": "Random variables are independent iff their joint density is a product of marginal densities. ",
    "generated": [
      "theorem aux.759196551386242367 {Œ© : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Œ©}\n    {‚Ñô : MeasureTheory.Measure Œ©} {Œº : MeasureTheORY.Measure Œ©} [MeasureTheory.IsFiniteMeasure ‚Ñô]\n    [MeasureTheory.SigmaFinite Œº] [MeasureTheory.SigmaFinite ŒΩ] [MeasureTheory.HasPDF (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô] :\n    Filter.tendsto Id (UniformSpace.nhdsFunMap‚ÇÇ Œ© (MeasureTheory. pdf ‚Ñô) (MeasureTheory. Measure.indicator (MeasureTheory.measure Œº) univ) (X, Y))\n      (UniformSpace.tendsto_iff‚ÇÇ fun (t ; a : ‚Ñù) ‚Ü¶ True) :=\n  by sorry ",
      "theorem ProbabilityTheory.pdf.ae_eq' (X : Type u_2) (hŒ≤ : Œ≤ = id), MeasureTheory.pdf X X ‚òî ¬µ = Subfunctor.Œπ_dom Dom Œ≤ :=\n  by sorry ",
      "theorem MeasureTheory.pdf_mul_pdf_self_unique_forall :\n    ‚àÄ {Œ© : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Œ©}\n      (‚Ñô : MeasureTheory.Measure Œ©) {Œº : MeasureTheory.Measure E} {f g : Œ© ‚Üí ‚Ñù},\n      f(X == 0 ‚Üí g(X) = 0) = Œº g ‚Üî ProbabilityTheory.pdf X ‚Ñô =·∂†[Œº] X ‚â† 0 ‚Üí f =·∂†[MeasureTheory.Measure.ae (m √ó ŒΩ‚Ñô)‚ÇÇs] r :=\n  by sorry ",
      "theorem IsLebesqueMeasure.ext :\n    ‚àÄ {Œ≥ : Type u_2} [gc : MeasurableSpace Œ≥] {l‚ÇÅ : OuterMeasure Œ≤} {m‚ÇÅ : MeasureTheory.MeasurableSpace.NullMeasurableSet Œ≤}\n      {l_gc : IsG2OrderIdeal l‚ÇÅ} {l‚ÇÅ‚ÇÅ :: s‚ÇÅ‚ÇÅ ‚Üê l‚ÇÅ _ , l‚ÇÅ‚ÇÇ :: s‚ÇÅII : { val := l‚ÇÅ II }) (l‚ÇÇ : OuterMeasure Œ±)\n      {mŒ±·µí·µñ : MeasureTheory.Measure.ae Œ±} _hcsm_ : Œ≥ ‚Üí*+ MeasureTheory.Measure F ‚Üí+* Œ≤ _ l‚ÇÅ œâ ‚äö x‚ú∏‚úø r, gx l·∂ú ‚Üí ‚ä§,\n      l‚ÇÅ < ‚ä§ => gc = ‚Üë{ mŒ± := ‚ÜëŒª‚Ñ¥x Œ¥f ‚Üî l‚ÇÅ := l‚ÇÅ }, y (F _ x (l‚ÇÅœâ _ ^ fun ii => P fun œÉ => s‚ÇÅ‚ÇÅ iii ‚à© s‚ÇÅII) ) = f :=\n  by sorry ",
      "theorem implies_congr : ‚àÄ {p‚ÇÅ p‚ÇÇ : Sort u} {q‚ÇÅ q‚ÇÇ : Sort v}, p‚ÇÅ = p‚ÇÇ ‚Üí q‚ÇÅ = q‚ÇÇ ‚Üí (p‚ÇÅ ‚Üí q‚ÇÅ) = (p‚ÇÇ ‚Üí q‚ÇÇ) := by sorry ",
      "theorem MulZeroClass.mul_zero : ‚àÄ {M‚ÇÄ : Type u} [self : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0 := by sorry ",
      "function aux.4289480891926772726 {Œ© : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Œ©}\n    {‚Ñô : MeasureTheory.Measure Œ©} {Œº : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F]\n    {ŒΩ : MeasureTheory.Measure F} {X : (a : Œ©) ‚Üí E} {Y : (a : Œ©) ‚Üí F} [inst_2 : MeasureTheory.IsFiniteMeasure ‚Ñô]\n    [inst_3 : MeasureTheory.SigmaFinite Œº] [inst_4 : MeasureTheory.SigmaFinite ŒΩ]\n    [inst_5 : MeasureTheory.HasPDF (fun (œâ : Œ©) ‚Ü¶ (X œâ, Y œâ)) ‚Ñô] :\n    ‚ÜëmeasureTheoryQuintalsDistribution X (MeasureTheory.Volume.spanningSets Œº Œª (x : E) (h : True), True u i).mk\n      (Fintype.measurableLattice BorelGen E) ‚àà\n      ENNreal.ofReal\n        ‚Ñô :=\n  by sorry ",
      "theorem MatrixSetId.indepFun_mul_left ;\ninferEventuallyFn\n  (fun _n ‚Ü¶ ¬¨((Bornology.cobounded (ulift.{u‚ÇÄ} ‚Ñù) ‚äì NormedAddGroupSeminormFamilyEyesEqId.inst1) \\{i‚ÇÅi‚ÇÇ, i‚ÇÇi‚ÇÉ ‚àß !i‚ÇÉi‚ÇÑ\\}))\n  ConvExpert ‚ñ∏\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (Œ∏‚ÇÅ : Real.Angle) (Œ∏‚ÇÇ : Real.Angle)\n  (x : V), (Orientation.rotation o Œ∏‚ÇÅ) ((Orientation.rotation o Œ∏‚ÇÇ) x) = (Orientation.rotation o (Œ∏‚ÇÅ + Œ∏‚ÇÇ)) x)",
    "theorem": "theorem Orientation.rotation_rotation :\n    (‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (Œ∏‚ÇÅ : Real.Angle)\n      (Œ∏‚ÇÇ : Real.Angle) (x : V),\n      (Orientation.rotation o Œ∏‚ÇÅ) ((Orientation.rotation o Œ∏‚ÇÇ) x) = (Orientation.rotation o (Œ∏‚ÇÅ + Œ∏‚ÇÇ)) x) :=\n  by sorry",
    "name": "Orientation.rotation_rotation",
    "lemma-type": "{V : Type u_1} ‚Üí\n  [NormedAddCommGroup V] ‚Üí\n    [InnerProductSpace ‚Ñù V] ‚Üí\n      [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] ‚Üí\n        (o : Orientation ‚Ñù V (Fin 2)) ‚Üí\n          (Œ∏‚ÇÅ : Real.Angle) ‚Üí\n            (Œ∏‚ÇÇ : Real.Angle) ‚Üí\n              (x : V) ‚Üí\n                Real.Angle.cos Œ∏‚ÇÅ ^ Nat.rawCast 1 * Nat.rawCast 1 *\n                    (Real.Angle.cos Œ∏‚ÇÇ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) =\n                  Real.Angle.cos Œ∏‚ÇÇ ^ Nat.rawCast 1 * (Real.Angle.cos Œ∏‚ÇÅ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0",
    "lemma": "theorem aux.8005496794787824446 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (Œ∏‚ÇÅ : Real.Angle) (Œ∏‚ÇÇ : Real.Angle)\n    (x : V) :\n    Real.Angle.cos Œ∏‚ÇÅ ^ Nat.rawCast 1 * Nat.rawCast 1 * (Real.Angle.cos Œ∏‚ÇÇ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) =\n      Real.Angle.cos Œ∏‚ÇÇ ^ Nat.rawCast 1 * (Real.Angle.cos Œ∏‚ÇÅ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0 :=\n  by sorry",
    "doc_string": "Rotating twice is equivalent to rotating by the sum of the angles. ",
    "generated": [
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem aux.10605729225322997389 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (Œ∏‚ÇÅ : Real.Angle) (Œ∏‚ÇÇ : Real.Angle)\n    (x : V) :\n    (Orientation.rotation o (Œ∏‚ÇÅ + Œ∏‚ÇÇ)) ((Orientation.rotation o Œ∏‚ÇÅ) x) =\n      Orientation.rotation o (Œ∏‚ÇÅ + Œ∏‚ÇÇ + 0) ((Orientation.rotation o Œ∏‚ÇÅ) x) :=\n  by sorry ",
      "theorem real_rotmate_of_oangle_ne_pi :\n    ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (x y : V),\n      O.oangle o x y ‚â† ‚ÜëReal.pi ‚Üí Real.Rotation.mk Œ∏ (Real.Angle.tan (O.oangle o y x)) = Orientation.rotation o Œ∏ :=\n  by sorry ",
      "theorem neg_neg_eq : ‚àÄ {G : Type u_1} [inst : InvolutiveNeg G] (a : G), - -a = a := by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem aux.2837650316923360764 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (Œ∏‚ÇÅ : Real.Angle) (Œ∏‚ÇÇ : Real.Angle)\n    (x : V) :\n    (((InnerProductGeometry.angle ((Orientation.rotation o Œ∏‚ÇÅ) ((Orientation.rotation o Œ∏‚ÇÇ) x)) ((Orientation.rotation o Œ∏‚ÇÇ)x))\n            ((Orientation.rotation o Œ∏‚ÇÇ) x) =\n          Real.pi) ‚Üî\n        (Real.angle\n          ((InnerProductGeometry.angle ((Orientation.rotation o Œ∏‚ÇÅ) ((Orientation.rotation o Œ∏‚ÇÇ) x)) ((Orientation.rotation o Œ∏‚ÇÇ) x))\n            ((Orientation.rotation o Œ∏‚ÇÇ) x) =\n          Real.pi)) :=\n  by sorry ",
      "theorem aux.2439950025294268662 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) (Œ∏‚ÇÅ : Real.Angle) (Œ∏‚ÇÇ : Real.Angle)\n    (x : V) (Œ¥ : Real.Angle) :\n    ((((Orientation.rotation o Œ∏‚ÇÅ) fun (x : V) ‚Ü¶ hx * Real.Angle.cos Œ¥ + Real.Angle.cos Œ¥ * hx) =\n          (((Orientation.rotation o Œ∏‚ÇÅ) fun (x : V) ‚Ü¶ hx * Real.Angle.cos (+ Œ¥) + Real.Angle.cos (+ Œ¥) * hx) *\n              fun (x : V) ‚Ü¶\n            Real.Angle.cos (+Œ¥) * hx +\n              Real.Angle.cos ((Orientation.rotation o\n                    ((Orientation.rotation o (-‚Üë d√©rlong Œ∏)) Œ∏ (* -Real.Angle.tan ‚ÜëŒ∏)))\n                (-Orientation.rotation.equivStriationAt f x) (f hx))) =\n        -(Orientation.rotation o Œ∏‚ÇÇ) hx -\n          ((Orientation.rotation o Œ∏‚ÇÅ) fun (x : V) ‚Ü¶ hx * Real.Angle.cos Œ¥ + Real.Angle.cos Œ¥ * (Real.Angle.toRealAngle z 1)x) *\n            ((Orientation.rotation o (-‚ÅÖŒ∏¬≤, Œ∏‚ÇÅ‚ÅÜ)) 1 + Right.neg (Orientation.rotation o (-ùìÇ ‚Ñù (-Real.Angle.sin a).toReal + (‚ä• ‚äî ‚ä•) ‚Ä¢ f)),hx))) =\n      (False := by sorry) :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans  r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {g : (a : ‚Ñù) ‚Üí ‚Ñù} {g' : (a : ‚Ñù) ‚Üí ‚Ñù} {a : ‚Ñù} {l : ‚Ñù} (hderiv : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ici a), HasDerivAt g (g' x) x)\n  (g'neg : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioi a), g' x ‚â§ 0) (hg : Filter.Tendsto g Filter.atTop (nhds l)),\n  MeasureTheory.IntegrableOn g' (Set.Ioi a))",
    "theorem": "theorem MeasureTheory.integrableOn_Ioi_deriv_of_nonpos' :\n    (‚àÄ {g : (a : ‚Ñù) ‚Üí ‚Ñù} {g' : (a : ‚Ñù) ‚Üí ‚Ñù} {a : ‚Ñù} {l : ‚Ñù}\n      (hderiv : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ici a), HasDerivAt g (g' x) x) (g'neg : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioi a), g' x ‚â§ 0)\n      (hg : Filter.Tendsto g Filter.atTop (nhds l)), MeasureTheory.IntegrableOn g' (Set.Ioi a)) :=\n  by sorry",
    "name": "MeasureTheory.integrableOn_Ioi_deriv_of_nonpos'",
    "lemma-type": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, a ‚àà Set.Ici a",
    "lemma": "theorem Set.left_mem_Ici : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, a ‚àà Set.Ici a := by sorry",
    "doc_string": "When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +‚àû)`. Version assuming differentiability\non `[a, +‚àû)`. ",
    "generated": [
      "theorem aux.4530729130573421864 {g : (a : ‚Ñù) ‚Üí ‚Ñù} {g' : (a : ‚Ñù) ‚Üí ‚Ñù} {a : ‚Ñù} {l : ‚Ñù}\n    (hderiv : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ici a), HasDerivAt g (g' x) x) (g'neg : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioi a), g' x ‚â§ 0)\n    (hg : Filter.Tendsto g Filter.atTop (nhds l)) : g' =·∂†[Filter.onFromOn (Filter.smallSets onReal) univ ‚ä§] g' :=\n  by sorry ",
      "theorem aux.4258121865352313138 {g : (a : ‚Ñù) ‚Üí ‚Ñù} {g' : (a : ‚Ñù) ‚Üí ‚Ñù} {a : ‚Ñù} {l : ‚Ñù}\n    (hderiv : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ici a), HasDerivAt g (g' x) x) (g'neg : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioi a), g' x ‚â§ 0)\n    (hg :Filter.Tendsto g Filter.atTop (nhds l)) (x : ‚Ñù) (hx : x ‚àà Set.Ici a) (j : ‚Ñù) (hx :j ‚â• x) : j > a := by sorry ",
      "theorem LT.lt.ne : ‚àÄ {Œ± : Sort u} [inst : LinearOrder Œ±] {a b : Œ±}, a < b ‚Üí a ‚â† b := by sorry ",
      "theorem Filter.univ_mem' : ‚àÄ {Œ± : Type u} {f : Filter Œ±} {s : Set Œ±}, (‚àÄ (a : Œ±), a ‚àà s) ‚Üí s ‚àà f := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem measurableSet_Ioi :\n    ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : OpensMeasurableSpace Œ±],\n      MeasurableSet (Set.Ioi a) :=\n  by sorry ",
      "theorem MeasureTheory.aecover_Ioi_lt_top :\n    ‚àÄ {Œº : MeasureTheory.Measure ‚Ñù} [inst : MeasureTheory.IsFiniteMeasureIntrinsic Œº] {r b : ‚Ñù},\n      b ‚â† ‚ä§ ‚Üí Filter.Liminf (ŒΩ ‚Üí ‚ä§) ‚ä• = ‚®Ü x ‚àà Set.Ioi b, Filter.map MeasureTheory.restrict Œº ‚äÜ nhds x :=\n  by sorry ",
      "theorem continuousOn_univ :\n    ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [T : PartialOrder Œ±] (h : Monotone a)\n      [self : OrderClosedTopology Œ±], ContinuousOn (@a) Set.univ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} {m : ‚Ñï} (hc : c ‚â† 0) (a_1 : c * a ‚â° c * b [MOD c * m]), a ‚â° b [MOD m])",
    "theorem": "theorem Nat.ModEq.mul_left_cancel' :\n    (‚àÄ {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} {m : ‚Ñï} (hc : c ‚â† 0) (a_1 : c * a ‚â° c * b [MOD c * m]), a ‚â° b [MOD m]) := by sorry",
    "name": "Nat.ModEq.mul_left_cancel'",
    "lemma-type": "{a : ‚Ñï} ‚Üí {b : ‚Ñï} ‚Üí {c : ‚Ñï} ‚Üí {m : ‚Ñï} ‚Üí (hc : c ‚â† 0) ‚Üí (‚àÄ (a_1 : ‚Üëm ‚à£ ‚Üëb - ‚Üëa), ‚Üëm ‚à£ ‚Üëb - ‚Üëa) = True",
    "lemma": "theorem aux.3693335900618259817 {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} {m : ‚Ñï} (hc : c ‚â† 0) :\n    (‚àÄ (a_1 : ‚Üëm ‚à£ ‚Üëb - ‚Üëa), ‚Üëm ‚à£ ‚Üëb - ‚Üëa) = True := by sorry",
    "doc_string": "Cancel left multiplication on both sides of the `‚â°` and in the modulus.\n\nFor cancelling left multiplication in the modulus, see `Nat.ModEq.of_mul_left`. ",
    "generated": [
      "theorem mul_div_assoc.fst : ‚àÄ {R : Type max u_1 u_2} [inst : Ring R] (a b c : R), 0 * (a / c) = 0 := by sorry ",
      "theorem mul_assoc : ‚àÄ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.1995992360132111391 {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} {m : ‚Ñï} (hc : c ‚â† 0) :\n    ‚àÄ {c : ‚Ñ§} {m : ‚Ñ§} (hne : Int.natAbs c * m = Int.natAbs c * Int.natAbs (c * c‚Åª¬π)) (c‚Åª¬≤ : IsUnits m),\n      ‚Üëc * a equivMod m :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "state={ max_length_natPos : Prop, max_out : max_length_natPos ‚Üí Nat.Pos, eq_true : max_length_natPos ‚Üí true,\n}\nproof_list : [true] = [] := by sorry ",
      "theorem modEq_trans : ‚àÄ {R : NonAssocSemiring} {a b c : R}, a ‚â° b [R mod] ‚Üí b ‚â° c [R mod] ‚Üí a ‚â° c [R mod] := by sorry ",
      "theorem Int.ofNat_ne : Nat.ofNat 1 = Nat.succ 0 ‚Üí ¬¨ Int.succ 0 = Nat.ofNat 1 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o y (y - x)) * ‚Äñy‚Äñ = ‚Äñx‚Äñ)",
    "theorem": "theorem Orientation.tan_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two :\n    (‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n      [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o y (y - x)) * ‚Äñy‚Äñ = ‚Äñx‚Äñ) :=\n  by sorry",
    "name": "Orientation.tan_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two",
    "lemma-type": "{V : Type u_1} ‚Üí\n  [NormedAddCommGroup V] ‚Üí\n    [InnerProductSpace ‚Ñù V] ‚Üí\n      [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] ‚Üí\n        (o : Orientation ‚Ñù V (Fin 2)) ‚Üí\n          {x : V} ‚Üí\n            {y : V} ‚Üí\n              (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) ‚Üí\n                (Real.Angle.tan (Orientation.oangle o y (y - x)) * ‚Äñy‚Äñ = ‚Äñx‚Äñ) =\n                  (Real.Angle.tan ‚Üë(InnerProductGeometry.angle y (y - x)) * ‚Äñy‚Äñ = ‚Äñx‚Äñ)",
    "lemma": "theorem aux.3459084036286254778 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) :\n    (Real.Angle.tan (Orientation.oangle o y (y - x)) * ‚Äñy‚Äñ = ‚Äñx‚Äñ) =\n      (Real.Angle.tan ‚Üë(InnerProductGeometry.angle y (y - x)) * ‚Äñy‚Äñ = ‚Äñx‚Äñ) :=\n  by sorry",
    "doc_string": "The tangent of an angle in a right-angled triangle multiplied by the adjacent side equals\nthe opposite side, version subtracting vectors. ",
    "generated": [
      "theorem aux.12771280237210376142 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) :\n    Orientation.oangle o x y = Orientation.oangle (-o) y x := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.11211386561895788974{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) : -Orientation.oangle o x y = ‚Üë(Real.pi / 2) := by sorry ",
      "question:\nNonterminal (simp_rw ‚Üí true) on Mathlib.Data.Orientation.Basic._auxLemma.35782812201207129765 (x_0 : Type)\n(x_1 : Type) (x_2 : Type) (x_3 : CommRing x_0) (x_4 : CommRing x_1) (x_5 : AddCommGroup x)\n(x_6 : Module x_0 x) (x_1 : Invertible (FiniteDimensional.finrank ‚Ñù V - 1)) :\n    ‚àÄ [x_2 : Invertible (1 - Orientation.tan (Orientation.oangle o y (y - x)))],\n      ‚Öü (‚Üë(FiniteDimensional.finrank ‚Ñù V - 1)) ‚Ä¢\n          (Complex.sin\n              (Orientation.oangle complex.Ix\n                neg ((Orientation.oangle o x ((Orientation.rotationOrientation o) (Orientation.symm (-1)) x)).toReal\n                    y)‚åã‚Çä - ‚Üë(Real.pi / 2))) +\n            ‚ÜëReal.pi \\* Orientation.tan\n          (Orientation.oangle o x ((Orientation.rotation O (-Orientation.oangle o)\n              (Orientation.negOrientation_neg_Orientation.symm o)) ((Orientation.rotation o) y) x)) ‚Ä¢\n            -‚Öü(‚Üë(FiniteDimensional.finrank ‚Ñù V - 1)) ‚Ä¢ y =\n        ‚ÅÖ‚Öü |(FiniteDimensional.finrank ‚Ñù V - 1)|‚ÅÜ‚Åª ‚Ä¢\n          ‚Äñ(Orientation.rotation o) (x + (Orientation.rotation O (-Orientation.oangle o)) x ‚Äñ^2‚Äñ / 1 - |(FiniteDimensional.finrank ‚Ñù V - 1)‚Äñ ^ 2‚Äñ)‚Äñ :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.11639394526551605162 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V]\n    [Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ‚Üë(Real.pi / 2)) :\n    (-Orientation.oangle (-o) x (x - y) = ‚Üë(Real.pi / 2)) =\n      (Real.Angle.tan (-Orientation.oangle (-o) x (x - y)) * ‚Äñx‚Äñ = ‚Äñy‚Äñ) :=\n  by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ‚Ñï) [inst_2 : CharP R p] (hp : p ‚â† 2),\n  Polynomial.cyclotomic' 2 R = Polynomial.X + 1)",
    "theorem": "theorem Polynomial.cyclotomic'_two :\n    (‚àÄ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ‚Ñï) [inst_2 : CharP R p] (hp : p ‚â† 2),\n      Polynomial.cyclotomic' 2 R = Polynomial.X + 1) :=\n  by sorry",
    "name": "Polynomial.cyclotomic'_two",
    "lemma-type": "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
    "lemma": "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry",
    "doc_string": "The second modified cyclotomic polyomial is `X + 1` if the characteristic of `R` is not `2`. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem pow_ne_one_of_two_lt :\n    ‚àÄ {M' : Type u_2} [inst : MonoidWithZeroWithEsup M'] [inst_1 : SuccOrder M'] [hm' : NoZeroSurjective ‚Ñï N'] {m', R := N'.SSup 1} {a : M'} [inst : PosMono ‚áëE.sup.toFun],\n      a ‚â† 0 ‚Üí two < m ‚Üí (R ‚Ä∫ n_¬∞ ¬∑ ¬∑) a = E (‚Üë(0 ^ n)) = a ‚Üí False :=\n  by sorry ",
      "theorem FiniteDimensional.polynomial_alg' :\n    ‚àÄ {R : Type u_8} [inst : CommRing (Polynomial R)], PolynomialRing (Multiset R) Polynomial R := by sorry ",
      "theorem eq_false : ‚àÄ {p : Prop}, ¬¨p ‚Üí p = False := by sorry ",
      "theorem aux.7932597031660635482 (R : Type u_2) [CommRing R] [IsDomain R] (p : ‚Ñï) [CharP R p] (hp : p ‚â† 2) :\n      ZMod.œÅ‚ÇÅ ^ ZMod.val 1 ‚â† 2 := by sorry ",
      "theorem Complex.natStrictEq_induction : ‚àÄ (sŒµc : Complex ‚ÜíProp NNReal) prop, sŒµc 0 ‚ä† (fun k t ws kHtk ‚Üí sŒµc k (t * tk ‚Ä¢ v)) rz :=\n  by sorry ",
      "theorem aux.5783310761928766555 (R : Type u_2) [CommRing R] [IsDomain R] (p : ‚Ñï) [CharP R p] (hp : p ‚â† 2) (_j‚ÇÅ : ‚Ñ§)\n    (_j‚ÇÇ : ‚Ñ§) (h : Nat.rawCast 4 * (‚Üë(Int.natAbs _j‚ÇÅ) ^ Nat.rawCast 1 * Nat.rawCast 1) = Nat.rawCast 4 * ‚Üë(_j‚ÇÇ ^ Nat.rawCast 1)) : 0 + 0 + ‚Üë(Int.natAbs _j‚ÇÅ ^ Nat.rawCast 1 * Nat.rawCast 1) =\n  ‚Üë(Int.natAbs _j‚ÇÅ ^ Nat.rawCast 1 * Nat.rawCast 1) := by sorry ",
      "theorem one_pow : ‚àÄ {M : Type u} [inst : Monoid M] (n : ‚Ñï), 1 ^ n = 1 := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ‚Üëu)) ‚Üî (IsAddUnit a))",
    "theorem": "theorem AddUnits.isAddUnit_add_addUnits :\n    (‚àÄ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ‚Üëu)) ‚Üî (IsAddUnit a)) := by sorry",
    "name": "AddUnits.isAddUnit_add_addUnits",
    "lemma-type": "{M : Type u_1} ‚Üí\n  [AddMonoid M] ‚Üí\n    (a : M) ‚Üí\n      (u : AddUnits M) ‚Üí (x : IsAddUnit (a + ‚Üëu)) ‚Üí (v : AddUnits M) ‚Üí (hv : ‚Üëv = a + ‚Üëu) ‚Üí ‚Üë(v + -u) = ‚Üëv + ‚Üë(-u)",
    "lemma": "theorem aux.17123692563786591682 {M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) (x : IsAddUnit (a + ‚Üëu))\n    (v : AddUnits M) (hv : ‚Üëv = a + ‚Üëu) : ‚Üë(v + -u) = ‚Üëv + ‚Üë(-u) := by sorry",
    "doc_string": "Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`.",
    "generated": [
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem add_inv' : ‚àÄ {G : Type u_2} [inst : SubnegZeroMonoid G] (a b : G), (a + b)‚Åª¬π = a‚Åª¬π + b‚Åª¬π := by sorry ",
      "theorem Zero.add_eq_right : ‚àÄ {M : Type u} [inst : Zero M] {a b : M}, 0 + a = a ‚Üî b = a := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem AddSubgroup.nsmul_mem :\n    ‚àÄ {M : Type u_1} [inst : AddMulAction M M] [inst_1 : Nontrivariancian M] {N : AddSubmonoid M} (x : N) {n : ‚Ñï},\n      n‚Ä¢x ‚àà N ‚Üî n = 0 ‚à® x ‚àà N :=\n  by sorry ",
      "theorem AddUnits.ne_neg :\n    ‚àÄ {R : Type u_6} [inst : Mul ‚ÇÅC] [inst : AddMonoid R] [inst_1 : Add Monoid 1C] [self : IsLeftRegular 1C]\n      (w : 1C) , w = -1 * w :=\n  by sorry ",
      "theorem zero_add : ‚àÄ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a := by sorry ",
      "theorem val_add_eq_add_val :\n    ‚àÄ {œÜ Œ≥ : Type u_1} [inst : Add œÜ] [inst_1 : Add Œ≥] (a b : œÜ) (c : Œ≥), ‚Üë(a + b) = ‚Üëa + ‚Üëb := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : PartialEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤} (a : PartialEquiv.IsImage e s t),\n  PartialEquiv.target e ‚à© ‚Üë(PartialEquiv.symm e) ‚Åª¬π' s = PartialEquiv.target e ‚à© t)",
    "theorem": "theorem PartialEquiv.IsImage.symm_preimage_eq :\n    (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : PartialEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤} (a : PartialEquiv.IsImage e s t),\n      PartialEquiv.target e ‚à© ‚Üë(PartialEquiv.symm e) ‚Åª¬π' s = PartialEquiv.target e ‚à© t) :=\n  by sorry",
    "name": "PartialEquiv.IsImage.symm_preimage_eq",
    "lemma-type": "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : PartialEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤},\n  PartialEquiv.IsImage e s t ‚Üî e.source ‚à© ‚Üëe ‚Åª¬π' t = e.source ‚à© s",
    "lemma": "theorem PartialEquiv.IsImage.iff_preimage_eq :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : PartialEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤},\n      PartialEquiv.IsImage e s t ‚Üî e.source ‚à© ‚Üëe ‚Åª¬π' t = e.source ‚à© s :=\n  by sorry",
    "doc_string": "**Alias** of the forward direction of `PartialEquiv.IsImage.iff_symm_preimage_eq`.",
    "generated": [
      "theorem aux.3448058076243453639 {Œ± : Type u_1} {Œ≤ : Type u_2} {e : PartialEquiv Œ± Œ≤} :\n    ‚àÄ {s : Set Œ±} {t : Set Œ≤} (a : PartialEquiv.IsImage e s t),\n      ‚àÉ i _, ‚àÄ (x : Œ≤) (y : x ‚àà i), x ‚àà ‚Üëe '' s ‚à© PartialEquiv.source e √óÀ¢ PartialEquiv.target e :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem PartialEquiv.isIMAGE_iff_inter :\n    ‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_3} {f : PartialEquiv Œ± Œ≥} {o : Set Œ≥}  {p : PartialFun Œ± Œ≥},\n      ùüÆ (p o (Set.inclusion (PartialEquiv.self_ofFun p (Function.InvFunPartial f))) (e.toFun) s)) =\n        { x | ‚àÄ·∂† (y : a) in p o, f ‚Üëy ‚àà {y | ‚Üëi y ‚àà o }} = {x | f ‚Üë‚Üëi x ‚àà {i‚ÇÇ | ‚àÉ y, x o‚ÇÉ i‚ÇÇ} ·∂ú o‚ÇÇ} :=\n  by sorry ",
      "theorem partialEquiv_source_subset :\n    ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (i : PartialEquiv Œ± Œ≤), PartialEquiv.source (‚áëi) ‚äÜ Set.univ := by sorry ",
      "theorem mem_inter_comm : ‚àÄ {Œ± : Type u‚ÇÅ} {f : Filter Œ±} {s t : Set Œ±}, s ‚àà f ‚àß t <|> t ‚àà f ‚àß s ‚àà f := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (r : ‚Ñù) (s : Set E),\n  ‚Üë‚ÜëŒº (r ‚Ä¢ s) = ENNReal.ofReal |r ^ FiniteDimensional.finrank ‚Ñù E| * ‚Üë‚ÜëŒº s)",
    "theorem": "theorem MeasureTheory.Measure.addHaar_smul :\n    (‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n      [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n      [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (r : ‚Ñù) (s : Set E),\n      ‚Üë‚ÜëŒº (r ‚Ä¢ s) = ENNReal.ofReal |r ^ FiniteDimensional.finrank ‚Ñù E| * ‚Üë‚ÜëŒº s) :=\n  by sorry",
    "name": "MeasureTheory.Measure.addHaar_smul",
    "lemma-type": "{E : Type u_1} ‚Üí\n  [NormedAddCommGroup E] ‚Üí\n    [NormedSpace ‚Ñù E] ‚Üí\n      [MeasurableSpace E] ‚Üí\n        [BorelSpace E] ‚Üí\n          [FiniteDimensional ‚Ñù E] ‚Üí\n            (Œº : MeasureTheory.Measure E) ‚Üí\n              [MeasureTheory.Measure.IsAddHaarMeasure Œº] ‚Üí\n                (r : ‚Ñù) ‚Üí\n                  (s : Set E) ‚Üí\n                    (h : r ‚â† 0) ‚Üí (r ^ FiniteDimensional.finrank ‚Ñù E)‚Åª¬π‚Åª¬π = r ^ FiniteDimensional.finrank ‚Ñù E",
    "lemma": "theorem aux.5077392164230726857 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E) [MeasureTheory.Measure.IsAddHaarMeasure Œº]\n    (r : ‚Ñù) (s : Set E) (h : r ‚â† 0) : (r ^ FiniteDimensional.finrank ‚Ñù E)‚Åª¬π‚Åª¬π = r ^ FiniteDimensional.finrank ‚Ñù E := by\n  sorry",
    "doc_string": "Rescaling a set by a factor `r` multiplies its measure by `abs (r ^ dim)`. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem LT.lt.le : ‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí a ‚â§ b := by sorry ",
      "theorem eq_or_self : ‚àÄ {Œ± : Sort u_1} (a : Œ±), a = a ‚à® ¬¨a := by sorry ",
      "theorem aux.9780819149776637284 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n    [MeasureTheory.Measure.IsAddHaarMeasure Œº] (r : ‚Ñù) (s : Set E) (hr : r < 0) (x : E) :\n    (r ‚Ä¢ x = 0 + r ‚Ä¢ x) = (r ‚Ä¢ x = r ‚Ä¢ r ‚Ä¢ x) := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem aux.3146040610635984591 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n    [MeasureTheory.Measure.IsAddHaarMeasure Œº] :\n    (measure_theory.Measure.restrict Œº (r ‚Ä¢ s) = ENNReal.restrict ‚Üë0 (r ‚Ä¢ s) +\n      ‚Üë(AbsoluteValue.abs r ‚Ä¢ measure_theory.Measure.restrict IsDual.dual Œº ‚Üë(Asymptotics.Right.IsBigO WithTop (a ^ (FiniteDimensional.finrank ‚Ñù Œµ) > 1)))) =\n      (measure_theory.Measure.restrict Œº (r ‚Ä¢ s) =\n        ‚Üë(AbsoluteValue.abs r ‚Ä¢ measure_theory.Measure.restrict IsDual.dual Œº ‚Üë(Asymptotics.Right.IsBigO WithTop (a ^ (FiniteDimensional.finrank ‚Ñù Œµ) > 1))) +\n            Finset.inf Œî fun a => Œ± * Finset.filter Asymptotics.leftNormal Œµ' * measure_theory.Measure.toContent Œº ‚Üëi ‚Üí\n        r *= Asymptotics.(norm_eq e) (@IsDualLeft.norm‚ÇÇ‚ÇÄ i) ‚Üí\n          measurable ((fun ha : Œ∏ = a‚ÇÅ * ha / a‚ÇÇ) ‚àß fun a i : ‚Ñù ‚Üí Set E ‚Üí set i ‚àà ha + œÜ u => measure_theory.MeasurableSet Set.univ);\n        r ‚Ä¢ (Finset.sum Asymptotics.right u fun a => Finset.toEncodable Aa fun a ‚Üî IsPartRight (AsymptoticsTo.ha)) :=\n  by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem mul_one : ‚àÄ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {R : Type u_1} [inst : CommRing R] {P : Polynomial R} (hunit : IsUnit P),\n  (IsUnit (Polynomial.coeff P 0)) ‚àß (‚àÄ (i : ‚Ñï) (a : i ‚â† 0), IsNilpotent (Polynomial.coeff P i)))",
    "theorem": "theorem Polynomial.coeff_isUnit_isNilpotent_of_isUnit :\n    (‚àÄ {R : Type u_1} [inst : CommRing R] {P : Polynomial R} (hunit : IsUnit P),\n      (IsUnit (Polynomial.coeff P 0)) ‚àß (‚àÄ (i : ‚Ñï) (a : i ‚â† 0), IsNilpotent (Polynomial.coeff P i))) :=\n  by sorry",
    "name": "Polynomial.coeff_isUnit_isNilpotent_of_isUnit",
    "lemma-type": "‚àÄ {R : Type u} [inst : Semiring R] [inst_1 : Nontrivial R], Polynomial.degree 1 = 0",
    "lemma": "theorem Polynomial.degree_one : ‚àÄ {R : Type u} [inst : Semiring R] [inst_1 : Nontrivial R], Polynomial.degree 1 = 0 :=\n  by sorry",
    "doc_string": "Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit.\n\nSee also `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent`. ",
    "generated": [
      "theorem Polynomial.coe_C :\n    ‚àÄ {R : Type u} [inst : Semiring R] {Œ± : (a : R) ‚Üí L} (c : Œ±), ‚Üë0 ^ alphas := by sorry ",
      "theorem Submodule.isNilpotent : ‚àÄ (R : Type u) [inst : CommRing R] {M : Submodule R M} {Q : Submodule R M},\n    M < Q ‚Üí Polynomial.isNilpotent HomOT.single f ‚Üí Polynomial.isNilpotent (RingHom.toMultilinearMap h) := by\n  sorry ",
      "theorem aux.8810033741927588860 {R : Type u_1} [CommRing R] {P : Polynomial R} (hunit : IsUnit P)\n    (hdvd : ‚àÄ (q : Polynomial R) (a : Polynomial.Monic q) (a : Nat.Coprime (Polynomial.deg q) (Polynomial.deg p)),\n      Polynomial.map (Int.castRingHom R) q ‚à£ P)\n    (hmin : Polynomial.coeff P 0 = 0)\n    (hexp : ‚àÄ {n : ‚Ñï} (a : 0 < n), Polynomial.coeff P n ÔøΩÔøΩ 0) :\n    Polynomial.coeff (PolyAnd.left exp.symm + PolyAnd.left exp.symm) 0 simeq 0 := by sorry ",
      "theorem Set.mem_toFinset' :\n    ‚àÄ {Œ± : Type u_1} {x : Œ±} (a : {x // Finset.toFintype x} = set.unbounded [x] univ), x ‚àà set.unbounded (x ‚Ä¢ nat_iff' x) :=\n  by sorry ",
      "theorem trans congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a b c : Œ±}, a = b ‚Üí (‚àÄ (c : Œ±), a = c ‚Üí b = c) ‚Üí a = b := by sorry ",
      "theorem congr : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ := by sorry ",
      "theorem symm : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem eq_false : ‚àÄ {p : Prop}, (p ‚Üí False) ‚Üí p = False := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n  {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x),\n  ‚àÉ t, (k ‚äÜ t) ‚àß ((IsOpen t) ‚àß (Bornology.IsBounded (f '' (t ‚à© s)))))",
    "theorem": "theorem Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt :\n    (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n      {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x),\n      ‚àÉ t, (k ‚äÜ t) ‚àß ((IsOpen t) ‚àß (Bornology.IsBounded (f '' (t ‚à© s))))) :=\n  by sorry",
    "name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt",
    "lemma-type": "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [PseudoMetricSpace Œ±] ‚Üí\n      [TopologicalSpace Œ≤] ‚Üí\n        {k : Set Œ≤} ‚Üí\n          {s : Set Œ≤} ‚Üí\n            {f : (a : Œ≤) ‚Üí Œ±} ‚Üí\n              (hk : IsCompact k) ‚Üí\n                (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x) ‚Üí\n                  (U : Set Œ≤) ‚Üí\n                    (h :\n                        ((IsOpen U) ‚àß (k ‚äÜ U)) ‚àß\n                          (‚àÉ i', (i' ‚àà Bornology.cobounded Œ±) ‚àß (Disjoint (U ‚à© s) (f ‚Åª¬π' id i')))) ‚Üí\n                      (left : (IsOpen U) ‚àß (k ‚äÜ U)) ‚Üí\n                        (right : ‚àÉ i', (i' ‚àà Bornology.cobounded Œ±) ‚àß (Disjoint (U ‚à© s) (f ‚Åª¬π' id i'))) ‚Üí\n                          (hUo : IsOpen U) ‚Üí\n                            (hkU : k ‚äÜ U) ‚Üí\n                              (t : Set Œ±) ‚Üí\n                                (h : (t ‚àà Bornology.cobounded Œ±) ‚àß (Disjoint (U ‚à© s) (f ‚Åª¬π' id t))) ‚Üí\n                                  (ht : t ‚àà Bornology.cobounded Œ±) ‚Üí\n                                    (hd : Disjoint (U ‚à© s) (f ‚Åª¬π' id t)) ‚Üí\n                                      (U ‚à© s ‚äÜ (f ‚Åª¬π' t)·∂ú) = (Disjoint (U ‚à© s) (f ‚Åª¬π' t))",
    "lemma": "theorem aux.11141344196659783695 {Œ± : Type u} {Œ≤ : Type v} [PseudoMetricSpace Œ±] [TopologicalSpace Œ≤] {k : Set Œ≤}\n    {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x) (U : Set Œ≤)\n    (h : ((IsOpen U) ‚àß (k ‚äÜ U)) ‚àß (‚àÉ i', (i' ‚àà Bornology.cobounded Œ±) ‚àß (Disjoint (U ‚à© s) (f ‚Åª¬π' id i'))))\n    (left : (IsOpen U) ‚àß (k ‚äÜ U)) (right : ‚àÉ i', (i' ‚àà Bornology.cobounded Œ±) ‚àß (Disjoint (U ‚à© s) (f ‚Åª¬π' id i')))\n    (hUo : IsOpen U) (hkU : k ‚äÜ U) (t : Set Œ±) (h : (t ‚àà Bornology.cobounded Œ±) ‚àß (Disjoint (U ‚à© s) (f ‚Åª¬π' id t)))\n    (ht : t ‚àà Bornology.cobounded Œ±) (hd : Disjoint (U ‚à© s) (f ‚Åª¬π' id t)) :\n    (U ‚à© s ‚äÜ (f ‚Åª¬π' t)·∂ú) = (Disjoint (U ‚à© s) (f ‚Åª¬π' t)) := by sorry",
    "doc_string": "If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. ",
    "generated": [
      "theorem aux.9243956950671355327 {Œ± : Type u} {Œ≤ : Type v} [PseudoMetricSpace Œ±] [TopologicalSpace Œ≤] {k : Set Œ≤}\n    {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x)\n    (hfin : ‚àÉ x, ‚àÄ (e : ‚Ñí≈õ Œ±) (a : e ‚àà uniformity Œ±), ‚àÉ c, s √óÀ¢ e ‚äÜ {p : Œ≤ √ó Œ± | p.1 ‚àà k √óÀ¢ (f \"\" (p.2))}):\n    ‚àÄ (Œµ : (a : Œ±) ‚Üí ‚Ñù), Filter.UnifIntegrable (fun (g : Œ≤ √ó Œ±) ‚Ü¶ Œµ (f g.2)) nat œÉ nhdsWithin 0 1 := by sorry ",
      "theorem forall_congr : ‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : Œ±), p a) = ‚àÄ (a : Œ±), q a := by\n  sorry ",
      "theorem IsCompact.inter_iUnion_closed :\n    ‚àÄ {X : Type u_1} {s S : Set X} [inst : TopologicalSpace X], IsCompact s ‚Üí (‚àÄ i ‚àà Set.Finite S, IsClosed Set.univ) ‚Üí ‚ãÇ i ‚àà S, s ‚à© ‚ãÉ i, s i = s := by sorry ",
      "theorem aux.15081451847990334508 {Œ± : Type u} {Œ≤ : Type v} [PseudoMetricSpace Œ±] [TopologicalSpace Œ≤] {k : Set Œ≤}\n    {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x)\n    (t·µ¢ : (a : Œ≤) ‚Üí Set Œ≤) (x : ‚àÄ (i : Œ≤), (ContinuousOn (t·µ¢ i) (borel ‚Üë(t·µ¢ i))) ‚àß (IsOpen (t·µ¢ i)))\n    (hs : IsOpen ((‚ãÉ i, t·µ¢ i)·∂ú)) (hst : k √óÀ¢ s ‚äÜ Prod.mk' (‚ãÇ i, t·µ¢ i) ‚Åª¬π' (s·∂ú √óÀ¢ s·∂ú)) :\n    ‚àÉ i, IsOpen ((t i ‚à© {x : Œ≤ √ó Œ≤ | (x.1, x.2) ‚àà s})·∂ú) := by sorry ",
      "theorem Filter.eventually_ne_atBot :\n    ‚àÄ {c c_1 v : Œ≤ ‚Üí E}, (v =* c ¬´¬±fun x => - c_1 x¬ª) ‚Üí ‚àÄ (L : E ‚Üí Filters Œ±), Filter.Eventually (c ¬´¬± L s) v := by\n  sorry ",
      "theorem Metric.exists_nhds_subset_open_isBounded_ball :\n    ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {s : Set Œ±},\n      IsCompact s ‚Üí HasDerivWithinAt nf (f' x x) s 2 ‚Üí ‚àÉ o ‚àà nhds x, IsOpen o ‚Üí BddBelow (\\s ‚à© o) ‚Üí IsBounded (\\s ‚à© o) :=\n  by sorry ",
      "theorem Set.forallSet_iff' : ‚àÄ {X : Type u} {E F : Set X·µ¶ ‚Ü° (i : X), X √ó Prop u} (y ‚àà x), Filter.Sets y Ef ‚Üî y.1 ‚àà x ‚àß E‚ÇÇ.left y (setOf (f fun ‚Ü¶ triv))) := by sorry ",
      "theorem ContinuousWithinAt.on_compact_absorption_on :\n    ‚àÄ {R : X ‚Üí Proj R} [inst : TConcreteRing X],\n      ‚àÄ {{A : X ‚Üí Œ±} ‚¶Ér : X·µ¶·µê·µó (R √ó X)‚¶Ñ, AbsMk r A, lsA ‚ó´ (id ‚àò Proja) <<SYS>>\n          A { x | A (lsRelA x) := A 0 ; ‚à•R id x‚à• ‚â§ Sinf ùíú (R r), id x ‚àà A { x | ‚Üë(lsProve R id x) }·∂ú √óÀ¢ s },\n      AbsoluteExact r A ‚ü®r, Sinf ùíú‚ü© (Subsystems R) (absInclA r ‚Üí h : (id ‚àò (lsProve refl r)) ‚â§ A * lsA),\n        r x ‚Üí { a | ‚àÄ r' ‚àà R x ‚â§ AbsoluteExact r (SinfS r h) ùíú r = a } = ‚Äπid ‚àò Proja id a = {r' | r' ‚àà Sinf ùíú} lf A‚Ä∫ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {K : Type uK} [inst : Field K] {V‚ÇÅ : Type uV‚ÇÅ} {V‚ÇÇ : Type uV‚ÇÇ} [inst_1 : AddCommGroup V‚ÇÅ] [inst_2 : Module K V‚ÇÅ]\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ},\n  (Function.Injective ‚áë(LinearMap.dualMap f)) ‚Üî (Function.Surjective ‚áëf))",
    "theorem": "theorem LinearMap.dualMap_injective_iff :\n    (‚àÄ {K : Type uK} [inst : Field K] {V‚ÇÅ : Type uV‚ÇÅ} {V‚ÇÇ : Type uV‚ÇÇ} [inst_1 : AddCommGroup V‚ÇÅ] [inst_2 : Module K V‚ÇÅ]\n      [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ},\n      (Function.Injective ‚áë(LinearMap.dualMap f)) ‚Üî (Function.Surjective ‚áëf)) :=\n  by sorry",
    "name": "LinearMap.dualMap_injective_iff",
    "lemma-type": "{K : Type uK} ‚Üí\n  [Field K] ‚Üí\n    {V‚ÇÅ : Type uV‚ÇÅ} ‚Üí\n      {V‚ÇÇ : Type uV‚ÇÇ} ‚Üí\n        [AddCommGroup V‚ÇÅ] ‚Üí\n          [Module K V‚ÇÅ] ‚Üí\n            [AddCommGroup V‚ÇÇ] ‚Üí\n              [Module K V‚ÇÇ] ‚Üí\n                {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ} ‚Üí\n                  (not_surj : ¬¨(Function.Surjective ‚áëf)) ‚Üí\n                    (inj : Function.Injective ‚áë(LinearMap.dualMap f)) ‚Üí\n                      (Function.Surjective ‚áëf) = (LinearMap.range f = ‚ä§)",
    "lemma": "theorem aux.9467030196494493139 {K : Type uK} [Field K] {V‚ÇÅ : Type uV‚ÇÅ} {V‚ÇÇ : Type uV‚ÇÇ} [AddCommGroup V‚ÇÅ] [Module K V‚ÇÅ]\n    [AddCommGroup V‚ÇÇ] [Module K V‚ÇÇ] {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ} (not_surj : ¬¨(Function.Surjective ‚áëf))\n    (inj : Function.Injective ‚áë(LinearMap.dualMap f)) : (Function.Surjective ‚áëf) = (LinearMap.range f = ‚ä§) := by sorry",
    "doc_string": "`f.dualMap` is injective if and only if `f` is surjective ",
    "generated": [
      "algorithm :\n```lean\ntheorem LinearMap.comp :\n    (‚àÄ {R : Type uR} {S : Type uS‚ÇÅ} {Q : Type uHQ} {Q‚ÇÇ : Type uK} [inst : CommSemiring R] [inst_1 : SemiringSquare Zero R]\n      {T : Type uT} [inst_2 : Semiring S] [inst_3 : SmoothFloor T] [inst_4 : Semiring S‚ÇÅ] [inst_5 : SMul zero R S],\n      Continuous (QuadraticForm.Dual.compSmooth R (LinearMap.flip‚ÇÇ ((‚áëzeroR SMul.toLinear mapDomain S) ‚àò‚Çó ‚áëf)\n        (Flip.sumEquiv Flip.fst (Flip.smulFstSndzero T S)))) :\n    Continuous ‚áëFlip.smulFstLiftT ZeroSZero.elim TSMapT ‚ÇÄ SMulT.toSL ‚áëFunctionZeroIsTrivial.zeroM.hsmul0 := by\n  sorry ",
      "theorem aux.3302121111415573705 {K : Type uK} [Field K] {V‚ÇÅ : Type uV‚ÇÅ} {V‚ÇÇ : Type uV‚ÇÇ} [AddCommGroup V‚ÇÅ] [Module K V‚ÇÅ]\n    [AddCommGroup V‚ÇÇ] [Module K V‚ÇÇ] {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ} : Function.Injective ‚áëf ‚Üî VFunictopic ‚áëf ‚áëf := by sorry ",
      "theorem forall_congr : ‚àÄ {Œ± : Sort u_1} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a ‚Üî q a) ‚Üí (‚àÄ (a : Œ±), p a) ‚Üî ‚àÄ (a : Œ±), q a :=\n  by sorry ",
      "theorem aux.1277183800734274732 {K : Type uK} [Field K] {V‚ÇÅ : Type uV‚ÇÅ} {V‚ÇÇ : Type uV‚ÇÇ} [AddCommGroup V‚ÇÅ] [Module K V‚ÇÅ]\n    [AddCommGroup V‚ÇÇ] [Module K V‚ÇÇ] {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ} (c : V‚ÇÇ ‚Üí‚Çó·ó±[K V‚ÇÅ] V¬π)\n    (h : ‚àÄ (xc : V^{[0]}[i][i.1]) (x1 : V √óÀ¢ V [[i.1.leftEquiv i.1]] xc),\n        LinearMap.toHomHom c (LinearMap.dualMap f xc) (f x1) =\n        LinearMap.toHomHom c (LinearMap.dualMap f (i.snd tc)) (i.snd tc)) :\n    Function.Injective ‚áë(f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ) := by sorry ",
      "theorem Function.Injective.compInjectiveLeft' :\n    ‚àÄ {A : Sort u_19} {B : Sort u_20} [inst : HasSmul A B] {C : Sort u_22} (S : Sort u_23) (B‚ÇÅ : Sort u_21)‚¶Éi : A ‚äó C ‚Üí‚∂£ B‚ÇÅ ‚¶Ñz·µ¢ : D.out = Unit. unit·µ¢ ‚Üí (fun (œâ : A ‚äó C) => ‚Üë(D.monoidHomeomorphism A C S.toEquiv\n          ((TensorProduct.leftReservation, CategoryTheory.Limits.IsTerminal.monoidEquivToIso B ‚â™‚Çú‚Çï‚Çá MonCat.morphism (TermineAccessible.final C))).hom (fun (x‚ÇÄ : CategoryTheory.Limits.functorTo C f ‚ñ°·µí·µï D)).hom\n          œâ) œâd) =\n      (function.injective D.hom ‚àß A = Unit) ‚Üí\n        PartialEquiv.bijective Function.leftReservationSendingB‚ÇÅNihomUnits C BI :=\n  by sorry ",
      "theorem mul_pos :\n    ‚àÄ {Œ± : Type u_1} {a b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosSMulNotPreimageMul Œ±],\n      0 < a ‚Üí 0 < b ‚Üí 0 < a * b :=\n  by sorry ",
      "theorem LinearMap.diceField'_injective :\n    ‚àÄ {K : Type (K+1)} [inst : Field K] {K' : Type (S - i * P + H Œ©) }\n      [inst' : nontriviallyNormedField ùïã](g : Dice(N i ‚ãû [inst, N - P‚ÇÇ ‚çâ K'] D (K' ‚Üí ùïã)))[inst''] {d‚ÇÅ, d‚ÇÇ : N},\n      d‚ÇÅ < g ‚Üí d‚ÇÇ < g ‚Üí d‚ÇÅ = d‚ÇÇ ‚Üí ‚ÜëK / {x_1 ‚Ü¶ .dir a x (g œà)) (fun d' => œà d') < {K'‚ÇÅ / .subinst a, K'‚ÇÇ / .subinst b, ‚®ê i, .subinst a}} ‚ñ∏\n      Dice.Nor(p).dicy ‚Üí Subtype.val ({D : ‚Üëp ‚Üí K} ‚àà dice) = r := by sorry ",
      "theorem aux.13491826193326798489 {K : Type uK} [Field K] {V‚ÇÅ : Type uV‚ÇÅ} {V‚ÇÇ : Type uV‚ÇÇ} [AddCommGroup V‚ÇÅ]\n    [Module K V‚ÇÅ] [AddCommGroup V‚ÇÇ) [Module K V‚ÇÇ] {f : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ} : ‚àÄ (h_lef : Function.Surjective ‚áëf),\n    Function.Injective ‚áë(LinearMap.dualMap f).compLinearMap (LinearMap.flip LinearMap.dualMap f) := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ‚Ñù G] {s : Set G} {x : G} {y : G}\n  (h : openSegment ‚Ñù x y ‚äÜ s), y - x ‚àà tangentConeAt ‚Ñù s x)",
    "theorem": "theorem mem_tangentCone_of_openSegment_subset :\n    (‚àÄ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ‚Ñù G] {s : Set G} {x : G} {y : G}\n      (h : openSegment ‚Ñù x y ‚äÜ s), y - x ‚àà tangentConeAt ‚Ñù s x) :=\n  by sorry",
    "name": "mem_tangentCone_of_openSegment_subset",
    "lemma-type": "{G : Type u_4} ‚Üí\n  [NormedAddCommGroup G] ‚Üí\n    [NormedSpace ‚Ñù G] ‚Üí {s : Set G} ‚Üí {x : G} ‚Üí {y : G} ‚Üí (h : openSegment ‚Ñù x y ‚äÜ s) ‚Üí Mathlib.Meta.NormNum.IsNat 2 2",
    "lemma": "theorem aux.9712431797913879751 {G : Type u_4} [NormedAddCommGroup G] [NormedSpace ‚Ñù G] {s : Set G} {x : G} {y : G}\n    (h : openSegment ‚Ñù x y ‚äÜ s) : Mathlib.Meta.NormNum.IsNat 2 2 := by sorry",
    "doc_string": "If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ",
    "generated": [
      "theorem mem_spanRotation_singleton :\n    ‚àÄ (x : SeminarAddChains Œ≤ Œ±) {v : ‚Ü•vSupp x}, v ‚àà {v | x v = x ‚ü®-1 ?_vT0‚ÑÇ‚ü© v} ‚Üî -1 < x => ‚Üë(-1) x v := by\n  sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤),\\ a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.14803565543406698541 {G : Type u_4} [NormedAddCommGroup G] [NormedSpace ‚Ñù G] {s : Set G} {x : G}\n    {y : G} (hy : y - x ‚àà normedSpan ‚Ñù (normNormedSpace ‚Ñù G) s) (hy : y ‚àà openPos subset_closed)\n    (hy : x ‚àà openNeg subset_closed) : x + y = y - x := by sorry ",
      "theorem Set.SetCodisjoint.add_right :\n    ‚àÄ {Œ± : Type u} {s t u : Set Œ±} [inst : Semigroup Œ±] [inst_1 : SetLike Œ± u],\n      SetCodisjoint s u ‚Üí SetDifference (s ‚ãÜ u) t = u ‚ãÜ (SetDiffereneSet t s) :=\n  by sorry ",
      "theorem vsub_add_vcancel :\n    ‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p‚ÇÅ p‚ÇÑ : P) (p‚ÇÇ : P),\n      p‚ÇÇ -·µ• p‚ÇÑ +·µ• p‚ÇÑ - (p‚ÇÇ -·µ• p‚ÇÅ +·µ• p‚ÇÅ) = p‚ÇÇ -·µ• p‚ÇÅ :=\n  by sorry ",
      "theorem TAngle.cos_neg_angle : ‚àÄ {R : Type u_1} [inst : NormedRing R] (x y :R·ó£), Real.cos (Angle.cos ‚Üë(-Angle.tanReal x y)) = Real.cos ‚Üë(Angle.tanReal |x| |y|) := by sorry ",
      "theorem sub_self : ‚àÄ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0 := by sorry ",
      "theorem Submodule.left_mem_of_mem_inf :\n    ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [INST : AddCommMonoid M] [inst_1 : Module R M]\n      {p q : Submodule R M} [p_le_q : p ‚â§ q] {x : M}, x ‚àà p ‚Üí x ‚àà q ‚Üí x ‚àà p :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {E : Type u_1} [inst : MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E},\n  MeasureTheory.pdf.uniformPDF s x = if (x ‚àà s) then (‚Üë‚ÜëŒº s)‚Åª¬π else 0)",
    "theorem": "theorem MeasureTheory.pdf.uniformPDF_ite :\n    (‚àÄ {E : Type u_1} [inst : MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E},\n      MeasureTheory.pdf.uniformPDF s x = if (x ‚àà s) then (‚Üë‚ÜëŒº s)‚Åª¬π else 0) :=\n  by sorry",
    "name": "MeasureTheory.pdf.uniformPDF_ite",
    "lemma-type": "{E : Type u_1} ‚Üí\n  [MeasurableSpace E] ‚Üí {Œº : MeasureTheory.Measure E} ‚Üí {s : Set E} ‚Üí {x : E} ‚Üí ‚àÄ (a : x ‚àà s), (‚Üë‚ÜëŒº s)‚Åª¬π * 1 = (‚Üë‚ÜëŒº s)‚Åª¬π",
    "lemma": "theorem aux.5825409960318014405 {E : Type u_1} [MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E} :\n    ‚àÄ (a : x ‚àà s), (‚Üë‚ÜëŒº s)‚Åª¬π * 1 = (‚Üë‚ÜëŒº s)‚Åª¬π := by sorry",
    "doc_string": "Alternative way of writing the uniformPDF. ",
    "generated": [
      "theorem congrArg : ‚àÄ {Œ± Œ≤ : Sort u} {a b c : Œ±} (h : a = b), h { x_1 := c } = h { x := c } := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem Set.ext : ‚àÄ {Œ± : Type u} {a b : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà a ‚Üî x ‚àà b) = (a = b) := by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem And.right : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry ",
      "theorem measurableSet_singleton :\n    ‚àÄ {Œ± : Type u_1} {mŒ± : MeasurableSpace Œ±} {h : MeasurableSet {a | p(a)}}, a ‚àà {a | p(a)} ‚Üí MeasurableSet p := by\n  sorry ",
      "theorem sub_inv_left' : ‚àÄ {Gamma : Type u_3} [inst : LinearOrderedField G] {g h : G}, x ‚àà Œì ‚Üí (g > h ‚Üí h / g < g·∂ú) ‚Üî g < g * Œ± => h / g + x / g * g > e := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (œÉ i)) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚Üî\n    (Monovary f (g ‚àò ‚áëœÉ)))",
    "theorem": "theorem Monovary.sum_smul_comp_perm_eq_sum_smul_iff :\n    (‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n      [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n      [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n      ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (œÉ i)) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚Üî\n        (Monovary f (g ‚àò ‚áëœÉ))) :=\n  by sorry",
    "name": "Monovary.sum_smul_comp_perm_eq_sum_smul_iff",
    "lemma-type": "{Œπ : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [LinearOrderedRing Œ±] ‚Üí\n        [LinearOrderedAddCommGroup Œ≤] ‚Üí\n          [Module Œ± Œ≤] ‚Üí\n            [OrderedSMul Œ± Œ≤] ‚Üí\n              {œÉ : Equiv.Perm Œπ} ‚Üí\n                {f : (a : Œπ) ‚Üí Œ±} ‚Üí\n                  {g : (a : Œπ) ‚Üí Œ≤} ‚Üí\n                    [Fintype Œπ] ‚Üí\n                      (hfg : Monovary f g) ‚Üí (x_0 : Equiv.Perm Œπ) ‚Üí (x_0 : Equiv.Perm Œπ) ‚Üí MonovaryOn f g ‚ÜëFinset.univ",
    "lemma": "theorem aux.3742146138015150119 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [LinearOrderedRing Œ±]\n    [LinearOrderedAddCommGroup Œ≤] [Module Œ± Œ≤] [OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n    [Fintype Œπ] (hfg : Monovary f g) (x_0 : Equiv.Perm Œπ) (x_0 : Equiv.Perm Œπ) : MonovaryOn f g ‚ÜëFinset.univ := by sorry",
    "doc_string": "**Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` monovary\ntogether. Stated by permuting the entries of `g`. ",
    "generated": [
      "theorem le_rfl : ‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±}, a ‚â§ a := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem And.right : ‚àÄ {a b : Prop}, a ‚àß b ‚Üí b := by sorry ",
      "theorem sum_congr_aux :\n    ‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s‚ÇÅ s‚ÇÇ : Finset Œ±} {n : Œ≤ ‚Üí Œ≤} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤ ‚Üí Œ≤},\n      s‚ÇÅ = s‚ÇÇ ‚Üí (‚àÄ x ‚àà s‚ÇÇ, n x = n x) ‚Üí ((‚àÄ x ‚àà s‚ÇÅ, f x n = f x) ‚àß (‚àÄ x ‚àâ s‚ÇÅ, f x n = f x)) ‚Üí (Finset.sum s‚ÇÅ f‚ÇÅ = Finset.sum s‚ÇÇ f‚ÇÇ) :=\n  by sorry ",
      "theorem trans : ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsTrans Œ± r] {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c := by sorry ",
      "theorem aux.5601663138841134411 {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [LinearOrderedRing Œ±]\n    [LinearOrderedAddCommGroup Œ≤] [Module Œ± Œ≤] [OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n    {g : (a : Œπ) ‚Üí Œ≤} [Fintype Œπ] (hfg : Monovary f g) :\n    Iff\n        ((‚àë' (i : Fin (Fintype.card { y : Œπ // y ‚àà Finset.range (Fintype.card { z : Fin Fintype.card }) })), f i ‚Ä¢ g i =\n            ‚àë' (i : Fin (Fintype.card { y : Œπ // y ‚àà Finset.range (Fintype.card { z : Fin Fintype.card }) })), f 0 ‚Ä¢\n              g i) ‚Üî\n          ((Equiv.Perm.sign (Equiv.Perm.det œÉ) ‚Ä¢ ‚Üë(Equiv.Perm.det œÉ).det = 1) ‚àß\n            ((Finset.sum Finset.univ fun (e : { z : Fin Fintype.card // y ‚àà Finset.range i }) ‚Ü¶\n                { val := ((z)), property := ((hu)) } ¬∑ f <| g (œÉ y) *) =\n              fun x => ‚àë a : Finset Œπ, f ‚Üëa ¬∑ g (œÉ a)) =\n        ((Equiv.Refl Œπ œÉ x x := by sorry) ‚àß\n          ((Function.invfun Equiv.swap '' Finset.univ - Function.invfun Equiv.swap 0 x =\n              f\n                ((Function.invfun Equiv.swap '' Finset.univ) (0 + (œÉ y).val)) ‚Ä¢\n                g ((Function.invfun Equiv.swap '' Finset.univ) (Fin.last N))) =\n            True) :=\n  by sorry ",
      "theorem congrUn : ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {x y : Œ±} {f g : Œ± ‚Üí Œ≤}$, f = g ‚Üí x = y ‚Üí f x = g y := by sorry ",
      "theorem Monovary.monovaryOn :\n    ‚àÄ {Œπ : Type u_1} {G : Type u_3} [inst : StrictOrderedSemiring G] [inst_1 : Module G œâ]\n      [inst_2 : SMulPosMono G œâ] [inst_3 : PosSmul G F œÜ], MonovaryOn F œÜ G fun B ‚Ü¶ B ‚àà Set.insert Œ∏ B ‚Ä¢ Function.Support f ‚Üí Œ¥ ‚â• œÜ :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {E : Type u_1} [inst : MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E},\n  MeasureTheory.pdf.uniformPDF s x = if (x ‚àà s) then (‚Üë‚ÜëŒº s)‚Åª¬π else 0)",
    "theorem": "theorem MeasureTheory.pdf.uniformPDF_ite :\n    (‚àÄ {E : Type u_1} [inst : MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E} {x : E},\n      MeasureTheory.pdf.uniformPDF s x = if (x ‚àà s) then (‚Üë‚ÜëŒº s)‚Åª¬π else 0) :=\n  by sorry",
    "name": "MeasureTheory.pdf.uniformPDF_ite",
    "lemma-type": "‚àÄ {p : Prop}, p = True ‚Üí p",
    "lemma": "theorem of_eq_true : ‚àÄ {p : Prop}, p = True ‚Üí p := by sorry",
    "doc_string": "Alternative way of writing the uniformPDF. ",
    "generated": [
      "theorem symm: ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsSymm Œ± r] {a b : Œ±}, r a b ‚Üí r b a := by sorry ",
      "theorem mul_comm : ‚àÄ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ",
      "theorem aux.3196671576251249987 {E : Type u_1} [MeasurableSpace E] {Œº : MeasureTheory.Measure E} {s : Set E}\n    {x : E} :\n    ((Finset.prod (MeasureTheory.toFinset Set Œπ) fun (Œπ : Set E) ‚Ü¶ pdf X Œº ŒΩ i) =\n        if (x ‚àà Œº s) then ‚Üë‚ÜëŒº s‚Åª¬π\n          (œÉ ‚ÜíE[Œπ (MeasureTheory.Measure.subtypeSet ( MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict ‚àû f‚Åª¬π) ‚à´ (x : Set ùïú √ó set ùïú) (MeasureTheory.Measure.subtypeSigmaœÉ Œº)) r, ‚Ñù) f (s x)))\n          id else\n        if True then 0 else ifFalseElse\n        ‚ÜëŒº.smulFun\n          (Id.toMeasurePreserving aeSeq Œº Œºf) (Set.indicator s (MeasureTheory.toAEMeasure f) f) x :=\n  by sorry ",
      "theorem or_false : ‚àÄ (p : Prop), (p ‚à® false) = p := by sorry ",
      "theorem MeasureTheory.hasPDF_mk :\n    ‚àÄ {Œ± : Type u_1} {B : MeasurableSpace Œ±} {mŒ± : MeasurableSpace ‚Ñù} [metric_smul : OuterMeasure.SmulRegBy mœÑ_{Œ±Œ≤} ‚Ñù‚Ñô.curve]\n      [inst : TopologicalSpace.Segregated Œ± by MeasurableSet mŒ±] (a Œ±) {t0 Œµ : ‚Ñù}, Measurable t0 ==> phfst a e.toMeas ‚Üëf, {xYK | x ‚àà t0..-Œµ < Y < t0..1} ‚Üí Œ≤ x = Œµ :=\n  by sorry ",
      "theorem And.right_ff : ‚àÄ {a b : prop}, a ‚àß b ‚Üí b := by sorry ",
      "theorem if_pos : ‚àÄ {c : Prop} {h : c}, c ‚Üí ‚àÄ (q : ¬¨c), ¬¨c := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {H : Type u_5} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ‚Ñù H] [inst_2 : CompleteSpace H]\n  (K : ConvexCone ‚Ñù H) (ne : Set.Nonempty ‚ÜëK) (hc : IsClosed ‚ÜëK), Set.innerDualCone ‚Üë(Set.innerDualCone ‚ÜëK) = K)",
    "theorem": "theorem ConvexCone.innerDualCone_of_innerDualCone_eq_self :\n    (‚àÄ {H : Type u_5} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ‚Ñù H] [inst_2 : CompleteSpace H]\n      (K : ConvexCone ‚Ñù H) (ne : Set.Nonempty ‚ÜëK) (hc : IsClosed ‚ÜëK), Set.innerDualCone ‚Üë(Set.innerDualCone ‚ÜëK) = K) :=\n  by sorry",
    "name": "ConvexCone.innerDualCone_of_innerDualCone_eq_self",
    "lemma-type": "{H : Type u_5} ‚Üí\n  [NormedAddCommGroup H] ‚Üí\n    [InnerProductSpace ‚Ñù H] ‚Üí\n      [CompleteSpace H] ‚Üí\n        (K : ConvexCone ‚Ñù H) ‚Üí (ne : Set.Nonempty ‚ÜëK) ‚Üí (hc : IsClosed ‚ÜëK) ‚Üí (x : H) ‚Üí (x ‚àà ‚ÜëK) = (x ‚àà K)",
    "lemma": "theorem aux.13439475715234067315 {H : Type u_5} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]\n    (K : ConvexCone ‚Ñù H) (ne : Set.Nonempty ‚ÜëK) (hc : IsClosed ‚ÜëK) (x : H) : (x ‚àà ‚ÜëK) = (x ‚àà K) := by sorry",
    "doc_string": "The inner dual of inner dual of a non-empty, closed convex cone is itself.  ",
    "generated": [
      "theorem map_eq_neg_neg_left : ‚àÄ {G : Type u_1} {H : Type u_2} {g : G ‚Üí M¬ª H} {m‚ÇÄ : M¬ª N‚ÇÄ}\n    [normedDivisionRing N‚ÇÄ] [seminormedAddCommGroup H] (m : M‚ÇÄ), (mapAddHom g ((ConvergingContent K).max.add' (addNormCmp m ‚Üëm‚ÇÄ) m)).toDual = -((ConvergingContent K).toDual)) := by sorry ",
      "theorem map_div' :\n    ‚àÄ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : DivInvMonoid G] [inst_1 : CommMonoid H]\n      [inst_2 : FunLike F G H] [mc : MonoidHomClass F G H] (hf : Continuous ‚áëhf) (x y : G),\n      division' y ‚àò DivisionRing.div a :=\n  by sorry ",
      "theorem Set.Nonempity.map :\n    ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f : Œ± ‚Üí Œ≤}, Set.Nonempty ‚Åª¬π' f '' ‚Üë{} ‚Üí Set.Nonempty ((fun x => f '' x) '' f ^{-1}(i.val)) :=\n  by sorry ",
      "theorem Set.Nonemptys.coe_coe :\n    ‚àÄ {s : Bool √ó Bool √ó Bool √ó Nat √ó Nat √ó Nat ‚Üí Prop} (a : s), Eq (‚Äñ(a.10).val‚Äñ) = Eq ‚Üë(‚Äñ(a.10).val‚Äñ) := by sorry ",
      "theorem continuous_const :\n    ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (x : Y),\n      Continuous fun x_1 => x :=\n  by sorry ",
      "theorem aux.9685223694728141131 {H : Type u_5} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H] [CompleteSpace H]\n    (K : ConvexCone ‚Ñù H) {ne : Set.Nonempty ‚ÜëK} (hc : IsClosed ‚ÜëK) :\n    SetDifference _ ‚Üë(innerDualCone ‚ÜëK) = ‚®Ö x_2, innerDualConeConeMk x_2 = ‚®Ö x_2 2 ‚Ä¢ submoduleDualConeMk ‚ÜëK x_2 := by\n  sorry ",
      "theorem of_eq : ‚àÄ {A : Prop}, (a = b) ‚Üí a ‚Üí b := by sorry ",
      "theorem Subtype.map_indicator_subtype :\n    ‚àÄ (S : Set Œ≤) {T s : Set (Set Œ±)] (f : (a : Œ±) ‚Üí Œ≤) (hf : ‚àÄ {a : Œ±} {t : Set Œ±}, t ‚äÜ Set.univ ‚Üí a ‚àà S ‚Üí a ‚àà t ‚Üí f a ‚àà s a),\n      ‚àÄ (hS : Set.dopedIdem U S), Fintype.indicator S f U = f :=\n  by sorry "
    ]
  },
  {
    "theorem-type": "(‚àÄ {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A] [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B]\n  [inst_2 : CategoryTheory.Abelian A] [inst_3 : CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n  (h :\n    ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (a : CategoryTheory.Exact f g),\n      CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n        ((CategoryTheory.Functor.toPrefunctor L).map g)),\n  CategoryTheory.Functor.PreservesMonomorphisms L)",
    "theorem": "theorem CategoryTheory.Functor.preservesMonomorphisms_of_map_exact :\n    (‚àÄ {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A]\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B] [inst_2 : CategoryTheory.Abelian A]\n      [inst_3 : CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n      (h :\n        ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (a : CategoryTheory.Exact f g),\n          CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n            ((CategoryTheory.Functor.toPrefunctor L).map g)),\n      CategoryTheory.Functor.PreservesMonomorphisms L) :=\n  by sorry",
    "name": "CategoryTheory.Functor.preservesMonomorphisms_of_map_exact",
    "lemma-type": "{A : Type u‚ÇÅ} ‚Üí\n  {B : Type u‚ÇÇ} ‚Üí\n    [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A] ‚Üí\n      [CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B] ‚Üí\n        [CategoryTheory.Abelian A] ‚Üí\n          [CategoryTheory.Abelian B] ‚Üí\n            (L : CategoryTheory.Functor A B) ‚Üí\n              (h :\n                  ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (a : CategoryTheory.Exact f g),\n                    CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n                      ((CategoryTheory.Functor.toPrefunctor L).map g)) ‚Üí\n                {X : A} ‚Üí\n                  {Y : A} ‚Üí\n                    (f : X ‚ü∂ Y) ‚Üí (hf : CategoryTheory.Mono f) ‚Üí (CategoryTheory.Functor.toPrefunctor L).map 0 = 0",
    "lemma": "theorem aux.9102600683017178407 {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A]\n    [CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B]\n    (L : CategoryTheory.Functor A B)\n    (h :\n      ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g))\n    {X : A} {Y : A} (f : X ‚ü∂ Y) (hf : CategoryTheory.Mono f) : (CategoryTheory.Functor.toPrefunctor L).map 0 = 0 := by\n  sorry",
    "doc_string": "A functor which preserves exactness preserves monomorphisms. ",
    "generated": [
      "theorem aux.4126514198340375326 {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A]\n    [CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B]\n    (L : CategoryTheory.Functor A B)\n    (h :\n      ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g)) :\n    Let q : Morphism property := by sorry ",
      "theorem congrArgs : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem eq_self : ‚àÄ {Œ± : Sort u_1} (a : Œ±), (a = a) = True := by sorry ",
      "theorem aux.6574495478927523707 {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A]\n    [CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n    (h :\n      ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {a : X ‚ü∂ Y} {b : Y ‚ü∂ Z},\n        ( CategoryTheory.CategoryStruct.comp a b ‚Üî 0) ‚Üî CategoryTheory.Exact a b)\n    (mŒ± : L Œ∑ S).property\n    (c : cokernel ((CategoryTheory.Functor.toPrefunctor L).map ‚ÜëŒ±))\n    (h‚ÇÇ :\n      CategoryTheory.CategoryStruct.comp\n          ((CategoryTheory.Functor.toPrefunctor L).map (FG.mono_fst hp (( CategoryTheory.Functor.toPrefunctor L).map Œ±)))\n           ((CategoryTheory.Functor.toPrefunctor L).map (FG.zero_desc hpp c)) =\n        0) :\n    (cokernel ((CategoryTheory.Functor.toPrefunctor L).map ‚ÜëŒ±) =\n       CategoryTheory.Limits.cokernelIsLimit\n          (CategoryTheory.Limits.Cofork.ofœÄ\n              ((CategoryTheory.Functor.toPrefunctor L).map (FG.mono_fst hp ((CategoryTheory.Functor.toPrefunctor L).map Œ±]))\n              (FG.zero_desc hpp c).left)) =\n      (Nonempty ((CategoryTheory.Functor.toPrefunctor (bicartian AB')).obj\n                (CategoryTheory.Limits.exact\n                      (FG.cokernelPullbackCoconne Iv (Functor.toPrefunctor F)\n                        ((CategoryTheory.Functor.toPrefunctor F).map Œ∑))?\n                      (nonEmpty.2 (NontrivialAux.exact_partialNom (Biactual.isBiproduct A Œ∑) œÉ a)))))) :=\n  by sorry ",
      "theorem Iff.of_eq : ‚àÄ {a b : Prop}, a = b ‚Üí (a ‚Üî b) := by sorry ",
      "theorem congrArg : ‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ := by sorry ",
      "theorem aux.7318826009018983527 {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A]\n    [inst_1 : CategoryTheory.Abelian A] [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B]\n    [inst_3 : CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n    (h :\n      ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ ‚¶Éf : X ‚ü∂ Y‚¶Ñ ‚¶Ég : Y ‚ü∂ Z‚¶Ñ (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g)) :\n    ‚àÄ {p : CategoryTheory.Limits.Cofork F hF} (sq : p ‚àà CategoryTheory.Limits.kernelForkSubobject F hF),\n      ¬¨p ‚àà AlgebraicTopology.DoldKan.fork‚ÇÇObjEquivLift.toFun D k a k‚ÇÄ =p ‚ä§ :=\n  by sorry ",
      "theorem aux.8166251946559830587 {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} [CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A]\n    [CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B]\n    (L : CategoryTheory.Functor A B)\n    (h :\n      ‚àÄ ‚¶ÉX : A‚¶Ñ ‚¶ÉY : A‚¶Ñ ‚¶ÉZ : A‚¶Ñ {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g)) :\n    CategoryTheory.Abelian.HasBiproducts A := by sorry "
    ]
  }
]
