{"theorem":"‚àÄ {R : Type u} [inst : Ring R], IsField R","text":"Every ring is a field.","result":true,"gps":[["‚àÄ {R : Type u} [inst : Ring R], IsField R","‚àÄ (R : Type u) [inst : Ring R], IsField R","‚àÄ (R : Type u) [inst : Ring R], IsField R"],["‚àÄ (R : Type u) [inst : Semiring R], Nontrivial R ‚Üí (‚àÄ (x : R), x ‚â† 0 ‚Üí ‚àÉ y, x * y = 1) ‚Üí IsField R"],["‚àÄ {R : Type u} [inst : CommSemiring R], IsField R"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ‚âÉ+* B ‚Üí IsDomain A\"},\n {\"role\": \"user\", \"content\": \"A field extension is integral if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"Stalks of a locally ringed space are local rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x\"},\n {\"role\": \"user\",\n  \"content\": \"Any infinite type can be endowed a field structure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K }\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"Every ring is a field.\"}]","all_elaborations":["‚àÄ {R : Type u} [inst : CommSemiring R], IsField R","‚àÄ {R : Type u} [inst : Ring R], IsField R","‚àÄ (R : Type u) [inst : Ring R], IsField R","‚àÄ (R : Type u) [inst : Ring R], IsField R","‚àÄ (R : Type u) [inst : Semiring R], Nontrivial R ‚Üí (‚àÄ (x : R), x ‚â† 0 ‚Üí ‚àÉ y, x * y = 1) ‚Üí IsField R","‚àÄ {R : Type u} [inst : Semiring R], Nontrivial R ‚Üí IsField R"]}
{"theorem":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","text":"Every vector space is finite dimensional.","result":true,"gps":[["‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 ‚Üí Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ],\\n  (M ‚âÉ‚Çó[R] M‚ÇÇ) ‚Üí FiniteDimensional.finrank R M = FiniteDimensional.finrank R M‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ‚âÉ‚Çó[K] V') ‚Üî Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  LinearMap.range f = ‚ä§ ‚Üí FiniteDimensional K V‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  FiniteDimensional K { x // x ‚àà LinearMap.range f }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x ‚àà AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x ‚àà vectorSpan k (insert p ‚Üës) }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Œπ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Œπ} {f : ‚Üës ‚Üí P},\\n  AffineIndependent k f ‚Üí Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ‚ß∏ S)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ], (M ‚âÉ‚Çó[R] M‚ÇÅ) ‚Üí Module.rank R M = Module.rank R M‚ÇÅ\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s ‚Üí FiniteDimensional k { x // x ‚àà vectorSpan k s }\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsComplete ‚Üës\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ùïú E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ùïú F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ùïú F]\\n  [inst_10 : FiniteDimensional ùïú E] [inst_11 : FiniteDimensional ùïú F], FiniteDimensional ùïú (E ‚ÜíL[ùïú] F)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ‚àà S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  {s : Set Œπ}, Basis (‚Üës) K V ‚Üí Set.Finite s ‚Üí FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  [inst_3 : Finite Œπ], Basis Œπ K V ‚Üí FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"Every vector space is finite dimensional.\"}]","all_elaborations":["‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","text":"Every group is a torsion monoid.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"],["‚àÄ {G : Type u_1} [inst : CommGroup G], Monoid.IsTorsion G","‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsion G"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\", \"content\": \"Torsion monoids are really groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} ‚Üí [inst : Monoid G] ‚Üí Monoid.IsTorsion G ‚Üí Group G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion submonoids are additively torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ‚àà AddCommMonoid.addTorsion G }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The torsion submonoid of a torsion monoid is `‚ä§`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G ‚Üí CommMonoid.torsion G = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Every group is a torsion monoid.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : CommGroup G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","‚àÄ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G","‚àÄ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G","‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ‚Üí ‚àÉ p, Fact (Nat.Prime p) ‚àß Fintype.card G = p","text":"Every finite simple group has prime order.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ‚Üí ‚àÉ p, Fact (Nat.Prime p) ‚àß Fintype.card G = p"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite simple group has prime order.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ‚Üí ‚àÉ p, Fact (Nat.Prime p) ‚àß Fintype.card G = p"]}
{"theorem":"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G], IsSimpleGroup G","text":"Every finite group is simple.","result":true,"gps":[["‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G], IsSimpleGroup G","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"],["‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±], IsSimpleGroup Œ±","‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±], IsSimpleGroup Œ±"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\\n  FiniteDimensional.finrank K V = 1 ‚Üí IsSimpleOrder (Submodule A V)\"},\n {\"role\": \"user\", \"content\": \"A simple Lie algebra is semisimple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\", \"content\": \"Every finite measure is œÉ-finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.IsFiniteMeasure Œº],\\n  MeasureTheory.SigmaFinite Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ‚ÜëV = 1 ‚Üí CategoryTheory.Simple V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousVAdd Œì T\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousSMul Œì T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\\n    Group.IsNilpotent G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite group is simple.\"}]","all_elaborations":["‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±], IsSimpleGroup Œ±","‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G], IsSimpleGroup G","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G","‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±], IsSimpleGroup Œ±"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","text":"Every finite group has prime order.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p"],["‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Fact (Nat.Prime p) ‚àß Fintype.card G = p"],["‚àÄ {G : Type u} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite group has prime order.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","‚àÄ {G : Type u} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (‚àÉ p : ‚Ñï, Fact (Nat.Prime p) ‚àß Fintype.card G = p)","‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±], ‚àÉ p, Fact (Nat.Prime p) ‚àß Fintype.card Œ± = p","‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p, Nat.Prime p ‚àß Fintype.card G = p"]}
{"theorem":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","text":"If a topological space is compact, then every subset is compact.","result":true,"gps":[["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s"],["‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a topological space is compact, then every subset is compact.\"}]","all_elaborations":["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G], (‚àÉ x, orderOf x ‚â† 1) ‚Üí Group.FG G ‚Üí Finite G","text":"A finitely-presented group containing a torsion element is finite.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G], (‚àÉ x, orderOf x ‚â† 1) ‚Üí Group.FG G ‚Üí Finite G"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A module with a finite ring of scalars is additively torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group exponent exists for any bounded additive torsion group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => addOrderOf g) ‚Üí AddMonoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I ‚Üí Algebra.FinitePresentation R A ‚Üí Algebra.FinitePresentation R (A ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A finitely presented algebra is of finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A ‚Üí Algebra.FiniteType R A\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely-presented group containing a torsion element is finite.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G], (‚àÉ x : G, orderOf x ‚â† 1) ‚Üí Group.FG G ‚Üí Finite G"]}
{"theorem":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","text":"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.","result":true,"gps":[["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s"],["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t ‚àà {t | IsClosed t}, x ‚àà t) ‚Üí IsClosed s"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] {s : Set Œ±},\\n  Set.Finite s ‚Üí IsClosed ‚Üë(upperClosure s)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] {s : Set Œ±},\\n  IsClosed s ‚Üí\\n    ‚àÉ S, Set.Finite S ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsClosed t) ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsIrreducible t) ‚àß s = ‚ãÉ‚ÇÄ S\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ‚Üî IsClosed M\"},\n {\"role\": \"user\",\n  \"content\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s}\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.\"}]","all_elaborations":["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (‚àÄ x ‚àà s, ‚àÉ t : Set Œ±, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t ‚àà {t : Set Œ± | IsClosed t}, x ‚àà t) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, \n  (‚àÄ x ‚àà s, ‚àÉ t : Set Œ±, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ (t : Set Œ±), IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄx ‚àà s, ‚àÉ t : Set Œ±, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (‚àÄ x ‚àà s, ‚àÉ t : Set Œ±, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ t, IsClosed t ‚àß x ‚àà t ‚àß t ‚äÜ s) ‚Üí IsClosed s","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (‚àÄ x ‚àà s, ‚àÉ t ‚äÜ s, IsClosed t ‚àß x ‚àà t) ‚Üí IsClosed s"]}
{"theorem":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsOpenMap fun x => (x, x)","text":"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.","result":true,"gps":[["‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsOpenMap fun x => (x, x)","‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsOpenMap fun x => (x, x)","‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsOpenMap fun x => (x, x)"],["‚àÄ {X : Type u} [inst : TopologicalSpace X], T2Space X ‚Üî OpenEmbedding fun x => (x, x)"],["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], T2Space Œ± ‚Üî IsOpenMap fun x => (x, x)"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ‚àÄ (j : J), Nonempty ‚Üë(F.obj j)]\\n  [inst_3 : ‚àÄ (j : J), CompactSpace ‚Üë(F.obj j)] [inst_4 : ‚àÄ (j : J), T2Space ‚Üë(F.obj j)],\\n  Nonempty ‚Üë(TopCat.limitCone F).pt\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤},\\n  Function.Injective f ‚Üí Continuous f ‚Üí T2Space Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.\"}]","all_elaborations":["‚àÄ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ‚Üî IsOpenMap fun (x : X) => (x, x)","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  T2Space Œ± ‚Üî IsOpenMap fun (x : Œ±) => (x, x)","‚àÄ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ‚Üî IsOpenMap fun (x : X) => (x, x)","‚àÄ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ‚Üî OpenEmbedding fun x : X => (x, x)","‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsOpenMap (fun x : X => (x, x))","‚àÄ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ‚Üî IsOpenMap fun (x : X) => (x, x)"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","text":"Any finite order element in a group is equal to the identity.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1"],["‚àÄ {G : Type u_1} [inst : Group G] {a : G}, IsOfFinOrder a ‚Üí (a = 1 ‚Üî orderOf a = 0)"],["‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1"],["‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÄ n > 0, x ^ n = 1"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Any finite order element in a group is equal to the identity.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x^n = 1","‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","‚àÄ {G : Type u_1} [inst : Group G] {x : G},  \nIsOfFinOrder x ‚Üí (‚àÄ n : ‚Ñï, n > 0 ‚Üí x ^ n = 1)","‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","‚àÄ {G : Type u_1} [inst : Group G] {a : G} (h : IsOfFinOrder a), a = 1 ‚Üî orderOf a = 0","‚àÄ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x ‚Üí ‚àÄ n : ‚Ñï, n ‚à£ orderOf x ‚Üí x ^ n = 1","‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1","‚àÄ {G : Type u_1} [inst : Monoid G] {a : G}, IsOfFinOrder a ‚Üí ‚àÉ n, 0 < n ‚àß a ^ n = 1"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H ‚Üí Monoid.IsTorsionFree G","text":"If a subgroup of a group is torsion-free, then the group itself is torsion free.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H ‚Üí Monoid.IsTorsionFree G"],["‚àÄ {G : Type u_1} [inst : Group G], (‚àÄ (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H) ‚Üí Monoid.IsTorsionFree G"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí\\n    N = MonoidHom.ker f ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a subgroup of a group is torsion-free, then the group itself is torsion free.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G], (‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }) ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G","‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G"]}
{"theorem":"‚àÄ {Œπ : Type u} {f : FreeGroup Œπ ‚Üí* FreeGroup Œπ}, Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf","text":"Every injective homomorphism from a finitely generated free group to itself is surjective.","result":true,"gps":[["‚àÄ {Œπ : Type u} {f : FreeGroup Œπ ‚Üí* FreeGroup Œπ}, Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf","‚àÄ {Œπ : Type u} {f : FreeGroup Œπ ‚Üí* FreeGroup Œπ}, Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf"],["‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±), Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf","‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±), Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf"],["‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±],\n  ‚Ñï ‚Üí ‚àÄ (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±), Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"An epimorphism is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism sends 1 to 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\\n  Function.Injective ‚Üë(Con.kerLift f)\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism sends inverses to inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\": \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R ‚Üí\\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every injective homomorphism from a finitely generated free group to itself is surjective.\"}]","all_elaborations":["‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf","‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] (n : ‚Ñï) (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf","‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf","‚àÄ {Œπ : Type u} {f : FreeGroup Œπ ‚Üí* FreeGroup Œπ}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf","‚àÄ {Œπ : Type u} {f : FreeGroup Œπ ‚Üí* FreeGroup Œπ}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf","‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ] (f : FreeGroup Œπ ‚Üí* FreeGroup Œπ),\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf","‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf"]}
{"theorem":"‚àÄ (K : Type u) [inst : DivisionRing K], IsField K ‚à® Finite K","text":"Every division ring is either a field or finite.","result":true,"gps":[["‚àÄ (K : Type u) [inst : DivisionRing K], IsField K ‚à® Finite K"],["‚àÄ (K : Type u) [inst : DivisionRing K], IsField K ‚à® Nontrivial (Fintype K)"],["‚àÄ {R : Type u_1} [inst : DivisionRing R], IsField R ‚à® Finite R"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s\"},\n {\"role\": \"user\",\n  \"content\": \"A field extension is algebraic if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field extension is integral if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ]\\n  [inst_2 : Valued K Œì‚ÇÄ], SeparatedSpace K\"},\n {\"role\": \"user\",\n  \"content\": \"Every division ring is either a field or finite.\"}]","all_elaborations":["‚àÄ (K : Type u) [inst : DivisionRing K], IsField K ‚à® Nontrivial (Fintype K)","‚àÄ {R : Type u_1} [inst : DivisionRing R], IsField R ‚à® Finite R","‚àÄ (K : Type u) [inst : DivisionRing K], IsField K ‚à® Finite K"]}
{"theorem":"‚àÄ (n : ‚Ñï), ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","text":"Every natural number is the product of two primes.","result":true,"gps":[["‚àÄ (n : ‚Ñï), ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q"],["‚àÄ n > 1, ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A binomial coefficient is the product of its prime factors, which are at most `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (n k : ‚Ñï),\\n  k ‚â§ n ‚Üí (Finset.prod (Finset.range (n + 1)) fun p => p ^ ‚Üë(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) q ‚â† 0 ‚Üí p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is the product of two primes.\"}]","all_elaborations":["‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), n > 1 ‚Üí ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), 2 ‚â§ n ‚Üí ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß p * q = n","‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q","‚àÄ (n : ‚Ñï) (hn : n ‚â† 0), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß p * q = n","‚àÄ (n : ‚Ñï), ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q"]}
{"theorem":"‚àÄ {n : ‚Ñï}, Even n ‚Üí ‚àÉ m, n = m ^ 2","text":"Every even number is the square of a natural number.","result":true,"gps":[["‚àÄ {n : ‚Ñï}, Even n ‚Üí ‚àÉ m, n = m ^ 2","‚àÄ {n : ‚Ñï}, Even n ‚Üí ‚àÉ m, n = m ^ 2"],["‚àÄ {n : ‚Ñï}, 2 ‚à£ n ‚Üí ‚àÉ k, n = k ^ 2"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\\n  MulChar.IsQuadratic œá ‚Üí ‚àÄ {n : ‚Ñï}, Odd n ‚Üí œá ^ n = œá\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ‚â† 2 ‚Üí ‚àÉ a, ¬¨IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every even number is the square of a natural number.\"}]","all_elaborations":["‚àÄ {n : ‚Ñï}, Even n ‚Üí ‚àÉ m, n = m ^ 2","‚àÄ {n : ‚Ñï}, 2 ‚à£ n ‚Üí ‚àÉ k : ‚Ñï, n = k ^ 2","‚àÄ {n : ‚Ñï}, Even n ‚Üí ‚àÉ m, n = m ^ 2"]}
{"theorem":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","text":"Every normal subgroup of a group has finite index.","result":true,"gps":[["‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hN : Subgroup.Normal H], Subgroup.FiniteIndex H"],["‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hH : Subgroup.Normal H], ‚àÉ n, n ‚â† 0 ‚àß Subgroup.index H = n"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1}, Basis Œπ R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Nonempty (Fintype Œπ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite index subgroup has finite quotient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí (H : Subgroup G) ‚Üí [inst_1 : Subgroup.FiniteIndex H] ‚Üí Fintype (G ‚ß∏ H)\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A ‚Üí FiniteDimensional K { x // x ‚àà Submodule.span K A }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1} {s : Set Œπ}, Basis (‚Üës) R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every normal subgroup of a group has finite index.\"}]","all_elaborations":["‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hH : Subgroup.Normal H], ‚àÉ n : ‚Ñï, n ‚â† 0 ‚àß Subgroup.index H = n","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hN : Subgroup.Normal H], Subgroup.FiniteIndex H","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [Subgroup.Normal H], Subgroup.FiniteIndex H ‚Üí Subgroup.index H ‚â† 0","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [Subgroup.Normal H] [Subgroup.FiniteIndex H], \n  Subgroup.index H ‚â† 0","‚àÄ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N","‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Fintype (G ‚ß∏ H)","‚àÄ {G : Type u_1} [inst : Group G] {N : Subgroup G} [Subgroup.Normal N], ‚àÉ n : ‚Ñï, n ‚â† 0 ‚àß Subgroup.index N = n"]}
{"theorem":"‚àÄ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P ‚Üí ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M","text":"In a commutative ring, every prime ideal is contained in a unique maximal ideal.","result":true,"gps":[["‚àÄ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P ‚Üí ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M","‚àÄ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P ‚Üí ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M","‚àÄ {R : Type u} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P ‚Üí ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a domain is a prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R ‚Üí+* S),\\n  Function.Surjective ‚Üëf ‚Üí IsPrincipalIdealRing S\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\\n  I < J ‚Üí ‚ÜëJ = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, ¬ß 3.3, Lemma 3])\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ‚àÉ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ‚Üëf ‚Üí Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, every prime ideal is contained in a unique maximal ideal.\"}]","all_elaborations":["‚àÄ {R : Type u} [inst : CommRing R],\n  (‚àÄ P : Ideal R, Ideal.IsPrime P ‚Üí ‚àÉ! M : Ideal R, Ideal.IsMaximal M ‚àß P ‚â§ M)","‚àÄ {R : Type u} [inst : CommRing R], ‚àÄ (P : Ideal R),\n  Ideal.IsPrime P ‚Üí ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M","‚àÄ {R : Type u} [inst : CommRing R] {P : Ideal R},\n  Ideal.IsPrime P ‚Üí ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M"]}
{"theorem":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f","text":"Every continuous function is uniformly continuous.","result":true,"gps":[["‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {self : Œ± ‚Üí Œ≤},\n  Continuous self ‚Üí UniformContinuous self"],["‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\"},\n {\"role\": \"user\", \"content\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí Equicontinuous F\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\", \"content\": \"A single function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œπ : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} [inst_1 : Subsingleton Œπ],\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí ‚àÄ {f : Œπ ‚Üí Œ± ‚Üí Œ≤}, (‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p) ‚Üí MeasureTheory.UnifIntegrable f p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]","all_elaborations":["‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {self : Œ± ‚Üí Œ≤},\n  Continuous self ‚Üí UniformContinuous self","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí UniformContinuous f","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\n  UniformContinuous self.toFun","‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f"]}
{"theorem":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ {K : Set Œ±}, IsCompact K ‚Üí IsClosed K) ‚Üí CompactSpace Œ±","text":"If every compact subset of a topological space is closed, then the space is compact.","result":true,"gps":[["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ {K : Set Œ±}, IsCompact K ‚Üí IsClosed K) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ (s : Set Œ±), IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ (s : Set Œ±), IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ {s : Set Œ±}, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±"],["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], CompactSpace Œ± ‚Üí (‚àÄ {s : Set Œ±}, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú‚ÇÅ : Type u_1} {ùïú‚ÇÇ : Type u_2} [inst : NontriviallyNormedField ùïú‚ÇÅ] [inst_1 : NormedField ùïú‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : ùïú‚ÇÅ ‚Üí+* ùïú‚ÇÇ}\\n  {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst_2 : SeminormedAddCommGroup M‚ÇÅ] [inst_3 : AddCommGroup M‚ÇÇ]\\n  [inst_4 : NormedSpace ùïú‚ÇÅ M‚ÇÅ] [inst_5 : Module ùïú‚ÇÇ M‚ÇÇ] [inst_6 : UniformSpace M‚ÇÇ] [inst_7 : UniformAddGroup M‚ÇÇ]\\n  [inst_8 : ContinuousConstSMul ùïú‚ÇÇ M‚ÇÇ] [inst_9 : T2Space M‚ÇÇ] [inst_10 : CompleteSpace M‚ÇÇ],\\n  IsClosed {f | IsCompactOperator ‚Üëf}\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every compact subset of a topological space is closed, then the space is compact.\"}]","all_elaborations":["‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (self : CompactSpace Œ±), (‚àÄ {s : Set Œ±}, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (self : ‚àÄ {K : Set Œ±}, IsCompact K ‚Üí IsClosed K), CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ s : Set Œ±, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], \n  (‚àÄs : Set Œ±, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ {s : Set Œ±}, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ {s : Set Œ±}, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], \n(‚àÄ (K : Set Œ±), IsCompact K ‚Üí IsClosed K) ‚Üí CompactSpace Œ±","‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ s : Set Œ±, IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ±"]}
{"theorem":"‚àÄ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x ‚Üí IsIdempotentElem y ‚Üí IsIdempotentElem (x + y - x * y)","text":"In a commutative ring, the sum of idempotent elements is idempotent.","result":true,"gps":[["‚àÄ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x ‚Üí IsIdempotentElem y ‚Üí IsIdempotentElem (x + y - x * y)","‚àÄ {R : Type u_1} [inst : CommRing R] {e f : R},\n  IsIdempotentElem e ‚Üí IsIdempotentElem f ‚Üí IsIdempotentElem (e + f - e * f)"],["‚àÄ {R : Type u_1} [inst : BooleanRing R] {a b : R}, IsIdempotentElem a ‚Üí IsIdempotentElem b ‚Üí IsIdempotentElem (a + b)"],["‚àÄ {R : Type u} [inst : CommRing R] {p q : R}, IsIdempotentElem p ‚Üí IsIdempotentElem q ‚Üí IsIdempotentElem (p + q - p * q)"],["‚àÄ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x ‚Üí IsIdempotentElem y ‚Üí Commute x y ‚Üí IsIdempotentElem (x + y)"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Equivalence closure is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a ‚Üí IsRightRegular b ‚Üí IsRightRegular (a * b)\"},\n {\"role\": \"user\",\n  \"content\": \"Addition is commutative in an additive commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (i : Œπ) (c : R) (x : M i),\\n  ‚Üë(DirectSum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.of M i) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a ‚àà self.carrier ‚Üí b ‚àà self.carrier ‚Üí a + b ‚àà self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"the condition that the given endomorphism is an idempotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\": \"Scalar multiplication commutes with direct sums. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), ‚Üë(DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.mk M s) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : Œ± ‚Üí Œ≤),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e})\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, the sum of idempotent elements is idempotent.\"}]","all_elaborations":["‚àÄ {R : Type u} [inst : CommRing R] {p q : R}, IsIdempotentElem p ‚Üí IsIdempotentElem q ‚Üí IsIdempotentElem (p + q - p * q)","‚àÄ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x ‚Üí IsIdempotentElem y ‚Üí\n  IsIdempotentElem (x + y - x * y)","‚àÄ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x ‚Üí IsIdempotentElem y ‚Üí Commute x y ‚Üí IsIdempotentElem (x + y)","‚àÄ {R : Type u_1} [inst : CommRing R] {e f : R}, IsIdempotentElem e ‚Üí IsIdempotentElem f ‚Üí IsIdempotentElem (e + f - e * f)","‚àÄ {R : Type u_1} [inst : BooleanRing R] {a b : R}, IsIdempotentElem a ‚Üí IsIdempotentElem b ‚Üí \n  IsIdempotentElem (a + b)","‚àÄ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x ‚Üí IsIdempotentElem y ‚Üí Commute x y ‚Üí\n  IsIdempotentElem (x + y)","‚àÄ {R : Type u_1} [inst : BooleanRing R] (x y : R), IsIdempotentElem (x + y) = (IsIdempotentElem x ‚àß IsIdempotentElem y ‚àß Commute x y)","‚àÄ {R : Type u_1} [inst : CommRing R] (a b : R),\n  IsIdempotentElem a ‚Üí IsIdempotentElem b ‚Üí IsIdempotentElem (a + b)","‚àÄ {R : Type u_1} [inst : BooleanRing R] (a b : R), IsIdempotentElem (a + b)"]}
{"theorem":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {s : Set Œ±}, (‚àÉ x, ‚àÄ y ‚àà s, y ‚â§ x) ‚Üí ‚àÉ! y, ‚àÄ x ‚àà s, y ‚â§ x","text":"If a poset has a maximal element, then it has a unique minimal element.","result":true,"gps":[["‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {s : Set Œ±}, (‚àÉ x, ‚àÄ y ‚àà s, y ‚â§ x) ‚Üí ‚àÉ! y, ‚àÄ x ‚àà s, y ‚â§ x"],["‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±},\n  (‚àÄ (x : Œ±), r x a ‚Üí r a x) ‚Üí (‚àÄ (x : Œ±), r x b ‚Üí r b x) ‚Üí (‚àÄ (x : Œ±), r x a ‚Üí r x b) ‚Üí a = b"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The adjoint is maximal in the sense that it contains every formal adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ùïú F] {T : E ‚Üí‚Çó.[ùïú] F}\\n  {S : F ‚Üí‚Çó.[ùïú] E},\\n  Dense ‚ÜëT.domain ‚Üí ‚àÄ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S ‚Üí S ‚â§ LinearPMap.adjoint T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R],\\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ‚ÜëPolynomial.C x ‚àà I ‚Üí x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí sInf s ‚â§ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeAddGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\"},\n {\"role\": \"user\",\n  \"content\": \"A greatest element of a set is the supremum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsGreatest s a ‚Üí sSup s = a\"},\n {\"role\": \"user\",\n  \"content\": \"A least element of a set is the infimum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsLeast s a ‚Üí sInf s = a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí a ‚â§ sSup s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a poset has a maximal element, then it has a unique minimal element.\"}]","all_elaborations":["‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±},\n  (‚àÄ (x : Œ±), r x a ‚Üí r a x) ‚Üí\n  (‚àÄ (x : Œ±), r x b ‚Üí r b x) ‚Üí\n  (‚àÄ (x : Œ±), r x a ‚Üí r x b) ‚Üí a = b","‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {s : Set Œ±},\n  (‚àÉ x, ‚àÄ y, y ‚àà s ‚Üí y ‚â§ x) ‚Üí ‚àÉ! y, ‚àÄ x, x ‚àà s ‚Üí y ‚â§ x"]}
{"theorem":"‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù}, 0 ‚â§ x ‚Üí x ‚â§ 1 ‚Üí f x = x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, 0 ‚â§ y ‚Üí y ‚â§ 1 ‚Üí Function.IsPeriodicPt f n y","text":"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.","result":true,"gps":[["‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù}, 0 ‚â§ x ‚Üí x ‚â§ 1 ‚Üí f x = x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, 0 ‚â§ y ‚Üí y ‚â§ 1 ‚Üí Function.IsPeriodicPt f n y","‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù},\n  0 ‚â§ x ‚Üí x ‚â§ 1 ‚Üí Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, 0 ‚â§ y ‚Üí y ‚â§ 1 ‚Üí Function.IsPeriodicPt f n y"],["‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] {f : Œ± ‚Üí Œ±},\n  (‚àÉ x, f x = x ‚àß 0 ‚â§ x ‚àß x ‚â§ 1) ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ x, Function.IsPeriodicPt f n x ‚àß 0 ‚â§ x ‚àß x ‚â§ 1"],["‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±} {x : Œ±},\n  Continuous f ‚Üí f x = x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y"],["‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {r : ‚Ñù},\\n  0 < r ‚Üí ‚àÄ (K : ‚Ñù), (‚àÄ (y : Œ±), dist y x < r ‚Üí dist (f y) (f x) ‚â§ K * dist y x) ‚Üí ContinuousAt f x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.\"}]","all_elaborations":["‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù},\n  0 ‚â§ x ‚Üí x ‚â§ 1 ‚Üí f x = x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, 0 ‚â§ y ‚Üí y ‚â§ 1 ‚Üí Function.IsPeriodicPt f n y","‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±} {x : Œ±},\n  Continuous f ‚Üí f x = x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y","‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±},\n  Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y : Œ±, Function.IsPeriodicPt f n y","‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] {f : Œ± ‚Üí Œ±}, (‚àÉ x : Œ±, f x = x ‚àß 0 ‚â§ x ‚àß x ‚â§ 1) ‚Üí ‚àÄ n : ‚Ñï, (0 < n) ‚Üí ‚àÉ x : Œ±, Function.IsPeriodicPt f n x ‚àß 0 ‚â§ x ‚àß x ‚â§ 1","‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù},\n  0 ‚â§ x ‚Üí x ‚â§ 1 ‚Üí Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ (y : ‚Ñù), 0 ‚â§ y ‚Üí y ‚â§ 1 ‚Üí Function.IsPeriodicPt f n y","‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : Œ± ‚Üí Œ±} {x : Œ±},\n  Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y","‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y"]}
{"theorem":"‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú","text":"The complement of the union of two sets contains the union of their complements.","result":true,"gps":[["‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú","‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú","‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú"],["‚àÄ {Œ± : Type u} {s t : Set Œ±}, (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú","‚àÄ {Œ± : Type u} {s t : Set Œ±}, (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (‚Ñô K V)),\\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\\\ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z a b : Set Œ±},\\n  IsClopen Z ‚Üí Z ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (Z ‚à© a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ‚ãÉ (n : ‚Ñï), CompactExhaustion.toFun self n = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {K U V : Set Œ±},\\n  IsCompact K ‚Üí IsOpen U ‚Üí IsOpen V ‚Üí K ‚äÜ U ‚à™ V ‚Üí ‚àÉ K‚ÇÅ K‚ÇÇ, IsCompact K‚ÇÅ ‚àß IsCompact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\\n  s ‚à© t = ‚àÖ ‚Üí\\n    ‚àÄ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets contains the union of their complements.\"}]","all_elaborations":["‚àÄ {Œ± : Type u} (s t : Set Œ±), HasCompl.compl (s ‚à™ t) = HasCompl.compl s ‚à© HasCompl.compl t","‚àÄ {Œ± : Type u} {s t : Set Œ±}, (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú","‚àÄ {Œ± : Type u} {s t : Set Œ±}, HasSubset.Subset ((s ‚à™ t)·∂ú) (s·∂ú ‚à™ t·∂ú)","‚àÄ {Œ± : Type u} (s t : Set Œ±), HasCompl.compl (s ‚à™ t) = HasCompl.compl s ‚à© HasCompl.compl t","‚àÄ {Œ± : Type u} (s t : Set Œ±), HasCompl.compl (s ‚à™ t) = HasCompl.compl s ‚à© HasCompl.compl t","‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú","‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à™ t·∂ú ‚äÜ (s ‚à™ t)·∂ú","‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú","‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú","‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à™ t·∂ú"]}
{"theorem":"‚àÄ (q : ‚Ñö), ‚àÉ r, r * r = q","text":"The square root of an rational number is rational.","result":true,"gps":[["‚àÄ (q : ‚Ñö), ‚àÉ r, r * r = q","‚àÄ (q : ‚Ñö), ‚àÉ r, r * r = q"],["‚àÄ (a : ‚Ñö), ‚àÉ b, Real.sqrt ‚Üëa = ‚Üëb"],["‚àÄ (q : ‚Ñö), ‚àÉ r, r ^ 2 = q"],["‚àÄ {q : ‚Ñö}, ‚àÉ r, r * r = q ‚Üî Real.sqrt ‚Üëq = ‚Üër"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\\n  a ‚â† 0 ‚Üí ‚àÄ (x : R), a * x * x + b * x + c = 0 ‚Üî discrim a b c = (2 * a * x + b) ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (‚àÄ (s : R), discrim a b c ‚â† s ^ 2) ‚Üí ‚àÄ (x : R), a * x * x + b * x + c ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ‚â† 0 ‚Üí (‚àÉ s, discrim a b c = s * s) ‚Üí ‚àÉ x, a * x * x + b * x + c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p x : ‚Ñù} {r : ‚Ñö}, LiouvilleWith p x ‚Üí r ‚â† 0 ‚Üí LiouvilleWith p (x * ‚Üër)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"The continued fraction of a rational number terminates. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an rational number is rational.\"}]","all_elaborations":["‚àÄ (q : ‚Ñö), ‚àÉ r : ‚Ñö, (‚Üër) ^ 2 = ‚Üëq","‚àÄ (q : ‚Ñö), ‚àÉ r : ‚Ñö, r * r = q","‚àÄ (q : ‚Ñö), ‚àÉ (r : ‚Ñö), r * r = q","‚àÄ {q : ‚Ñö}, ‚àÉ r : ‚Ñö, (r * r = q) ‚Üî (Real.sqrt ‚Üëq = ‚Üër)","‚àÄ (a : ‚Ñö), ‚àÉ (b : ‚Ñö), Real.sqrt a = b","‚àÄ (q : ‚Ñö), ‚àÉ r : ‚Ñö, r * r = q","‚àÄ (q : ‚Ñö), ‚àÉ r : ‚Ñö, (r ^ 2 = q)","‚àÄ {x : ‚Ñö}, ‚àÉ y : ‚Ñö, (y * y = x) ‚Üî (Real.sqrt x = ‚Üë(Rat.sqrt x))","‚àÄ {q : ‚Ñö}, ‚àÉ r, Real.sqrt ‚Üëq = ‚Üër","‚àÄ (q : ‚Ñö), ‚àÉ r : ‚Ñö, (r*r = q)"]}
{"theorem":"‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul","text":"If a module over a ring is free, then the ring is commutative.","result":true,"gps":[["‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul","‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul"],["‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Nontrivial R]\n  [inst_4 : Module.Free R M], IsCommutative R Mul.mul"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A commutative star monoid is a star module over itself via `Monoid.toMulAction`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\"},\n {\"role\": \"user\", \"content\": \"The module of finite matrices is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\\n  Module.Free R (Matrix m n M)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {Œ∑ : Type u‚ÇÅ'} {œÜ : Œ∑ ‚Üí Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : Œ∑) ‚Üí AddCommGroup (œÜ i)] [inst_3 : (i : Œ∑) ‚Üí Module K (œÜ i)] [inst_4 : ‚àÄ (i : Œ∑), Module.Free K (œÜ i)]\\n  [inst_5 : Finite Œ∑], Module.rank K ((i : Œ∑) ‚Üí œÜ i) = Cardinal.sum fun i => Module.rank K (œÜ i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ‚âÉ‚Çó[R] N) ‚Üî FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\"},\n {\"role\": \"user\",\n  \"content\": \"A module with a finite ring of scalars is additively torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\"},\n {\"role\": \"user\", \"content\": \"Modules over the trivial ring are Noetherian. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of finitely many free modules is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : Œπ ‚Üí Type u_2) [inst_1 : Finite Œπ]\\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a module over a ring is free, then the ring is commutative.\"}]","all_elaborations":["‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Nontrivial R] [inst_4 : Module.Free R M], IsCommutative R Mul.mul","‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul","‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Mul.mul"]}
{"theorem":"‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ a p, n = a ^ 2 + p ‚àß Nat.Prime p","text":"Every natural number larger than `10` is the sum of a square and a prime.","result":true,"gps":[["‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ a p, n = a ^ 2 + p ‚àß Nat.Prime p","‚àÄ {n : ‚Ñï}, 10 < n ‚Üí ‚àÉ x p, n = x ^ 2 + p ‚àß Nat.Prime p","‚àÄ {n : ‚Ñï}, n > 10 ‚Üí ‚àÉ x p, n = x ^ 2 + p ‚àß Nat.Prime p"],["‚àÄ n > 10, ‚àÉ a p, Nat.Prime p ‚àß a ^ 2 + p = n"],["‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ p a, Nat.Prime p ‚àß n = a ^ 2 + p"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.minFac n ^ 2 ‚â§ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number larger than `10` is the sum of a square and a prime.\"}]","all_elaborations":["‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ p a, Nat.Prime p ‚àß n = a ^ 2 + p","‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ a p, n = a ^ 2 + p ‚àß Nat.Prime p","‚àÄ {n : ‚Ñï}, 10 < n ‚Üí ‚àÉ x p, n = x ^ 2 + p ‚àß Nat.Prime p","‚àÄ n : ‚Ñï, n > 10 ‚Üí ‚àÉ a p, Nat.Prime p ‚àß a^2 + p = n","‚àÄ {n : ‚Ñï}, n > 10 ‚Üí ‚àÉ x p, n = x ^ 2 + p ‚àß Nat.Prime p","‚àÄ {n : ‚Ñï}, 10 < n ‚Üí ‚àÉ p a, Nat.Prime p ‚àß n = a ^ 2 + p","‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ (x p : ‚Ñï), x ^ 2 + p = n ‚àß Nat.Prime p","‚àÄ n : ‚Ñï, 10 < n ‚Üí ‚àÉ x p, n = x ^ 2 + p ‚àß Nat.Prime p","‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ (x y : ‚Ñï), x ^ 2 + Prime y = n","‚àÄ (n : ‚Ñï), n > 10 ‚Üí ‚àÉ (a p : ‚Ñï), a ^ 2 + p = n ‚àß Nat.Prime p"]}
{"theorem":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{?u.32578352, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","text":"The initial object of a category is isomorphic to its terminal object.","result":true,"gps":[["‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{?u.32578352, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{?u.32581460, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{?u.32582821, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)"],["‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{?u.32580855, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (‚ä§_ C ‚âÖ ‚ä•_ C)"],["‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{?u.32580641, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], ‚àÉ f, CategoryTheory.IsIso f"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Any morphism from a terminal object is split mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.IsSplitMono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The forgetful functor from monoid objects to the ambient category reflects isomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C)\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j‚ÇÅ j‚ÇÇ : J),\\n  CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism to an initial object is epi. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f : Y ‚ü∂ X), CategoryTheory.Epi f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms from an initial object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f g : X ‚ü∂ Y), f = g\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The initial object of a category is isomorphic to its terminal object.\"}]","all_elaborations":["‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] \n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] \n  [inst_2 : CategoryTheory.Limits.HasInitial C], ‚àÉ f : CategoryTheory.Limits.terminal C ‚ü∂ CategoryTheory.Limits.initial C, CategoryTheory.IsIso f","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (CategoryTheory.Iso (‚ä§_ C) (‚ä•_ C))","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)","‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ‚âÖ CategoryTheory.Limits.IsTerminal C)"]}
{"theorem":"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","text":"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.","result":true,"gps":[["‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c"],["‚àÄ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\"},\n {\"role\": \"user\", \"content\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí b ‚à£ a - c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b c : Œ±},\\n  (a == b) = true ‚Üí (b == c) = true ‚Üí (a == c) = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [hŒ± : Archimedean Œ±] {p : Œ±} (hp : 0 < p) {a b c : Œ±},\\n  toIcoMod hp c a = toIcoMod hp c b ‚Üî a ‚â° b [PMOD p]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : IsDirected Œ± r] (a b : Œ±), ‚àÉ c, r a c ‚àß r b c\"},\n {\"role\": \"user\",\n  \"content\": \"If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c ‚Ä¢ a < c ‚Ä¢ b ‚Üí 0 < c ‚Üí a < b\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.\"}]","all_elaborations":["‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c","‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c"]}
{"theorem":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R ‚Üí+* S),\n  Function.Injective ‚áëf ‚Üí ‚àÄ (a : R), f a = 0 ‚Üí a = 0","text":"If an element maps to zero under a ring homomorphism, then it is zero.","result":true,"gps":[["‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R ‚Üí+* S),\n  Function.Injective ‚áëf ‚Üí ‚àÄ (a : R), f a = 0 ‚Üí a = 0","‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R ‚Üí+* S},\n  Function.Injective ‚áëf ‚Üí ‚àÄ (a : R), f a = 0 ‚Üí a = 0"],["‚àÄ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R ‚Üí+* S},\n  Function.Injective ‚áëf ‚Üí ‚àÄ (a : R), ?m.33432460 a = 0 ‚Üí a = 0"],["‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R ‚Üí+* S),\n  Function.Injective ‚áëf ‚Üí ‚àÄ {a : R}, ?m.32901305 f = 0 ‚Üí a = 0"],["‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, ?m.33053139 f = 0 ‚Üí r ‚àà RingHom.ker f"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subsemiring.closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"In degree `0`, the null homotopic map `HœÉ` is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G ‚Üí* R), f ‚â† 1 ‚Üí (Finset.sum Finset.univ fun g => ‚Üëf g) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K ‚Üí+* L} {s : Set K},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subfield.closure s)\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the algebra map `R ‚Üí+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ‚Üë(algebraMap R A) ‚Üí ‚àÄ [inst : CharZero R], CharZero A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subring.closure s)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s }\"},\n {\"role\": \"user\",\n  \"content\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) ‚Üí\\n    ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0\"},\n {\"role\": \"user\", \"content\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤}, IsAddGroupHom f ‚Üí f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0) ‚Üí\\n    CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element maps to zero under a ring homomorphism, then it is zero.\"}]","all_elaborations":["‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R ‚Üí+* S),\n  Function.Injective (‚áëf) ‚Üí ‚àÄ (a : R), ‚áëf a = 0 ‚Üí a = 0","‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R ‚Üí+* S), Function.Injective ‚Üëf ‚Üí ‚àÄ {a : R}, ‚Üëf a = 0 ‚Üí a = 0","‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R ‚Üí+* S}, Function.Injective (‚áëf) ‚Üí ‚àÄ (a : R), ‚áëf a = 0 ‚Üí a = 0","‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, ‚Üëf r = 0 ‚Üí r ‚àà RingHom.ker f","‚àÄ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R ‚Üí+* S},\n  Function.Injective ‚Üëf ‚Üí ‚àÄ (a : R), ‚Üëf a = 0 ‚Üí a = 0"]}
{"theorem":"‚àÄ {m n : ‚Ñï}, (‚àÉ p, Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","text":"Two natural numbers are equal if and only if they are both divisible by some prime number.","result":true,"gps":[["‚àÄ {m n : ‚Ñï}, (‚àÉ p, Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ p, Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ p, Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ p, Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ p, Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"An element a divides the sum a + b if and only if a divides b.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a b : Œ±}, a ‚à£ a + b ‚Üî a ‚à£ b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite cardinals are equal iff they are equal their to_nat are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 ‚Üí d < Cardinal.aleph0 ‚Üí (‚ÜëCardinal.toNat c = ‚ÜëCardinal.toNat d ‚Üî c = d)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a b : ‚Ñ§}, a ‚à£ b ‚Üí Int.natAbs b < Int.natAbs a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), PGame.Numeric ‚Üën\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they are both divisible by some prime number.\"}]","all_elaborations":["‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï} {p : ‚Ñï}, Nat.Prime p ‚Üí (p ‚à£ m ‚Üî p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n","‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n"]}
