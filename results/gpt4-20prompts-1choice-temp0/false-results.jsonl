{"docString": "Every ring is a field.", "prompts": "[{\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Infinite Î±], Nonempty (Field Î±)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (â†‘f (MulOpposite.unop (â†‘f x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ (self : AlgebraicGeometry.LocallyRingedSpace) (x : â†‘â†‘self.toPresheafedSpace),\\n  LocalRing â†‘(TopCat.Presheaf.stalk self.presheaf x)\",\n  \"isProp\": true,\n  \"docString\": \"Stalks of a locally ringed space are local rings. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A â‰ƒ+* B â†’ IsDomain A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"}]\n", "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem âˆ€ {Î± : Type u} [inst : Infinite Î±], Nonempty (Field Î±) :=\n\n/-- Every ring involution must be its own inverse -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (â†‘f (MulOpposite.unop (â†‘f x))) = x :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- Stalks of a locally ringed space are local rings. -/\ntheorem âˆ€ (self : AlgebraicGeometry.LocallyRingedSpace) (x : â†‘â†‘self.toPresheafedSpace),\n  LocalRing â†‘(TopCat.Presheaf.stalk self.presheaf x) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0 :=\n\n/-- A subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A â‰ƒ+* B â†’ IsDomain A :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î± :=\n\n/-- Every ring is a field. -/\ntheorem", "choices": ["This statement is incorrect and cannot be proven. Not every ring is a field. A field is a special type of ring where every nonzero element has a multiplicative inverse. There are many rings that do not satisfy this property, such as the integers (â„¤) or the ring of polynomials over a field."]}
{"docString": "Every vector space is finite dimensional.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    â†‘(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x âˆˆ AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x âˆˆ vectorSpan k (insert p â†‘s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] [inst_5 : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚),\\n  FiniteDimensional K { x // x âˆˆ LinearMap.range f }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] [inst_5 : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚),\\n  LinearMap.range f = âŠ¤ â†’ FiniteDimensional K Vâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]\\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚],\\n  (M â‰ƒâ‚—[R] Mâ‚‚) â†’ FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    â†‘(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\n  [inst_4 : FiniteDimensional k { x // x âˆˆ AffineSubspace.direction s }] (p : P),\n  FiniteDimensional k { x // x âˆˆ vectorSpan k (insert p â†‘s) } :=\n\n/-- The range of a linear map defined on a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] [inst_5 : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚),\n  FiniteDimensional K { x // x âˆˆ LinearMap.range f } :=\n\n/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] [inst_5 : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚),\n  LinearMap.range f = âŠ¤ â†’ FiniteDimensional K Vâ‚‚ :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹ :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚],\n  (M â‰ƒâ‚—[R] Mâ‚‚) â†’ FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚ :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem", "choices": ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V "]}
{"docString": "Every group is a torsion monoid.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G â†’ CommMonoid.torsion G = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The torsion submonoid of a torsion monoid is `âŠ¤`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x âˆˆ AddCommMonoid.addTorsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion submonoids are additively torsion.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"{G : Type u_1} â†’ [inst : Monoid G] â†’ Monoid.IsTorsion G â†’ Group G\",\n  \"isProp\": false,\n  \"docString\": \"Torsion monoids are really groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"}]\n", "prompt_cons": "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- The torsion submonoid of a torsion monoid is `âŠ¤`. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G â†’ CommMonoid.torsion G = âŠ¤ :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Additive torsion submonoids are additively torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x âˆˆ AddCommMonoid.addTorsion G } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G :=\n\n/-- Torsion monoids are really groups. -/\ntheorem {G : Type u_1} â†’ [inst : Monoid G] â†’ Monoid.IsTorsion G â†’ Group G :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H :=\n\n/-- The additive torsion submonoid of an abelian group equals the torsion\nsubgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Every group is a torsion monoid. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "]}
{"docString": "Every finite simple group has prime order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- Every finite simple group has prime order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], âˆƒ p [hp : Fact (Nat.Prime p)], Fintype.card G = p "]}
{"docString": "Every finite group is simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : Finite Î“], ProperlyDiscontinuousSMul Î“ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\\n  [inst_3 : Finite Î“], ProperlyDiscontinuousVAdd Î“ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k â†‘V = 1 â†’ CategoryTheory.Simple V\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {_m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\\n  MeasureTheory.SigmaFinite Î¼\",\n  \"isProp\": true,\n  \"docString\": \"Every finite measure is Ïƒ-finite. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L\",\n  \"isProp\": true,\n  \"docString\": \"A simple Lie algebra is semisimple. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\\n  FiniteDimensional.finrank K V = 1 â†’ IsSimpleOrder (Submodule A V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : Finite Î“], ProperlyDiscontinuousSMul Î“ T :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\n  [inst_3 : Finite Î“], ProperlyDiscontinuousVAdd Î“ T :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- Any `k`-algebra module which is 1-dimensional over `k` is simple. -/\ntheorem âˆ€ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\n  FiniteDimensional.finrank k â†‘V = 1 â†’ CategoryTheory.Simple V :=\n\n/-- Every finite measure is Ïƒ-finite. -/\ntheorem âˆ€ {Î± : Type u_1} {_m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\n  MeasureTheory.SigmaFinite Î¼ :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- A simple Lie algebra is semisimple. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L :=\n\n/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\n  FiniteDimensional.finrank K V = 1 â†’ IsSimpleOrder (Submodule A V) :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Every finite group is simple. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p â†’ IsSimpleGroup G "]}
{"docString": "Every finite group has prime order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Every finite group has prime order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p "]}
{"docString": "Every set has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a Ïƒ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds 0) â†’ Filter.Tendsto Î¼s F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"â†‘â†‘MeasureTheory.volume (â‹ƒ (p : â„) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Real.convergent 0 n = 0\",\n  \"isProp\": true,\n  \"docString\": \"All convergents of `0` are zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E}, Convex â„ s â†’ â†‘â†‘Î¼ (frontier s) = 0\",\n  \"isProp\": true,\n  \"docString\": \"Haar measure of the frontier of a convex set is zero. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.hausdorffDist s s = 0\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `â„ Ã— â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {i j : Set Î±},\\n  MeasurableSet i â†’\\n    MeasurableSet j â†’\\n      MeasureTheory.VectorMeasure.restrict 0 i â‰¤ MeasureTheory.VectorMeasure.restrict s i âˆ§\\n          MeasureTheory.VectorMeasure.restrict s iá¶œ â‰¤ MeasureTheory.VectorMeasure.restrict 0 iá¶œ â†’\\n        MeasureTheory.VectorMeasure.restrict 0 j â‰¤ MeasureTheory.VectorMeasure.restrict s j âˆ§\\n            MeasureTheory.VectorMeasure.restrict s já¶œ â‰¤ MeasureTheory.VectorMeasure.restrict 0 já¶œ â†’\\n          â†‘s (i âˆ† j) = 0 âˆ§ â†‘s (iá¶œ âˆ† já¶œ) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The symmetric difference of two Hahn decompositions has measure zero. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Metric.diam âˆ… = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹], MeasureTheory.Measure.hausdorffMeasure â†‘(Fintype.card Î¹) = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `Î¹ â†’ â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- A set in a Ïƒ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds 0) â†’ Filter.Tendsto Î¼s F (nhds 0) :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume (â‹ƒ (p : â„) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- All convergents of `0` are zero. -/\ntheorem âˆ€ (n : â„•), Real.convergent 0 n = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- Haar measure of the frontier of a convex set is zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E}, Convex â„ s â†’ â†‘â†‘Î¼ (frontier s) = 0 :=\n\n/-- The empty set is collinear. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k âˆ… :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0 :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.hausdorffDist s s = 0 :=\n\n/-- In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume :=\n\n/-- In the space `â„ Ã— â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume :=\n\n/-- The symmetric difference of two Hahn decompositions has measure zero. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {i j : Set Î±},\n  MeasurableSet i â†’\n    MeasurableSet j â†’\n      MeasureTheory.VectorMeasure.restrict 0 i â‰¤ MeasureTheory.VectorMeasure.restrict s i âˆ§\n          MeasureTheory.VectorMeasure.restrict s iá¶œ â‰¤ MeasureTheory.VectorMeasure.restrict 0 iá¶œ â†’\n        MeasureTheory.VectorMeasure.restrict 0 j â‰¤ MeasureTheory.VectorMeasure.restrict s j âˆ§\n            MeasureTheory.VectorMeasure.restrict s já¶œ â‰¤ MeasureTheory.VectorMeasure.restrict 0 já¶œ â†’\n          â†‘s (i âˆ† j) = 0 âˆ§ â†‘s (iá¶œ âˆ† já¶œ) = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Metric.diam âˆ… = 0 :=\n\n/-- In the space `Î¹ â†’ â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹], MeasureTheory.Measure.hausdorffMeasure â†‘(Fintype.card Î¹) = MeasureTheory.volume :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), â†‘â†‘MeasureTheory.volume s = 0 "]}
{"docString": "If a topological space is compact, then every subset is compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V) :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± Ã— Î²) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s "]}
{"docString": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\\n  OpensMeasurableSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a Ïƒ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt ğ•œ f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"â†‘â†‘MeasureTheory.volume (â‹ƒ (p : â„) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds 0) â†’ Filter.Tendsto Î¼s F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_3) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ğ•œ] F)},\\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) {K : Set F},\\n  IsComplete K â†’ MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function, with derivative in a given complete\\nset, is Borel-measurable. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  OpensMeasurableSpace Î± :=\n\n/-- A set in a Ïƒ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt ğ•œ f x} :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume (â‹ƒ (p : â„) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds 0) â†’ Filter.Tendsto Î¼s F (nhds 0) :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem âˆ€ (ğ•œ : Type u_3) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ğ•œ] F)},\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K} :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0 :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s :=\n\n/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) {K : Set F},\n  IsComplete K â†’ MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K} :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), MeasurableSet s â†’ Â¬ BorelSpace.Measurable s â†’ â†‘â†‘Î¼ s = 0 "]}
{"docString": "A finitely-presented group containing a torsion element is finite.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A â†’ Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsion G â†’ Set.Finite (Set.range fun g => addOrderOf g) â†’ AddMonoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group exponent exists for any bounded additive torsion group.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"}]\n", "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  Algebra.FinitePresentation R A â†’ Algebra.FiniteType R A :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I) :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- The group exponent exists for any bounded additive torsion group. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsion G â†’ Set.Finite (Set.range fun g => addOrderOf g) â†’ AddMonoid.ExponentExists G :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem âˆ€ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], Group.FinitePresentation G â†’ (âˆƒ g âˆˆ G, orderOf g â‰  1) â†’ Finite G "]}
{"docString": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M â†” IsClosed M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"}]\n", "prompt_cons": "/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- In a sequential space, a sequentially closed set is closed. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s â†’ IsClosed s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M â†” IsClosed M :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s "]}
{"docString": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X Ã— X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ Function.Injective f â†’ ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Î³ : Type w} [inst_6 : MetricSpace Î³]\\n  {Î¦ : X â†’ Î³} {Î¨ : Y â†’ Î³},\\n  Isometry Î¦ â†’ Isometry Î¨ â†’ GromovHausdorff.ghDist X Y â‰¤ Metric.hausdorffDist (Set.range Î¦) (Set.range Î¨)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {f : Î± â†’ Î²},\\n  Function.Injective f â†’ Continuous f â†’ T2Space Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners â„ E H â†’\\n    âˆ€ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Ïƒ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : âˆ€ (j : J), Nonempty â†‘(F.obj j)]\\n  [inst_3 : âˆ€ (j : J), CompactSpace â†‘(F.obj j)] [inst_4 : âˆ€ (j : J), T2Space â†‘(F.obj j)],\\n  Nonempty â†‘(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"}]\n", "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ Function.Injective f â†’ ClosedEmbedding f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem âˆ€ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Î³ : Type w} [inst_6 : MetricSpace Î³]\n  {Î¦ : X â†’ Î³} {Î¨ : Y â†’ Î³},\n  Isometry Î¦ â†’ Isometry Î¨ â†’ GromovHausdorff.ghDist X Y â‰¤ Metric.hausdorffDist (Set.range Î¦) (Set.range Î¨) :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H :=\n\n/-- The **Heineâ€“Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {f : Î± â†’ Î²},\n  Function.Injective f â†’ Continuous f â†’ T2Space Î± :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î± :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- A Ïƒ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners â„ E H â†’\n    âˆ€ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : âˆ€ (j : J), Nonempty â†‘(F.obj j)]\n  [inst_3 : âˆ€ (j : J), CompactSpace â†‘(F.obj j)] [inst_4 : âˆ€ (j : J), T2Space â†‘(F.obj j)],\n  Nonempty â†‘(TopCat.limitCone F).pt :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X Ã— X$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsOpenMap (Î» (x : Î±), (x, x)) "]}
{"docString": "Any finite order element in a group is equal to the identity.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1 "]}
{"docString": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’\\n    N = MonoidHom.ker f â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ (Monoid.IsTorsion H â†” Monoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"}]\n", "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G } :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥ :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’\n    N = MonoidHom.ker f â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ (Monoid.IsTorsion H â†” Monoid.IsTorsion G) :=\n\n/-- The additive torsion submonoid of an abelian group equals the torsion\nsubgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G "]}
{"docString": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R â†’\\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Bijective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Bijective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra Râ‚ A] [inst_4 : Algebra Râ‚ B] (f : A â†’â‚[Râ‚] B), Function.Injective â†‘(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u}, Function.Injective FreeGroup.of\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\\n  Function.Injective â†‘(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_3} {Râ‚‚ : Type u_2} {Mâ‚‚ : Type u_4} [inst : Ring R] [inst_1 : Ring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : Mâ‚‚ â†’â‚—[Râ‚‚] Mâ‚‚ â§¸ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f â†’ u = v) â†’ LinearMap.range f = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"An epimorphism is surjective. \"}]\n", "prompt_cons": "/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R â†’\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0) :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Bijective â†‘f :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Bijective â†‘f :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c) :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem âˆ€ {Râ‚ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra Râ‚ A] [inst_4 : Algebra Râ‚ B] (f : A â†’â‚[Râ‚] B), Function.Injective â†‘(Ideal.kerLiftAlg f) :=\n\n/-- The canonical map from the type to the free group is an injection. -/\ntheorem âˆ€ {Î± : Type u}, Function.Injective FreeGroup.of :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹ :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\n  Function.Injective â†‘(Con.kerLift f) :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ f 1 = 1 :=\n\n/-- An epimorphism is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_3} {Râ‚‚ : Type u_2} {Mâ‚‚ : Type u_4} [inst : Ring R] [inst_1 : Ring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\n  [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\n  (âˆ€ (u v : Mâ‚‚ â†’â‚—[Râ‚‚] Mâ‚‚ â§¸ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f â†’ u = v) â†’ LinearMap.range f = âŠ¤ :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Fintype Î±] {f : FreeGroup Î± â†’* FreeGroup Î±},\n  Function.Injective â†‘f â†’ Function.Surjective â†‘f "]}
{"docString": "Every division ring is either a field or finite.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"}]\n", "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0 :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î± :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- A subfield is closed under division. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î± :=\n\n/-- A finite set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem", "choices": ["âˆ€ (K : Type u_1) [inst : DivisionRing K], IsField K âˆ¨ Fintype K "]}
{"docString": "Every natural number is the product of two primes.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Î¹ : Type u_1} (s : Finset Î¹)\\n  (f : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•),\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Prime (f i)) â†’\\n    (âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ f i â‰  f j) â†’\\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of distinct prime powers in a Dedekind domain is the product of these\\nprime powers. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ (n k : â„•),\\n  k â‰¤ n â†’ (Finset.prod (Finset.range (n + 1)) fun p => p ^ â†‘(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k\",\n  \"isProp\": true,\n  \"docString\":\n  \"A binomial coefficient is the product of its prime factors, which are at most `n`. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The intersection of distinct prime powers in a Dedekind domain is the product of these\nprime powers. -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Î¹ : Type u_1} (s : Finset Î¹)\n  (f : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•),\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Prime (f i)) â†’\n    (âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ f i â‰  f j) â†’\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ FermatPsp n 1 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- A binomial coefficient is the product of its prime factors, which are at most `n`. -/\ntheorem âˆ€ (n k : â„•),\n  k â‰¤ n â†’ (Finset.prod (Finset.range (n + 1)) fun p => p ^ â†‘(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem", "choices": ["âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q "]}
{"docString": "Every even number is the square of a natural number.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡ :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, Even n â†’ âˆƒ x, n = x ^ 2 "]}
{"docString": "Every normal subgroup of a group has finite index.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type u_1} {s : Set Î¹}, Basis (â†‘s) R M â†’ Module.rank R M < Cardinal.aleph0 â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A â†’ FiniteDimensional K { x // x âˆˆ Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ [inst_1 : Subgroup.FiniteIndex H] â†’ Fintype (G â§¸ H)\",\n  \"isProp\": false,\n  \"docString\": \"A finite index subgroup has finite quotient. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type u_1}, Basis Î¹ R M â†’ Module.rank R M < Cardinal.aleph0 â†’ Nonempty (Fintype Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n", "prompt_cons": "/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- The additive subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0 :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type u_1} {s : Set Î¹}, Basis (â†‘s) R M â†’ Module.rank R M < Cardinal.aleph0 â†’ Set.Finite s :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem âˆ€ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\n  Set.Finite A â†’ FiniteDimensional K { x // x âˆˆ Submodule.span K A } :=\n\n/-- A finite index subgroup has finite quotient. -/\ntheorem {G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ [inst_1 : Subgroup.FiniteIndex H] â†’ Fintype (G â§¸ H) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite type. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type u_1}, Basis Î¹ R M â†’ Module.rank R M < Cardinal.aleph0 â†’ Nonempty (Fintype Î¹) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H â‰  0 "]}
{"docString": "The characteristic polynomial of every matrix has real roots.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : IsROrC Î±] {A : Matrix n n Î±},\\n  Matrix.IsHermitian A â†’ (fun i => â†‘(â†‘IsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] [inst_3 : DecidableEq S]\\n  (m : R â†’+* S) (d : â„•) {U : Set R},\\n  Set.Finite U â†’\\n    Set.Finite\\n      (â‹ƒ (f : Polynomial R) (_ : Polynomial.natDegree f â‰¤ d âˆ§ âˆ€ (i : â„•), Polynomial.coeff f i âˆˆ U),\\n        â†‘(Multiset.toFinset (Polynomial.roots (Polynomial.map m f))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of roots of all polynomials of bounded degree and having coefficients in a finite set\\nis finite. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : â„} {d : â„•} (f : F â†’+* K)\\n  {p : Polynomial F},\\n  Polynomial.Monic p â†’\\n    Polynomial.Splits f p â†’\\n      Polynomial.natDegree p â‰¤ d â†’\\n        (âˆ€ (z : K), z âˆˆ Polynomial.roots (Polynomial.map f p) â†’ â€–zâ€– â‰¤ B) â†’\\n          âˆ€ (i : â„•), â€–Polynomial.coeff (Polynomial.map f p) iâ€– â‰¤ max B 1 ^ d * â†‘(Nat.choose d (d / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coefficients of the monic polynomials of bounded degree with bounded roots are\\nuniformly bounded. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\\n  â†‘(Polynomial.aeval x) (minpoly A x) = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is a root of its minimal polynomial. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.natDegree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The degree of a minimal polynomial, as a natural number, is positive. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {Î¼ : R} {k : â„•}, Module.End.HasGeneralizedEigenvalue f Î¼ k â†’ Module.End.HasEigenvalue f Î¼\",\n  \"isProp\": true,\n  \"docString\": \"All generalized eigenvalues are eigenvalues. \"}]\n", "prompt_cons": "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : IsROrC Î±] {A : Matrix n n Î±},\n  Matrix.IsHermitian A â†’ (fun i => â†‘(â†‘IsROrC.re (Matrix.diag A i))) = Matrix.diag A :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1 :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1 :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q :=\n\n/-- The degree of a minimal polynomial is positive. -/\ntheorem âˆ€ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.degree (minpoly A x) :=\n\n/-- Every identity matrix is diagonal. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The set of roots of all polynomials of bounded degree and having coefficients in a finite set\nis finite. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] [inst_3 : DecidableEq S]\n  (m : R â†’+* S) (d : â„•) {U : Set R},\n  Set.Finite U â†’\n    Set.Finite\n      (â‹ƒ (f : Polynomial R) (_ : Polynomial.natDegree f â‰¤ d âˆ§ âˆ€ (i : â„•), Polynomial.coeff f i âˆˆ U),\n        â†‘(Multiset.toFinset (Polynomial.roots (Polynomial.map m f)))) :=\n\n/-- The coefficients of the monic polynomials of bounded degree with bounded roots are\nuniformly bounded. -/\ntheorem âˆ€ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : â„} {d : â„•} (f : F â†’+* K)\n  {p : Polynomial F},\n  Polynomial.Monic p â†’\n    Polynomial.Splits f p â†’\n      Polynomial.natDegree p â‰¤ d â†’\n        (âˆ€ (z : K), z âˆˆ Polynomial.roots (Polynomial.map f p) â†’ â€–zâ€– â‰¤ B) â†’\n          âˆ€ (i : â„•), â€–Polynomial.coeff (Polynomial.map f p) iâ€– â‰¤ max B 1 ^ d * â†‘(Nat.choose d (d / 2)) :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- An element is a root of its minimal polynomial. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\n  â†‘(Polynomial.aeval x) (minpoly A x) = 0 :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- The degree of a minimal polynomial, as a natural number, is positive. -/\ntheorem âˆ€ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.natDegree (minpoly A x) :=\n\n/-- All generalized eigenvalues are eigenvalues. -/\ntheorem âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {Î¼ : R} {k : â„•}, Module.End.HasGeneralizedEigenvalue f Î¼ k â†’ Module.End.HasEigenvalue f Î¼ :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem", "choices": ["âˆ€ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type u_2} [inst_2 : CommRing R] [inst_3 : Algebra R â„]\n  (M : Matrix n n R), âˆƒ p, Polynomial.map (algebraMap R â„) (Matrix.charpoly M) = p "]}
{"docString": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S â‰¤ nonZeroDivisors R â†’\\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective â†‘f â†’ Ideal.IsMaximal (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  âˆƒ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, Â§ 3.3, Lemma 3])\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\\n  I < J â†’ â†‘J = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R â†’+* S),\\n  Function.Surjective â†‘f â†’ IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a domain is a prime ideal. \"}]\n", "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S â‰¤ nonZeroDivisors R â†’\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\n  Function.Surjective â†‘f â†’ Ideal.IsMaximal (RingHom.ker f) :=\n\n/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, Â§ 3.3, Lemma 3]) -/\ntheorem âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\n  âˆƒ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\n  I < J â†’ â†‘J = Set.univ :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem âˆ€ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R â†’+* S),\n  Function.Surjective â†‘f â†’ IsPrincipalIdealRing S :=\n\n/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f) :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M "]}
{"docString": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} [inst_1 : Subsingleton Î¹],\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ âˆ€ {f : Î¹ â†’ Î± â†’ Î²}, (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UnifIntegrable f p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A single function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformlyOn F f p s â†’\\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"}]\n", "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- A single function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} [inst_1 : Subsingleton Î¹],\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ âˆ€ {f : Î¹ â†’ Î± â†’ Î²}, (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UnifIntegrable f p Î¼ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousAt f x :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ Equicontinuous F :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformlyOn F f p s â†’\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f "]}
{"docString": "Every uniformly continuous function is bounded above.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Sort u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±},\\n  (âˆ€ (x : Î¹), f x â‰¤ c) â†’ iSup f â‰¤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {I : Set Î²} {S : Î² â†’ Set Î±},\\n  Set.Finite I â†’ (BddAbove (â‹ƒ (i : Î²) (_ : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ BddAbove (S i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\\n  TotallyBounded s â†’ UniformContinuous f â†’ TotallyBounded (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformlyOn F f p s â†’\\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] {s t : Set Î³}, BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} [inst : ConditionallyCompleteLattice Î±] {f : Î¹ â†’ Î±},\\n  BddBelow (Set.range f) â†’ âˆ€ (c : Î¹), iInf f â‰¤ f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed infimum of a function is bounded above by the value taken at one point\"}]\n", "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Sort u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±},\n  (âˆ€ (x : Î¹), f x â‰¤ c) â†’ iSup f â‰¤ c :=\n\n/-- A finite set is bounded above. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f) :=\n\n/-- A finite union of sets which are all bounded above is still bounded above. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {I : Set Î²} {S : Î² â†’ Set Î±},\n  Set.Finite I â†’ (BddAbove (â‹ƒ (i : Î²) (_ : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ BddAbove (S i)) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- The image of a totally bounded set under a uniformly continuous map is totally bounded. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  TotallyBounded s â†’ UniformContinuous f â†’ TotallyBounded (f '' s) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformlyOn F f p s â†’\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] {s t : Set Î³}, BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- The indexed infimum of a function is bounded above by the value taken at one point -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} [inst : ConditionallyCompleteLattice Î±] {f : Î¹ â†’ Î±},\n  BddBelow (Set.range f) â†’ âˆ€ (c : Î¹), iInf f â‰¤ f c :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : Nonempty Î±] [inst_3 : BoundedOrder Î²]\n  {f : Î± â†’ Î²}, UniformContinuous f â†’ BddAbove (Set.range f) "]}
{"docString": "If every compact subset of a topological space is closed, then the space is compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œâ‚ : Type u_1} {ğ•œâ‚‚ : Type u_2} [inst : NontriviallyNormedField ğ•œâ‚] [inst_1 : NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚}\\n  {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst_2 : SeminormedAddCommGroup Mâ‚] [inst_3 : AddCommGroup Mâ‚‚]\\n  [inst_4 : NormedSpace ğ•œâ‚ Mâ‚] [inst_5 : Module ğ•œâ‚‚ Mâ‚‚] [inst_6 : UniformSpace Mâ‚‚] [inst_7 : UniformAddGroup Mâ‚‚]\\n  [inst_8 : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [inst_9 : T2Space Mâ‚‚] [inst_10 : CompleteSpace Mâ‚‚],\\n  IsClosed {f | IsCompactOperator â†‘f}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem âˆ€ {ğ•œâ‚ : Type u_1} {ğ•œâ‚‚ : Type u_2} [inst : NontriviallyNormedField ğ•œâ‚] [inst_1 : NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚}\n  {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst_2 : SeminormedAddCommGroup Mâ‚] [inst_3 : AddCommGroup Mâ‚‚]\n  [inst_4 : NormedSpace ğ•œâ‚ Mâ‚] [inst_5 : Module ğ•œâ‚‚ Mâ‚‚] [inst_6 : UniformSpace Mâ‚‚] [inst_7 : UniformAddGroup Mâ‚‚]\n  [inst_8 : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [inst_9 : T2Space Mâ‚‚] [inst_10 : CompleteSpace Mâ‚‚],\n  IsClosed {f | IsCompactOperator â†‘f} :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], (âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s) â†’ CompactSpace Î± "]}
{"docString": "In a commutative ring, the sum of idempotent elements is idempotent.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I â†’ (IsIdempotentElem I â†” âˆƒ e, IsIdempotentElem e âˆ§ I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} [inst : AddCommMonoid Î²] {s : Finset Î±} (f : Î± â†’ Î²),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), â†‘f (a + b) = â†‘f a + â†‘f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (s : Finset Î¹) (c : R)\\n  (x : (i : â†‘â†‘s) â†’ M â†‘i), â†‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â†‘(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\",\n  \"isProp\": true,\n  \"docString\": \"the condition that the given endomorphism is an idempotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a âˆˆ self.carrier â†’ b âˆˆ self.carrier â†’ a + b âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (i : Î¹) (c : R) (x : M i),\\n  â†‘(DirectSum.of M i) (c â€¢ x) = c â€¢ â†‘(DirectSum.of M i) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Addition is commutative in an additive commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a â†’ IsRightRegular b â†’ IsRightRegular (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y â†’ IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence closure is idempotent. \"}]\n", "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\n  Ideal.FG I â†’ (IsIdempotentElem I â†” âˆƒ e, IsIdempotentElem e âˆ§ I = Submodule.span R {e}) :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- Moving to the opposite additive commutative monoid commutes with summing. -/\ntheorem âˆ€ {Î² : Type u} {Î± : Type v} [inst : AddCommMonoid Î²] {s : Finset Î±} (f : Î± â†’ Î²),\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x) :=\n\n/-- By definition, a ring isomorphism preserves the additive structure. -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), â†‘f (a + b) = â†‘f a + â†‘f b :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (s : Finset Î¹) (c : R)\n  (x : (i : â†‘â†‘s) â†’ M â†‘i), â†‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â†‘(DirectSum.mk M s) x :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- the condition that the given endomorphism is an idempotent -/\ntheorem âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p :=\n\n/-- The sum of two elements of an additive subsemigroup belongs to the subsemigroup. -/\ntheorem âˆ€ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\n  a âˆˆ self.carrier â†’ b âˆˆ self.carrier â†’ a + b âˆˆ self.carrier :=\n\n/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (i : Î¹) (c : R) (x : M i),\n  â†‘(DirectSum.of M i) (c â€¢ x) = c â€¢ â†‘(DirectSum.of M i) x :=\n\n/-- Addition is commutative in an additive commutative semigroup. -/\ntheorem âˆ€ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a :=\n\n/-- In a semigroup, the product of right-regular elements is right-regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a â†’ IsRightRegular b â†’ IsRightRegular (a * b) :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x y : G},\n  AddCommute x y â†’ IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- Equivalence closure is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) "]}
{"docString": "The number of partitions of a finite set is a prime number.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\\n  Set.Finite {I | Ideal.IsPrime I} â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\": \"A Dedekind domain is a PID if its set of primes is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"âˆ€ (p : Nat.Primes), PNat.factorMultiset â†‘p = PrimeMultiset.ofPrime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Factoring a prime gives the corresponding one-element multiset. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- A finite set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- A Dedekind domain is a PID if its set of primes is finite. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\n  Set.Finite {I | Ideal.IsPrime I} â†’ IsPrincipalIdealRing R :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- The partition is supremum-independent -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem âˆ€ (p : Nat.Primes), PNat.factorMultiset â†‘p = PrimeMultiset.ofPrime p :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Fintype Î±], Nat.Prime (Finset.card (Finset.powerset (Fintype.elems Î±))) "]}
{"docString": "If a poset has a maximal element, then it has a unique minimal element.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {L : List (Î± Ã— Bool)} [inst : DecidableEq Î±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsGreatest s a â†’ sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeAddGroup.Red Lâ‚ Lâ‚‚ â†’ FreeAddGroup.reduce Lâ‚ = FreeAddGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ â†’ FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words have a common maximal reduction, then they correspond to the same element in the\\nfree group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeGroup.Red Lâ‚ Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ sInf s â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is more than the set infimum. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R],\\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), â†‘Polynomial.C x âˆˆ I â†’ x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {L : List (Î± Ã— Bool)} [inst : DecidableEq Î±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\\n  âˆƒ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\\nthe lemma implies there exists a vertex. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeAddGroup.mk Lâ‚ = FreeAddGroup.mk Lâ‚‚ â†’ FreeAddGroup.reduce Lâ‚ = FreeAddGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the additive free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends an element of the\\nfree group to its maximal reduction is well-defined.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ğ•œ F] {T : E â†’â‚—.[ğ•œ] F}\\n  {S : F â†’â‚—.[ğ•œ] E},\\n  Dense â†‘T.domain â†’ âˆ€ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S â†’ S â‰¤ LinearPMap.adjoint T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The adjoint is maximal in the sense that it contains every formal adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±] [inst_1 : OrderBot Î±] [inst_2 : WellFoundedLT Î±] (a : Î±),\\n  âˆƒ s, Finset.sup s id = a âˆ§ âˆ€ â¦ƒb : Î±â¦„, b âˆˆ s â†’ SupIrred b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a well-founded lattice, any element is the supremum of finitely many sup-irreducible\\nelements. This is the order-theoretic analogue of prime factorisation. \"}]\n", "prompt_cons": "/-- A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem âˆ€ {Î± : Type u} {L : List (Î± Ã— Bool)} [inst : DecidableEq Î±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s :=\n\n/-- A greatest element of a set is the supremum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsGreatest s a â†’ sSup s = a :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeAddGroup.Red Lâ‚ Lâ‚‚ â†’ FreeAddGroup.reduce Lâ‚ = FreeAddGroup.reduce Lâ‚‚ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0 :=\n\n/-- If two words have a common maximal reduction, then they correspond to the same element in the\nfree group. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ â†’ FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚ :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeGroup.Red Lâ‚ Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ :=\n\n/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0 :=\n\n/-- Any element of a set is more than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ sInf s â‰¤ a :=\n\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R],\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), â†‘Polynomial.C x âˆˆ I â†’ x = 0 :=\n\n/-- A word and its maximal reduction correspond to the same element of the additive free\ngroup. -/\ntheorem âˆ€ {Î± : Type u} {L : List (Î± Ã— Bool)} [inst : DecidableEq Î±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L :=\n\n/-- There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\n  âˆƒ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v :=\n\n/-- If two words correspond to the same element in the additive free group, then they\nhave a common maximal reduction. This is the proof that the function that sends an element of the\nfree group to its maximal reduction is well-defined. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeAddGroup.mk Lâ‚ = FreeAddGroup.mk Lâ‚‚ â†’ FreeAddGroup.reduce Lâ‚ = FreeAddGroup.reduce Lâ‚‚ :=\n\n/-- The adjoint is maximal in the sense that it contains every formal adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ğ•œ F] {T : E â†’â‚—.[ğ•œ] F}\n  {S : F â†’â‚—.[ğ•œ] E},\n  Dense â†‘T.domain â†’ âˆ€ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S â†’ S â‰¤ LinearPMap.adjoint T :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- In a well-founded lattice, any element is the supremum of finitely many sup-irreducible\nelements. This is the order-theoretic analogue of prime factorisation. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±] [inst_1 : OrderBot Î±] [inst_2 : WellFoundedLT Î±] (a : Î±),\n  âˆƒ s, Finset.sup s id = a âˆ§ âˆ€ â¦ƒb : Î±â¦„, b âˆˆ s â†’ SupIrred b :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±] [inst_2 : BoundedOrder Î±],\n  âˆƒ! a, âˆ€ (b : Î±), a â‰¤ b "]}
{"docString": "The automorphism group of an Abelian group is cyclic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gáµƒáµ’áµ– G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddAction Î± Î²] (x : Î²),\\n  AddAction.IsPretransitive Î± â†‘(AddAction.orbit Î± x)\",\n  \"isProp\": true,\n  \"docString\": \"The action of an additive group on an orbit is transitive.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- The right regular action of an additive group on itself is transitive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gáµƒáµ’áµ– G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The action of an additive group on an orbit is transitive. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddAction Î± Î²] (x : Î²),\n  AddAction.IsPretransitive Î± â†‘(AddAction.orbit Î± x) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddAut G) "]}
{"docString": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"âˆ€ {f : Ordinal.{u} â†’ Ordinal.{u}}, Ordinal.IsNormal f â†’ Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x : Î±), âˆƒ y, y âˆˆ Set.Ico 0 c âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ico a (a + c) âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ico a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"âˆ€ {o : Ordinal.{u}} {f : (b : Ordinal.{u}) â†’ b < o â†’ Ordinal.{max u v} â†’ Ordinal.{max u v}},\\n  (âˆ€ (i : Ordinal.{u}) (hi : i < o), Ordinal.IsNormal (f i hi)) â†’\\n    Set.Unbounded (fun x x_1 => x < x_1) (â‹‚ (i : Ordinal.{u}) (hi : i < o), Function.fixedPoints (f i hi))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of the fixed point lemma for normal functions: any family of normal functions\\nhas an unbounded set of common fixed points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {Î¼ : MeasureTheory.Measure â„}\\n  {a b : â„}, Set.EqOn f g (Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ioc a (a + c) âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ioc a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.SigmaFinite Î¼]\\n  {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), 0 < g x) âˆ§ Measurable g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sigma-finite measure space, there exists an integrable function which is\\npositive everywhere (and with an arbitrarily small integral). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {m n : â„•},\\n  Function.IsPeriodicPt f m x â†’ Function.IsPeriodicPt f n y â†’ 0 < m â†’ 0 < n â†’ f x = f y â†’ x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²} {x : Î±} {r : â„},\\n  0 < r â†’ âˆ€ (K : â„), (âˆ€ (y : Î±), dist y x < r â†’ dist (f y) (f x) â‰¤ K * dist y x) â†’ ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_1} [inst : TopologicalSpace Gâ‚€] [inst_1 : GroupWithZero Gâ‚€] [inst_2 : ContinuousMul Gâ‚€],\\n  Filter.Tendsto Inv.inv (nhds 1) (nhds 1) â†’ HasContinuousInvâ‚€ Gâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a group with zero has continuous multiplication and `fun x â†¦ xâ»Â¹` is continuous at one,\\nthen it is continuous at any unit. \"}]\n", "prompt_cons": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem âˆ€ {f : Ordinal.{u} â†’ Ordinal.{u}}, Ordinal.IsNormal f â†’ Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- A continuous, periodic function has compact range. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ico 0 c` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x : Î±), âˆƒ y, y âˆˆ Set.Ico 0 c âˆ§ f x = f y :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ico a (a + c)` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ico a (a + c) âˆ§ f x = f y :=\n\n/-- A generalization of the fixed point lemma for normal functions: any family of normal functions\nhas an unbounded set of common fixed points. -/\ntheorem âˆ€ {o : Ordinal.{u}} {f : (b : Ordinal.{u}) â†’ b < o â†’ Ordinal.{max u v} â†’ Ordinal.{max u v}},\n  (âˆ€ (i : Ordinal.{u}) (hi : i < o), Ordinal.IsNormal (f i hi)) â†’\n    Set.Unbounded (fun x x_1 => x < x_1) (â‹‚ (i : Ordinal.{u}) (hi : i < o), Function.fixedPoints (f i hi)) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {Î¼ : MeasureTheory.Measure â„}\n  {a b : â„}, Set.EqOn f g (Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼ :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ioc a (a + c)` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ioc a (a + c) âˆ§ f x = f y :=\n\n/-- In a sigma-finite measure space, there exists an integrable function which is\npositive everywhere (and with an arbitrarily small integral). -/\ntheorem âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.SigmaFinite Î¼]\n  {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), 0 < g x) âˆ§ Measurable g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ < Îµ :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {m n : â„•},\n  Function.IsPeriodicPt f m x â†’ Function.IsPeriodicPt f n y â†’ 0 < m â†’ 0 < n â†’ f x = f y â†’ x = y :=\n\n/-- If a function is locally Lipschitz around a point, then it is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²} {x : Î±} {r : â„},\n  0 < r â†’ âˆ€ (K : â„), (âˆ€ (y : Î±), dist y x < r â†’ dist (f y) (f x) â‰¤ K * dist y x) â†’ ContinuousAt f x :=\n\n/-- If a group with zero has continuous multiplication and `fun x â†¦ xâ»Â¹` is continuous at one,\nthen it is continuous at any unit. -/\ntheorem âˆ€ {Gâ‚€ : Type u_1} [inst : TopologicalSpace Gâ‚€] [inst_1 : GroupWithZero Gâ‚€] [inst_2 : ContinuousMul Gâ‚€],\n  Filter.Tendsto Inv.inv (nhds 1) (nhds 1) â†’ HasContinuousInvâ‚€ Gâ‚€ :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y "]}
{"docString": "The complement of the union of two sets contains the union of their complements.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\\n  s âˆ© t = âˆ… â†’\\n    âˆ€ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} {Î² : Type ub} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {a : Set (Î± Ã— Î±)},\\n  a âˆˆ uniformity Î± â†’\\n    âˆ€ {b : Set (Î² Ã— Î²)},\\n      b âˆˆ uniformity Î² â†’\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a âˆª (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b âˆˆ\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s âˆª t) = affineSpan k s âŠ” affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {s t : Set Î³}, BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  â‹ƒ (n : â„•), CompactExhaustion.toFun self n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] {s t : Set Î³}, BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ y âˆˆ self.sets â†’ x âˆ© y âˆˆ self.sets\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"}]\n", "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t) :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\n  s âˆ© t = âˆ… â†’\n    âˆ€ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T :=\n\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem âˆ€ {Î± : Type ua} {Î² : Type ub} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {a : Set (Î± Ã— Î±)},\n  a âˆˆ uniformity Î± â†’\n    âˆ€ {b : Set (Î² Ã— Î²)},\n      b âˆˆ uniformity Î² â†’\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a âˆª (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b âˆˆ\n          UniformSpace.Core.sum.uniformity :=\n\n/-- The span of a union of sets is the sup of their spans. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s âˆª t) = affineSpan k s âŠ” affineSpan k t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {s t : Set Î³}, BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- The union of all sets in a compact exhaustion equals the entire space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  â‹ƒ (n : â„•), CompactExhaustion.toFun self n = Set.univ :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] {s t : Set Î³}, BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\ t) :=\n\n/-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\ntheorem âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ y âˆˆ self.sets â†’ x âˆ© y âˆˆ self.sets :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆ© tá¶œ "]}
{"docString": "The square root of an rational number is rational.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, LiouvilleWith p x â†’ r â‰  0 â†’ LiouvilleWith p (x * â†‘r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a â‰  0 â†’ (âˆƒ s, discrim a b c = s * s) â†’ âˆƒ x, a * x * x + b * x + c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\": \"âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I â†” Ideal.IsRadical I\",\n  \"isProp\": true,\n  \"docString\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\\n  n â‰  0 â†’ âˆ€ {x y : Î±}, x < y â†’ 0 < y â†’ âˆƒ q, 0 < q âˆ§ x < â†‘q ^ n âˆ§ â†‘q ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\\n  a â‰  0 â†’ âˆ€ (x : R), a * x * x + b * x + c = 0 â†” discrim a b c = (2 * a * x + b) ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"}]\n", "prompt_cons": "/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2} :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, LiouvilleWith p x â†’ r â‰  0 â†’ LiouvilleWith p (x * â†‘r) :=\n\n/-- A quadratic has roots if its discriminant has square roots -/\ntheorem âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a â‰  0 â†’ (âˆƒ s, discrim a b c = s * s) â†’ âˆƒ x, a * x * x + b * x + c = 0 :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- An ideal is radical iff it is equal to its radical. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I â†” Ideal.IsRadical I :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  n â‰  0 â†’ âˆ€ {x y : Î±}, x < y â†’ 0 < y â†’ âˆƒ q, 0 < q âˆ§ x < â†‘q ^ n âˆ§ â†‘q ^ n < y :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- A quadratic has roots if and only if its discriminant equals some square. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\n  a â‰  0 â†’ âˆ€ (x : R), a * x * x + b * x + c = 0 â†” discrim a b c = (2 * a * x + b) ^ 2 :=\n\n/-- The square root of an rational number is rational. -/\ntheorem", "choices": ["âˆ€ (q : â„š), âˆƒ r, Real.sqrt q = â†‘r "]}
{"docString": "If a module over a ring is free, then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V â†” Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} (R : Type u) [inst : Semiring R] (M : Î¹ â†’ Type u_2) [inst_1 : Finite Î¹]\\n  [inst_2 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_3 : (i : Î¹) â†’ Module R (M i)]\\n  [inst_4 : âˆ€ (i : Î¹), Module.Free R (M i)], Module.Free R ((i : Î¹) â†’ M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M â‰ƒâ‚—[R] N) â†” FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Submodule K V), IsAtom W â†” âˆƒ v x, W = Submodule.span K {v}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The atoms of the lattice of submodules of a module over a division ring are the\\nsubmodules equal to the span of a nonzero element of the module. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherianRing R] {A : Set M}, Set.Finite A â†’ IsNoetherian R { x // x âˆˆ Submodule.span R A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a module over a Noetherian ring, the submodule generated by finitely many vectors is\\nNoetherian. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M â†’â‚—[R] N) (g : N â†’â‚—[R] P),\\n  Function.Injective â†‘f â†’ Function.Surjective â†‘g â†’ LinearMap.range f = LinearMap.ker g â†’ IsNoetherian R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the first and final modules in a short exact sequence are Noetherian,\\nthen the middle module is also Noetherian. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Bijective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\\n  Function.Surjective â†‘(Finsupp.total M M R id)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any module is a quotient of a free module. This is stated as surjectivity of\\n`Finsupp.total M M R id : (M â†’â‚€ R) â†’â‚—[R] M`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {Î· : Type uâ‚'} {Ï† : Î· â†’ Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : Î·) â†’ AddCommGroup (Ï† i)] [inst_3 : (i : Î·) â†’ Module K (Ï† i)] [inst_4 : âˆ€ (i : Î·), Module.Free K (Ï† i)]\\n  [inst_5 : Finite Î·], Module.rank K ((i : Î·) â†’ Ï† i) = Cardinal.sum fun i => Module.rank K (Ï† i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\\n  Module.Free R (Matrix m n M)\",\n  \"isProp\": true,\n  \"docString\": \"The module of finite matrices is free. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A commutative star monoid is a star module over itself via `Monoid.toMulAction`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"}]\n", "prompt_cons": "/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V â†” Module.Finite K V :=\n\n/-- The product of finitely many free modules is free. -/\ntheorem âˆ€ {Î¹ : Type u_1} (R : Type u) [inst : Semiring R] (M : Î¹ â†’ Type u_2) [inst_1 : Finite Î¹]\n  [inst_2 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_3 : (i : Î¹) â†’ Module R (M i)]\n  [inst_4 : âˆ€ (i : Î¹), Module.Free R (M i)], Module.Free R ((i : Î¹) â†’ M i) :=\n\n/-- The lattice of submodules of a module over a division ring is atomistic. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsAtomistic (Submodule K V) :=\n\n/-- Modules over the trivial ring are Noetherian. -/\ntheorem âˆ€ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem âˆ€ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- Two finite and free modules are isomorphic if and only if they have the same (finite) rank. -/\ntheorem âˆ€ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  Nonempty (M â‰ƒâ‚—[R] N) â†” FiniteDimensional.finrank R M = FiniteDimensional.finrank R N :=\n\n/-- A module over a semiring is `Finite` if it is finitely generated as a module. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : Module.Finite R M], Submodule.FG âŠ¤ :=\n\n/-- The category of modules has enough projectives, since every module is a quotient of a free\nmodule. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R) :=\n\n/-- The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Submodule K V), IsAtom W â†” âˆƒ v x, W = Submodule.span K {v} :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥ :=\n\n/-- In a module over a Noetherian ring, the submodule generated by finitely many vectors is\nNoetherian. -/\ntheorem âˆ€ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherianRing R] {A : Set M}, Set.Finite A â†’ IsNoetherian R { x // x âˆˆ Submodule.span R A } :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f :=\n\n/-- If the first and final modules in a short exact sequence are Noetherian,\nthen the middle module is also Noetherian. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M â†’â‚—[R] N) (g : N â†’â‚—[R] P),\n  Function.Injective â†‘f â†’ Function.Surjective â†‘g â†’ LinearMap.range f = LinearMap.ker g â†’ IsNoetherian R N :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Bijective â†‘f :=\n\n/-- Any module is a quotient of a free module. This is stated as surjectivity of\n`Finsupp.total M M R id : (M â†’â‚€ R) â†’â‚—[R] M`. -/\ntheorem âˆ€ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Function.Surjective â†‘(Finsupp.total M M R id) :=\n\n/-- The rank of a finite product of free modules is the sum of the ranks. -/\ntheorem âˆ€ {K : Type u} {Î· : Type uâ‚'} {Ï† : Î· â†’ Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\n  [inst_2 : (i : Î·) â†’ AddCommGroup (Ï† i)] [inst_3 : (i : Î·) â†’ Module K (Ï† i)] [inst_4 : âˆ€ (i : Î·), Module.Free K (Ï† i)]\n  [inst_5 : Finite Î·], Module.rank K ((i : Î·) â†’ Ï† i) = Cardinal.sum fun i => Module.rank K (Ï† i) :=\n\n/-- The module of finite matrices is free. -/\ntheorem âˆ€ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\n  Module.Free R (Matrix m n M) :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- A commutative star monoid is a star module over itself via `Monoid.toMulAction`. -/\ntheorem âˆ€ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem", "choices": ["âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) "]}
{"docString": "If the set of units of a ring forms a group then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R\",\n  \"isProp\": true,\n  \"docString\": \"Any commutative ring satisfies the `StrongRankCondition`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"}]\n", "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹ :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_1}\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Multiplication is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any commutative ring satisfies the `StrongRankCondition`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Units R)], IsCommutative R (*) "]}
{"docString": "Every natural number larger than `10` is the sum of a square and a prime.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ FermatPsp n 1 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem", "choices": ["âˆ€ (n : â„•), 10 < n â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p "]}
{"docString": "The initial object of a category is isomorphic to its terminal object.", "prompts": "[{\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (X âŸ¶ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F â†’ CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C)) â†’ CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T â†’\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) â†’ CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X â†’ âˆ€ (f g : X âŸ¶ Y), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms from an initial object are equal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X â†’ âˆ€ (f : Y âŸ¶ X), CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism to an initial object is epi. \"},\n {\"theorem\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\": \"A category with finite biproducts has a zero object. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (jâ‚ jâ‚‚ : J),\\n  CategoryTheory.Zigzag jâ‚ jâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : âˆ€ {X Y : C} (f : X âŸ¶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\",\n  \"isProp\": true,\n  \"docString\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"theorem\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\\n  (âˆ€ (A : C) (f : I âŸ¶ A), CategoryTheory.IsIso f) â†’ CategoryTheory.Limits.HasStrictTerminalObjects C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\\nhas strict terminal objects. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The forgetful functor from monoid objects to the ambient category reflects isomorphisms. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.IsSplitMono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is split mono. \"}]\n", "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (X âŸ¶ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- The category `D` has isomorphic objects equal -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F â†’ CategoryTheory.Skeletal D :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C)) â†’ CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T â†’\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) â†’ CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- Any two morphisms from an initial object are equal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X â†’ âˆ€ (f g : X âŸ¶ Y), f = g :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- Any morphism to an initial object is epi. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsInitial X â†’ âˆ€ (f : Y âŸ¶ X), CategoryTheory.Epi f :=\n\n/-- A category with finite biproducts has a zero object. -/\ntheorem âˆ€ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- In a connected category, any two objects are related by `Zigzag`. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (jâ‚ jâ‚‚ : J),\n  CategoryTheory.Zigzag jâ‚ jâ‚‚ :=\n\n/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : âˆ€ {X Y : C} (f : X âŸ¶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\n  CategoryTheory.Limits.HasImages C :=\n\n/-- Any category with pushouts and initial object has binary coproducts. -/\ntheorem âˆ€ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C :=\n\n/-- The map from the (any as stated) initial object to any other object is a\nmonomorphism -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X) :=\n\n/-- Each connected component of the category is connected. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\n  (âˆ€ (A : C) (f : I âŸ¶ A), CategoryTheory.IsIso f) â†’ CategoryTheory.Limits.HasStrictTerminalObjects C :=\n\n/-- The forgetful functor from monoid objects to the ambient category reflects isomorphisms. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C) :=\n\n/-- Any morphism from a terminal object is split mono. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.IsSplitMono f :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem", "choices": ["âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.Initial C â‰… CategoryTheory.Limits.Terminal C "]}
{"docString": "If the composition of two functions is continuous, then each of them is continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => â€–g xâ€–) â†’ MeasureTheory.Integrable f â†’ Continuous g â†’ Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³},\\n  s âŠ† f â»Â¹' e.source â†’ (ContinuousOn f s â†” ContinuousOn (â†‘e âˆ˜ f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±},\\n  f â»Â¹' e.source = Set.univ â†’ (Continuous f â†” Continuous (â†‘e âˆ˜ f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous if and only if its composition with a local homeomorphism\\non the left is continuous and its image is contained in the source. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G],\\n  HasCompactSupport g â†’ MeasureTheory.LocallyIntegrable f â†’ Continuous g â†’ Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is locally integrable and the other has compact\\nsupport and is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î³ : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±]\\n  [inst_2 : OpensMeasurableSpace Î±] [inst_3 : TopologicalSpace Î³] [inst_4 : MeasurableSpace Î³] [inst_5 : BorelSpace Î³]\\n  {f g : Î± â†’ Î³} {s : Set Î±} [inst_6 : (j : Î±) â†’ Decidable (j âˆˆ s)],\\n  ContinuousOn f s â†’ ContinuousOn g sá¶œ â†’ MeasurableSet s â†’ Measurable (Set.piecewise s f g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is defined piecewise in terms of functions which are continuous on their\\nrespective pieces, then it is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {Î¼ : MeasureTheory.Measure â„}\\n  {a b : â„}, Set.EqOn f g (Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_1} {Î³ : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²},\\n  Continuous g â†’ MeasureTheory.AEStronglyMeasurable f Î¼ â†’ MeasureTheory.AEStronglyMeasurable (fun x => g (f x)) Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of a continuous function and an ae strongly measurable function is ae strongly\\nmeasurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n", "prompt_cons": "/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\n  BddAbove (Set.range fun x => â€–g xâ€–) â†’ MeasureTheory.Integrable f â†’ Continuous g â†’ Continuous (convolution f g L) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s)) :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³},\n  s âŠ† f â»Â¹' e.source â†’ (ContinuousOn f s â†” ContinuousOn (â†‘e âˆ˜ f) s) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A function is continuous if and only if its composition with a local homeomorphism\non the left is continuous and its image is contained in the source. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±},\n  f â»Â¹' e.source = Set.univ â†’ (Continuous f â†” Continuous (â†‘e âˆ˜ f)) :=\n\n/-- The convolution is continuous if one function is locally integrable and the other has compact\nsupport and is continuous. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G],\n  HasCompactSupport g â†’ MeasureTheory.LocallyIntegrable f â†’ Continuous g â†’ Continuous (convolution f g L) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f :=\n\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {Î³ : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±]\n  [inst_2 : OpensMeasurableSpace Î±] [inst_3 : TopologicalSpace Î³] [inst_4 : MeasurableSpace Î³] [inst_5 : BorelSpace Î³]\n  {f g : Î± â†’ Î³} {s : Set Î±} [inst_6 : (j : Î±) â†’ Decidable (j âˆˆ s)],\n  ContinuousOn f s â†’ ContinuousOn g sá¶œ â†’ MeasurableSet s â†’ Measurable (Set.piecewise s f g) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {Î¼ : MeasureTheory.Measure â„}\n  {a b : â„}, Set.EqOn f g (Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼ :=\n\n/-- The composition of a continuous function and an ae strongly measurable function is ae strongly\nmeasurable. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_1} {Î³ : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  Continuous g â†’ MeasureTheory.AEStronglyMeasurable f Î¼ â†’ MeasureTheory.AEStronglyMeasurable (fun x => g (f x)) Î¼ :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g "]}
{"docString": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c â€¢ a < c â€¢ b â†’ 0 < c â†’ a < b\",\n  \"isProp\": true,\n  \"docString\": \"If `c â€¢ a < c â€¢ b` for some positive `c`, then `a < b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [hÎ± : Archimedean Î±] {p : Î±} (hp : 0 < p) {a b c : Î±},\\n  toIcoMod hp c a = toIcoMod hp c b â†” a â‰¡ b [PMOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : BEq Î±] [self : PartialEquivBEq Î±] {a b c : Î±},\\n  (a == b) = true â†’ (b == c) = true â†’ (a == c) = true\",\n  \"isProp\": true,\n  \"docString\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, a % b = c â†’ b âˆ£ a - c\",\n  \"isProp\": true,\n  \"docString\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => âˆƒ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation â€œthere exists an element that semiconjugates `a` to `b`â€ on a semigroup\\nis transitive. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z â†’ SemiconjBy b x y â†’ SemiconjBy (a * b) x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\\nsemiconjugates `x` to `z`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CommMonoid Î±] (a b u : Î±), IsUnit u â†’ (a âˆ£ u * b â†” a âˆ£ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\\nassociates of `b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CircularPartialOrder Î±] {a b c : Î±}, btw a b c â†’ btw c b a â†’ a = b âˆ¨ b = c âˆ¨ c = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\\namong `a`, `b`, `c` are identical. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CommMonoid Î±] {a b : Î±} {u : Î±Ë£}, â†‘u * a âˆ£ b â†” a âˆ£ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a commutative monoid, an element `a` divides an element `b` iff all\\nleft associates of `a` divide `b`.\"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- If `c â€¢ a < c â€¢ b` for some positive `c`, then `a < b`. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [self : OrderedSMul R M] {a b : M} {c : R}, c â€¢ a < c â€¢ b â†’ 0 < c â†’ a < b :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [hÎ± : Archimedean Î±] {p : Î±} (hp : 0 < p) {a b c : Î±},\n  toIcoMod hp c a = toIcoMod hp c b â†” a â‰¡ b [PMOD p] :=\n\n/-- Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : BEq Î±] [self : PartialEquivBEq Î±] {a b c : Î±},\n  (a == b) = true â†’ (b == c) = true â†’ (a == c) = true :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ b âˆ£ a - c :=\n\n/-- The relation â€œthere exists an element that semiconjugates `a` to `b`â€ on a semigroup\nis transitive. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => âˆƒ c, SemiconjBy c a b :=\n\n/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X :=\n\n/-- Equality behind `Commute a b`; useful for rewriting. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ a * b = b * a :=\n\n/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z â†’ SemiconjBy b x y â†’ SemiconjBy (a * b) x z :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CommMonoid Î±] (a b u : Î±), IsUnit u â†’ (a âˆ£ u * b â†” a âˆ£ b) :=\n\n/-- If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\namong `a`, `b`, `c` are identical. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CircularPartialOrder Î±] {a b c : Î±}, btw a b c â†’ btw c b a â†’ a = b âˆ¨ b = c âˆ¨ c = a :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CommMonoid Î±] {a b : Î±} {u : Î±Ë£}, â†‘u * a âˆ£ b â†” a âˆ£ b :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem", "choices": ["âˆ€ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c "]}
{"docString": "If an element maps to zero under a ring homomorphism, then it is zero.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\\n  (âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0) â†’\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²}, IsAddGroupHom f â†’ f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) â†’\\n    âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r âˆˆ RingHom.ker f â†” â†‘f r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\",\n  \"isProp\": true,\n  \"docString\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R â†’+* S} {s : Set R},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†” Subsingleton Mâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective â†‘(algebraMap R A) â†’ âˆ€ [inst : CharZero R], CharZero A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R â†’+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map one to one. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G â†’* R), f â‰  1 â†’ (Finset.sum Finset.univ fun g => â†‘f g) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : â„•), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HÏƒ q) 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"In degree `0`, the null homotopic map `HÏƒ` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R â†’+* S} {s : Set R},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"}]\n", "prompt_cons": "/-- Ring homomorphisms map zero to zero. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 0 = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R â‰ƒ+* S), â†‘f 0 = 0 :=\n\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\n  (âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0) â†’\n    CategoryTheory.Mono f :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²}, IsAddGroupHom f â†’ f 0 = 0 :=\n\n/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) â†’\n    âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0 :=\n\n/-- An element is in the kernel if and only if it maps to zero. -/\ntheorem âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, r âˆˆ RingHom.ker f â†” â†‘f r = 0 :=\n\n/-- The zero morphism maps every pseudoelement to 0. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€– :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R â†’+* S} {s : Set R},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subring.closure s) :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†” Subsingleton Mâ‚€ :=\n\n/-- If the algebra map `R â†’+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective â†‘(algebraMap R A) â†’ âˆ€ [inst : CharZero R], CharZero A :=\n\n/-- Ring homomorphisms map one to one. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 1 = 1 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s) :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\n  (f : G â†’* R), f â‰  1 â†’ (Finset.sum Finset.univ fun g => â†‘f g) = 0 :=\n\n/-- In degree `0`, the null homotopic map `HÏƒ` is zero. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : â„•), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HÏƒ q) 0 = 0 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R â†’+* S} {s : Set R},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subsemiring.closure s) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem", "choices": ["âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R â†’+* S} {r : R}, â†‘f r = 0 â†’ r âˆˆ RingHom.ker f "]}
{"docString": "Implication `â†’` is symmetric. If `P â†’ Q` then `Q â†’ P`.", "prompts": "[{\"theorem\": \"âˆ€ {p q r : Prop}, (p â†’ q) â†’ (q â†’ r) â†’ p â†’ r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y : Î±}, r x y â†’ r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    âˆ€ (P : CategoryTheory.Functor Cáµ’áµ– D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor Cáµ’áµ– D)\\n  [inst_3 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)áµ’áµ– D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P âŸ¶ Pâº)âº = Pâº âŸ¶ Pâºâº` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’ CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ (x : Î±), r x x\",\n  \"isProp\": true,\n  \"docString\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M â†’ Prop},\\n  (âˆ€ (I : Submodule R M), (âˆ€ (J : Submodule R M), J > I â†’ P J) â†’ P I) â†’ âˆ€ (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `âˆ€ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a b c d : Î±} [inst : Preorder Î±], c â‰¤ a â†’ b â‰¤ d â†’ a â‰¤ b â†’ c â‰¤ d\",\n  \"isProp\": true,\n  \"docString\": \"monotonicity of `â‰¤` with respect to `â†’` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} [self : Antisymm r] {a b : Î±}, r a b â†’ r b a â†’ a = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antisymmetric relation `(Â·â‰¤Â·)` satisfies `a â‰¤ b â†’ b â‰¤ a â†’ a = b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x y : Î±), x â‡¨ y = y âŠ” xá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"`x â‡¨ y` is equal to `y âŠ” xá¶œ` \"},\n {\"theorem\":\n  \"âˆ€ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P â†’\\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P)\",\n  \"isProp\": true,\n  \"docString\": \"`P` as a morphism property respects isomorphisms \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, â†‘c x y â†’ â†‘c y x\",\n  \"isProp\": true,\n  \"docString\": \"Congruence relations are symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace), P f â†’ P (f âˆ£_ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : HeytingAlgebra Î±]\\n  [inst_1 : HeytingAlgebra Î²] [self : HeytingHomClass F Î± Î²] (f : F) (a b : Î±), â†‘f (a â‡¨ b) = â†‘f a â‡¨ â†‘f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T â‰¤ S â†’\\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\\n      [inst_5 : Fintype (M â§¸ T)],\\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, â†‘c x y â†’ â†‘c y x\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are symmetric.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A âŸ¶ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\\n  CategoryTheory.IsReflexivePair g f\",\n  \"isProp\": true,\n  \"docString\": \"If `f,g` is reflexive, then `g,f` is reflexive. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : BiheytingAlgebra Î±]\\n  [inst_1 : BiheytingAlgebra Î²] [self : BiheytingHomClass F Î± Î²] (f : F) (a b : Î±), â†‘f (a â‡¨ b) = â†‘f a â‡¨ â†‘f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a bi-Heyting homomorphism preserves the Heyting implication.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. \"}]\n", "prompt_cons": "/-- Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`. -/\ntheorem âˆ€ {p q r : Prop}, (p â†’ q) â†’ (q â†’ r) â†’ p â†’ r :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y : Î±}, r x y â†’ r y x :=\n\n/-- `(P âŸ¶ Pâº)âº = Pâº âŸ¶ Pâºâº` -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D]\n  [inst_2 :\n    âˆ€ (P : CategoryTheory.Functor Cáµ’áµ– D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  (P : CategoryTheory.Functor Cáµ’áµ– D)\n  [inst_3 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)áµ’áµ– D],\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- `P` respects isomorphisms. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’ CategoryTheory.MorphismProperty.RespectsIso P :=\n\n/-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z :=\n\n/-- An equivalence relation is reflexive: `x ~ x` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ (x : Î±), r x x :=\n\n/-- If `âˆ€ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] {P : Submodule R M â†’ Prop},\n  (âˆ€ (I : Submodule R M), (âˆ€ (J : Submodule R M), J > I â†’ P J) â†’ P I) â†’ âˆ€ (I : Submodule R M), P I :=\n\n/-- monotonicity of `â‰¤` with respect to `â†’` -/\ntheorem âˆ€ {Î± : Type u} {a b c d : Î±} [inst : Preorder Î±], c â‰¤ a â†’ b â‰¤ d â†’ a â‰¤ b â†’ c â‰¤ d :=\n\n/-- An antisymmetric relation `(Â·â‰¤Â·)` satisfies `a â‰¤ b â†’ b â‰¤ a â†’ a = b`. -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} [self : Antisymm r] {a b : Î±}, r a b â†’ r b a â†’ a = b :=\n\n/-- `x â‡¨ y` is equal to `y âŠ” xá¶œ` -/\ntheorem âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x y : Î±), x â‡¨ y = y âŠ” xá¶œ :=\n\n/-- `P` as a morphism property respects isomorphisms -/\ntheorem âˆ€ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P â†’\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P) :=\n\n/-- Congruence relations are symmetric. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, â†‘c x y â†’ â†‘c y x :=\n\n/-- If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace), P f â†’ P (f âˆ£_ U) :=\n\n/-- The proposition that a Heyting homomorphism preserves the Heyting implication. -/\ntheorem âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : HeytingAlgebra Î±]\n  [inst_1 : HeytingAlgebra Î²] [self : HeytingHomClass F Î± Î²] (f : F) (a b : Î±), â†‘f (a â‡¨ b) = â†‘f a â‡¨ â†‘f b :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T â‰¤ S â†’\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\n      [inst_5 : Fintype (M â§¸ T)],\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T) :=\n\n/-- Additive congruence relations are symmetric. -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, â†‘c x y â†’ â†‘c y x :=\n\n/-- If `f,g` is reflexive, then `g,f` is reflexive. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A âŸ¶ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\n  CategoryTheory.IsReflexivePair g f :=\n\n/-- The proposition that a bi-Heyting homomorphism preserves the Heyting implication. -/\ntheorem âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : BiheytingAlgebra Î±]\n  [inst_1 : BiheytingAlgebra Î²] [self : BiheytingHomClass F Î± Î²] (f : F) (a b : Î±), â†‘f (a â‡¨ b) = â†‘f a â‡¨ â†‘f b :=\n\n/-- If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i :=\n\n/-- Implication `â†’` is symmetric. If `P â†’ Q` then `Q â†’ P`. -/\ntheorem", "choices": ["This statement is incorrect. Implication `â†’` is not symmetric."]}
{"docString": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [self : GCDMonoid Î±] {a b c : Î±}, a âˆ£ c â†’ a âˆ£ b â†’ a âˆ£ gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"âˆ€ (n : â„•), PGame.Numeric â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"âˆ€ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 â†’ d < Cardinal.aleph0 â†’ (â†‘Cardinal.toNat c = â†‘Cardinal.toNat d â†” c = d)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite cardinals are equal iff they are equal their to_nat are equal \"},\n {\"theorem\": \"âˆ€ {a b : â„¤}, a âˆ£ b â†’ Int.natAbs b < Int.natAbs a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a b : Î±}, a âˆ£ a + b â†” a âˆ£ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum a + b if and only if a divides b.\"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- Any common divisor of both elements is a divisor of the GCD. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [self : GCDMonoid Î±] {a b c : Î±}, a âˆ£ c â†’ a âˆ£ b â†’ a âˆ£ gcd c b :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem âˆ€ (n : â„•), PGame.Numeric â†‘n :=\n\n/-- Two finite cardinals are equal iff they are equal their to_nat are equal -/\ntheorem âˆ€ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 â†’ d < Cardinal.aleph0 â†’ (â†‘Cardinal.toNat c = â†‘Cardinal.toNat d â†” c = d) :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem âˆ€ {a b : â„¤}, a âˆ£ b â†’ Int.natAbs b < Int.natAbs a â†’ b = 0 :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- An element a divides the sum a + b if and only if a divides b. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a b : Î±}, a âˆ£ a + b â†” a âˆ£ b :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem", "choices": ["âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n "]}
