[
  {
    "docString": "Every ring is a field.",
    "prompts": "[{\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x)\",\n  \"isProp\": true,\n  \"docString\": \"Stalks of a locally ringed space are local rings. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ‚âÉ+* B ‚Üí IsDomain A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"}]\n",
    "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem ‚àÄ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ‚àà S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ‚àà S :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K } :=\n\n/-- Fields are commutative. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ± :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä• :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±) :=\n\n/-- Every ring involution must be its own inverse -/\ntheorem ‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I) :=\n\n/-- Stalks of a locally ringed space are local rings. -/\ntheorem ‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem ‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0 :=\n\n/-- A subring contains the ring's 0. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§ :=\n\n/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\ntheorem ‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ‚âÉ+* B ‚Üí IsDomain A :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ± :=\n\n/-- Every ring is a field. -/\ntheorem",
    "choices": [
      "This statement is incorrect and cannot be proven. Not every ring is a field. A field is a special type of ring where every nonzero element has a multiplicative inverse. There are many rings that do not satisfy this property, such as the integers (‚Ñ§) or the ring of polynomials over a field."
    ]
  },
  {
    "docString": "Every vector space is finite dimensional.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  [inst_3 : Finite Œπ], Basis Œπ K V ‚Üí FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  {s : Set Œπ}, Basis (‚Üës) K V ‚Üí Set.Finite s ‚Üí FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ùïú E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ùïú F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ùïú F]\\n  [inst_10 : FiniteDimensional ùïú E] [inst_11 : FiniteDimensional ùïú F], FiniteDimensional ùïú (E ‚ÜíL[ùïú] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsComplete ‚Üës\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type w} [inst_4 : Fintype Œπ], Basis Œπ R M ‚Üí Module.rank R M = ‚Üë(Fintype.card Œπ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"‚àÄ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    ‚Üë(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget‚ÇÇ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s ‚Üí FiniteDimensional k { x // x ‚àà vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ], (M ‚âÉ‚Çó[R] M‚ÇÅ) ‚Üí Module.rank R M = Module.rank R M‚ÇÅ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ‚ß∏ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Œπ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Œπ} {f : ‚Üës ‚Üí P},\\n  AffineIndependent k f ‚Üí Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x ‚àà AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x ‚àà vectorSpan k (insert p ‚Üës) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  FiniteDimensional K { x // x ‚àà LinearMap.range f }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  LinearMap.range f = ‚ä§ ‚Üí FiniteDimensional K V‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {Œπ : Type w} [inst_4 : Fintype Œπ],\\n  Basis Œπ K V ‚Üí FiniteDimensional.finrank K V = Fintype.card Œπ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ‚âÉ‚Çó[K] V') ‚Üî Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ],\\n  (M ‚âÉ‚Çó[R] M‚ÇÇ) ‚Üí FiniteDimensional.finrank R M = FiniteDimensional.finrank R M‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 ‚Üí Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"}]\n",
    "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\n  [inst_3 : Finite Œπ], Basis Œπ K V ‚Üí FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\n  {s : Set Œπ}, Basis (‚Üës) K V ‚Üí Set.Finite s ‚Üí FiniteDimensional K V :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ‚àà S } :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem ‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ùïú E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ùïú F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ùïú F]\n  [inst_10 : FiniteDimensional ùïú E] [inst_11 : FiniteDimensional ùïú F], FiniteDimensional ùïú (E ‚ÜíL[ùïú] F) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsComplete ‚Üës :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type w} [inst_4 : Fintype Œπ], Basis Œπ R M ‚Üí Module.rank R M = ‚Üë(Fintype.card Œπ) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem ‚àÄ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    ‚Üë(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget‚ÇÇ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem ‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s ‚Üí FiniteDimensional k { x // x ‚àà vectorSpan k s } :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ], (M ‚âÉ‚Çó[R] M‚ÇÅ) ‚Üí Module.rank R M = Module.rank R M‚ÇÅ :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ‚ß∏ S) :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Œπ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Œπ} {f : ‚Üës ‚Üí P},\n  AffineIndependent k f ‚Üí Set.Finite s :=\n\n/-- The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. -/\ntheorem ‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\n  [inst_4 : FiniteDimensional k { x // x ‚àà AffineSubspace.direction s }] (p : P),\n  FiniteDimensional k { x // x ‚àà vectorSpan k (insert p ‚Üës) } :=\n\n/-- The range of a linear map defined on a finite-dimensional space is also finite-dimensional. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\n  FiniteDimensional K { x // x ‚àà LinearMap.range f } :=\n\n/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\n  LinearMap.range f = ‚ä§ ‚Üí FiniteDimensional K V‚ÇÇ :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Œπ : Type w} [inst_4 : Fintype Œπ],\n  Basis Œπ K V ‚Üí FiniteDimensional.finrank K V = Fintype.card Œπ :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ‚âÉ‚Çó[K] V') ‚Üî Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ],\n  (M ‚âÉ‚Çó[R] M‚ÇÇ) ‚Üí FiniteDimensional.finrank R M = FiniteDimensional.finrank R M‚ÇÇ :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 ‚Üí Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem",
    "choices": [
      "‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V "
    ]
  },
  {
    "docString": "Every group is a torsion monoid.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G ‚Üí CommMonoid.torsion G = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"The torsion submonoid of a torsion monoid is `‚ä§`. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ‚àà AddCommMonoid.addTorsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion submonoids are additively torsion.\"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"{G : Type u_1} ‚Üí [inst : Monoid G] ‚Üí Monoid.IsTorsion G ‚Üí Group G\",\n  \"isProp\": false,\n  \"docString\": \"Torsion monoids are really groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"}]\n",
    "prompt_cons": "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- The torsion submonoid of a torsion monoid is `‚ä§`. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G ‚Üí CommMonoid.torsion G = ‚ä§ :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G) :=\n\n/-- Additive torsion submonoids are additively torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ‚àà AddCommMonoid.addTorsion G } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G :=\n\n/-- Torsion monoids are really groups. -/\ntheorem {G : Type u_1} ‚Üí [inst : Monoid G] ‚Üí Monoid.IsTorsion G ‚Üí Group G :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H :=\n\n/-- The additive torsion submonoid of an abelian group equals the torsion\nsubgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G) :=\n\n/-- Every group is a torsion monoid. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "
    ]
  },
  {
    "docString": "Every finite simple group has prime order.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, orderOf x = p :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, addOrderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ }) :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí Prime (minpoly A x) :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=\n\n/-- Every finite simple group has prime order. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], ‚àÉ p [hp : Fact (Nat.Prime p)], Fintype.card G = p "
    ]
  },
  {
    "docString": "Every finite group is simple.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousSMul Œì T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousVAdd Œì T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous.\"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ‚ÜëV = 1 ‚Üí CategoryTheory.Simple V\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.IsFiniteMeasure Œº],\\n  MeasureTheory.SigmaFinite Œº\",\n  \"isProp\": true,\n  \"docString\": \"Every finite measure is œÉ-finite. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L\",\n  \"isProp\": true,\n  \"docString\": \"A simple Lie algebra is semisimple. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\\n  FiniteDimensional.finrank K V = 1 ‚Üí IsSimpleOrder (Submodule A V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"}]\n",
    "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\n    Group.IsNilpotent G :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem ‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\n  [inst_3 : Finite Œì], ProperlyDiscontinuousSMul Œì T :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem ‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\n  [inst_3 : Finite Œì], ProperlyDiscontinuousVAdd Œì T :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G } :=\n\n/-- Any `k`-algebra module which is 1-dimensional over `k` is simple. -/\ntheorem ‚àÄ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\n  FiniteDimensional.finrank k ‚ÜëV = 1 ‚Üí CategoryTheory.Simple V :=\n\n/-- Every finite measure is œÉ-finite. -/\ntheorem ‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.IsFiniteMeasure Œº],\n  MeasureTheory.SigmaFinite Œº :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- A simple Lie algebra is semisimple. -/\ntheorem ‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L :=\n\n/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\n  FiniteDimensional.finrank K V = 1 ‚Üí IsSimpleOrder (Submodule A V) :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Every finite group is simple. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ‚Üí IsSimpleGroup G "
    ]
  },
  {
    "docString": "Every finite group has prime order.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ± :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, orderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ }) :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, addOrderOf x = p :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x) :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x) :=\n\n/-- Every finite group has prime order. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ‚àÉ p : ‚Ñï, Fact (Nat.Prime p) ‚àß Fintype.card G = p "
    ]
  },
  {
    "docString": "Every set has Lebesgue measure zero.",
    "prompts": "[{\"theorem\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\\n  (m : MeasureTheory.OuterMeasure Œ±) (s : Set Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ u, u ‚àà nhdsWithin x s ‚àß ‚Üëm u = 0) ‚Üí ‚Üëm s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded s ‚Üí\\n    Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\\n  (s : Set Œ±), (‚àÄ (n : ‚Ñï), ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n) = 0) ‚Üî ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a œÉ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"‚Üë‚ÜëMeasureTheory.volume (‚ãÉ (p : ‚Ñù) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Real.convergent 0 n = 0\",\n  \"isProp\": true,\n  \"docString\": \"All convergents of `0` are zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E}, Convex ‚Ñù s ‚Üí ‚Üë‚ÜëŒº (frontier s) = 0\",\n  \"isProp\": true,\n  \"docString\": \"Haar measure of the frontier of a convex set is zero. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ‚àÖ\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s s = 0\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `‚Ñù √ó ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {i j : Set Œ±},\\n  MeasurableSet i ‚Üí\\n    MeasurableSet j ‚Üí\\n      MeasureTheory.VectorMeasure.restrict 0 i ‚â§ MeasureTheory.VectorMeasure.restrict s i ‚àß\\n          MeasureTheory.VectorMeasure.restrict s i·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 i·∂ú ‚Üí\\n        MeasureTheory.VectorMeasure.restrict 0 j ‚â§ MeasureTheory.VectorMeasure.restrict s j ‚àß\\n            MeasureTheory.VectorMeasure.restrict s j·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 j·∂ú ‚Üí\\n          ‚Üës (i ‚àÜ j) = 0 ‚àß ‚Üës (i·∂ú ‚àÜ j·∂ú) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The symmetric difference of two Hahn decompositions has measure zero. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±], Metric.diam ‚àÖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ], MeasureTheory.Measure.hausdorffMeasure ‚Üë(Fintype.card Œπ) = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `Œπ ‚Üí ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"}]\n",
    "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\n  Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\n  (m : MeasureTheory.OuterMeasure Œ±) (s : Set Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ u, u ‚àà nhdsWithin x s ‚àß ‚Üëm u = 0) ‚Üí ‚Üëm s = 0 :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\n  Metric.Bounded s ‚Üí\n    Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0 :=\n\n/-- A set in a œÉ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\n  (s : Set Œ±), (‚àÄ (n : ‚Ñï), ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n) = 0) ‚Üî ‚Üë‚ÜëŒº s = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem ‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0) :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem ‚Üë‚ÜëMeasureTheory.volume (‚ãÉ (p : ‚Ñù) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- All convergents of `0` are zero. -/\ntheorem ‚àÄ (n : ‚Ñï), Real.convergent 0 n = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0 :=\n\n/-- Haar measure of the frontier of a convex set is zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E}, Convex ‚Ñù s ‚Üí ‚Üë‚ÜëŒº (frontier s) = 0 :=\n\n/-- The empty set is collinear. -/\ntheorem ‚àÄ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k ‚àÖ :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0 :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s s = 0 :=\n\n/-- In the space `‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume :=\n\n/-- In the space `‚Ñù √ó ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume :=\n\n/-- The symmetric difference of two Hahn decompositions has measure zero. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {i j : Set Œ±},\n  MeasurableSet i ‚Üí\n    MeasurableSet j ‚Üí\n      MeasureTheory.VectorMeasure.restrict 0 i ‚â§ MeasureTheory.VectorMeasure.restrict s i ‚àß\n          MeasureTheory.VectorMeasure.restrict s i·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 i·∂ú ‚Üí\n        MeasureTheory.VectorMeasure.restrict 0 j ‚â§ MeasureTheory.VectorMeasure.restrict s j ‚àß\n            MeasureTheory.VectorMeasure.restrict s j·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 j·∂ú ‚Üí\n          ‚Üës (i ‚àÜ j) = 0 ‚àß ‚Üës (i·∂ú ‚àÜ j·∂ú) = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±], Metric.diam ‚àÖ = 0 :=\n\n/-- In the space `Œπ ‚Üí ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem ‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ], MeasureTheory.Measure.hausdorffMeasure ‚Üë(Fintype.card Œπ) = MeasureTheory.volume :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] (s : Set Œ±), ‚Üë‚ÜëMeasureTheory.volume s = 0 "
    ]
  },
  {
    "docString": "If a topological space is compact, then every subset is compact.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G ‚Üí LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- The underlying topological space is compact. -/\ntheorem ‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V) :=\n\n/-- In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V) :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§ :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem ‚àÄ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem ‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G ‚Üí LocallyCompactSpace G :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] (s : Set Œ±), IsCompact s "
    ]
  },
  {
    "docString": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
    "prompts": "[{\"theorem\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\\n  (m : MeasureTheory.OuterMeasure Œ±) (s : Set Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ u, u ‚àà nhdsWithin x s ‚àß ‚Üëm u = 0) ‚Üí ‚Üëm s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded s ‚Üí\\n    Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type w} [inst : TopologicalSpace G] (Œº : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ‚â§ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Œº)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±],\\n  OpensMeasurableSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\\n  (s : Set Œ±), (‚àÄ (n : ‚Ñï), ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n) = 0) ‚Üî ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a œÉ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] (f : ‚Ñù ‚Üí F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt ‚Ñù f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt ùïú f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"‚Üë‚ÜëMeasureTheory.volume (‚ãÉ (p : ‚Ñù) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"‚àÄ (ùïú : Type u_3) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E ‚ÜíL[ùïú] F)},\\n  IsComplete K ‚Üí MeasurableSet {x | DifferentiableAt ùïú f x ‚àß fderiv ùïú f x ‚àà K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±]\\n  [inst_3 : LinearOrder Œ±] [inst_4 : OrderTopology Œ±] [inst_5 : TopologicalSpace.SecondCountableTopology Œ±] {s : Set Œ±},\\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí s ‚àà nhdsWithin x (Set.Ioi x)) ‚Üí MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] (f : ‚Ñù ‚Üí F) {K : Set F},\\n  IsComplete K ‚Üí MeasurableSet {x | DifferentiableWithinAt ‚Ñù f (Set.Ici x) x ‚àß derivWithin f (Set.Ici x) x ‚àà K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function, with derivative in a given complete\\nset, is Borel-measurable. \"}]\n",
    "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\n  Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\n  (m : MeasureTheory.OuterMeasure Œ±) (s : Set Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ u, u ‚àà nhdsWithin x s ‚àß ‚Üëm u = 0) ‚Üí ‚Üëm s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\n  Metric.Bounded s ‚Üí\n    Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem ‚àÄ {G : Type w} [inst : TopologicalSpace G] (Œº : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S ‚â§ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Œº) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem ‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul‚ÇÇ G]\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Œº]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ŒΩ],\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±],\n  OpensMeasurableSpace Œ± :=\n\n/-- A set in a œÉ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\n  (s : Set Œ±), (‚àÄ (n : ‚Ñï), ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n) = 0) ‚Üî ‚Üë‚ÜëŒº s = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem ‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd‚ÇÇ G]\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ŒΩ],\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0 :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] (f : ‚Ñù ‚Üí F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt ‚Ñù f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt ùïú f x} :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem ‚Üë‚ÜëMeasureTheory.volume (‚ãÉ (p : ‚Ñù) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem ‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0) :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem ‚àÄ (ùïú : Type u_3) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E ‚ÜíL[ùïú] F)},\n  IsComplete K ‚Üí MeasurableSet {x | DifferentiableAt ùïú f x ‚àß fderiv ùïú f x ‚àà K} :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0 :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±]\n  [inst_3 : LinearOrder Œ±] [inst_4 : OrderTopology Œ±] [inst_5 : TopologicalSpace.SecondCountableTopology Œ±] {s : Set Œ±},\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí s ‚àà nhdsWithin x (Set.Ioi x)) ‚Üí MeasurableSet s :=\n\n/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem ‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] (f : ‚Ñù ‚Üí F) {K : Set F},\n  IsComplete K ‚Üí MeasurableSet {x | DifferentiableWithinAt ‚Ñù f (Set.Ici x) x ‚àß derivWithin f (Set.Ici x) x ‚àà K} :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : BorelSpace Œ±]\n  (Œº : MeasureTheory.Measure Œ±) (s : Set Œ±), MeasurableSet s ‚Üí ¬¨ BorelSpace.Measurable s ‚Üí ‚Üë‚ÜëŒº s = 0 "
    ]
  },
  {
    "docString": "A finitely-presented group containing a torsion element is finite.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A ‚Üí Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I ‚Üí Algebra.FinitePresentation R A ‚Üí Algebra.FinitePresentation R (A ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => addOrderOf g) ‚Üí AddMonoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group exponent exists for any bounded additive torsion group.\"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"}]\n",
    "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem ‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  Algebra.FinitePresentation R A ‚Üí Algebra.FiniteType R A :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G) :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G) :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem ‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I ‚Üí Algebra.FinitePresentation R A ‚Üí Algebra.FinitePresentation R (A ‚ß∏ I) :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G :=\n\n/-- The group exponent exists for any bounded additive torsion group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => addOrderOf g) ‚Üí AddMonoid.ExponentExists G :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem ‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G], Group.FinitePresentation G ‚Üí (‚àÉ g ‚àà G, orderOf g ‚â† 1) ‚Üí Finite G "
    ]
  },
  {
    "docString": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (‚Ñô K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ‚â§ W ‚Üî S ‚äÜ ‚ÜëW\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ‚Üî IsClosed M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] {s : Set Œ±},\\n  IsClosed s ‚Üí\\n    ‚àÉ S, Set.Finite S ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsClosed t) ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsIrreducible t) ‚àß s = ‚ãÉ‚ÇÄ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] {s : Set Œ±},\\n  Set.Finite s ‚Üí IsClosed ‚Üë(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"}]\n",
    "prompt_cons": "/-- A closed subset of a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s} :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem ‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\n  Convex ùïú s ‚Üí Convex ùïú (closure s) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t) :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (‚Ñô K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ‚â§ W ‚Üî S ‚äÜ ‚ÜëW :=\n\n/-- In a sequential space, a sequentially closed set is closed. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s ‚Üí IsClosed s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ‚Üî IsClosed M :=\n\n/-- The underlying topological space is compact. -/\ntheorem ‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f) :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] {s : Set Œ±},\n  IsClosed s ‚Üí\n    ‚àÉ S, Set.Finite S ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsClosed t) ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsIrreducible t) ‚àß s = ‚ãÉ‚ÇÄ S :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] {s : Set Œ±},\n  Set.Finite s ‚Üí IsClosed ‚Üë(upperClosure s) :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ t, IsClosed t ‚àß x ‚àà t) ‚Üí IsClosed s "
    ]
  },
  {
    "docString": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Œ≥ : Type w} [inst_6 : MetricSpace Œ≥]\\n  {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥},\\n  Isometry Œ¶ ‚Üí Isometry Œ® ‚Üí GromovHausdorff.ghDist X Y ‚â§ Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : T2Space Œ±] [inst_2 : ProperSpace Œ±],\\n  IsCompact s ‚Üî IsClosed s ‚àß Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine‚ÄìBorel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤},\\n  Function.Injective f ‚Üí Continuous f ‚Üí T2Space Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±],\\n  TotallyDisconnectedSpace Œ± ‚Üî TotallySeparatedSpace Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners ‚Ñù E H ‚Üí\\n    ‚àÄ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A œÉ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"‚àÄ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ‚àÄ (j : J), Nonempty ‚Üë(F.obj j)]\\n  [inst_3 : ‚àÄ (j : J), CompactSpace ‚Üë(F.obj j)] [inst_4 : ‚àÄ (j : J), T2Space ‚Üë(F.obj j)],\\n  Nonempty ‚Üë(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"}]\n",
    "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf :=\n\n/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem ‚àÄ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Œ≥ : Type w} [inst_6 : MetricSpace Œ≥]\n  {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥},\n  Isometry Œ¶ ‚Üí Isometry Œ® ‚Üí GromovHausdorff.ghDist X Y ‚â§ Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®) :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem ‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H :=\n\n/-- The **Heine‚ÄìBorel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : T2Space Œ±] [inst_2 : ProperSpace Œ±],\n  IsCompact s ‚Üî IsClosed s ‚àß Metric.Bounded s :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem ‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤},\n  Function.Injective f ‚Üí Continuous f ‚Üí T2Space Œ± :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±],\n  TotallyDisconnectedSpace Œ± ‚Üî TotallySeparatedSpace Œ± :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ± :=\n\n/-- A œÉ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners ‚Ñù E H ‚Üí\n    ‚àÄ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem ‚àÄ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ‚àÄ (j : J), Nonempty ‚Üë(F.obj j)]\n  [inst_3 : ‚àÄ (j : J), CompactSpace ‚Üë(F.obj j)] [inst_4 : ‚àÄ (j : J), T2Space ‚Üë(F.obj j)],\n  Nonempty ‚Üë(TopCat.limitCone F).pt :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  T2Space Œ± ‚Üî IsOpenMap (Œª (x : Œ±), (x, x)) "
    ]
  },
  {
    "docString": "Any finite order element in a group is equal to the identity.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x y : G}, y ‚àà Subgroup.closure {x} ‚Üî ‚àÉ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"}]\n",
    "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x) :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ± :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {x y : G}, y ‚àà Subgroup.closure {x} ‚Üî ‚àÉ n, x ^ n = y :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ‚Üí ‚àÉ n, 0 < n ‚àß x ^ n = 1 "
    ]
  },
  {
    "docString": "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí\\n    N = MonoidHom.ker f ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"}]\n",
    "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G } :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä• :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí\n    N = MonoidHom.ker f ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G) :=\n\n/-- The additive torsion submonoid of an abelian group equals the torsion\nsubgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } ‚Üí Monoid.IsTorsionFree G "
    ]
  },
  {
    "docString": "Every injective homomorphism from a finitely generated free group to itself is surjective.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R ‚Üí\\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\\n  Function.Injective ‚Üë(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"An epimorphism is surjective. \"}]\n",
    "prompt_cons": "/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1) :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R ‚Üí\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0) :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c) :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f) :=\n\n/-- The canonical map from the type to the free group is an injection. -/\ntheorem ‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem ‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\n  Function.Injective ‚Üë(Con.kerLift f) :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí f 1 = 1 :=\n\n/-- An epimorphism is surjective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§ :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] {f : FreeGroup Œ± ‚Üí* FreeGroup Œ±},\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf "
    ]
  },
  {
    "docString": "Every division ring is either a field or finite.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ]\\n  [inst_2 : Valued K Œì‚ÇÄ], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"}]\n",
    "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem ‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ]\n  [inst_2 : Valued K Œì‚ÇÄ], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem ‚àÄ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ‚àà S :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ‚àà S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem ‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0 :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ± :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ± :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- A subfield is closed under division. -/\ntheorem ‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ± :=\n\n/-- A finite set is bounded -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem",
    "choices": [
      "‚àÄ (K : Type u_1) [inst : DivisionRing K], IsField K ‚à® Fintype K "
    ]
  },
  {
    "docString": "Every natural number is the product of two primes.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Œπ : Type u_1} (s : Finset Œπ)\\n  (f : Œπ ‚Üí Ideal R) (e : Œπ ‚Üí ‚Ñï),\\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí Prime (f i)) ‚Üí\\n    (‚àÄ (i : Œπ), i ‚àà s ‚Üí ‚àÄ (j : Œπ), j ‚àà s ‚Üí i ‚â† j ‚Üí f i ‚â† f j) ‚Üí\\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of distinct prime powers in a Dedekind domain is the product of these\\nprime powers. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\": \"‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) q ‚â† 0 ‚Üí p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"‚àÄ (n k : ‚Ñï),\\n  k ‚â§ n ‚Üí (Finset.prod (Finset.range (n + 1)) fun p => p ^ ‚Üë(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k\",\n  \"isProp\": true,\n  \"docString\":\n  \"A binomial coefficient is the product of its prime factors, which are at most `n`. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3 :=\n\n/-- The intersection of distinct prime powers in a Dedekind domain is the product of these\nprime powers. -/\ntheorem ‚àÄ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Œπ : Type u_1} (s : Finset Œπ)\n  (f : Œπ ‚Üí Ideal R) (e : Œπ ‚Üí ‚Ñï),\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí Prime (f i)) ‚Üí\n    (‚àÄ (i : Œπ), i ‚àà s ‚Üí ‚àÄ (j : Œπ), j ‚àà s ‚Üí i ‚â† j ‚Üí f i ‚â† f j) ‚Üí\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem ‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí Prime (minpoly A x) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2 :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem ‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem ‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) q ‚â† 0 ‚Üí p = q :=\n\n/-- A binomial coefficient is the product of its prime factors, which are at most `n`. -/\ntheorem ‚àÄ (n k : ‚Ñï),\n  k ‚â§ n ‚Üí (Finset.prod (Finset.range (n + 1)) fun p => p ^ ‚Üë(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem",
    "choices": [
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p * q "
    ]
  },
  {
    "docString": "Every even number is the square of a natural number.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b, n = a ^ 2 * b ‚àß IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ‚â† 2 ‚Üí ‚àÉ a, ¬¨IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"‚àÄ {n x y : ‚Ñï}, n = x ^ 2 + y ^ 2 ‚Üí Nat.coprime x y ‚Üí IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\\n  MulChar.IsQuadratic œá ‚Üí ‚àÄ {n : ‚Ñï}, Odd n ‚Üí œá ^ n = œá\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ‚àÄ (a b c d x y z w : ‚Ñï),\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem ‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b, n = a ^ 2 * b ‚àß IsSquare (-1) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ‚â† 2 ‚Üí ‚àÉ a, ¬¨IsSquare a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ‚àÄ {n x y : ‚Ñï}, n = x ^ 2 + y ^ 2 ‚Üí Nat.coprime x y ‚Üí IsSquare (-1) :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\n  MulChar.IsQuadratic œá ‚Üí ‚àÄ {n : ‚Ñï}, Odd n ‚Üí œá ^ n = œá :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem",
    "choices": [
      "‚àÄ {n : ‚Ñï}, Even n ‚Üí ‚àÉ x, n = x ^ 2 "
    ]
  },
  {
    "docString": "Every normal subgroup of a group has finite index.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1} {s : Set Œπ}, Basis (‚Üës) R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A ‚Üí FiniteDimensional K { x // x ‚àà Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí (H : Subgroup G) ‚Üí [inst_1 : Subgroup.FiniteIndex H] ‚Üí Fintype (G ‚ß∏ H)\",\n  \"isProp\": false,\n  \"docString\": \"A finite index subgroup has finite quotient. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1}, Basis Œπ R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Nonempty (Fintype Œπ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0 :=\n\n/-- The additive subgroup has finite index -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0 :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ‚àà H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} {s : Set Œπ}, Basis (‚Üës) R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Set.Finite s :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem ‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\n  Set.Finite A ‚Üí FiniteDimensional K { x // x ‚àà Submodule.span K A } :=\n\n/-- A finite index subgroup has finite quotient. -/\ntheorem {G : Type u_1} ‚Üí [inst : Group G] ‚Üí (H : Subgroup G) ‚Üí [inst_1 : Subgroup.FiniteIndex H] ‚Üí Fintype (G ‚ß∏ H) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G } :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite type. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1}, Basis Œπ R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Nonempty (Fintype Œπ) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx :=\n\n/-- A subgroup is closed under division. -/\ntheorem ‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ‚â† 0 "
    ]
  },
  {
    "docString": "The characteristic polynomial of every matrix has real roots.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : IsROrC Œ±] {A : Matrix n n Œ±},\\n  Matrix.IsHermitian A ‚Üí (fun i => ‚Üë(‚ÜëIsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"‚àÄ {f : Polynomial ‚ÑÇ}, 0 < Polynomial.degree f ‚Üí ‚àÉ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\\n  {T : E ‚Üí‚Çó[ùïú] E}, LinearMap.IsSymmetric T ‚Üí ‚àÄ {Œº : ùïú}, Module.End.HasEigenvalue T Œº ‚Üí ‚Üë(starRingEnd ùïú) Œº = Œº\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"‚àÄ (p : Polynomial ‚Ñù),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ‚â§\\n    Finset.card (Multiset.toFinset (Polynomial.roots (‚ÜëPolynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ‚Ñù] (p : Polynomial F),\\n  Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet (‚ÜëPolynomial.derivative p) ‚Ñù) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ‚ÑÇ A] (a : { x // x ‚àà selfAdjoint A }) {z : ‚ÑÇ},\\n  z ‚àà spectrum ‚ÑÇ ‚Üëa ‚Üí z = ‚Üëz.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\\n  ‚àÉ n f _hf q, p = ‚Üë(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] [inst_3 : DecidableEq S]\\n  (m : R ‚Üí+* S) (d : ‚Ñï) {U : Set R},\\n  Set.Finite U ‚Üí\\n    Set.Finite\\n      (‚ãÉ (f : Polynomial R) (_ : Polynomial.natDegree f ‚â§ d ‚àß ‚àÄ (i : ‚Ñï), Polynomial.coeff f i ‚àà U),\\n        ‚Üë(Multiset.toFinset (Polynomial.roots (Polynomial.map m f))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of roots of all polynomials of bounded degree and having coefficients in a finite set\\nis finite. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : ‚Ñù} {d : ‚Ñï} (f : F ‚Üí+* K)\\n  {p : Polynomial F},\\n  Polynomial.Monic p ‚Üí\\n    Polynomial.Splits f p ‚Üí\\n      Polynomial.natDegree p ‚â§ d ‚Üí\\n        (‚àÄ (z : K), z ‚àà Polynomial.roots (Polynomial.map f p) ‚Üí ‚Äñz‚Äñ ‚â§ B) ‚Üí\\n          ‚àÄ (i : ‚Ñï), ‚ÄñPolynomial.coeff (Polynomial.map f p) i‚Äñ ‚â§ max B 1 ^ d * ‚Üë(Nat.choose d (d / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coefficients of the monic polynomials of bounded degree with bounded roots are\\nuniformly bounded. \"},\n {\"theorem\":\n  \"‚àÄ (p : Polynomial ‚Ñù),\\n  ‚ÜëMultiset.card (Polynomial.roots p) ‚â§ ‚ÜëMultiset.card (Polynomial.roots (‚ÜëPolynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"‚àÄ {p : Polynomial ‚Ñö},\\n  Irreducible p ‚Üí\\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) = Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 2 ‚Üí\\n        Function.Bijective ‚Üë(Polynomial.Gal.galActionHom p ‚ÑÇ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"‚àÄ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\\n  ‚Üë(Polynomial.aeval x) (minpoly A x) = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is a root of its minimal polynomial. \"},\n {\"theorem\":\n  \"‚àÄ {p : Polynomial ‚Ñö},\\n  Irreducible p ‚Üí\\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 1 ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚Üí\\n        Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 3 ‚Üí\\n          Function.Bijective ‚Üë(Polynomial.Gal.galActionHom p ‚ÑÇ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p ‚Üî ‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.natDegree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The degree of a minimal polynomial, as a natural number, is positive. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {Œº : R} {k : ‚Ñï}, Module.End.HasGeneralizedEigenvalue f Œº k ‚Üí Module.End.HasEigenvalue f Œº\",\n  \"isProp\": true,\n  \"docString\": \"All generalized eigenvalues are eigenvalues. \"}]\n",
    "prompt_cons": "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem ‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : IsROrC Œ±] {A : Matrix n n Œ±},\n  Matrix.IsHermitian A ‚Üí (fun i => ‚Üë(‚ÜëIsROrC.re (Matrix.diag A i))) = Matrix.diag A :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem ‚àÄ {f : Polynomial ‚ÑÇ}, 0 < Polynomial.degree f ‚Üí ‚àÉ z, Polynomial.IsRoot f z :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {T : E ‚Üí‚Çó[ùïú] E}, LinearMap.IsSymmetric T ‚Üí ‚àÄ {Œº : ùïú}, Module.End.HasEigenvalue T Œº ‚Üí ‚Üë(starRingEnd ùïú) Œº = Œº :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ‚àÄ (p : Polynomial ‚Ñù),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ‚â§\n    Finset.card (Multiset.toFinset (Polynomial.roots (‚ÜëPolynomial.derivative p))) + 1 :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ‚àÄ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ‚Ñù] (p : Polynomial F),\n  Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet (‚ÜëPolynomial.derivative p) ‚Ñù) + 1 :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem ‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule ‚ÑÇ A] (a : { x // x ‚àà selfAdjoint A }) {z : ‚ÑÇ},\n  z ‚àà spectrum ‚ÑÇ ‚Üëa ‚Üí z = ‚Üëz.re :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem ‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\n  ‚àÉ n f _hf q, p = ‚Üë(MvPolynomial.rename f) q :=\n\n/-- The degree of a minimal polynomial is positive. -/\ntheorem ‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x) :=\n\n/-- Every identity matrix is diagonal. -/\ntheorem ‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1 :=\n\n/-- The set of roots of all polynomials of bounded degree and having coefficients in a finite set\nis finite. -/\ntheorem ‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] [inst_3 : DecidableEq S]\n  (m : R ‚Üí+* S) (d : ‚Ñï) {U : Set R},\n  Set.Finite U ‚Üí\n    Set.Finite\n      (‚ãÉ (f : Polynomial R) (_ : Polynomial.natDegree f ‚â§ d ‚àß ‚àÄ (i : ‚Ñï), Polynomial.coeff f i ‚àà U),\n        ‚Üë(Multiset.toFinset (Polynomial.roots (Polynomial.map m f)))) :=\n\n/-- The coefficients of the monic polynomials of bounded degree with bounded roots are\nuniformly bounded. -/\ntheorem ‚àÄ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : ‚Ñù} {d : ‚Ñï} (f : F ‚Üí+* K)\n  {p : Polynomial F},\n  Polynomial.Monic p ‚Üí\n    Polynomial.Splits f p ‚Üí\n      Polynomial.natDegree p ‚â§ d ‚Üí\n        (‚àÄ (z : K), z ‚àà Polynomial.roots (Polynomial.map f p) ‚Üí ‚Äñz‚Äñ ‚â§ B) ‚Üí\n          ‚àÄ (i : ‚Ñï), ‚ÄñPolynomial.coeff (Polynomial.map f p) i‚Äñ ‚â§ max B 1 ^ d * ‚Üë(Nat.choose d (d / 2)) :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem ‚àÄ (p : Polynomial ‚Ñù),\n  ‚ÜëMultiset.card (Polynomial.roots p) ‚â§ ‚ÜëMultiset.card (Polynomial.roots (‚ÜëPolynomial.derivative p)) + 1 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ‚àÄ {p : Polynomial ‚Ñö},\n  Irreducible p ‚Üí\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) = Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 2 ‚Üí\n        Function.Bijective ‚Üë(Polynomial.Gal.galActionHom p ‚ÑÇ) :=\n\n/-- An element is a root of its minimal polynomial. -/\ntheorem ‚àÄ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\n  ‚Üë(Polynomial.aeval x) (minpoly A x) = 0 :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ‚àÄ {p : Polynomial ‚Ñö},\n  Irreducible p ‚Üí\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 1 ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚Üí\n        Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 3 ‚Üí\n          Function.Bijective ‚Üë(Polynomial.Gal.galActionHom p ‚ÑÇ) :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem ‚àÄ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p ‚Üî ‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- The degree of a minimal polynomial, as a natural number, is positive. -/\ntheorem ‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.natDegree (minpoly A x) :=\n\n/-- All generalized eigenvalues are eigenvalues. -/\ntheorem ‚àÄ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {Œº : R} {k : ‚Ñï}, Module.End.HasGeneralizedEigenvalue f Œº k ‚Üí Module.End.HasEigenvalue f Œº :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem",
    "choices": [
      "‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type u_2} [inst_2 : CommRing R] [inst_3 : Algebra R ‚Ñù]\n  (M : Matrix n n R), ‚àÉ p, Polynomial.map (algebraMap R ‚Ñù) (Matrix.charpoly M) = p "
    ]
  },
  {
    "docString": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ {I : Ideal R}, IsUnit ‚ÜëI ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S ‚â§ nonZeroDivisors R ‚Üí\\n    Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ (I I' : FractionalIdeal S A), I * I' = 1 ‚Üí Submodule.IsPrincipal ‚ÜëI\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ‚Üëf ‚Üí Ideal.IsMaximal (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ‚àÉ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, ¬ß 3.3, Lemma 3])\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\\n  I < J ‚Üí ‚ÜëJ = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R ‚Üí+* S),\\n  Function.Surjective ‚Üëf ‚Üí IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a domain is a prime ideal. \"}]\n",
    "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R],\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I) :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ {I : Ideal R}, IsUnit ‚ÜëI ‚Üí Submodule.IsPrincipal I :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M :=\n\n/-- The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ‚àÄ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S ‚â§ nonZeroDivisors R ‚Üí\n    Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ (I I' : FractionalIdeal S A), I * I' = 1 ‚Üí Submodule.IsPrincipal ‚ÜëI :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I :=\n\n/-- The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem ‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\n  Function.Surjective ‚Üëf ‚Üí Ideal.IsMaximal (RingHom.ker f) :=\n\n/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, ¬ß 3.3, Lemma 3]) -/\ntheorem ‚àÄ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\n  ‚àÉ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä• :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem ‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\n  I < J ‚Üí ‚ÜëJ = Set.univ :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem ‚àÄ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R ‚Üí+* S),\n  Function.Surjective ‚Üëf ‚Üí IsPrincipalIdealRing S :=\n\n/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f) :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ‚àÉ! M, Ideal.IsMaximal M ‚àß P ‚â§ M "
    ]
  },
  {
    "docString": "Every continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œπ : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} [inst_1 : Subsingleton Œπ],\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí ‚àÄ {f : Œπ ‚Üí Œ± ‚Üí Œ≤}, (‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p) ‚Üí MeasureTheory.UnifIntegrable f p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A single function is uniformly integrable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u) ‚Üí ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±),\\n      x ‚àà s ‚Üí\\n        ‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n          u ‚àà uniformity Œ≤ ‚Üí\\n            ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformlyOn F f p s ‚Üí\\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"}]\n",
    "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº :=\n\n/-- Uniform continuity of the function -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F :=\n\n/-- A single function is uniformly integrable. -/\ntheorem ‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œπ : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} [inst_1 : Subsingleton Œπ],\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí ‚àÄ {f : Œπ ‚Üí Œ± ‚Üí Œ≤}, (‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p) ‚Üí MeasureTheory.UnifIntegrable f p Œº :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    ContinuousAt f x :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u) ‚Üí ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±),\n      x ‚àà s ‚Üí\n        ‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n          u ‚àà uniformity Œ≤ ‚Üí\n            ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    ContinuousOn f s :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí Equicontinuous F :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformlyOn F f p s ‚Üí\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±] (f : Œ± ‚Üí Œ≤),\n  Continuous f ‚Üí UniformContinuous f "
    ]
  },
  {
    "docString": "Every uniformly continuous function is bounded above.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\\n  (‚àÄ (x : Œπ), f x ‚â§ c) ‚Üí iSup f ‚â§ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±}, Set.Finite s ‚Üí BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±},\\n  Set.Finite I ‚Üí (BddAbove (‚ãÉ (i : Œ≤) (_ : i ‚àà I), S i) ‚Üî ‚àÄ (i : Œ≤), i ‚àà I ‚Üí BddAbove (S i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±},\\n  TotallyBounded s ‚Üí UniformContinuous f ‚Üí TotallyBounded (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformlyOn F f p s ‚Üí\\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : Œπ ‚Üí Œ±},\\n  BddBelow (Set.range f) ‚Üí ‚àÄ (c : Œπ), iInf f ‚â§ f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed infimum of a function is bounded above by the value taken at one point\"}]\n",
    "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K) :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddAbove (Set.range f) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K) :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\n  (‚àÄ (x : Œπ), f x ‚â§ c) ‚Üí iSup f ‚â§ c :=\n\n/-- A finite set is bounded above. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±}, Set.Finite s ‚Üí BddAbove s :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddBelow (Set.range f) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i) :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f) :=\n\n/-- A finite union of sets which are all bounded above is still bounded above. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±},\n  Set.Finite I ‚Üí (BddAbove (‚ãÉ (i : Œ≤) (_ : i ‚àà I), S i) ‚Üî ‚àÄ (i : Œ≤), i ‚àà I ‚Üí BddAbove (S i)) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº :=\n\n/-- The image of a totally bounded set under a uniformly continuous map is totally bounded. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±},\n  TotallyBounded s ‚Üí UniformContinuous f ‚Üí TotallyBounded (f '' s) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    Continuous f :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformlyOn F f p s ‚Üí\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº :=\n\n/-- The indexed infimum of a function is bounded above by the value taken at one point -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : Œπ ‚Üí Œ±},\n  BddBelow (Set.range f) ‚Üí ‚àÄ (c : Œπ), iInf f ‚â§ f c :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : Nonempty Œ±] [inst_3 : BoundedOrder Œ≤]\n  {f : Œ± ‚Üí Œ≤}, UniformContinuous f ‚Üí BddAbove (Set.range f) "
    ]
  },
  {
    "docString": "If every compact subset of a topological space is closed, then the space is compact.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"‚àÄ {ùïú‚ÇÅ : Type u_1} {ùïú‚ÇÇ : Type u_2} [inst : NontriviallyNormedField ùïú‚ÇÅ] [inst_1 : NormedField ùïú‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : ùïú‚ÇÅ ‚Üí+* ùïú‚ÇÇ}\\n  {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst_2 : SeminormedAddCommGroup M‚ÇÅ] [inst_3 : AddCommGroup M‚ÇÇ]\\n  [inst_4 : NormedSpace ùïú‚ÇÅ M‚ÇÅ] [inst_5 : Module ùïú‚ÇÇ M‚ÇÇ] [inst_6 : UniformSpace M‚ÇÇ] [inst_7 : UniformAddGroup M‚ÇÇ]\\n  [inst_8 : ContinuousConstSMul ùïú‚ÇÇ M‚ÇÇ] [inst_9 : T2Space M‚ÇÇ] [inst_10 : CompleteSpace M‚ÇÇ],\\n  IsClosed {f | IsCompactOperator ‚Üëf}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- The underlying topological space is compact. -/\ntheorem ‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s :=\n\n/-- In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§ :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±) :=\n\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem ‚àÄ {ùïú‚ÇÅ : Type u_1} {ùïú‚ÇÇ : Type u_2} [inst : NontriviallyNormedField ùïú‚ÇÅ] [inst_1 : NormedField ùïú‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : ùïú‚ÇÅ ‚Üí+* ùïú‚ÇÇ}\n  {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst_2 : SeminormedAddCommGroup M‚ÇÅ] [inst_3 : AddCommGroup M‚ÇÇ]\n  [inst_4 : NormedSpace ùïú‚ÇÅ M‚ÇÅ] [inst_5 : Module ùïú‚ÇÇ M‚ÇÇ] [inst_6 : UniformSpace M‚ÇÇ] [inst_7 : UniformAddGroup M‚ÇÇ]\n  [inst_8 : ContinuousConstSMul ùïú‚ÇÇ M‚ÇÇ] [inst_9 : T2Space M‚ÇÇ] [inst_10 : CompleteSpace M‚ÇÇ],\n  IsClosed {f | IsCompactOperator ‚Üëf} :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem ‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\n  Convex ùïú s ‚Üí Convex ùïú (closure s) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ± :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ (s : Set Œ±), IsCompact s ‚Üí IsClosed s) ‚Üí CompactSpace Œ± "
    ]
  },
  {
    "docString": "In a commutative ring, the sum of idempotent elements is idempotent.",
    "prompts": "[{\"theorem\": \"‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : Œ± ‚Üí Œ≤),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), ‚Üë(DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\",\n  \"isProp\": true,\n  \"docString\": \"the condition that the given endomorphism is an idempotent \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a ‚àà self.carrier ‚Üí b ‚àà self.carrier ‚Üí a + b ‚àà self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (i : Œπ) (c : R) (x : M i),\\n  ‚Üë(DirectSum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.of M i) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Addition is commutative in an additive commutative semigroup. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a ‚Üí IsRightRegular b ‚Üí IsRightRegular (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence closure is idempotent. \"}]\n",
    "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e}) :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y :=\n\n/-- Moving to the opposite additive commutative monoid commutes with summing. -/\ntheorem ‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : Œ± ‚Üí Œ≤),\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x) :=\n\n/-- By definition, a ring isomorphism preserves the additive structure. -/\ntheorem ‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem ‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), ‚Üë(DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.mk M s) x :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- the condition that the given endomorphism is an idempotent -/\ntheorem ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p :=\n\n/-- The sum of two elements of an additive subsemigroup belongs to the subsemigroup. -/\ntheorem ‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\n  a ‚àà self.carrier ‚Üí b ‚àà self.carrier ‚Üí a + b ‚àà self.carrier :=\n\n/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem ‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (i : Œπ) (c : R) (x : M i),\n  ‚Üë(DirectSum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.of M i) x :=\n\n/-- Addition is commutative in an additive commutative semigroup. -/\ntheorem ‚àÄ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a :=\n\n/-- In a semigroup, the product of right-regular elements is right-regular. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a ‚Üí IsRightRegular b ‚Üí IsRightRegular (a * b) :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- Equivalence closure is idempotent. -/\ntheorem ‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a ‚Üí IsIdempotentElem b ‚Üí IsIdempotentElem (a + b) "
    ]
  },
  {
    "docString": "The number of partitions of a finite set is a prime number.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {a : Set Œ±}, Set.Finite a ‚Üí Set.Finite {b | b ‚äÜ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : Œπ ‚Üí WithTop R},\\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) ‚Üí (Finset.prod s fun i => f i) < ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\\n  Set.Finite {I | Ideal.IsPrime I} ‚Üí IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\": \"A Dedekind domain is a PID if its set of primes is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Countable s ‚Üí Set.Countable {t | Set.Finite t ‚àß t ‚äÜ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"‚àÄ (p : Nat.Primes), PNat.factorMultiset ‚Üëp = PrimeMultiset.ofPrime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Factoring a prime gives the corresponding one-element multiset. \"}]\n",
    "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ‚àÄ {Œ± : Type u} {a : Set Œ±}, Set.Finite a ‚Üí Set.Finite {b | b ‚äÜ a} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí Prime (minpoly A x) :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a)) :=\n\n/-- A finite set is bounded -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I :=\n\n/-- A product of finite numbers is still finite -/\ntheorem ‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : Œπ ‚Üí WithTop R},\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) ‚Üí (Finset.prod s fun i => f i) < ‚ä§ :=\n\n/-- A Dedekind domain is a PID if its set of primes is finite. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\n  Set.Finite {I | Ideal.IsPrime I} ‚Üí IsPrincipalIdealRing R :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem ‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Countable s ‚Üí Set.Countable {t | Set.Finite t ‚àß t ‚äÜ s} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq :=\n\n/-- The partition is supremum-independent -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem ‚àÄ (p : Nat.Primes), PNat.factorMultiset ‚Üëp = PrimeMultiset.ofPrime p :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±], Nat.Prime (Finset.card (Finset.powerset (Fintype.elems Œ±))) "
    ]
  },
  {
    "docString": "If a poset has a maximal element, then it has a unique minimal element.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí a ‚â§ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsGreatest s a ‚Üí sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsLeast s a ‚Üí sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeAddGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ ‚Üí FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words have a common maximal reduction, then they correspond to the same element in the\\nfree group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí sInf s ‚â§ a\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is more than the set infimum. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R],\\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ‚ÜëPolynomial.C x ‚àà I ‚Üí x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\\n  ‚àÉ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\\nthe lemma implies there exists a vertex. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeAddGroup.mk L‚ÇÅ = FreeAddGroup.mk L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the additive free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends an element of the\\nfree group to its maximal reduction is well-defined.\"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ùïú F] {T : E ‚Üí‚Çó.[ùïú] F}\\n  {S : F ‚Üí‚Çó.[ùïú] E},\\n  Dense ‚ÜëT.domain ‚Üí ‚àÄ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S ‚Üí S ‚â§ LinearPMap.adjoint T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The adjoint is maximal in the sense that it contains every formal adjoint. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] [inst_2 : WellFoundedLT Œ±] (a : Œ±),\\n  ‚àÉ s, Finset.sup s id = a ‚àß ‚àÄ ‚¶Éb : Œ±‚¶Ñ, b ‚àà s ‚Üí SupIrred b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a well-founded lattice, any element is the supremum of finitely many sup-irreducible\\nelements. This is the order-theoretic analogue of prime factorisation. \"}]\n",
    "prompt_cons": "/-- A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem ‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí a ‚â§ sSup s :=\n\n/-- A greatest element of a set is the supremum of this set. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsGreatest s a ‚Üí sSup s = a :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsLeast s a ‚Üí sInf s = a :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem ‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem ‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\n  FreeAddGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem ‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0 :=\n\n/-- If two words have a common maximal reduction, then they correspond to the same element in the\nfree group. -/\ntheorem ‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\n  FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ ‚Üí FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem ‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\n  FreeGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ :=\n\n/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\ntheorem ‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\n  FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0 :=\n\n/-- Any element of a set is more than the set infimum. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí sInf s ‚â§ a :=\n\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R],\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ‚ÜëPolynomial.C x ‚àà I ‚Üí x = 0 :=\n\n/-- A word and its maximal reduction correspond to the same element of the additive free\ngroup. -/\ntheorem ‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L :=\n\n/-- There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\n  ‚àÉ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v :=\n\n/-- If two words correspond to the same element in the additive free group, then they\nhave a common maximal reduction. This is the proof that the function that sends an element of the\nfree group to its maximal reduction is well-defined. -/\ntheorem ‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\n  FreeAddGroup.mk L‚ÇÅ = FreeAddGroup.mk L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ :=\n\n/-- The adjoint is maximal in the sense that it contains every formal adjoint. -/\ntheorem ‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ùïú F] {T : E ‚Üí‚Çó.[ùïú] F}\n  {S : F ‚Üí‚Çó.[ùïú] E},\n  Dense ‚ÜëT.domain ‚Üí ‚àÄ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S ‚Üí S ‚â§ LinearPMap.adjoint T :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I :=\n\n/-- In a well-founded lattice, any element is the supremum of finitely many sup-irreducible\nelements. This is the order-theoretic analogue of prime factorisation. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] [inst_2 : WellFoundedLT Œ±] (a : Œ±),\n  ‚àÉ s, Finset.sup s id = a ‚àß ‚àÄ ‚¶Éb : Œ±‚¶Ñ, b ‚àà s ‚Üí SupIrred b :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : Nonempty Œ±] [inst_2 : BoundedOrder Œ±],\n  ‚àÉ! a, ‚àÄ (b : Œ±), a ‚â§ b "
    ]
  },
  {
    "docString": "The automorphism group of an Abelian group is cyclic.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `‚Ñ§` is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (x : Œ≤),\\n  AddAction.IsPretransitive Œ± ‚Üë(AddAction.orbit Œ± x)\",\n  \"isProp\": true,\n  \"docString\": \"The action of an additive group on an orbit is transitive.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ‚â§ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Œº : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Œº] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\n  IsCyclic { x // x ‚àà S } :=\n\n/-- Every subgroup of `‚Ñ§` is cyclic. -/\ntheorem ‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a} :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- The right regular action of an additive group on itself is transitive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G :=\n\n/-- The action of an additive group on an orbit is transitive. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (x : Œ≤),\n  AddAction.IsPretransitive Œ± ‚Üë(AddAction.orbit Œ± x) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ‚â§ 1 :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Œº : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Œº] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Œº :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddAut G) "
    ]
  },
  {
    "docString": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"‚àÄ {f : Ordinal.{u} ‚Üí Ordinal.{u}}, Ordinal.IsNormal f ‚Üí Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x : Œ±), ‚àÉ y, y ‚àà Set.Ico 0 c ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ico a (a + c) ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ico a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {o : Ordinal.{u}} {f : (b : Ordinal.{u}) ‚Üí b < o ‚Üí Ordinal.{max u v} ‚Üí Ordinal.{max u v}},\\n  (‚àÄ (i : Ordinal.{u}) (hi : i < o), Ordinal.IsNormal (f i hi)) ‚Üí\\n    Set.Unbounded (fun x x_1 => x < x_1) (‚ãÇ (i : Ordinal.{u}) (hi : i < o), Function.fixedPoints (f i hi))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of the fixed point lemma for normal functions: any family of normal functions\\nhas an unbounded set of common fixed points. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ioc a (a + c) ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ioc a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.SigmaFinite Œº]\\n  {Œµ : ENNReal}, Œµ ‚â† 0 ‚Üí ‚àÉ g, (‚àÄ (x : Œ±), 0 < g x) ‚àß Measurable g ‚àß ‚à´‚Åª (x : Œ±), ‚Üë(g x) ‚àÇŒº < Œµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sigma-finite measure space, there exists an integrable function which is\\npositive everywhere (and with an arbitrarily small integral). \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {r : ‚Ñù},\\n  0 < r ‚Üí ‚àÄ (K : ‚Ñù), (‚àÄ (y : Œ±), dist y x < r ‚Üí dist (f y) (f x) ‚â§ K * dist y x) ‚Üí ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"theorem\":\n  \"‚àÄ {G‚ÇÄ : Type u_1} [inst : TopologicalSpace G‚ÇÄ] [inst_1 : GroupWithZero G‚ÇÄ] [inst_2 : ContinuousMul G‚ÇÄ],\\n  Filter.Tendsto Inv.inv (nhds 1) (nhds 1) ‚Üí HasContinuousInv‚ÇÄ G‚ÇÄ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a group with zero has continuous multiplication and `fun x ‚Ü¶ x‚Åª¬π` is continuous at one,\\nthen it is continuous at any unit. \"}]\n",
    "prompt_cons": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem ‚àÄ {f : Ordinal.{u} ‚Üí Ordinal.{u}}, Ordinal.IsNormal f ‚Üí Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem ‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f) :=\n\n/-- A continuous, periodic function has compact range. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ico 0 c` such that `f x = f y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x : Œ±), ‚àÉ y, y ‚àà Set.Ico 0 c ‚àß f x = f y :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem ‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ico a (a + c)` such that `f x = f y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ico a (a + c) ‚àß f x = f y :=\n\n/-- A generalization of the fixed point lemma for normal functions: any family of normal functions\nhas an unbounded set of common fixed points. -/\ntheorem ‚àÄ {o : Ordinal.{u}} {f : (b : Ordinal.{u}) ‚Üí b < o ‚Üí Ordinal.{max u v} ‚Üí Ordinal.{max u v}},\n  (‚àÄ (i : Ordinal.{u}) (hi : i < o), Ordinal.IsNormal (f i hi)) ‚Üí\n    Set.Unbounded (fun x x_1 => x < x_1) (‚ãÇ (i : Ordinal.{u}) (hi : i < o), Function.fixedPoints (f i hi)) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ioc a (a + c)` such that `f x = f y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ioc a (a + c) ‚àß f x = f y :=\n\n/-- In a sigma-finite measure space, there exists an integrable function which is\npositive everywhere (and with an arbitrarily small integral). -/\ntheorem ‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.SigmaFinite Œº]\n  {Œµ : ENNReal}, Œµ ‚â† 0 ‚Üí ‚àÉ g, (‚àÄ (x : Œ±), 0 < g x) ‚àß Measurable g ‚àß ‚à´‚Åª (x : Œ±), ‚Üë(g x) ‚àÇŒº < Œµ :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K) :=\n\n/-- If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y :=\n\n/-- If a function is locally Lipschitz around a point, then it is continuous at this point. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {r : ‚Ñù},\n  0 < r ‚Üí ‚àÄ (K : ‚Ñù), (‚àÄ (y : Œ±), dist y x < r ‚Üí dist (f y) (f x) ‚â§ K * dist y x) ‚Üí ContinuousAt f x :=\n\n/-- If a group with zero has continuous multiplication and `fun x ‚Ü¶ x‚Åª¬π` is continuous at one,\nthen it is continuous at any unit. -/\ntheorem ‚àÄ {G‚ÇÄ : Type u_1} [inst : TopologicalSpace G‚ÇÄ] [inst_1 : GroupWithZero G‚ÇÄ] [inst_2 : ContinuousMul G‚ÇÄ],\n  Filter.Tendsto Inv.inv (nhds 1) (nhds 1) ‚Üí HasContinuousInv‚ÇÄ G‚ÇÄ :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y "
    ]
  },
  {
    "docString": "The complement of the union of two sets contains the union of their complements.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\\n  s ‚à© t = ‚àÖ ‚Üí\\n    ‚àÄ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {a : Set (Œ± √ó Œ±)},\\n  a ‚àà uniformity Œ± ‚Üí\\n    ‚àÄ {b : Set (Œ≤ √ó Œ≤)},\\n      b ‚àà uniformity Œ≤ ‚Üí\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ‚à™ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ‚àà\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {K U V : Set Œ±},\\n  IsCompact K ‚Üí IsOpen U ‚Üí IsOpen V ‚Üí K ‚äÜ U ‚à™ V ‚Üí ‚àÉ K‚ÇÅ K‚ÇÇ, IsCompact K‚ÇÅ ‚àß IsCompact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ‚ãÉ (n : ‚Ñï), CompactExhaustion.toFun self n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z a b : Set Œ±},\\n  IsClopen Z ‚Üí Z ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (Z ‚à© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (‚Ñô K V)),\\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"}]\n",
    "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t) :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem ‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\n  s ‚à© t = ‚àÖ ‚Üí\n    ‚àÄ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤) :=\n\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem ‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT :=\n\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem ‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {a : Set (Œ± √ó Œ±)},\n  a ‚àà uniformity Œ± ‚Üí\n    ‚àÄ {b : Set (Œ≤ √ó Œ≤)},\n      b ‚àà uniformity Œ≤ ‚Üí\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ‚à™ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ‚àà\n          UniformSpace.Core.sum.uniformity :=\n\n/-- The span of a union of sets is the sup of their spans. -/\ntheorem ‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t) :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {K U V : Set Œ±},\n  IsCompact K ‚Üí IsOpen U ‚Üí IsOpen V ‚Üí K ‚äÜ U ‚à™ V ‚Üí ‚àÉ K‚ÇÅ K‚ÇÇ, IsCompact K‚ÇÅ ‚àß IsCompact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ :=\n\n/-- The union of all sets in a compact exhaustion equals the entire space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  ‚ãÉ (n : ‚Ñï), CompactExhaustion.toFun self n = Set.univ :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z a b : Set Œ±},\n  IsClopen Z ‚Üí Z ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (Z ‚à© a) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a)) :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\ t) :=\n\n/-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\ntheorem ‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t) :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (‚Ñô K V)),\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú ‚äÜ s·∂ú ‚à© t·∂ú "
    ]
  },
  {
    "docString": "The square root of an rational number is rational.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"‚àÄ {p x : ‚Ñù} {r : ‚Ñö}, LiouvilleWith p x ‚Üí r ‚â† 0 ‚Üí LiouvilleWith p (x * ‚Üër)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ‚â† 0 ‚Üí (‚àÉ s, discrim a b c = s * s) ‚Üí ‚àÉ x, a * x * x + b * x + c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I\",\n  \"isProp\": true,\n  \"docString\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (‚àÄ (s : R), discrim a b c ‚â† s ^ 2) ‚Üí ‚àÄ (x : R), a * x * x + b * x + c ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\\n  a ‚â† 0 ‚Üí ‚àÄ (x : R), a * x * x + b * x + c = 0 ‚Üî discrim a b c = (2 * a * x + b) ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"}]\n",
    "prompt_cons": "/-- Every finite convergent corresponds to a rational number. -/\ntheorem ‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem ‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2} :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1 :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem ‚àÄ {p x : ‚Ñù} {r : ‚Ñö}, LiouvilleWith p x ‚Üí r ‚â† 0 ‚Üí LiouvilleWith p (x * ‚Üër) :=\n\n/-- A quadratic has roots if its discriminant has square roots -/\ntheorem ‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ‚â† 0 ‚Üí (‚àÉ s, discrim a b c = s * s) ‚Üí ‚àÉ x, a * x * x + b * x + c = 0 :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- An ideal is radical iff it is equal to its radical. -/\ntheorem ‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem ‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (‚àÄ (s : R), discrim a b c ‚â† s ^ 2) ‚Üí ‚àÄ (x : R), a * x * x + b * x + c ‚â† 0 :=\n\n/-- A quadratic has roots if and only if its discriminant equals some square. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\n  a ‚â† 0 ‚Üí ‚àÄ (x : R), a * x * x + b * x + c = 0 ‚Üî discrim a b c = (2 * a * x + b) ^ 2 :=\n\n/-- The square root of an rational number is rational. -/\ntheorem",
    "choices": [
      "‚àÄ (q : ‚Ñö), ‚àÉ r, Real.sqrt q = ‚Üër "
    ]
  },
  {
    "docString": "If a module over a ring is free, then the ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : Œπ ‚Üí Type u_2) [inst_1 : Finite Œπ]\\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ‚âÉ‚Çó[R] N) ‚Üî FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Submodule K V), IsAtom W ‚Üî ‚àÉ v x, W = Submodule.span K {v}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The atoms of the lattice of submodules of a module over a division ring are the\\nsubmodules equal to the span of a nonzero element of the module. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherianRing R] {A : Set M}, Set.Finite A ‚Üí IsNoetherian R { x // x ‚àà Submodule.span R A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a module over a Noetherian ring, the submodule generated by finitely many vectors is\\nNoetherian. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] P),\\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëg ‚Üí LinearMap.range f = LinearMap.ker g ‚Üí IsNoetherian R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the first and final modules in a short exact sequence are Noetherian,\\nthen the middle module is also Noetherian. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\\n  Function.Surjective ‚Üë(Finsupp.total M M R id)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any module is a quotient of a free module. This is stated as surjectivity of\\n`Finsupp.total M M R id : (M ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M`. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {Œ∑ : Type u‚ÇÅ'} {œÜ : Œ∑ ‚Üí Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : Œ∑) ‚Üí AddCommGroup (œÜ i)] [inst_3 : (i : Œ∑) ‚Üí Module K (œÜ i)] [inst_4 : ‚àÄ (i : Œ∑), Module.Free K (œÜ i)]\\n  [inst_5 : Finite Œ∑], Module.rank K ((i : Œ∑) ‚Üí œÜ i) = Cardinal.sum fun i => Module.rank K (œÜ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\\n  Module.Free R (Matrix m n M)\",\n  \"isProp\": true,\n  \"docString\": \"The module of finite matrices is free. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A commutative star monoid is a star module over itself via `Monoid.toMulAction`. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"}]\n",
    "prompt_cons": "/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V ‚Üî Module.Finite K V :=\n\n/-- The product of finitely many free modules is free. -/\ntheorem ‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : Œπ ‚Üí Type u_2) [inst_1 : Finite Œπ]\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i) :=\n\n/-- The lattice of submodules of a module over a division ring is atomistic. -/\ntheorem ‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsAtomistic (Submodule K V) :=\n\n/-- Modules over the trivial ring are Noetherian. -/\ntheorem ‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem ‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- Two finite and free modules are isomorphic if and only if they have the same (finite) rank. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  Nonempty (M ‚âÉ‚Çó[R] N) ‚Üî FiniteDimensional.finrank R M = FiniteDimensional.finrank R N :=\n\n/-- A module over a semiring is `Finite` if it is finitely generated as a module. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : Module.Finite R M], Submodule.FG ‚ä§ :=\n\n/-- The category of modules has enough projectives, since every module is a quotient of a free\nmodule. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R) :=\n\n/-- The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. -/\ntheorem ‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Submodule K V), IsAtom W ‚Üî ‚àÉ v x, W = Submodule.span K {v} :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä• :=\n\n/-- In a module over a Noetherian ring, the submodule generated by finitely many vectors is\nNoetherian. -/\ntheorem ‚àÄ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherianRing R] {A : Set M}, Set.Finite A ‚Üí IsNoetherian R { x // x ‚àà Submodule.span R A } :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf :=\n\n/-- If the first and final modules in a short exact sequence are Noetherian,\nthen the middle module is also Noetherian. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] P),\n  Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëg ‚Üí LinearMap.range f = LinearMap.ker g ‚Üí IsNoetherian R N :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf :=\n\n/-- Any module is a quotient of a free module. This is stated as surjectivity of\n`Finsupp.total M M R id : (M ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M`. -/\ntheorem ‚àÄ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Function.Surjective ‚Üë(Finsupp.total M M R id) :=\n\n/-- The rank of a finite product of free modules is the sum of the ranks. -/\ntheorem ‚àÄ {K : Type u} {Œ∑ : Type u‚ÇÅ'} {œÜ : Œ∑ ‚Üí Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\n  [inst_2 : (i : Œ∑) ‚Üí AddCommGroup (œÜ i)] [inst_3 : (i : Œ∑) ‚Üí Module K (œÜ i)] [inst_4 : ‚àÄ (i : Œ∑), Module.Free K (œÜ i)]\n  [inst_5 : Finite Œ∑], Module.rank K ((i : Œ∑) ‚Üí œÜ i) = Cardinal.sum fun i => Module.rank K (œÜ i) :=\n\n/-- The module of finite matrices is free. -/\ntheorem ‚àÄ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\n  Module.Free R (Matrix m n M) :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf :=\n\n/-- A commutative star monoid is a star module over itself via `Monoid.toMulAction`. -/\ntheorem ‚àÄ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) "
    ]
  },
  {
    "docString": "If the set of units of a ring forms a group then the ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom fun a => (f a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R\",\n  \"isProp\": true,\n  \"docString\": \"Any commutative ring satisfies the `StrongRankCondition`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [self : OrderedCommGroup Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c * a ‚â§ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí IsGroupHom fun a => (f a)‚Åª¬π :=\n\n/-- Fields are commutative. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x :=\n\n/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R],\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\n  IsCyclic { x // x ‚àà S } :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- Multiplication is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any commutative ring satisfies the `StrongRankCondition`. -/\ntheorem ‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ‚àÄ {Œ± : Type u} [self : OrderedCommGroup Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c * a ‚â§ c * b :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Units R)], IsCommutative R (*) "
    ]
  },
  {
    "docString": "Every natural number larger than `10` is the sum of a square and a prime.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.minFac n ^ 2 ‚â§ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b, n = a ^ 2 * b ‚àß IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"‚àÄ {n x y : ‚Ñï}, n = x ^ 2 + y ^ 2 ‚Üí Nat.coprime x y ‚Üí IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.minFac n ^ 2 ‚â§ n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1 :=\n\n/-- A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem ‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem ‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem ‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b, n = a ^ 2 * b ‚àß IsSquare (-1) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem ‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ‚àÄ {n x y : ‚Ñï}, n = x ^ 2 + y ^ 2 ‚Üí Nat.coprime x y ‚Üí IsSquare (-1) :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem",
    "choices": [
      "‚àÄ (n : ‚Ñï), 10 < n ‚Üí ‚àÉ x p, n = x ^ 2 + p ‚àß Nat.Prime p "
    ]
  },
  {
    "docString": "The initial object of a category is isomorphic to its terminal object.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (X ‚ü∂ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (‚ä§_ C)) ‚Üí CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T ‚Üí\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) ‚Üí CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f g : X ‚ü∂ Y), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms from an initial object are equal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f : Y ‚ü∂ X), CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism to an initial object is epi. \"},\n {\"theorem\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\": \"A category with finite biproducts has a zero object. \"},\n {\"theorem\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j‚ÇÅ j‚ÇÇ : J),\\n  CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\",\n  \"isProp\": true,\n  \"docString\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"theorem\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"theorem\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\\n  (‚àÄ (A : C) (f : I ‚ü∂ A), CategoryTheory.IsIso f) ‚Üí CategoryTheory.Limits.HasStrictTerminalObjects C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\\nhas strict terminal objects. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The forgetful functor from monoid objects to the ambient category reflects isomorphisms. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.IsSplitMono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is split mono. \"}]\n",
    "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (X ‚ü∂ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- The category `D` has isomorphic objects equal -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (‚ä§_ C)) ‚Üí CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T ‚Üí\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) ‚Üí CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- Any two morphisms from an initial object are equal. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f g : X ‚ü∂ Y), f = g :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- Any morphism to an initial object is epi. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f : Y ‚ü∂ X), CategoryTheory.Epi f :=\n\n/-- A category with finite biproducts has a zero object. -/\ntheorem ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- In a connected category, any two objects are related by `Zigzag`. -/\ntheorem ‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j‚ÇÅ j‚ÇÇ : J),\n  CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ :=\n\n/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\n  CategoryTheory.Limits.HasImages C :=\n\n/-- Any category with pushouts and initial object has binary coproducts. -/\ntheorem ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C :=\n\n/-- The map from the (any as stated) initial object to any other object is a\nmonomorphism -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X) :=\n\n/-- Each connected component of the category is connected. -/\ntheorem ‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\n  (‚àÄ (A : C) (f : I ‚ü∂ A), CategoryTheory.IsIso f) ‚Üí CategoryTheory.Limits.HasStrictTerminalObjects C :=\n\n/-- The forgetful functor from monoid objects to the ambient category reflects isomorphisms. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C) :=\n\n/-- Any morphism from a terminal object is split mono. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.IsSplitMono f :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem",
    "choices": [
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.Initial C ‚âÖ CategoryTheory.Limits.Terminal C "
    ]
  },
  {
    "docString": "If the composition of two functions is continuous, then each of them is continuous.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => ‚Äñg x‚Äñ) ‚Üí MeasureTheory.Integrable f ‚Üí Continuous g ‚Üí Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≤ ‚Üí Œ≥} {s : Set Œ≤},\\n  s ‚äÜ e.target ‚Üí (ContinuousOn f s ‚Üî ContinuousOn (f ‚àò ‚Üëe) (e.source ‚à© ‚Üëe ‚Åª¬π' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤},\\n  Dense s ‚Üí ‚àÄ {f g : Œ≤ ‚Üí Œ±}, Continuous f ‚Üí Continuous g ‚Üí Set.EqOn f g s ‚Üí f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} {s : Set Œ≥},\\n  s ‚äÜ f ‚Åª¬π' e.source ‚Üí (ContinuousOn f s ‚Üî ContinuousOn (‚Üëe ‚àò f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {U : Set X}\\n  {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº U)] g ‚Üí\\n    IsOpen U ‚Üí ContinuousOn f U ‚Üí ContinuousOn g U ‚Üí Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±},\\n  f ‚Åª¬π' e.source = Set.univ ‚Üí (Continuous f ‚Üî Continuous (‚Üëe ‚àò f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous if and only if its composition with a local homeomorphism\\non the left is continuous and its image is contained in the source. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G],\\n  HasCompactSupport g ‚Üí MeasureTheory.LocallyIntegrable f ‚Üí Continuous g ‚Üí Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is locally integrable and the other has compact\\nsupport and is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±]\\n  [inst_2 : OpensMeasurableSpace Œ±] [inst_3 : TopologicalSpace Œ≥] [inst_4 : MeasurableSpace Œ≥] [inst_5 : BorelSpace Œ≥]\\n  {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [inst_6 : (j : Œ±) ‚Üí Decidable (j ‚àà s)],\\n  ContinuousOn f s ‚Üí ContinuousOn g s·∂ú ‚Üí MeasurableSet s ‚Üí Measurable (Set.piecewise s f g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is defined piecewise in terms of functions which are continuous on their\\nrespective pieces, then it is measurable. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_1} {Œ≥ : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : TopologicalSpace Œ≤] [inst_1 : TopologicalSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤},\\n  Continuous g ‚Üí MeasureTheory.AEStronglyMeasurable f Œº ‚Üí MeasureTheory.AEStronglyMeasurable (fun x => g (f x)) Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of a continuous function and an ae strongly measurable function is ae strongly\\nmeasurable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n",
    "prompt_cons": "/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g :=\n\n/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem ‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'}\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\n  BddAbove (Set.range fun x => ‚Äñg x‚Äñ) ‚Üí MeasureTheory.Integrable f ‚Üí Continuous g ‚Üí Continuous (convolution f g L) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≤ ‚Üí Œ≥} {s : Set Œ≤},\n  s ‚äÜ e.target ‚Üí (ContinuousOn f s ‚Üî ContinuousOn (f ‚àò ‚Üëe) (e.source ‚à© ‚Üëe ‚Åª¬π' s)) :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤},\n  Dense s ‚Üí ‚àÄ {f g : Œ≤ ‚Üí Œ±}, Continuous f ‚Üí Continuous g ‚Üí Set.EqOn f g s ‚Üí f = g :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} {s : Set Œ≥},\n  s ‚äÜ f ‚Åª¬π' e.source ‚Üí (ContinuousOn f s ‚Üî ContinuousOn (‚Üëe ‚àò f) s) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {U : Set X}\n  {f g : X ‚Üí Y},\n  f =·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº U)] g ‚Üí\n    IsOpen U ‚Üí ContinuousOn f U ‚Üí ContinuousOn g U ‚Üí Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f :=\n\n/-- A function is continuous if and only if its composition with a local homeomorphism\non the left is continuous and its image is contained in the source. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±},\n  f ‚Åª¬π' e.source = Set.univ ‚Üí (Continuous f ‚Üî Continuous (‚Üëe ‚àò f)) :=\n\n/-- The convolution is continuous if one function is locally integrable and the other has compact\nsupport and is continuous. -/\ntheorem ‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'}\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G],\n  HasCompactSupport g ‚Üí MeasureTheory.LocallyIntegrable f ‚Üí Continuous g ‚Üí Continuous (convolution f g L) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K) :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f :=\n\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±]\n  [inst_2 : OpensMeasurableSpace Œ±] [inst_3 : TopologicalSpace Œ≥] [inst_4 : MeasurableSpace Œ≥] [inst_5 : BorelSpace Œ≥]\n  {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [inst_6 : (j : Œ±) ‚Üí Decidable (j ‚àà s)],\n  ContinuousOn f s ‚Üí ContinuousOn g s·∂ú ‚Üí MeasurableSet s ‚Üí Measurable (Set.piecewise s f g) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº :=\n\n/-- The composition of a continuous function and an ae strongly measurable function is ae strongly\nmeasurable. -/\ntheorem ‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_1} {Œ≥ : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\n  [inst : TopologicalSpace Œ≤] [inst_1 : TopologicalSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤},\n  Continuous g ‚Üí MeasureTheory.AEStronglyMeasurable f Œº ‚Üí MeasureTheory.AEStronglyMeasurable (fun x => g (f x)) Œº :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K) :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, Continuous (g ‚àò f) ‚Üí Continuous f ‚Üí Continuous g "
    ]
  },
  {
    "docString": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c ‚Ä¢ a < c ‚Ä¢ b ‚Üí 0 < c ‚Üí a < b\",\n  \"isProp\": true,\n  \"docString\": \"If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : IsDirected Œ± r] (a b : Œ±), ‚àÉ c, r a c ‚àß r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [hŒ± : Archimedean Œ±] {p : Œ±} (hp : 0 < p) {a b c : Œ±},\\n  toIcoMod hp c a = toIcoMod hp c b ‚Üî a ‚â° b [PMOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b c : Œ±},\\n  (a == b) = true ‚Üí (b == c) = true ‚Üí (a == c) = true\",\n  \"isProp\": true,\n  \"docString\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"theorem\": \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí b ‚à£ a - c\",\n  \"isProp\": true,\n  \"docString\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ‚àÉ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation ‚Äúthere exists an element that semiconjugates `a` to `b`‚Äù on a semigroup\\nis transitive. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z ‚Üí SemiconjBy b x y ‚Üí SemiconjBy (a * b) x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\\nsemiconjugates `x` to `z`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] (a b u : Œ±), IsUnit u ‚Üí (a ‚à£ u * b ‚Üî a ‚à£ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\\nassociates of `b`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CircularPartialOrder Œ±] {a b c : Œ±}, btw a b c ‚Üí btw c b a ‚Üí a = b ‚à® b = c ‚à® c = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\\namong `a`, `b`, `c` are identical. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] {a b : Œ±} {u : Œ±À£}, ‚Üëu * a ‚à£ b ‚Üî a ‚à£ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a commutative monoid, an element `a` divides an element `b` iff all\\nleft associates of `a` divide `b`.\"}]\n",
    "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [self : OrderedSMul R M] {a b : M} {c : R}, c ‚Ä¢ a < c ‚Ä¢ b ‚Üí 0 < c ‚Üí a < b :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem ‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : IsDirected Œ± r] (a b : Œ±), ‚àÉ c, r a c ‚àß r b c :=\n\n/-- If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [hŒ± : Archimedean Œ±] {p : Œ±} (hp : 0 < p) {a b c : Œ±},\n  toIcoMod hp c a = toIcoMod hp c b ‚Üî a ‚â° b [PMOD p] :=\n\n/-- Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b c : Œ±},\n  (a == b) = true ‚Üí (b == c) = true ‚Üí (a == c) = true :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem ‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí b ‚à£ a - c :=\n\n/-- The relation ‚Äúthere exists an element that semiconjugates `a` to `b`‚Äù on a semigroup\nis transitive. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ‚àÉ c, SemiconjBy c a b :=\n\n/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X :=\n\n/-- Equality behind `Commute a b`; useful for rewriting. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí a * b = b * a :=\n\n/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z ‚Üí SemiconjBy b x y ‚Üí SemiconjBy (a * b) x z :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] (a b u : Œ±), IsUnit u ‚Üí (a ‚à£ u * b ‚Üî a ‚à£ b) :=\n\n/-- If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\namong `a`, `b`, `c` are identical. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CircularPartialOrder Œ±] {a b c : Œ±}, btw a b c ‚Üí btw c b a ‚Üí a = b ‚à® b = c ‚à® c = a :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] {a b : Œ±} {u : Œ±À£}, ‚Üëu * a ‚à£ b ‚Üî a ‚à£ b :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem",
    "choices": [
      "‚àÄ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b ‚Üí Commute b c ‚Üí Commute a c "
    ]
  },
  {
    "docString": "If an element maps to zero under a ring homomorphism, then it is zero.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0) ‚Üí\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤}, IsAddGroupHom f ‚Üí f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) ‚Üí\\n    ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\",\n  \"isProp\": true,\n  \"docString\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ‚Üë(algebraMap R A) ‚Üí ‚àÄ [inst : CharZero R], CharZero A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R ‚Üí+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map one to one. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K ‚Üí+* L} {s : Set K},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G ‚Üí* R), f ‚â† 1 ‚Üí (Finset.sum Finset.univ fun g => ‚Üëf g) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"In degree `0`, the null homotopic map `HœÉ` is zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"}]\n",
    "prompt_cons": "/-- Ring homomorphisms map zero to zero. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 0 = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem ‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0 :=\n\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\n  (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0) ‚Üí\n    CategoryTheory.Mono f :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤}, IsAddGroupHom f ‚Üí f 0 = 0 :=\n\n/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) ‚Üí\n    ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0 :=\n\n/-- An element is in the kernel if and only if it maps to zero. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0 :=\n\n/-- The zero morphism maps every pseudoelement to 0. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s } :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R ‚Üí+* S} {s : Set R},\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subring.closure s) :=\n\n/-- A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. -/\ntheorem ‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I) :=\n\n/-- In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ :=\n\n/-- If the algebra map `R ‚Üí+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem ‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective ‚Üë(algebraMap R A) ‚Üí ‚àÄ [inst : CharZero R], CharZero A :=\n\n/-- Ring homomorphisms map one to one. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 1 = 1 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem ‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K ‚Üí+* L} {s : Set K},\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subfield.closure s) :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\n  (f : G ‚Üí* R), f ‚â† 1 ‚Üí (Finset.sum Finset.univ fun g => ‚Üëf g) = 0 :=\n\n/-- In degree `0`, the null homotopic map `HœÉ` is zero. -/\ntheorem ‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) 0 = 0 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R ‚Üí+* S} {s : Set R},\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subsemiring.closure s) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R ‚Üí+* S} {r : R}, ‚Üëf r = 0 ‚Üí r ‚àà RingHom.ker f "
    ]
  },
  {
    "docString": "Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.",
    "prompts": "[{\"theorem\": \"‚àÄ {p q r : Prop}, (p ‚Üí q) ‚Üí (q ‚Üí r) ‚Üí p ‚Üí r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y : Œ±}, r x y ‚Üí r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ‚àÄ (P : CategoryTheory.Functor C·µí·µñ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor C·µí·µñ D)\\n  [inst_3 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p q : Œ±}, Irreducible p ‚Üí Irreducible q ‚Üí p ‚à£ q ‚Üí q ‚à£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. \"},\n {\"theorem\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y z : Œ±}, r x y ‚Üí r y z ‚Üí r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ (x : Œ±), r x x\",\n  \"isProp\": true,\n  \"docString\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M ‚Üí Prop},\\n  (‚àÄ (I : Submodule R M), (‚àÄ (J : Submodule R M), J > I ‚Üí P J) ‚Üí P I) ‚Üí ‚àÄ (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `‚àÄ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {a b c d : Œ±} [inst : Preorder Œ±], c ‚â§ a ‚Üí b ‚â§ d ‚Üí a ‚â§ b ‚Üí c ‚â§ d\",\n  \"isProp\": true,\n  \"docString\": \"monotonicity of `‚â§` with respect to `‚Üí` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : Antisymm r] {a b : Œ±}, r a b ‚Üí r b a ‚Üí a = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antisymmetric relation `(¬∑‚â§¬∑)` satisfies `a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú\",\n  \"isProp\": true,\n  \"docString\": \"`x ‚á® y` is equal to `y ‚äî x·∂ú` \"},\n {\"theorem\":\n  \"‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P ‚Üí\\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P)\",\n  \"isProp\": true,\n  \"docString\": \"`P` as a morphism property respects isomorphisms \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, ‚Üëc x y ‚Üí ‚Üëc y x\",\n  \"isProp\": true,\n  \"docString\": \"Congruence relations are symmetric. \"},\n {\"theorem\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí\\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace), P f ‚Üí P (f ‚à£_ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : HeytingAlgebra Œ±]\\n  [inst_1 : HeytingAlgebra Œ≤] [self : HeytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ‚â§ S ‚Üí\\n    ‚àÄ [inst_3 : DecidablePred fun x => x ‚àà Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ‚ß∏ S)]\\n      [inst_5 : Fintype (M ‚ß∏ T)],\\n      Fintype.card { x // x ‚àà Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ‚ß∏ S) = Fintype.card (M ‚ß∏ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, ‚Üëc x y ‚Üí ‚Üëc y x\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are symmetric.\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A ‚ü∂ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\\n  CategoryTheory.IsReflexivePair g f\",\n  \"isProp\": true,\n  \"docString\": \"If `f,g` is reflexive, then `g,f` is reflexive. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : BiheytingAlgebra Œ±]\\n  [inst_1 : BiheytingAlgebra Œ≤] [self : BiheytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a bi-Heyting homomorphism preserves the Heyting implication.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n ‚Üí Œ±},\\n  Matrix.IsSymm (Matrix.circulant v) ‚Üí ‚àÄ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `‚àÄ i j : I, v (- i) = v i`. \"}]\n",
    "prompt_cons": "/-- Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. -/\ntheorem ‚àÄ {p q r : Prop}, (p ‚Üí q) ‚Üí (q ‚Üí r) ‚Üí p ‚Üí r :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y : Œ±}, r x y ‚Üí r y x :=\n\n/-- `(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D]\n  [inst_2 :\n    ‚àÄ (P : CategoryTheory.Functor C·µí·µñ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  (P : CategoryTheory.Functor C·µí·µñ D)\n  [inst_3 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D],\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P) :=\n\n/-- If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p q : Œ±}, Irreducible p ‚Üí Irreducible q ‚Üí p ‚à£ q ‚Üí q ‚à£ p :=\n\n/-- `P` respects isomorphisms. -/\ntheorem ‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí CategoryTheory.MorphismProperty.RespectsIso P :=\n\n/-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\ntheorem ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y z : Œ±}, r x y ‚Üí r y z ‚Üí r x z :=\n\n/-- An equivalence relation is reflexive: `x ~ x` -/\ntheorem ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ (x : Œ±), r x x :=\n\n/-- If `‚àÄ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] {P : Submodule R M ‚Üí Prop},\n  (‚àÄ (I : Submodule R M), (‚àÄ (J : Submodule R M), J > I ‚Üí P J) ‚Üí P I) ‚Üí ‚àÄ (I : Submodule R M), P I :=\n\n/-- monotonicity of `‚â§` with respect to `‚Üí` -/\ntheorem ‚àÄ {Œ± : Type u} {a b c d : Œ±} [inst : Preorder Œ±], c ‚â§ a ‚Üí b ‚â§ d ‚Üí a ‚â§ b ‚Üí c ‚â§ d :=\n\n/-- An antisymmetric relation `(¬∑‚â§¬∑)` satisfies `a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b`. -/\ntheorem ‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : Antisymm r] {a b : Œ±}, r a b ‚Üí r b a ‚Üí a = b :=\n\n/-- `x ‚á® y` is equal to `y ‚äî x·∂ú` -/\ntheorem ‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú :=\n\n/-- `P` as a morphism property respects isomorphisms -/\ntheorem ‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P ‚Üí\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P) :=\n\n/-- Congruence relations are symmetric. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, ‚Üëc x y ‚Üí ‚Üëc y x :=\n\n/-- If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. -/\ntheorem ‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace), P f ‚Üí P (f ‚à£_ U) :=\n\n/-- The proposition that a Heyting homomorphism preserves the Heyting implication. -/\ntheorem ‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : HeytingAlgebra Œ±]\n  [inst_1 : HeytingAlgebra Œ≤] [self : HeytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T ‚â§ S ‚Üí\n    ‚àÄ [inst_3 : DecidablePred fun x => x ‚àà Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ‚ß∏ S)]\n      [inst_5 : Fintype (M ‚ß∏ T)],\n      Fintype.card { x // x ‚àà Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ‚ß∏ S) = Fintype.card (M ‚ß∏ T) :=\n\n/-- Additive congruence relations are symmetric. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, ‚Üëc x y ‚Üí ‚Üëc y x :=\n\n/-- If `f,g` is reflexive, then `g,f` is reflexive. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A ‚ü∂ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\n  CategoryTheory.IsReflexivePair g f :=\n\n/-- The proposition that a bi-Heyting homomorphism preserves the Heyting implication. -/\ntheorem ‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : BiheytingAlgebra Œ±]\n  [inst_1 : BiheytingAlgebra Œ≤] [self : BiheytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b :=\n\n/-- If `circulant v` is symmetric, `‚àÄ i j : I, v (- i) = v i`. -/\ntheorem ‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n ‚Üí Œ±},\n  Matrix.IsSymm (Matrix.circulant v) ‚Üí ‚àÄ (i : n), v (-i) = v i :=\n\n/-- Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`. -/\ntheorem",
    "choices": [
      "This statement is incorrect. Implication `‚Üí` is not symmetric."
    ]
  },
  {
    "docString": "Two natural numbers are equal if and only if they are both divisible by some prime number.",
    "prompts": "[{\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), PGame.Numeric ‚Üën\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"‚àÄ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 ‚Üí d < Cardinal.aleph0 ‚Üí (‚ÜëCardinal.toNat c = ‚ÜëCardinal.toNat d ‚Üî c = d)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite cardinals are equal iff they are equal their to_nat are equal \"},\n {\"theorem\": \"‚àÄ {a b : ‚Ñ§}, a ‚à£ b ‚Üí Int.natAbs b < Int.natAbs a ‚Üí b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a b : Œ±}, a ‚à£ a + b ‚Üî a ‚à£ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum a + b if and only if a divides b.\"}]\n",
    "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem ‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem ‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n :=\n\n/-- A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c :=\n\n/-- Any common divisor of both elements is a divisor of the GCD. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n] :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem ‚àÄ (n : ‚Ñï), PGame.Numeric ‚Üën :=\n\n/-- Two finite cardinals are equal iff they are equal their to_nat are equal -/\ntheorem ‚àÄ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 ‚Üí d < Cardinal.aleph0 ‚Üí (‚ÜëCardinal.toNat c = ‚ÜëCardinal.toNat d ‚Üî c = d) :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem ‚àÄ {a b : ‚Ñ§}, a ‚à£ b ‚Üí Int.natAbs b < Int.natAbs a ‚Üí b = 0 :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R :=\n\n/-- An element a divides the sum a + b if and only if a divides b. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a b : Œ±}, a ‚à£ a + b ‚Üî a ‚à£ b :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem",
    "choices": [
      "‚àÄ {m n : ‚Ñï}, (‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ m ‚àß p ‚à£ n) ‚Üî m = n "
    ]
  }
]