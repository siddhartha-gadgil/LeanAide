[
  {
    "docString": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\\nit suffices to show it holds when `x â‰  y`. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"}]\n",
    "prompt_cons": "/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\nit suffices to show it holds when `x â‰  y`. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y :=\n\n/-- The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x) :=\n\n/-- If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational. -/\ntheorem",
    "choices": [
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 âˆ§ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) "
    ]
  },
  {
    "docString": "Prove that there is no rational number whose square is $12$.",
    "prompts": "[{\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"}]\n",
    "prompt_cons": "/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- Prove that there is no rational number whose square is $12$. -/\ntheorem",
    "choices": [
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) ",
      "Irrational (Real.sqrt 12) "
    ]
  },
  {
    "docString": "Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\\n  BddBelow s â†’ BddBelow t â†’ Set.Nonempty (s âˆ© t) â†’ sInf s âŠ” sInf t â‰¤ sInf (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of an intersection of two sets is bounded below by the maximum of the\\ninfima of each set, if all sets are bounded below and nonempty.\"}]\n",
    "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u)) :=\n\n/-- The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\n  BddBelow s â†’ BddBelow t â†’ Set.Nonempty (s âˆ© t) â†’ sInf s âŠ” sInf t â‰¤ sInf (s âˆ© t) :=\n\n/-- Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : ConditionallyCompleteLattice Î±] {s : Set Î±},\n  BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (Set.image Neg.neg s) ",
      "forall {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : Ring Î±] [has_le Î±] {s : Set Î±},\n  BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (Set.Image Neg.neg s) ",
      "forall {s : Set â„}, BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (-s) ",
      "âˆ€ {Î± : Type u_1} [conditionallyCompleteLinearOrder : ConditionallyCompleteLinearOrder Î±] [OrderedAddCommGroup Î±] {A : Set Î±},\n  BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (-A) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : OrderTopology Î±] [inst_2 : ConditionallyCompleteLattice Î±] [inst_3 : TopologicalSpace Î±],\n  {s : Set Î±}, BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (-s) ",
      "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] [_inst_2 : OrderedAddCommGroup Î±] {s : Set Î±},\n  BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (Set.image (fun x => -x) s) ",
      "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : AddCommGroup Î±] [inst_2 : HasOrderedSub Î±] {s : Set Î±},\n  BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (Set.Preimage Neg.neg s) ",
      "âˆ€ {Î± : Type u_1} [self : ConditionallyCompleteLattice Î±] {s : Set Î±},\n  BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (Set.image Neg.neg s) ",
      "forall {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrder Î±] [inst_2 : OrderedAddCommGroup Î±] {A : Set Î±},\n  BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (Set.Preimage Neg.neg A) ",
      "forall (A : set â„), bdd_below A â†’ set.nonempty A â†’\n  real.Inf A = -real.Sup (has_neg.neg '' A) "
    ]
  },
  {
    "docString": "If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "prompts": "[{\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$. -/\ntheorem",
    "choices": [
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ w * w.conj = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ w.abs = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ w.abs = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ w.abs = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘r = Complex.abs z âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r â€¢ w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘r = Complex.abs z âˆ§ w * â†‘r = z âˆ§ Complex.abs w = 1 ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ (â†‘Complex.abs w = 1) âˆ§ z = â†‘r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘r = Complex.abs z âˆ§ â†‘(Complex.abs w) = 1 âˆ§ z = â†‘r * w "
    ]
  },
  {
    "docString": "If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\\n  Â¬SameRay â„ x y â†’ â€–x + yâ€– < â€–xâ€– + â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a strictly convex space, if `x` and `y` are not in the same ray, then `â€–x + yâ€– < â€–xâ€– + â€–yâ€–`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\ndoesn't assume `0â‰¤K`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\nassumes `0â‰¤K`. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a â‰¤ b â†” -b â‰¤ a` on `EReal`. \"}]\n",
    "prompt_cons": "/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `â€–x + yâ€– < â€–xâ€– + â€–yâ€–`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\n  Â¬SameRay â„ x y â†’ â€–x + yâ€– < â€–xâ€– + â€–yâ€– :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\ndoesn't assume `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\nassumes `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f :=\n\n/-- `-a â‰¤ b â†” -b â‰¤ a` on `EReal`. -/\ntheorem âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a :=\n\n/-- If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$. -/\ntheorem",
    "choices": [
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "forall {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ x y : â„‚, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ (x y : â„‚), abs (abs x - abs y) â‰¤ abs (x - y) "
    ]
  },
  {
    "docString": "Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.",
    "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\\n  {r : ENNReal}, r < dimH s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\\nsecond countable topology, then there exists a point `x âˆˆ s` such that every neighborhood\\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s t : Set Î±} {r : ENNReal},\\n  x âˆˆ s â†’ EMetric.hausdorffEdist s t < r â†’ âˆƒ y, y âˆˆ t âˆ§ edist x y < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the Hausdorff distance is `< r`, then any point in one of the sets has\\na corresponding point at distance `< r` in the other set \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"}]\n",
    "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\nsecond countable topology, then there exists a point `x âˆˆ s` such that every neighborhood\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\n  {r : ENNReal}, r < dimH s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t :=\n\n/-- If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s t : Set Î±} {r : ENNReal},\n  x âˆˆ s â†’ EMetric.hausdorffEdist s t < r â†’ âˆƒ y, y âˆˆ t âˆ§ edist x y < r :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$. -/\ntheorem",
    "choices": [
      "âˆ€ {k : â„•} [inst : LinearOrderedField k] {x y z : k} {d r : â„},\n  k â‰¥ 3 â†’ x â‰  y â†’ edist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ z, Infinite z âˆ§ (âˆ€ z âˆˆ z, edist z x = r âˆ§ edist z y = r) ",
      "âˆ€ {k : â„•} (hk : k â‰¥ 3) {x y : â„^k} {d r : â„},\n  âˆ¥x - yâˆ¥ = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ Set.Infinite {z : â„^k | âˆ¥z - xâˆ¥ = r âˆ§ âˆ¥z - yâˆ¥ = r} ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : â„^k} {d r : â„}, d = dist x y â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ f : â„• â†’ â„^k, (âˆ€ n, dist (f n) x = r âˆ§ dist (f n) y = r) âˆ§ âˆ€ n m, n â‰  m â†’ f n â‰  f m ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ k} {d r : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒá¶  z, dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {k : â„•} (hk : k â‰¥ 3) {x y : â„^k} {d r : â„}, dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ f : â„• â†’ â„^k, (âˆ€ n : â„•, dist (f n) x = r âˆ§ dist (f n) y = r) âˆ§ âˆ€ m n : â„•, m â‰  n â†’ f m â‰  f n ",
      "âˆ€ {k : â„•} {x y : EuclideanSpace â„ k} {r d : â„}, k â‰¥ 3 â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ (z : â„• â†’ EuclideanSpace â„ k), (âˆ€ n, dist (z n) x = r âˆ§ dist (z n) y = r) âˆ§ âˆ€ m n, m â‰  n â†’ z m â‰  z n ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : â„^k} {r d : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ (âˆƒ z, dist z x = r âˆ§ dist z y = r) ",
      "âˆ€ {k : N} {x y : EuclideanSpace â„ k} (hr : â„) {d : â„},\n  k â‰¥ 3 â†’ x â‰  y â†’ d = dist x y â†’ d > 0 â†’ hr > 0 â†’ 2 * hr > d â†’ âˆƒá¶  z in atTop (EuclideanSpace â„ k), dist z x = hr âˆ§ dist z y = hr ",
      "âˆ€ {k : â„•} (hk : k â‰¥ 3) {x y : â„^k} {d : â„} (hd : dist x y = d) {r : â„} (hr : 0 < r) (h_rd : 2 * r > d), âˆƒ (z : Set (â„^k)), Cardinal.mk (â†¥z) = Cardinal.omega âˆ§ âˆ€ w âˆˆ z, dist w x = r âˆ§ dist w y = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ k} {d r : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒá¶  z, dist z x = r âˆ§ dist z y = r "
    ]
  },
  {
    "docString": "If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\\n`x : M` such that `B x x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x â‰  0`. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$ -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} {k : â„•} [inst : Ring R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Finâ‚“ k â†’ R},\n  k â‰¥ 2 â†’ âˆƒ y : Finâ‚“ k â†’ R, y â‰  0 âˆ§ (Finset.sum (Finset.univ : Finset (Finâ‚“ k)) (Î» i, x i * y i)) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : Ring R] [inst_1 : IsDomain R] {x : Fin k â†’ R}, k â‰¥ 2 â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ Matrix.dotProduct x y = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Finâ‚“ k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Finâ‚“ k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : Ring R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Fintype.sum (Fin k) (Î» i, x i * y i)) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ (Î» i, x i * y i)) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ (Î» i, x i * y i)) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  2 â‰¤ k â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Fintype.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {x : Fin k â†’ R},\n  k â‰¥ 2 â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Finset.sum (Finset.range k) (Î» i, x i * y i)) = 0 "
    ]
  },
  {
    "docString": "Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"}]\n",
    "prompt_cons": "/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c) :=\n\n/-- Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$. -/\ntheorem",
    "choices": [
      "forall {R : Type u_1} [euclidean_domain R] (a b : R), âˆƒ c r, (âˆ€ x, (dist x a = 2 * dist x b) â†” (dist x c = r)) âˆ§ (3 * c = 4 * b - a) âˆ§ (3 * r = 2 * dist b a) ",
      "âˆ€ {R : Type u_1} [metric_space R] [inhabited R] (a b : R), âˆƒ c r, (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) âˆ§ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {R : Type u} [metric_space R] {k : â„•} {a b : k â†’ R},\n  (âˆƒ c : k â†’ R, âˆƒ r : â„, (âˆ€ x : k â†’ R, dist x a = 2 * dist x b â†” dist x c = r) âˆ§ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a) ",
      "âˆ€ {R : Type u_1} [metric_space R] {k : â„•} {a b : R^k}, âˆƒ c : R^k, âˆƒ r : â„, (âˆ€ x : R^k, dist x a = 2 * dist x b â†” dist x c = r) âˆ§ (3 * c = 4 * b - a) âˆ§ (3 * r = 2 * dist b a) ",
      "âˆ€ {R : Type u_1} [metric_space R] {a b c : R} {r : â„},\n  (âˆ€ x : R, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {R : Type u_1} [metric_space R] {a b c x : R} {k : â„•} {r : â„},\n  (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {R : Type u_1} [normed_ring R] [nontrivial R] (a b : R), âˆƒ c r : R, (âˆ€ x : R, âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥ â†” âˆ¥x - câˆ¥ = r) âˆ§ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * âˆ¥b - aâˆ¥ ",
      "forall {R : Type} [metric_space R] {k : â„•} {a b : R} {c : R} {r : â„}, (âˆ€ x : R, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {R : Type u_1} [metric_space R] {k : â„•} {a b : R^k}, âˆƒ (c : R^k) (r : â„), (âˆ€ x : R^k, dist x a = 2 * dist x b â†” dist x c = r) âˆ§ 3*c = 4*b - a âˆ§ 3*r = 2*dist b a ",
      "âˆ€ {R : Type u} [normed_ring R] {a b c : R} {r : â„}, (âˆ€ x, (âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥) â†” (âˆ¥x - câˆ¥ = r)) â†’ (3 * c = 4 * b - a) âˆ§ (3 * r = 2 * âˆ¥b - aâˆ¥) "
    ]
  },
  {
    "docString": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"}]\n",
    "prompt_cons": "/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (h : âˆ€ s : Set Î±, Set.Infinite s â†’ âˆƒ x, x âˆˆ s âˆ§ IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (h : âˆ€ s : Set Î±, Set.Infinite s â†’ âˆƒ x, x âˆˆ s âˆ§ IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : âˆ€ (s : Set Î±), Set.Infinite s â†’ âˆƒ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (H : âˆ€ s : Set Î±, Set.Infinite s â†’ (âˆƒ x, IsLimitPoint s x)),\n  TopologicalSpace.SeparableSpace Î± ",
      "forall {Î± : Type u} [inst : MetricSpace Î±] (H : âˆ€ s : Set Î±, Set.Infinite s â†’ âˆƒ x, x âˆˆ s âˆ§ IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (h : âˆ€ s : Set Î±, Set.Countable s â†’ âˆƒ x, x âˆˆ closure s),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (H : âˆ€ s : Set Î±, Set.Infinite s â†’ âˆƒ x, IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : EmetricSpace Î±] (h : âˆ€ s : Set Î±, Set.Infinite s â†’ âˆƒ x, x âˆˆ limit_pts s),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (h : âˆ€ s : Set Î±, âˆƒ x, x âˆˆ s âˆ§ Infinite s â†’ âˆƒ y, y â‰  x âˆ§ âˆ€ Îµ > 0, âˆƒ x âˆˆ s, x â‰  y âˆ§ dist x y < Îµ),\n  TopologicalSpace.SeparableSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] (h : âˆ€ (s : Set Î±), Set.Countable s â†’ Â¬Set.Infinite s â†’ âˆƒ x, x âˆˆ s âˆ§ IsLimitPointOf s x),\n  TopologicalSpace.SeparableSpace Î± "
    ]
  },
  {
    "docString": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\\n  IsComplete s â†’\\n    âˆ€ (hsf : Set.MapsTo f s s),\\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\\n        âˆ€ {x : Î±},\\n          x âˆˆ s â†’\\n            edist x (f x) â‰  âŠ¤ â†’\\n              âˆƒ y,\\n                y âˆˆ s âˆ§\\n                  Function.IsFixedPt f y âˆ§\\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Banach fixed-point theorem for maps contracting on a complete subset. \"}]\n",
    "prompt_cons": "/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- Banach fixed-point theorem for maps contracting on a complete subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\n  IsComplete s â†’\n    âˆ€ (hsf : Set.MapsTo f s s),\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\n        âˆ€ {x : Î±},\n          x âˆˆ s â†’\n            edist x (f x) â‰  âŠ¤ â†’\n              âˆƒ y,\n                y âˆˆ s âˆ§\n                  Function.IsFixedPt f y âˆ§\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K) :=\n\n/-- Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect. -/\ntheorem",
    "choices": [
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ k â†’ â„)},\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ P âŠ† Closure E âˆ§ P âŠ† {x | IsCondensationPoint x E} ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace.SecondCountableTopology â„],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ Set.Nonempty P âˆ§ P âŠ† E ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace.SecondCountableTopology â„],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ P âŠ† Closure E âˆ§ âˆ€ x âˆˆ P, Filter.NeBot (ğ“[E] x) ",
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ k â†’ â„)}, Â¬Set.Countable E â†’\n  âˆƒ P : Set (Finâ‚“ k â†’ â„), Perfect P âˆ§ Set.Nonempty P âˆ§ P âŠ† E ",
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ k â†’ â„)},\n  Â¬Set.Countable E â†’\n    let P ",
      "âˆ€ {Î± : Type u} {E : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_2 : TopologicalSpace.IsTotalSeparableSpace Î±] [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : DenselyOrdered Î±],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ P âŠ† E ",
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ k â†’ â„)}, Â¬Set.Countable E â†’\n  âˆƒ P, Perfect P âˆ§ Set.Nonempty P âˆ§ âˆ€ (x : Finâ‚“ k â†’ â„), HasMem.Mem x P â†” HasMem.Mem x (CondensationPoints E) ",
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ k â†’ â„)},\n  Â¬Set.Countable E â†’\n    let P ",
      "âˆ€ {E : Set â„^k} [inst : TopologicalSpace â„^k] [inst_1 : TopologicalSpace.SecondCountableTopology â„^k],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ P âŠ† E âˆ§ âˆ€ x âˆˆ E, IsCondensationPoint x P ",
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ k â†’ â„)} [inst : TopologicalSpace (Finâ‚“ k â†’ â„)] [inst_1 : TopologicalSpace.SecondCountableTopology (Finâ‚“ k â†’ â„)],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ Set.Nonempty P âˆ§ P âŠ† CondensationPts E "
    ]
  },
  {
    "docString": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"}]\n",
    "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {A : Set Î±},\n  IsClosed A â†’ âˆƒ P, âˆƒ Q, Perfect P âˆ§ Set.Countable Q âˆ§ A = P âˆª Q ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {C : Set Î±},\n  IsClosed C â†’ âˆƒ (P : Set Î±) (H : Set Î±), Perfect P âˆ§ Set.Countable H âˆ§ C = P âˆª H ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±}, IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±}, \n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t u, Perfect t âˆ§ Set.Countable u âˆ§ s = t âˆª u ",
      "âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {C : Set Î±},\n  IsClosed C â†’ âˆƒ P A, Perfect P âˆ§ Set.Countable A âˆ§ C = P âˆª A ",
      "âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±],\n  âˆ€ {C : Set Î±}, IsClosed C â†’ âˆƒ P A, Set.Countable A âˆ§ Perfect P âˆ§ C = P âˆª A ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ "
    ]
  },
  {
    "docString": "Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"}]\n",
    "prompt_cons": "/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] {s : â„• â†’ Î±}, Summable s â†’ Summable (Î» n, âˆ¥s nâˆ¥) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedAddCommGroup Î±] {Î² : Type v} [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace Î²]\n  {s : Î² â†’ Î±}, Filter.Tendsto s Filter.atTop (nhds 0) â†’ Filter.Tendsto (fun b => abs (s b)) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] {s : â„• â†’ Î±} {a : Î±},\n  Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs a)) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {s : â„• â†’ Î±},\n  Filter.Tendsto s Filter.atTop (nhds (lim Filter.atTop s)) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs (lim Filter.atTop s))) ",
      "âˆ€ {Î± : Type u} {f : â„• â†’ Î±} [_inst_1 : LinearOrderedAddCommGroup Î±], CauchySeq f â†’ CauchySeq (abs âˆ˜ f) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] {s : â„• â†’ Î±} {a : Î±},\n  Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs a)) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {s : â„• â†’ Î±},\n  Filter.Tendsto s Filter.atTop (nhds (limit s)) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs (limit s))) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î²] {s : Î± â†’ Î²} {b : Filter Î±} {x : Î²},\n  Filter.Tendsto s b (nhds x) â†’ Filter.Tendsto (fun n => dist (s n) x) b (nhds 0) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedAddCommGroup Î±] {s : â„• â†’ Î±} {l : Î±},\n  Filter.Tendsto s Filter.atTop (nhds l) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs l)) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] {s : â„• â†’ Î±} {a : Î±},\n  Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs a)) "
    ]
  },
  {
    "docString": "If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"}]\n",
    "prompt_cons": "/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (0 : â„) n < 2 ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries 0 n < 2 ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (1 / 2 ^ n) n < 2 âˆ§ âˆ€ (i : â„•), i < n â†’ Real.sqrtTwoAddSeries (1 / 2 ^ (i + 1)) i < 2 ",
      "âˆ€ (n : â„•), Real.sqrt (2 + Real.sqrt (Real.sqrtTwoAddSeries (â†‘1 / â†‘1) n)) < 2 ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (â†‘1 / â†‘1) n < 2 ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ",
      "âˆ€ (n : â„•), 0 < Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n âˆ§ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ",
      "forall (n : â„•), Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 "
    ]
  },
  {
    "docString": "Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"}]\n",
    "prompt_cons": "/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [Archimedean Î±], Filter.Tendsto (Î» n : â„•, Finset.sum (Finset.range n) (Î» i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±], Filter.Tendsto (Î» n, Finset.sum (Finset.range n) (Î» i, (Real.sqrt (i + 1) - Real.sqrt i))) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (Î» n, Finset.sum (Finset.range n) (Î» i, Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [archimedean Î±],\n  Filter.Tendsto (Î» n, Finset.sum (Finset.range n) (Î» i, Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [archimedean Î±], Filter.Tendsto (Î» n, Finset.sum (Finset.range n) (Î» i, Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [Archimedean Î±],\n  Filter.Tendsto (Î» n : â„•, Finset.sum (Finset.range n) (Î» i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [archimedean Î±], Filter.Tendsto (Î» n : â„•, Finset.sum (Finset.range n) (Î» i => real.sqrt (i + 1) - real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [archimedean Î±],\n  Filter.Tendsto (Î» n, Finset.sum (Finset.range n) (Î» i, real.sqrt (i + 1) - real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (Î» n, Finset.sum (Finset.range n) (Î» i, (Real.sqrt (i + 1) - Real.sqrt i))) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±], Filter.Tendsto (Î»n : â„•, Finset.sum (Finset.range n) (Î»i => real.sqrt (â†‘(i + 1)) - real.sqrt â†‘i)) Filter.atTop Filter.atTop "
    ]
  },
  {
    "docString": "If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. \"}]\n",
    "prompt_cons": "/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : NormedField Î±] [inst_1 : NormedField Î²] [self : Summable (Î± Ã— Î²)]\n  [self_1 : MonotoneSequence (Î± Ã— Î²)] [self_2 : Bounded (Î± Ã— Î²)],\n  Summable (Î» (n : â„•), Summable.partialSums (Î± Ã— Î²) n * MonotoneSequence.partialSums (Î± Ã— Î²) n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedSemiring Î±] [inst_1 : OrderedSemiring Î²] [inst_2 : TopologicalSpace Î±] [inst_3 : TopologicalSpace Î²] [inst_4 : SupConvergenceClass Î±] [inst_5 : SupConvergenceClass Î²],\n  Filter.Tendsto (fun n => âˆ‘ (k : â„•) in Finset.range n, a k) Filter.atTop (nhds a) â†’\n    Monotone b â†’ BddAbove (range b) â†’ Filter.Tendsto (fun n => âˆ‘ (k : â„•) in Finset.range n, a k * b k) Filter.atTop (nhds (a * sup (range b))) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : AddCommGroup Î±] [inst_2 : TopologicalAddGroup Î±] [inst_3 : TopologicalSpace Î²] [inst_4 : Preorder Î²] [inst_5 : OrderClosedTopology Î²] [self : HasSum Î±] (f : â„• â†’ Î±) (g : â„• â†’ Î²),\n  Filter.Tendsto f Filter.atTop (nhds 0) â†’\n    Monotone g â†’ BddAbove (Set.Range g) â†’\n      âˆ€ (a : Î±), HasSum (fun n => f n) a â†’\n        Filter.Tendsto (fun n => f n * g n) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : AddCommGroup Î±] [inst_2 : UniformSpace Î²]\n  [inst_3 : LinearOrder Î²] [inst_4 : OrderTopology Î²] [inst_5 : TopologicalAddGroup Î±] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  (Filter.HasAntitoneBasis Filter.atTop b) â†’\n    Filter.Tendsto a Filter.atTop (ğ“ 0) â†’\n      Filter.Tendsto (fun n => a n * b n) Filter.atTop (ğ“ 0) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedSemiring Î±] [inst_1 : OrderedCancelAddCommMonoid Î²] [inst_2 : Preorder Î²]\n  {a : â„• â†’ Î±} {b : â„• â†’ Î²} {l : Filter Î±},\n  Filter.HasBasis l Filter.atTop (Set.Iic âˆ˜ b) â†’\n    Filter.Tendsto (fun n => âˆ‘ (i : â„•) in Finset.range n, a i) Filter.atTop l â†’\n      Filter.Tendsto (fun n => âˆ‘ (i : â„•) in Finset.range n, a i * b i) Filter.atTop l ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommMonoid Î²] [inst_2 : OrderTopology Î²] [self : SupConvergenceClass Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  Filter.Tendsto a Filter.atTop (nhds 0) â†’\n    (âˆ€ (n : â„•), b n â‰¤ b (n + 1)) â†’\n      BddAbove (Set.Range b) â†’\n        Filter.Tendsto (fun n => a n * b n) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : Archimedean Î±] [inst_4 : TopologicalRing Î²] [inst_5 : TopologicalAddGroup Î²] (a : â„• â†’ Î²) (b : â„• â†’ Î±),\n  Filter.Tendsto a Filter.atTop (nhds 0) â†’\n    (âˆ€ (n : â„•), b n â‰¤ b (n + 1)) â†’\n      BddAbove (Set.Range b) â†’ Filter.Tendsto (fun n => a n * b n) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : AddCommGroup Î±] [inst_2 : UniformSpace Î²] [inst_3 : LinearOrderedAddCommGroup Î²] [inst_4 : TopologicalAddGroup Î±]\n  (a : â„• â†’ Î±) (b : â„• â†’ Î²) (A : Î±) (B : Î²),\n  Filter.Tendsto a Filter.atTop (nhds A) â†’\n    (âˆ€ (n : â„•), b n â‰¤ b (n + 1)) â†’\n      BddAbove (Set.Range b) â†’\n        Filter.Tendsto (fun n => a n * b n) Filter.atTop (nhds (A * B)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [_inst_1 : LinearOrderedField Î±] [_inst_2 : Archimedean Î±]\n  [_inst_3 : TopologicalSpace Î±] [_inst_4 : OrderTopology Î±] [_inst_5 : TopologicalAddGroup Î±]\n  {a : â„• â†’ Î±} {b : â„• â†’ Î±} [ha : Summable a] [hb : Monotone b] (hb_bound : BddAbove (Set.Range b)),\n  Summable (Î» (n : â„•), a n * b n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : AddCommGroup Î±] [inst_2 : TopologicalAddGroup Î±] [inst_3 : Monoid Î²] [inst_4 : Preorder Î²] [inst_5 : TopologicalSpace Î²] [self : SupConvergenceClass Î±] {a : Î² â†’ Î±} {b : Î² â†’ Î²},\n  HasSum a (SupConvergenceClass SupConvergenceClass.Sup) â†’\n    Monotone b â†’ BddAbove (Set.Range b) â†’\n      HasSum (fun n => a n * b n) (SupConvergenceClass SupConvergenceClass.Sup) "
    ]
  },
  {
    "docString": "Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"}]\n",
    "prompt_cons": "/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±} {u' : â„• â†’ Î²} {p : Î±},\n  CauchySeq u â†’\n    Filter.Tendsto (u âˆ˜ u') Filter.atTop (nhds p) â†’ Filter.Tendsto u Filter.atTop (nhds p) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {p : â„• â†’ Î±} {l : â„• â†’ â„•} {x : Î±},\n  CauchySeq p â†’ Filter.Tendsto l Filter.atTop Filter.atTop â†’ Filter.Tendsto (Î» n, p (l n)) Filter.atTop (nhds x) â†’ Filter.Tendsto p Filter.atTop (nhds x) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±} {u' : â„• â†’ Î±} {l : â„• â†’ Î²} {x : Î±},\n  CauchySeq u â†’\n    Filter.Tendsto l Filter.atTop Filter.atTop â†’\n      Filter.Tendsto u' Filter.atTop (nhds x) â†’\n        (âˆ€ n, u (l n) = u' n) â†’ Filter.Tendsto u Filter.atTop (nhds x) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±} {ul : â„• â†’ Î²} {x : Î±},\n  CauchySeq u â†’\n    Filter.Tendsto (u âˆ˜ ul) Filter.atTop (nhds x) â†’ Filter.Tendsto u Filter.atTop (nhds x) ",
      "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±} {p : Î±} (seq : â„• â†’ â„•),\n  CauchySeq u â†’\n    Filter.Tendsto (u âˆ˜ seq) Filter.atTop (nhds p) â†’ Filter.Tendsto u Filter.atTop (nhds p) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {p : â„• â†’ Î±} {p_sub : â„• â†’ Î±} {l : â„• â†’ â„•} {x : Î±},\n  CauchySeq p â†’ Filter.Tendsto (Î» n, p (l n)) Filter.atTop (nhds x) â†’ Filter.Tendsto p Filter.atTop (nhds x) ",
      "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {Î² : Type v} [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±} {p : â„• â†’ Î²} {x : Î±},\n  CauchySeq u â†’\n    Filter.Tendsto (u âˆ˜ p) Filter.atTop (nhds x) â†’ Filter.Tendsto u Filter.atTop (nhds x) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {p : â„• â†’ Î±} {l : â„• â†’ â„•} {x : Î±},\n  CauchySeq p â†’\n    Filter.Tendsto (fun n => p (l n)) Filter.atTop (nhds x) â†’ Filter.Tendsto p Filter.atTop (nhds x) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {p : â„• â†’ Î±} {p' : Î±} {l : â„• â†’ â„•},\n  CauchySeq p â†’\n    Filter.Tendsto (p âˆ˜ l) Filter.atTop (nhds p') â†’ Filter.Tendsto p Filter.atTop (nhds p') ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {p : â„• â†’ Î±} (hp : CauchySeq p) {l : â„• â†’ â„•} {L : Filter â„•}\n  (hl : Filter.Tendsto l L Filter.atTop) {a : Î±}, Filter.Tendsto (fun n => p (l n)) L (nhds a) â†’ Filter.Tendsto p Filter.atTop (nhds a) "
    ]
  },
  {
    "docString": "Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"One of the most useful consequences of Baire theorem: if a countable union of closed sets\\ncovers the space, then one of the sets has nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [Nonempty Î±] [inst_2 : CompleteSpace Î±]\n  {Î² : Type u_2} [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : CompleteSpace Î±]\n  {Î² : Type u_2} [inst_4 : SemilatticeSup Î²] [inst_5 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’\n    (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : CompleteSpace Î±]\n  {Î² : Type u_2} [inst_4 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : CompleteSpace Î±]\n  {Î² : Type u_2} [inst_4 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] {Î² : Type u_2}\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (n : Î²), IsOpen (f n)) â†’ (âˆ€ (n : Î²), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : Î²), f n) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : CompleteSpace Î±] {Î² : Type u_2} [inst_4 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "forall {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Nonempty Î±] {Î² : Type u_2} [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : CompleteSpace Î±] {Î² : Type u_2} [inst_4 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (n : Î²), IsOpen (f n)) â†’ (âˆ€ (n : Î²), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : Î²), f n) ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : CompleteSpace Î±]\n  {Î² : Type u_2} [inst_4 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : CompleteSpace Î±]\n  {Î² : Type u_2} [inst_4 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) "
    ]
  },
  {
    "docString": "If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$). -/\ntheorem",
    "choices": [
      "âˆ€ {X Y : Type u_1} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y) (E : Set X),\n  Continuous f â†’ Closure (f '' E) âŠ† f '' Closure E ",
      "âˆ€ {X Y : Type u_1} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y),\n  Continuous f â†’ âˆ€ (E : Set X), f '' Closure E âŠ† Closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y),\n  Continuous f â†’ âˆ€ (E : Set X), f '' Closure E âŠ† Closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y) (E : Set X),\n  Continuous f â†’ Closure (f '' E) âŠ† f '' Closure E ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y),\n  Continuous f â†’ âˆ€ (E : Set X), f '' Closure E âŠ† Closure (f '' E) ",
      "âˆ€ {X Y : Type u} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y),\n  Continuous f â†’ âˆ€ (E : Set X), f '' Closure E âŠ† Closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y) (E : Set X),\n  Continuous f â†’ Closure (f '' E) âŠ† f '' Closure E ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y),\n  Continuous f â†’ âˆ€ (E : Set X), f '' Closure E âŠ† Closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y),\n  Continuous f â†’ âˆ€ (E : Set X), f '' Closure E âŠ† Closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y]\n  (f : X â†’ Y) (E : Set X), Continuous f â†’ Closure (f '' E) âŠ† f '' Closure E "
    ]
  },
  {
    "docString": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"}]\n",
    "prompt_cons": "/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$. -/\ntheorem",
    "choices": [
      "forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace Y]\n  {E : Set X} {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f g : X â†’ Y},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {f g : X â†’ Y} {E : Set X}, Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y] {E : Set X} {f g : X â†’ Y},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "forall {X Y : Type} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : TopologicalSpace Y] [inst_3 : T2Space Y] (E : Set X)\n  (f g : X â†’ Y), Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (Set.Image f E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {E : Set X} {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (Set.Image f E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  (f g : X â†’ Y) (E : Set X), Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "âˆ€ {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [MetricSpace X] [MetricSpace Y]\n  {f g : X â†’ Y} {E : Set X}, Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "forall {X Y : Type*} [TopologicalSpace X] [MetricSpace X] [TopologicalSpace Y] [MetricSpace Y]\n  (f g : X â†’ Y) (E : Set X), Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (Set.Image f E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space X] [inst_3 : MetricSpace Y]\n  {E : Set X} (f g : C(X, Y)),\n  Dense E â†’ Dense (f '' E) "
    ]
  },
  {
    "docString": "If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"}]\n",
    "prompt_cons": "/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g, Continuous g âˆ§ Set.EqOn f g E ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ âˆ€ (x : â„), x âˆˆ E â†’ g x = f x ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„} [inst : TopologicalSpace â„],\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g, Continuous g âˆ§ Set.EqOn g f E ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : LinearOrder X] [inst_2 : OrderTopology X] [inst_3 : DenselyOrdered X]\n  {f : X â†’ â„} {E : Set X},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ (g : X â†’ â„), Continuous g âˆ§ âˆ€ (x : X), x âˆˆ E â†’ g x = f x ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ âˆ€ (x : â„), x âˆˆ E â†’ g x = f x ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ Set.EqOn g f E ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ Set.EqOn f g E ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„}, IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ Set.EqOn f g E ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ Set.EqOn f g E ",
      "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ Set.EqOn f g E "
    ]
  },
  {
    "docString": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace Î²] [inst_3 : T2Space Î²]\n  {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’\n  (Compact (SetOf (Î» p : Î± Ã— Î², p.2 = f p.1 âˆ§ p.1 âˆˆ E)) â†” ContinuousOn f E) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  (f : Î± â†’ Î²), Continuous f â†” Compact (Set.Graph f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (IsCompact (Set.Graph f E) â†” ContinuousOn f E) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] [inst_3 : CompactSpace Î±]\n  (f : Î± â†’ Î²), Compact (Set.Graph f) â†” Continuous f ",
      "âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (f : E â†’ F) (s : Set E),\n  IsCompact s â†’\n    (ContinuousOn f s â†” IsCompact (SetOf (Î» (x : E Ã— F), x.2 = f x.1 âˆ§ x.1 âˆˆ s))) ",
      "âˆ€ {Î± : Type u} {E : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace E] [inst_2 : T2Space E]\n  [inst_3 : CompactSpace Î±] [inst_4 : T2Space Î±] (f : Î± â†’ E),\n  Continuous f â†” Compact (Graph f Î± E) ",
      "âˆ€ {E : Type u} [inst : TopologicalSpace E] [inst_1 : TopologicalSpace â„] {f : E â†’ â„} {s: Set E},\n  Compact s â†” ContinuousOn f s â†’ Compact (Set.Graph f s) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±]\n  [inst_4 : LinearOrder Î²] [inst_5 : OrderTopology Î²] {s : Set Î±} {f : Î± â†’ Î²},\n  IsCompact s â†’ (ContinuousOn f s â†” IsCompact (SetOf (Î» (x : Î± Ã— Î²), x.2 = f x.1 âˆ§ x.1 âˆˆ s))) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²]\n  [inst_3 : CompactSpace Î±] {f : Î± â†’ Î²},\n  Compact (SetOf (Î» (x : Î± Ã— Î²), x.snd = f x.fst)) â†” Continuous f ",
      "âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] {f : E â†’ F} {s : Set E},\n  IsCompact s â†’\n    (ContinuousOn f s â†” IsCompact (Prod.fst â»Â¹' s âˆ© (Prod.snd â»Â¹' Closure (f '' s)))) "
    ]
  },
  {
    "docString": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : LinearOrder â„] [inst_2 : OrderTopology â„] [inst_3 : Nonempty â„],\n  Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ IsUnboundedOn f E ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : Nonempty Î±] {E : Set Î±},\n  Bdd E â†’ âˆƒ (f : Î± â†’ â„), UniformContinuous f âˆ§ Â¬ Bdd (f '' E) ",
      "âˆ€ {E : Set â„} [inst : MetricSpace â„] [inst_1 : Nonempty E] [inst_2 : Bounded E],\n  âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬(BddAbove (f '' E) âˆ§ BddBelow (f '' E)) ",
      "âˆ€ {E : Set â„} (hE : Bounded E), âˆƒ (f : â„ â†’ â„) (hf : UniformContinuous f), Â¬ BddAbove (f '' E) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : MetricSpace â„] [inst_2 : Nonempty â„],\n  Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬BddAbove (f '' E) ",
      "âˆ€ {E : Type u_1} [inst : LinearOrder E] [inst_1 : TopologicalSpace E] [inst_2 : OrderClosedTopology E] [inst_3 : BddAbove E],\n  âˆƒ (f : E â†’ â„), UniformContinuous f âˆ§ Â¬ BddAbove (f '' E) ",
      "âˆ€ {E : Set â„} [inst : MetricSpace â„] [inst_1 : Nonempty E] [inst_2 : Bounded E],\n  âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ (âˆ€ (K : Set â„), IsCompact K â†’ Not (BddAbove (f '' E))) ",
      "âˆ€ {E : Set â„} [inst : LinearOrder â„] [inst_1 : TopologicalSpace â„] [inst_2 : OrderClosedTopology â„],\n  Bdd E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆƒ K : Set â„, IsCompact K âˆ§ ContinuousOn f K âˆ§ Â¬Bdd (f '' K) ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace â„] [inst_1 : PseudoMetricSpace â„] (K : TopologicalSpace.Compacts â„),\n  Bounded E â†’ âˆƒ (f : E â†’ â„), UniformContinuous f âˆ§ Â¬ BddAbove (f '' E) ",
      "âˆ€ {E : Type u_1} [inst : MetricSpace E] [inst_1 : Nonempty E] [inst_2 : Bounded E],\n  âˆƒ (f : E â†’ â„), UniformlyContinuous f âˆ§ Â¬ BddAbove (f '' E) âˆ§ Â¬ BddBelow (f '' E) "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î² â†’ Î±} {g : Î³ â†’ Î²},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "
    ]
  },
  {
    "docString": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„},\\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` takes either its maximum\\nor its minimum value at a point in the interior of the interval. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„},\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous. -/\ntheorem",
    "choices": [
      "âˆ€ (f : â„ â†’ â„), IsIntermediateValueUniv f â†’ (âˆ€ r : â„š, IsClosed (f â»Â¹' {r})) â†’ Continuous f ",
      "âˆ€ (f : â„ â†’ â„), (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r : â„š, IsClosed {x | f x = r}) â†’ Continuous f ",
      "âˆ€ (f : â„ â†’ â„),\n  (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x âˆˆ Set.Icc a b, f x = c) â†’\n  (âˆ€ r : â„š, IsClosed (SetOf (Î» x, f x = r))) â†’\n  Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r, IsClosed (SetOf (Î» x, f x = r))) â†’\n  Continuous f ",
      "âˆ€ (f : â„ â†’ â„),\n  (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r, IsClosed (SetOf (Î» x, f x = r))) â†’\n  Continuous f ",
      "âˆ€ (f : â„ â†’ â„), IntermediateValueUniv f â†’ (âˆ€ q : â„š, IsClosed (fâ»Â¹' {q})) â†’ Continuous f ",
      "âˆ€ (f : â„ â†’ â„),\n  (âˆ€ a b c : â„, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r : â„š, IsClosed (SetOf (Î» x, f x = r))) â†’\n  Continuous f ",
      "forall {f : â„ â†’ â„} (hivp : âˆ€ a b c, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c)\n  (hclosed : âˆ€ q : â„š, IsClosed {x | f x = q}),\n  Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r : â„š, IsClosed (SetOf (Î» x, f x = r))) â†’\n  Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ a b c, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r, IsClosed (f â»Â¹' {r})) â†’\n  Continuous f "
    ]
  },
  {
    "docString": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\\n      ConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\\nverify the inequality `a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`. The\\nmain use case is `E = â„` however one can apply it, e.g., to `â„^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) â†’\\n      StrictConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\\nto verify the inequality `a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. \"}]\n",
    "prompt_cons": "/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\nverify the inequality `a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`. The\nmain use case is `E = â„` however one can apply it, e.g., to `â„^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\n      ConcaveOn ğ•œ s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\nto verify the inequality `a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) â†’\n      StrictConcaveOn ğ•œ s f :=\n\n/-- Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : LinearOrderedField ğ•œ] [inst_1 : OrderedAddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f ((a + b)â»Â¹ â€¢ (a â€¢ x + b â€¢ y)) â‰¤ (a â€¢ f x + b â€¢ f y)) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx y : ğ•œâ¦„,\n        x âˆˆ s â†’\n          y âˆˆ s â†’ x â‰  y â†’\n            f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn ğ•œ s f ",
      "forall {a b : â„}, a < b -> âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Ioo a b) â†’\n    (âˆ€ x y : â„, x âˆˆ Ioo a b â†’ y âˆˆ Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ (Ioo a b) f ",
      "âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Ioo a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Ioo a b â†’ âˆ€ (y : â„), y âˆˆ Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Ioo a b) f ",
      "âˆ€ {a b : â„} {f : â„ â†’ â„},\n  a < b â†’\n    ContinuousOn f (Set.Ioo a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ âˆ€ (y : â„), y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n        ConvexOn â„ (Set.Ioo a b) f ",
      "âˆ€ {a b : â„} (hab : a < b), ConvexOn â„ (Ioo a b) (fun x => â„) ",
      "âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (set.Ioo a b) â†’\n        (âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ âˆ€ (y : â„), y âˆˆ set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (set.Ioo a b) f ",
      "âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Ioo a b) â†’\n        (âˆ€ (x : â„),\n            x âˆˆ Ioo a b â†’ âˆ€ (y : â„), y âˆˆ Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Ioo a b) f ",
      "âˆ€ {E : Type u_1} [inst : LinearOrderedField E] [inst_1 : TopologicalSpace E] [inst_2 : OrderTopology E]\n  [inst_3 : OpensMeasurableSpace E] {s : Set E} {f : E â†’ â„},\n  Convex E s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      âˆ€ â¦ƒa b : Eâ¦„, a âˆˆ s â†’ b âˆˆ s â†’ a < b â†’ âˆ€ â¦ƒc d : Eâ¦„, 0 < c â†’ 0 < d â†’ c + d = 1 â†’ c â€¢ f a + d â€¢ f b â‰¤ f (c â€¢ a + d â€¢ b) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : LinearOrderedField ğ•œ] [inst_1 : OrderedAddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ (a â€¢ f x + b â€¢ f y)) â†’\n      ConvexOn ğ•œ s f "
    ]
  },
  {
    "docString": "Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x â‰¤ B' x` on `[a, b)`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"}]\n",
    "prompt_cons": "/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x â‰¤ B' x` on `[a, b)`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$. -/\ntheorem",
    "choices": [
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n        let g ",
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo a b) x) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n          StrictMonoOn f (Set.Ioo a b) âˆ§\n            âˆ€ {g g' : â„ â†’ â„},\n              (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x) â†’\n                (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g' x = 1 / f' (g x)) â†’\n                  âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt g (g' x) (Set.Ioo a b) x ",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo a b) x) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n      StrictMonoOn f (Set.Ioo a b) âˆ§\n        (âˆƒ (g : â„ â†’ â„) (g' : â„ â†’ â„),\n           âˆ€ (x : â„),\n             x âˆˆ Set.Ioo a b â†’\n               HasDerivWithinAt g (g' x) (Set.Ioo (f a) (f b)) (f x) âˆ§ g' x = (1 / f' x)) ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (c : â„), c âˆˆ Set.Ioo a b â†’ âˆƒ (f' : â„), HasDerivWithinAt f f' (Set.Ioi c) c âˆ§ f' > 0) â†’\n        (âˆ€ x y, x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ x < y â†’ f x < f y) âˆ§\n          (âˆƒ (g : â„ â†’ â„),\n            (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ âˆƒ (g' : â„), HasDerivWithinAt g g' (Set.Ioi y) y âˆ§ g' = (1 / f' (g y)) âˆ§ g y âˆˆ Set.Ioo a b) âˆ§\n            âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x) ",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n        StrictMonoOn f (Set.Ioo a b) âˆ§\n          âˆ€ â¦ƒg : â„ â†’ â„â¦„, (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’\n              (DifferentiableAt â„ g (f x) âˆ§ deriv g (f x) = (f' x)â»Â¹)) ",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo a b) x) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n          StrictMonoOn f (Set.Ioo a b) âˆ§\n            âˆƒ (g : â„ â†’ â„),\n              (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x) âˆ§\n                Continuous g âˆ§\n                  âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (1 / f' x) (f x)",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n        StrictMonoOn f (Set.Ioo a b) âˆ§\n          âˆ€ â¦ƒg g' : â„ â†’ â„â¦„,\n            (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ HasDerivAt g (g' y) y) â†’\n              âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g' (f x) = 1 / f' x ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (derivWithin f (Set.Ioo a b) x) (Set.Ici x) x) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ derivWithin f (Set.Ioo a b) x > 0) â†’\n          StrictMonoOn f (Set.Ioo a b) âˆ§\n            (âˆ€ {g : â„ â†’ â„}, g = Function.inverse f â†’\n              ContinuousOn g (Set.Icc (f a) (f b)) â†’\n                (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt g (1 / (derivWithin f (Set.Ioo a b) x)) (Set.Ici (f x)) (f x))) ",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n        StrictMonoOn f (Set.Ioo a b) âˆ§\n          âˆ€ â¦ƒg : â„ â†’ â„â¦„, IsStrictMono g âˆ§ âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x â†’\n            (âˆƒ g' : â„ â†’ â„, âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (g' (f x)) (f x) âˆ§ g' (f x) = 1 / f' x) ",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioo x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ f' x > 0) â†’\n        âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Ioo a b â†’ StrictMono f "
    ]
  },
  {
    "docString": "If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\\nvaries over the `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"}]\n",
    "prompt_cons": "/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\nvaries over the `n`-th roots of unity. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶ :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1. -/\ntheorem",
    "choices": [
      "/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem alg_int_norm_one_is_root_of_unity (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 ",
      "âˆ€ {C : â„• â†’ â„}, (âˆ€ n, C 0 + âˆ‘ k in Finset.range n, C (k + 1) / (k + 1)) = 0 â†’\n  âˆƒ x âˆˆ Icc (0 : â„) 1, âˆ€ n, C 0 + âˆ‘ k in Finset.range n, C (k + 1) * x ^ k = 0 ",
      "âˆ€ {R : Type u_1} [inst : Field R] [inst_1 : IsDomain R] {C : Finâ‚“ (n + 1) â†’ R},\n  (âˆ€ x, HasDerivAt (Finâ‚“.sum_elim (fun i => C i) (fun i => C (Finâ‚“.succ i) * (x ^ i))) 0 x) â†’\n    (âˆƒ x : â„, 0 â‰¤ x âˆ§ x â‰¤ 1 âˆ§ (Finâ‚“.sum_elim (fun i => C i) (fun i => C (Finâ‚“.succ i) * (x ^ i))) x = 0) ",
      "âˆ€ {n : â„•} {C : Finâ‚“ (n + 2) â†’ â„},\n  (âˆ‘ i : Finâ‚“ (n + 2), C i / (i + 1 : â„)) = 0 â†’\n    âˆƒ x : â„, 0 < x âˆ§ x < 1 âˆ§ (âˆ‘ i : Finâ‚“ (n + 2), C i * x ^ i) = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : LinearOrderedField R] {C : â„• â†’ R},\n  (âˆ€ n, C n / (n + 1) â‰¥ 0) â†’\n  (âˆ‘ (n : â„•) in Finset.range (Nat.succ (Nat.succ n)), C n / (n + 1)) = 0 â†’\n  âˆƒ x : R, 0 < x âˆ§ x < 1 âˆ§ (âˆ‘ (n : â„•) in Finset.range (Nat.succ (Nat.succ n)), C n * x ^ n) = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsField R] [inst_2 : CharZero R] {n : â„•} (C : Finâ‚“ (n + 2) â†’ R),\n  (âˆ‘ i : Finâ‚“ (n + 2), C i / (i + 1)) = 0 â†’ âˆƒ (xâ‚€ : R), 0 â‰¤ xâ‚€ âˆ§ xâ‚€ â‰¤ 1 âˆ§ (âˆ‘ i : Finâ‚“ (n + 1), C (Finâ‚“.succ i) * xâ‚€ ^ i) = -C 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {C : â„• â†’ R},\n  (âˆ‘ k in Finset.range (n + 2), C k / (k + 1)) = 0 â†’\n    âˆƒ x âˆˆ Icc (0 : R) 1, Polynomial.eval x (Finset.sum (Finset.range (n + 1)) fun i => Polynomial.C (C i) * Polynomial.X ^ i) = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {C : â„• â†’ R},\n  (âˆ‘ i in Finset.range (n + 1), C i / (i + 1)) = 0 â†’\n    âˆƒ x : R, 0 < x âˆ§ x < 1 âˆ§ (âˆ‘ i in Finset.range (n + 1), C i * x ^ i) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ i in Finset.range (n + 2), C i / (i + 1)) = 0 â†’\n    âˆƒ x : â„, 0 â‰¤ x âˆ§ x â‰¤ 1 âˆ§ (Finset.sum (Finset.range (n + 1)) fun i => C i * x ^ i) = 0 ",
      "forall {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {C : Finâ‚“ (n + 1) â†’ R},\n  (âˆ‘ i, C i / (i + 1)) = 0 â†’\n    âˆƒ xâ‚€ âˆˆ set.Icc (0 : R) 1, (âˆ‘ i, C i * xâ‚€ ^ i) = 0 "
    ]
  },
  {
    "docString": "Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\\n  (âˆ€ (Z : C) (g : Z âŸ¶ X), CategoryTheory.CategoryStruct.comp g f = 0 â†’ g = 0) â†’ CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g â‰« f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. \"}]\n",
    "prompt_cons": "/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `g â‰« f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\n  (âˆ€ (Z : C) (g : Z âŸ¶ X), CategoryTheory.CategoryStruct.comp g f = 0 â†’ g = 0) â†’ CategoryTheory.Mono f :=\n\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n\n/-- Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing. -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (set.Ici 0) â†’ (âˆ€ x > 0, HasDerivAt f (deriv f x) x) â†’ f 0 = 0 â†’ Monotone (deriv f) â†’ Monotone (Î»x, (f x) / x) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (set.Ici 0) â†’ (âˆ€ x > 0, DifferentiableAt â„ f x) â†’ f 0 = 0 â†’\n  Monotone (deriv f) â†’ Monotone (Î» x, f x / x) ",
      "âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ âˆ€ (x : â„), 0 < x â†’ DifferentiableAt â„ f x â†’\n  (âˆ€ (x y : â„), 0 â‰¤ x â†’ x â‰¤ y â†’ deriv f x â‰¤ deriv f y) â†’ (âˆ€ (x y : â„), 0 < x â†’ x â‰¤ y â†’ f x / x â‰¤ f y / y) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ (âˆ€ x âˆˆ (Set.Ioi 0), DifferentiableAt â„ f x) â†’ f 0 = 0 â†’\n  (âˆ€ x y âˆˆ (Set.Ioi 0), x < y â†’ deriv f x â‰¤ deriv f y) â†’ Monotone (Î» x, (f x) / x) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ (âˆ€ x âˆˆ Set.Ioi 0, DifferentiableAt â„ f x) â†’ f 0 = 0 â†’ (âˆ€ x y âˆˆ Set.Ioi 0, x < y â†’ deriv f x < deriv f y) â†’ Monotone (Î» x : â„, f x / x) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ DifferentiableOn â„ f (Set.Ioi 0) â†’ f 0 = 0 â†’\n  Monotone (deriv f) â†’ Monotone (Î» x, f x / x) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’ f 0 = 0 â†’\n  (âˆ€ x y, 0 < x â†’ x < y â†’ deriv f x < deriv f y) â†’ Monotone (Î» x, f x / x) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ DifferentiableOn â„ f (Set.Ioi 0) â†’ f 0 = 0 â†’\n  Monotone (deriv f) â†’ Monotone (Î» x, f x / x) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn f (Set.Ici 0) â†’ (âˆ€ x > 0, DifferentiableAt â„ f x) â†’ f 0 = 0 â†’\n  Monotone (deriv f) â†’ Monotone (Î» x, f x / x) "
    ]
  },
  {
    "docString": "Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\\nthen `f` is convex on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"}]\n",
    "prompt_cons": "/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\nthen `f` is convex on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$ -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„}, Differentiable â„ (Set.Ioi a) f â†’ Differentiable â„ (Set.Ioi a) (deriv f) â†’\n  (âˆ€ Mâ‚€ Mâ‚ Mâ‚‚ : â„, Mâ‚€ = Sup (abs âˆ˜ f '' Set.Ioi a) â†’ Mâ‚ = Sup (abs âˆ˜ deriv f '' Set.Ioi a) â†’ Mâ‚‚ = Sup (abs âˆ˜ deriv^[2] f '' Set.Ioi a) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚) ",
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n  (âˆ€ {a : â„}, a > 0 â†’\n    (âˆ€ x, x > a â†’\n      (âˆƒ Mâ‚€, (âˆ€ z, z > a â†’ abs (f z) â‰¤ Mâ‚€)) âˆ§\n      (âˆƒ Mâ‚, (âˆ€ z, z > a â†’ abs (deriv f z) â‰¤ Mâ‚)) âˆ§\n      (âˆƒ Mâ‚‚, (âˆ€ z, z > a â†’ abs (deriv^[2] f z) â‰¤ Mâ‚‚)))) â†’\n  âˆ€ { Mâ‚ Mâ‚€ Mâ‚‚ : â„}, 0 < Mâ‚ âˆ§ 0 < Mâ‚€ âˆ§ 0 < Mâ‚‚ â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆ€ (x : â„), a < x â†’ |f x| â‰¤ Mâ‚€ âˆ§ |deriv f x| â‰¤ Mâ‚ âˆ§ |deriv^[2] f x| â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  DifferentiableOn â„ f (Set.Ioi a) â†’\n    DifferentiableOn â„ (deriv f) (Set.Ioi a) â†’\n      âˆ€ (Mâ‚€ Mâ‚ Mâ‚‚ : â„),\n        (âˆ€ (x : â„), x âˆˆ Set.Ioi a â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), x âˆˆ Set.Ioi a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ioi a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ * Mâ‚ â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "forall {f : â„ â†’ â„} {a : â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n      (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n        (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆ€ (x : â„), x > a â†’ âˆ€ (Mâ‚€ Mâ‚ Mâ‚‚ : â„),\n      (Mâ‚€ â‰¥ 0 âˆ§ Mâ‚ â‰¥ 0 âˆ§ Mâ‚‚ â‰¥ 0) â†’\n        (abs (f x) â‰¤ Mâ‚€ âˆ§ abs (deriv f x) â‰¤ Mâ‚ âˆ§ abs (deriv^[2] f x) â‰¤ Mâ‚‚)) â†’\n          âˆ€ (Mâ‚ Mâ‚€ Mâ‚‚ : â„), Mâ‚ * Mâ‚ â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  (âˆ€ x : â„, x > a â†’ DifferentiableAt â„ f x) â†’\n  (âˆ€ x : â„, x > a â†’ DifferentiableAt â„ (deriv f) x) â†’\n  (âˆ€ x : â„, x > a â†’ abs (f x) â‰¤ Mâ‚€) â†’\n  (âˆ€ x : â„, x > a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n  (âˆ€ x : â„, x > a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  (âˆ€ x, x > a â†’ abs (f x) â‰¤ Mâ‚€) â†’ (âˆ€ x, x > a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’ (âˆ€ x, x > a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "forall {a : â„} {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      (âˆƒ M0 M1 M2 : â„,\n        (âˆ€ x, a < x â†’ abs (f x) â‰¤ M0) âˆ§\n        (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ M1) âˆ§\n        (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ M2)) â†’\n          âˆƒ M1 M0 M2 : â„, M1^2 â‰¤ 4 * M0 * M2 ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆ€ (x : â„), a < x â†’\n      (âˆ€ (Mâ‚€ : â„), (âˆ€ (y : â„), a < y â†’ abs (f y) â‰¤ Mâ‚€) â†’\n        âˆ€ (Mâ‚ : â„), (âˆ€ (y : â„), a < y â†’ abs (deriv f y) â‰¤ Mâ‚) â†’\n          âˆ€ (Mâ‚‚ : â„), (âˆ€ (y : â„), a < y â†’ abs (deriv^[2] f y) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚)) "
    ]
  },
  {
    "docString": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. \"}]\n",
    "prompt_cons": "/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x} :=\n\n/-- Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x, x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "forall {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A "
    ]
  },
  {
    "docString": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\\n  (F : Î¹ â†’ C(Î±, Î²)),\\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\n  (F : Î¹ â†’ C(Î±, Î²)),\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {X : Type v} [inst : (a : Î±) â†’ TopologicalSpace (X a)],\n  TopologicalSpace (â¨… (a : Î±), X a) ",
      "âˆ€ {X : Type u} {Î¹ : Type v} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {Î± : Type u_1} {X : Type u_2} {ğ”— : Î± â†’ TopologicalSpace X},\n  TopologicalSpace X ",
      "âˆ€ {Î± : Type u} {X : Type v} (t : Î± â†’ TopologicalSpace X),\n  TopologicalSpace (Inf t) ",
      "âˆ€ {Î± : Type u} {X : Type u_1} (T : Î± â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  TopologicalSpace.mkOfNhds (Î» (x : X) (s : Set X), âˆƒ (i : Î¹), s âˆˆ (T i).nhds x) ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {Î± : Type u} {X : Type u_1} (T : Î± â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {Î± : Type u} {X : Type v} (T : Î± â†’ TopologicalSpace X),\n  TopologicalSpace X "
    ]
  },
  {
    "docString": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\\n  ContinuousMap.compactOpen =\\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. \"}]\n",
    "prompt_cons": "/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  ContinuousMap.compactOpen =\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  ExistsUnique fun (T_min : TopologicalSpace X) => âˆ€ (Î± : Î¹), HasSubset.Subset (T Î±).sets (T_min.sets) ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (T' : TopologicalSpace X), âˆ€ i, T i â‰¤ T' ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ",
      "âˆ€ {Î¹ : Type u_1} {X : Type u_2} {T : Î¹ â†’ Set (Set X)},\n  âˆƒ (Tâ‚€ : Set (Set X)), (âˆ€ (Î± : Î¹), T Î± âŠ† Tâ‚€) âˆ§ âˆ€ (Tâ‚ : Set (Set X)), (âˆ€ (Î± : Î¹), T Î± âŠ† Tâ‚) â†’ Tâ‚€ âŠ† Tâ‚ ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ (T' : TopologicalSpace X), (âˆ€ (i : Î¹), T i â‰¤ T') âˆ§ âˆ€ (T'' : TopologicalSpace X), (âˆ€ (i : Î¹), T i â‰¤ T'') â†’ T' â‰¤ T'' ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {ğ”— : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (T : TopologicalSpace X), âˆ€ (i : Î¹), ğ”— i â‰¤ T ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} {ğ”— : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (T : TopologicalSpace X), âˆ€ i, TopologicalSpace.generate_from (ğ”— i).sets â‰¤ T ",
      "âˆ€ {Î± : Type u} {X : Type u_1} (ğ”— : Î± â†’ Set (Set X)),\n  âˆƒ! (ğ”—â‚€ : Set (Set X)), TopologicalSpace.GenerateFrom ğ”—â‚€ âˆ§ âˆ€ a, ğ”— a âŠ† ğ”—â‚€ ",
      "âˆ€ {Î± : Type u_1} {X : Type u_2} (T : Î± â†’ TopologicalSpace X),\n  âˆƒ! (T_min : TopologicalSpace X), (âˆ€ T' âˆˆ T, T_min â‰¤ T') âˆ§ âˆ€ T'', (âˆ€ T' âˆˆ T, T'' â‰¤ T') â†’ T_min â‰¤ T'' "
    ]
  },
  {
    "docString": "Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\\n  TopologicalSpace.IsTopologicalBasis s â†’\\n    âˆ€ {t : Set (Set Î²)},\\n      TopologicalSpace.IsTopologicalBasis t â†’\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"}]\n",
    "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    âˆ€ {t : Set (Set Î²)},\n      TopologicalSpace.IsTopologicalBasis t â†’\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t) :=\n\n/-- Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {t' : TopologicalSpace Î± | A âŠ† t'.is_open_set} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    t = TopologicalSpace.generateFrom A â†’\n      âˆ€ {u : TopologicalSpace Î±},\n        (A âŠ† u.1) â†’ (t â‰¤ u) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    t = TopologicalSpace.generateFrom A â†’\n      t = inf {u | TopologicalSpace.generateFrom A â‰¤ u} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {Ï„ : TopologicalSpace Î± | A âŠ† Ï„.1} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† t.2} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {Ï„ : TopologicalSpace Î± | A âŠ† Ï„.s} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {T : TopologicalSpace Î± | A âŠ† T.basis_sets} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† TopologicalSpace.IsOpen t} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    t = TopologicalSpace.generateFrom A â†’\n      t = â‹‚â‚€ {T : TopologicalSpace Î± | A âŠ† T.1} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = Inf {Ï„ : TopologicalSpace Î± | A âŠ† Ï„.1} "
    ]
  },
  {
    "docString": "Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is\\ntotally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L â†’ T2Space (L â‰ƒâ‚[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic extension, then the Krull topology on `L â‰ƒâ‚[K] L` is Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E], UniformSpace.toTopologicalSpace â‰¤ WeakDual.instTopologicalSpace\",\n  \"isProp\": true,\n  \"docString\":\n  \"The weak-star topology is coarser than the dual-norm topology. \"}]\n",
    "prompt_cons": "/-- If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is\ntotally disconnected. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ IsTotallyDisconnected Set.univ :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If `L/K` is an algebraic extension, then the Krull topology on `L â‰ƒâ‚[K] L` is Hausdorff. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ T2Space (L â‰ƒâ‚[K] L) :=\n\n/-- The weak-star topology is coarser than the dual-norm topology. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], UniformSpace.toTopologicalSpace â‰¤ WeakDual.instTopologicalSpace :=\n\n/-- Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable. -/\ntheorem",
    "choices": [
      "NotComparableLowerLimitAndKTopology : NotComparable Order.topologicalSpace ",
      "lower_limit_not_comparable_k_topology : Â¬(TopologicalSpace.coarserThan (lowerLimitTopology â„) (kTopology â„) âˆ¨ TopologicalSpace.coarserThan (kTopology â„) (lowerLimitTopology â„)) ",
      "âˆ€ {R : Type u_1} [inst : LinearOrderedField R] [inst_1 : TopologicalSpace R] [inst_2 : LowerLimitTopology R]\n  [inst_3 : KTopology R], Â¬(TopologicalSpace.toUniformSpace â‰¤ LowerLimitTopology.toUniformSpace)\n  âˆ§ Â¬(LowerLimitTopology.toUniformSpace â‰¤ TopologicalSpace.toUniformSpace) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerLimitTopology Î±]\n  [inst_3 : KTopology Î±], Â¬(UniformSpace.toTopologicalSpace â‰¤ LowerLimitTopology.toTopologicalSpace) âˆ§\n  Â¬(LowerLimitTopology.toTopologicalSpace â‰¤ KTopology.toTopologicalSpace) ",
      "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerLimitTopology Î±] [inst_3 : KTopology Î±],\n  Not (LowerLimitTopology.toTopologicalSpace â‰¤ KTopology.toTopologicalSpace) âˆ§\n  Not (KTopology.toTopologicalSpace â‰¤ LowerLimitTopology.toTopologicalSpace) ",
      "âˆ€ {R : Type u_1} [inst : LinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : LowerLimitTopology R] [inst_3 : KTopology R],\n  Â¬(LowerLimitTopology.toTopologicalSpace â‰¤ KTopology.toTopologicalSpace) âˆ§\n  Â¬(KTopology.toTopologicalSpace â‰¤ LowerLimitTopology.toTopologicalSpace) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  Not (TopologicalSpace.lowerLimitTopology Î± â‰¤ TopologicalSpace.KTopology Î±) âˆ§\n  Not (TopologicalSpace.KTopology Î± â‰¤ TopologicalSpace.lowerLimitTopology Î±) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], Â¬(LowerLimitTopologicalSpace â‰¤ KTopologicalSpace) âˆ§ Â¬(KTopologicalSpace â‰¤ LowerLimitTopologicalSpace) ",
      "forall {R : Type u_1} [inst : LinearOrderedField R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R] [inst_3 : KTopology R],\n  Â¬((LowerLimitTopologicalSpace R).toUniformSpace.toTopologicalSpace â‰¤ (KTopologyTopologicalSpace R).toUniformSpace.toTopologicalSpace) âˆ§\n  Â¬((KTopologyTopologicalSpace R).toUniformSpace.toTopologicalSpace â‰¤ (LowerLimitTopologicalSpace R).toUniformSpace.toTopologicalSpace) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerLimitTopology Î±]\n  [inst_3 : KTopology Î±], noncomparable_topologies "
    ]
  },
  {
    "docString": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"}]\n",
    "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼)) :=\n\n/-- Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ â„} {f : Î± â†’ â„} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), ennreal.of_real (bound a) âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), ennreal.of_real (F n a) âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), ennreal.of_real (f a) âˆ‚Î¼)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {S : Set Î±} [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_3 : OrderTopology Î±] (ab_set : Set (Î± Ã— Î±)),\n  (âˆ€ (ab : Î± Ã— Î±), ab âˆˆ ab_set â†” (ab.fst < ab.snd âˆ§ Set.Range Rat.of_int âŠ† insert ab.fst (insert ab.snd Set.Univ))) â†’\n    TopologicalSpace.IsTopologicalBasis (SetOf fun I => âˆƒ ab âˆˆ ab_set, I = Set.Ioo ab.fst ab.snd) â†’\n      Not (TopologicalSpace.IsTopologicalBasis (SetOf fun I => âˆƒ a âˆˆ insert âŠ¥ Set.Univ, I = Set.Ici a)) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  Â¬TopologicalSpace.IsTopologicalBasis (SetOf fun s => âˆƒ a b : â„š, a < b âˆ§ Ioo (a : Î±) (b : Î±) = s) ",
      "âˆ€ {Î± : Type*} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {Î¹ : Type*} [inst_3 : Nonempty Î¹]\n  (l : Î¹ â†’ Î±) {a b : Î±} (hab : a < b) (ha : âˆƒ q : â„š, a < q âˆ§ (q : Î±) â‰¤ b) (hb : âˆƒ q : â„š, a â‰¤ (q : Î±) âˆ§ q < b),\n  âˆƒ u v : Set Î±, HasMem.Mem u (OrderTopology.BasisSet.IntervalBasis l) âˆ§ HasMem.Mem v (OrderTopology.BasisSet.IntervalBasis l) âˆ§\n    a âˆˆ u âˆ§ b âˆˆ v âˆ§ u âˆ© v = âˆ… ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] {Î¹ : Type u_2} {l : Filter Î¹} [inst_1 : Nonempty Î¹]\n  [inst_2 : Filter.IsCountablyGenerated l] {B : Î¹ â†’ Set Î±} {a : Î±}, (forall n : Î¹, IsOpen (B n)) â†’\n    Directed Superset B â†’ (âˆ€ (s : Set Î±), IsOpen s â†’ a âˆˆ s â†’ âˆƒ (i : Î¹), B i âŠ† s) â†’\n      (âˆƒ (s : Set Î±), IsOpen s âˆ§ Â¬(âˆƒ (i : Î¹), B i âŠ† s)) ",
      "âˆ€ {Î± : Type} (_inst_1 : TopologicalSpace Î±) {s : Set Î±},\n  (âˆƒ (y : Î±), y âˆˆ s) â†’\n    (âˆƒ (a b : â„š), a < b âˆ§ âˆ€ (x : Î±), x âˆˆ s â†” a < x âˆ§ x < b) â†’\n      TopologicalSpace.IsTopologicalBasis (SetOf (Î» (t : Set Î±), âˆƒ (a b : â„š), a < b âˆ§ âˆ€ (x : Î±), x âˆˆ t â†” a < x âˆ§ x < b)) â†’\n        TopologicalSpace.GeneratesTopology (TopologicalSpace.coarserThan _) (nhdsWithin s (Set.Iio _)) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  âˆƒ V : Set (Set Î±),\n    TopologicalSpace.IsTopologicalBasis V âˆ§\n      âˆ€ a b : Î±, a < b â†’ âˆƒ u âˆˆ V, a âˆˆ u âˆ§ âˆ€ (v : Set Î±), a âˆˆ v â†’ v âˆˆ V â†’ v âŠ† u â†’ b âˆˆ v â†’ u = v ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : NoMinOrder Î±] [inst_3 : NoMaxOrder Î±],\n  (TopologicalSpace.IsTopologicalBasis {s : Set Î± | âˆƒ (a b : â„š), a < b âˆ§ s = Set.Ioo a b}) â†’\n    (âˆƒ (a b : â„š), a < b âˆ§ âˆ€ (l : Î±), Filter.NeBot (ğ“[Set.Ico l (b : Î±)] l)) â†’\n      Â¬TopologicalSpace.IsTopologicalBasis {s : Set Î± | âˆƒ (l : Î±), s = Set.Ico l (Inf {b : Î± | b > l})} ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenseOrder Î±],\n  Set.Union (SetOf fun ab => ab.1 < ab.2 âˆ§ (âˆ€ x, ab.1 < x âˆ§ x < ab.2 â†’ x âˆˆ Set.Ioo ab.1 ab.2) âˆ§\n                                (âˆ€ x, x < ab.1 âˆ¨ ab.2 < x â†’ x âˆ‰ Set.Ioo ab.1 ab.2)) â‰  TopologicalSpace.generateFrom (SetOf Set.Ioi) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  let B "
    ]
  },
  {
    "docString": "A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\\nhomotopic to `ContinuousMap.pi fâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\nhomotopic to `ContinuousMap.pi fâ‚`. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚) :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f :=\n\n/-- A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps. -/\ntheorem",
    "choices": [
      "open_map_prod_fst {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] : IsOpenMap (Prod.fst : X Ã— Y â†’ X) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap (Prod.fst : X Ã— Y â†’ X) âˆ§ IsOpenMap (Prod.snd : X Ã— Y â†’ Y) ",
      "forall {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap (Prod.fst : X Ã— Y â†’ X) âˆ§ IsOpenMap (Prod.snd : X Ã— Y â†’ Y) ",
      "prod_fst_open_map {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] : IsOpenMap (Prod.fst : X Ã— Y â†’ X) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap (Prod.fst : Î± Ã— Î² â†’ Î±) âˆ§ IsOpenMap (Prod.snd : Î± Ã— Î² â†’ Î²) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap (Prod.fst : X Ã— Y â†’ X) âˆ§ IsOpenMap (Prod.snd : X Ã— Y â†’ Y) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap (Prod.fst : X Ã— Y â†’ X) âˆ§ IsOpenMap (Prod.snd : X Ã— Y â†’ Y) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap (Prod.fst : X Ã— Y â†’ X) âˆ§ IsOpenMap (Prod.snd : X Ã— Y â†’ Y) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap (Prod.fst : X Ã— Y â†’ X) âˆ§ IsOpenMap (Prod.snd : X Ã— Y â†’ Y) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap (@Prod.fst Î± Î²) âˆ§ IsOpenMap (@Prod.snd Î± Î²) "
    ]
  },
  {
    "docString": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"}]\n",
    "prompt_cons": "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’\n    (IsOpen (U - A) âˆ§ IsClosed (A - U)) ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] {U A : Set X},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ (IsOpen (U - A) âˆ§ IsClosed (A - U)) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A U : Set Î±},\n  IsOpen U â†’ IsClosed A â†’\n    IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) "
    ]
  },
  {
    "docString": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"}]\n",
    "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : TopologicalSpace Î²]\n  [inst_3 : OrderTopology Î²] {f g h : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ (âˆ€ x, h x = min (f x) (g x)) â†’ Continuous h ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» (x : Î²), min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [t : OrderTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î²]\n  [t : OrderTopology Î²] {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [t : OrderTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [t : OrderTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î²] [t : OrderTopology Î²]\n  [inst_2 : TopologicalSpace Î±] {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_2 : TopologicalSpace Y] [inst_3 : LinearOrder Y] [t : OrderTopology Y]\n  {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î²]\n  [t : OrderTopology Î²] {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  ContinuousOn f s â†’ ContinuousOn g s â†’ ContinuousOn (Î» x, min (f x) (g x)) s "
    ]
  },
  {
    "docString": "Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"}]\n",
    "prompt_cons": "/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {X : Î± â†’ Type u_3} [inst : (a : Î±) â†’ TopologicalSpace (X a)] {x : Î  a, X a} {x_seq : Î¹ â†’ Î  a, X a} {p : Filter Î¹},\n  Filter.Tendsto x_seq p (nhds x) â†” âˆ€ a, Filter.Tendsto (fun i => x_seq i a) p (nhds (x a)) ",
      "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {x : â„• â†’ (a : Î±) â†’ Î² a} {limit : (a : Î±) â†’ Î² a},\n  Filter.Tendsto x Filter.atTop (nhds limit) â†” âˆ€ a, Filter.Tendsto (fun n => x n a) Filter.atTop (nhds (limit a)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} [inst : (i : Î±) â†’ TopologicalSpace (Î² i)] {x : Î¹ â†’ Î± â†’ Î²} {y : Î± â†’ Î²},\n  Filter.Tendsto x Filter.atTop (nhds y) â†” âˆ€ i, Filter.Tendsto (fun n => x n i) Filter.atTop (nhds (y i)) ",
      "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] {x : â„• â†’ ((a : Î±) â†’ Î² a)} {y : (a : Î±) â†’ Î² a},\n  Filter.Tendsto x Filter.atTop (nhds y) â†” âˆ€ a : Î±, Filter.Tendsto (fun n => x n a) Filter.atTop (nhds (y a)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {X : Î± â†’ Type u_3} [inst_1 : (i : Î±) â†’ TopologicalSpace (X i)]\n  {x : â„• â†’ (i : Î±) â†’ X i} {f : (i : Î±) â†’ X i},\n  Filter.Tendsto x Filter.atTop (nhds f) â†” âˆ€ i, Filter.Tendsto (fun n => x n i) Filter.atTop (nhds (f i)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Î± â†’ Type u_3} [_i : (a : Î±) â†’ TopologicalSpace (Î² a)] {g : â„• â†’ (a : Î±) â†’ Î² a} {f : (a : Î±) â†’ Î² a},\n  Filter.Tendsto g Filter.atTop (nhds f) â†” âˆ€ a, Filter.Tendsto (fun n => g n a) Filter.atTop (nhds (f a)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] {X : Î¹ â†’ (a : Î±) â†’ Î² a} {x : (a : Î±) â†’ Î² a},\n  Filter.Tendsto X Filter.atTop (nhds x) â†” âˆ€ a : Î±, Filter.Tendsto (fun i => X i a) Filter.atTop (nhds (x a)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Î± â†’ Type u_3} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] {A : â„• â†’ (a : Î±) â†’ Î² a} {x : (a : Î±) â†’ Î² a},\n  Filter.Tendsto A Filter.atTop (nhds x) â†” âˆ€ a : Î±, Filter.Tendsto (Î» n, A n a) Filter.atTop (nhds (x a)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Î± â†’ Type u_2} [_inst_1 : (a : Î±) â†’ TopologicalSpace (Î² a)] {f : â„• â†’ ((a : Î±) â†’ Î² a)} {x : ((a : Î±) â†’ Î² a)},\n  Filter.Tendsto f Filter.atTop (nhds x) â†”\n  âˆ€ a : Î±, Filter.Tendsto (fun n => f n a) Filter.atTop (nhds (x a)) ",
      "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] {x : (a : Î±) â†’ Î² a} {F : â„• â†’ (a : Î±) â†’ Î² a},\n  Filter.Tendsto F Filter.atTop (nhds x) â†” âˆ€ a : Î±, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (x a)) "
    ]
  },
  {
    "docString": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"}]\n",
    "prompt_cons": "/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n] :=\n\n/-- Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$. -/\ntheorem",
    "choices": [
      "âˆ€ (x : â„) (hx : 0 â‰¤ x âˆ§ x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedRing Î±] [inst_2 : OrderTopology Î±] (s : â„• â†’ Î± â†’ â„)\n  (hs : âˆ€ n x, 0 â‰¤ x âˆ§ x â‰¤ 1 â†’ 0 â‰¤ s n x âˆ§ s n x â‰¤ x^n),\n  âˆ€ (x : Î±), 0 â‰¤ x âˆ§ x â‰¤ 1 â†’ Filter.Tendsto (fun n => s n x) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  (âˆ€ x : Î±, 0 â‰¤ x âˆ§ x â‰¤ 1) â†’ âˆ€ (x : Î±), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  (x : Î±), x âˆˆ Set.Icc (0 : Î±) 1 â†’ âˆ€ (n : â„•), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : Archimedean Î±] {x : Î±}, Zero.zero â‰¤ x â†’ x â‰¤ One.one â†’\n    Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds Zero.zero) ",
      "âˆ€ (x : â„) (hx : 0 â‰¤ x âˆ§ x â‰¤ 1),\n  Filter.Tendsto (fun n => x^n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] [inst_2 : TopologicalSpace Î±]\n  [OrderTopology Î±] (x : Î±), x âˆˆ Set.Icc (0 : Î±) (1 : Î±) â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (0 : Î±)) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] (x : Î±),\n  0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (n : â„•) (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (ite (x < 1) 0 1)) ",
      "âˆ€ {x : â„} (hx : x âˆˆ Icc (0 : â„) 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) "
    ]
  },
  {
    "docString": "Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  ContinuousAt f x â†’\\n    Filter.Tendsto g p (nhds x) â†’\\n      (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gâ‚™` tends to `x`, then `Fâ‚™ (gâ‚™)` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [inst_2 : CompactSpace Î±],\\n  Filter.Tendsto F p (nhds f) â†” TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence in the compact-open topology is the same as uniform convergence for sequences of\\ncontinuous functions on a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If `Fâ‚™` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gâ‚™` tends to `x`, then `Fâ‚™ (gâ‚™)` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  ContinuousAt f x â†’\n    Filter.Tendsto g p (nhds x) â†’\n      (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [inst_2 : CompactSpace Î±],\n  Filter.Tendsto F p (nhds f) â†” TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    (âˆ€ (Îµ : â„), 0 < Îµ â†’ âˆƒ (N : Î¹), âˆ€ (i : Î¹), N â‰¤ i â†’ âˆ€ (y : Î±), dist (F i y) (f y) < Îµ) â†’\n      Filter.Tendsto (fun n => â†‘(F n) (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {x : Î±} {p : Filter Î¹} {f : Î± â†’ Î²}\n  {F : Î¹ â†’ (Î± â†’ Î²)} (h : Continuous f) (hâ‚ : Filter.TendstoUniformly F f p) (g : Î¹ â†’ Î±) (hâ‚‚ : Filter.Tendsto g p (nhds x)),\n  Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : C(Î±, Î²)} {p : Filter Î¹}\n  {x : Î±} {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’\n      Filter.Tendsto (fun n => â†‘(F n) (g n)) p (nhds (â†‘f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : C(Î±, Î²)} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly F (â†‘f) p â†’\n      Filter.Tendsto (fun n => â†‘(F n) (g n)) p (nhds (â†‘f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  Continuous f â†’\n    Filter.Tendsto g p (nhds x) â†’\n      TendstoUniformly F f p â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : C(Î±, Î²)} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly F f p â†’\n      Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²]\n  {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  Continuous f â†’\n    Filter.Tendsto g p (nhds x) â†’\n      TendstoUniformly F f p â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : Î± â†’ Î²}\n  {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly (fun i a => â†‘(F i) a) (f) p â†’\n      Filter.Tendsto (fun n => â†‘(F n) (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : C(Î±, Î²)}\n  {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly F f p â†’\n      Filter.Tendsto (fun n => â†‘(F n) (g n)) p (nhds (â†‘f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ C(Î±, Î²)} {f : C(Î±, Î²)}\n  {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly F (â†‘f) p â†’\n      Filter.Tendsto (fun n => â†‘(F n) (g n)) p (nhds (â†‘f x)) "
    ]
  },
  {
    "docString": "If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\":\n  \"âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\\n  {s : Set ((n : â„•) â†’ E n)},\\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a retraction onto this\\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r :=\n\n/-- Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. -/\ntheorem âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\n  {s : Set ((n : â„•) â†’ E n)},\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ Continuous f :=\n\n/-- If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsClosed A â†’ Continuous f â†’ (âˆ€ a âˆˆ A, f a = a) â†’ Set.range f = A â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsSubSet A â†’ Continuous f â†’ (âˆ€ a âˆˆ A, f a = a) â†’ Set.range f = A â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsRetraction f A â†’ Continuous f â†’ Set.range f = A â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  (âˆ€ (a : Î±), a âˆˆ A â†’ r a = a) â†’ Set.range r = A â†’ Continuous r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  IsRetraction A r â†’ Continuous r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ f x = x) â†’ Set.range f = s â†’ Continuous f â†’ QuotientMap f ",
      "forall {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ Set.range f = Î² â†’ (âˆ€ (x : Î±), f x = x) â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsSubset A Set.Univ â†’ (âˆ€ a, a âˆˆ A â†’ f a = a) â†’ Continuous f â†’ Set.range f = A â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  Set.range r = A â†’ (âˆ€ a âˆˆ A, r a = a) â†’ Continuous r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ (âˆ€ x : Î±, f x âˆˆ s â†’ f x = x) â†’ Set.range f = s â†’ QuotientMap f "
    ]
  },
  {
    "docString": "Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"}]\n",
    "prompt_cons": "/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_1 : Preorder Î¹] (A : Î¹ â†’ Set Î±),\n  (âˆ€ n : Î¹, IsConnected (A n)) â†’ (âˆ€ n : Î¹, Set.Nonempty (A n âˆ© A (n+1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [lt : LinearOrder Î¹] [succ : SuccOrder Î¹] {A : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), IsConnected (A i)) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (A i âˆ© A (SuccOrder.succ i))) â†’ IsConnected (â‹ƒ (i : Î¹), A i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_1 : Preorder Î¹] (A : Î¹ â†’ Set Î±),\n  (âˆ€ (n : Î¹), IsConnected (A n)) â†’\n    (âˆ€ (n : Î¹), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_1 : Preorder Î¹] (A : Î¹ â†’ Set Î±),\n  (âˆ€ (i : Î¹), IsConnected (A i)) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (A i âˆ© A (i + 1))) â†’ IsConnected (â‹ƒ (i : Î¹), A i) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_2 : Preorder Î¹] {A : Î¹ â†’ Set Î±},\n  (âˆ€ (n : Î¹), IsConnected (A n)) â†’\n    (âˆ€ (n : Î¹), Set.Nonempty (A n âˆ© A (n+1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_1 : Preorder Î¹] (A : Î¹ â†’ Set Î±),\n  (âˆ€ (n : Î¹), IsConnected (A n)) â†’\n    (âˆ€ (n : Î¹), Set.Nonempty (A n âˆ© A (n+1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : â„•} (A : Î¹ â†’ Set Î±),\n   (âˆ€ (n : Î¹), IsConnected (A n)) â†’\n     (âˆ€ (n : Î¹), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_2 : Preorder Î¹] (A : Î¹ â†’ Set Î±),\n  (âˆ€ (n : Î¹), IsConnected (A n)) â†’ (âˆ€ (n : Î¹), Set.Nonempty (A n âˆ© A (n+1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) "
    ]
  },
  {
    "docString": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite type with cofinite topology is an irreducible topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that definability is closed under finite projections. \"}]\n",
    "prompt_cons": "/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- An infinite type with cofinite topology is an irreducible topological space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Shows that definability is closed under finite projections. -/\ntheorem âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s) :=\n\n/-- Show that if $X$ is an infinite set, it is connected in the finite complement topology. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IsConnected (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IsConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) "
    ]
  },
  {
    "docString": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"}]\n",
    "prompt_cons": "/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst_Î± : TopologicalSpace Î±] [inst_Î² : TopologicalSpace Î²] {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X.prod Y) \\ (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst_Î± : TopologicalSpace Î±] [inst_Î² : TopologicalSpace Î²] {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  X âŠ† A â†’ A â‰  X â†’ Y âŠ† B â†’ B â‰  Y â†’ IsConnected X â†’ IsConnected Y â†’ IsConnected ((X.product Y) - (A.product B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [instâ‚ : TopologicalSpace Î±] [instâ‚‚ : TopologicalSpace Î²]\n  {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²}, IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’\n  IsConnected ((X.prod Y) \\ (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [instÎ± : TopologicalSpace Î±] [instÎ² : TopologicalSpace Î²]\n  {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X.prod Y) - (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [instÎ± : TopologicalSpace Î±] [instÎ² : TopologicalSpace Î²]\n  (X : Set Î±) (Y : Set Î²) (A : Set Î±) (B : Set Î²),\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ \n  IsConnected ((X Ã— Y) - (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  {A : Set Î±} {B : Set Î²} {X : Set Î±} {Y : Set Î²},\n  A âŠ† X â†’ B âŠ† Y â†’ A â‰  X â†’ B â‰  Y â†’\n  IsConnected X â†’ IsConnected Y â†’\n  IsConnected ((X Ã— Y) - (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [instÎ± : TopologicalSpace Î±] [instÎ² : TopologicalSpace Î²]\n  (X : Set Î±) (Y : Set Î²) (A : Set Î±) (B : Set Î²),\n  A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected X â†’ IsConnected Y â†’ IsConnected ((X Ã— Y) - (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst1 : TopologicalSpace Î±] [inst2 : TopologicalSpace Î²]\n  {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²}, IsProperSubset A X â†’ IsProperSubset B Y\n  â†’ IsConnected X â†’ IsConnected Y â†’ IsConnected ((X.prod Y) - (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst1 : TopologicalSpace Î±] [inst2 : TopologicalSpace Î²]\n  {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’\n  IsConnected ((X.prod Y) - (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [instÎ± : TopologicalSpace Î±] [instÎ² : TopologicalSpace Î²]\n  {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  IsProperSubset A X â†’ IsProperSubset B Y â†’ IsConnected X â†’ IsConnected Y â†’\n  IsConnected ((X Ã— Y) - (A Ã— B)) "
    ]
  },
  {
    "docString": "Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x\",\n  \"isProp\": true,\n  \"docString\": \"The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"}]\n",
    "prompt_cons": "/-- If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. -/\ntheorem âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {f : Î± â†’ â„} {S : Set Î±} [inst : TopologicalSpace Î±] [H : IsPreconnected S],\n  ContinuousOn f S â†’ S âŠ† Circle â†’ âˆƒ x, âˆƒ H, f x = f (-x) ",
      "âˆ€ {Î± : Type u_1} {f : Î± â†’ â„} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace â„] [inst_2 : T1Space â„] [inst_3 : NoZeroDivisors â„],\n  ContinuousOn f S â†’ IsAntipodalOn S â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ {ğ•œ : Type u_2} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ] {f : Circle â†’ ğ•œ},\n  Continuous f â†’ âˆƒ x : Circle, f x = f (-x) ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Circle Î±] {ğ•œ : Type u_2} [inst_2 : TopologicalSpace ğ•œ] {f : Î± â†’ ğ•œ},\n  Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S ",
      "âˆ€ {f : Circle â†’ â„} [inst : TopologicalSpace Circle] [inst_1 : TopologicalSpace â„],\n  Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : AddGroup Î±] [inst_3 : AddGroup Î²] [self : AddAntilipschitzWith Î± Î²] (f : Î± â†’+ Î²),\n  Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ {f : Circle â†’ â„} [inst : TopologicalSpace Circle] [inst_1 : TopologicalSpace â„],\n  Continuous f â†’ âˆƒ x : Circle, f x = f (-x) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [BorderedHeawood : CompactSpace Î±] [Mycielski : T2Space Î±] [Trivial : T2Space Î²] (f : Î± â†’ Î²), Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ {f : Circle â†’ â„}, Continuous f â†’ âˆƒ x, f x = f (-x) "
    ]
  },
  {
    "docString": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"}]\n",
    "prompt_cons": "/-- A nonempty convex set is path connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î± :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [i : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "forall {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] (U : Set X),\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {s : Set X},\n  IsOpen s â†’ IsConnected s â†’ IsPathConnected s ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [i : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] (U : Set X),\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U "
    ]
  },
  {
    "docString": "Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"}]\n",
    "prompt_cons": "/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±],\n  âˆ€ (A : Set (Set Î±)), (âˆ€ (a : Set Î±), a âˆˆ A â†’ IsClosed a âˆ§ IsConnected a) â†’\n  Zorn.Chain HasSubset.Subset A â†’ IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±],\n  âˆ€ {ğ’œ : Set (Set Î±)}, (âˆ€ A âˆˆ ğ’œ, IsClosed A âˆ§ IsConnected A) â†’\n  Zorn.Chain HasSubset.Subset ğ’œ â†’\n  IsConnected (â‹‚â‚€ ğ’œ) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±] \n  {A : Set (Set Î±)}, (âˆ€ (a : Set Î±), a âˆˆ A â†’ IsConnected a âˆ§ IsClosed a) â†’ \n  SimpleOrder A â†’ IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±],\n  âˆ€ (A : Set (Set Î±)), (âˆ€ a âˆˆ A, IsClosed a âˆ§ IsConnected a) â†’ Zorn.Chain HasSubset.Subset A â†’\n    IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±],\n  âˆ€ (A : Set (Set Î±)), (âˆ€ (a : Set Î±), a âˆˆ A â†’ (IsClosed a âˆ§ IsConnected a)) â†’\n  Zorn.Chain HasSubset.Subset A â†’ âˆƒ (Y : Set Î±), Y = â‹‚â‚€ A âˆ§ IsConnected Y ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±],\n  âˆ€ (A : Set (Set Î±)), âˆ€ (Y : Set Î±),\n  (âˆ€ (s : Set Î±), s âˆˆ A â†’ IsClosed s âˆ§ IsConnected s) â†’\n  Zorn.Chain (âŠ†) A â†’ (âˆ€ (s : Set Î±), s âˆˆ A â†’ Y âŠ† s) â†’\n  IsConnected Y ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±]\n  {A : Set (Set Î±)}, (âˆ€ a âˆˆ A, IsClosed a âˆ§ IsConnected a) â†’ DirectedOn (âŠ‚) A â†’ IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±],\n  âˆ€ (A : Set (Set Î±)), (âˆ€ (a : Set Î±), a âˆˆ A â†’ IsClosed a âˆ§ IsConnected a) â†’\n  (âˆ€ (aâ‚ aâ‚‚ : Set Î±), aâ‚ âˆˆ A â†’ aâ‚‚ âˆˆ A â†’ aâ‚ âŠ† aâ‚‚ âˆ¨ aâ‚‚ âŠ† aâ‚) â†’\n  IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : T2Space Î±], \n  âˆ€ (A : Set (Set Î±)), (âˆ€ a âˆˆ A, IsClosed a âˆ§ IsConnected a) â†’ (âˆ€ a b âˆˆ A, a âŠ† b âˆ¨ b âŠ† a) â†’ \n  IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X] {A : Set (Set X)}, \n  (âˆ€ a âˆˆ A, IsClosed a âˆ§ IsConnected a) â†’ \n  Zorn.Chain (âŠ†) A â†’ \n  IsConnected (â‹‚â‚€ A) "
    ]
  },
  {
    "docString": "Show that a connected metric space having more than one point is uncountable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\\n  IsOpenMap Quotient.mk' â†’ TopologicalSpace.SecondCountableTopology (Quotient S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open quotient of a second countable space is second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"}]\n",
    "prompt_cons": "/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- An open quotient of a second countable space is second countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\n  IsOpenMap Quotient.mk' â†’ TopologicalSpace.SecondCountableTopology (Quotient S) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- Show that a connected metric space having more than one point is uncountable. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace.ConnectedSpace X],\n  Nonempty (X Ã— X) â†’ Set.Nonempty X â†’ Â¬Set.Countable X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace X] [inst_2 : TopologicalSpace.ConnectedSpace X],\n  Set.Nonempty X â†’ Set.Nonempty (SetOf fun x => x â‰  X) â†’ Set.Noncountable X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.ConnectedSpace X],\n  Nonempty (X Ã— X â†’â‚€ X) â†’ Set.Uncountable X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.ConnectedSpace X],\n  2 â‰¤ cardinal.mk X â†’ Â¬ Set.Countable X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.ConnectedSpace X] [inst_2 : Nonempty X] [inst_3 : Nontrivial X],\n  Set.Uncountable (Set.Univ : Set X) ",
      "forall {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace.ConnectedSpace X],\n  (Exists (xâ‚€ : X), Exists (xâ‚ : X), xâ‚€ â‰  xâ‚) â†’ Â¬Set.Countable (Set.Univ : Set X) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [TopologicalSpace.SecondCountableTopology X]\n  [TopologicalSpace.ConnectedSpace X] [Nonempty X] [Nontrivial X],\n  Set.Uncountable (Set.Univ : Set X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace.ConnectedSpace X],\n  Set.Nonempty (SetOf fun x => Â¬(x = Classical.choice inst_2.nonempty)) â†’\n  Â¬Set.Countable (SetOf fun x => Â¬(x = Classical.choice inst_2.nonempty)) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace.ConnectedSpace X],\n  Nonempty X â†’ Set.Countable X â†’ False ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.ConnectedSpace X],\n  2 â‰¤ Cardinal.mk X â†’ Â¬Set.Countable X "
    ]
  },
  {
    "docString": "Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  IsSeqCompact s â†’ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  IsSeqCompact s â†’ IsCompact s :=\n\n/-- Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n      Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n        (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n          (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  TopologicalSpace.IsCountablyCompact X â†”\n    âˆ€ (Z : â„• â†’ Set X),\n      (âˆ€ n : â„•, Set.Nonempty (Z n)) â†’\n        (âˆ€ n : â„•, IsClosed (Z n)) â†’\n          (âˆ€ n m : â„•, m â‰¥ n â†’ Z m âŠ† Z n) â†’ Set.Nonempty (â‹‚ (n : â„•), Z n) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±),\n      (âˆ€ (n : â„•), IsClosed (C n)) â†’\n        (âˆ€ (n : â„•), Set.Nonempty (C n)) â†’\n          (âˆ€ (n : â„•), C n âŠ‡ C (n + 1)) â†’ Set.Nonempty (â‹‚ (n : â„•), C n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (Z i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’\n          (âˆ€ (i : â„•), Z (i+1) âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X â†”\n    âˆ€ {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (C : Î¹ â†’ Set X),\n      (âˆ€ (i : Î¹), IsClosed (C i)) â†’\n        (âˆ€ (i : Î¹), Set.Nonempty (C i)) â†’\n          Directed (fun x x_1 => x âŠ‡ x_1) C â†’ Set.Nonempty (â‹‚ (i : Î¹), C i) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X â†”\n    âˆ€ (C : â„• â†’ Set X),\n      (âˆ€ (n : â„•), IsClosed (C n)) â†’\n        (âˆ€ (n : â„•), Set.Nonempty (C n)) â†’ (âˆ€ (n : â„•), C n âŠ‡ C (n + 1)) â†’ Set.Nonempty (â‹‚ (n : â„•), C n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (C : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) C â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (C i)) â†’\n      (âˆ€ (i : Î¹), IsClosed (C i)) â†’ (IsCountablyCompact Î± â†” Set.Nonempty (â‹‚ (i : Î¹), C i)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (F : â„• â†’ Set Î±),\n      (âˆ€ (n : â„•), IsClosed (F n)) â†’\n        (âˆ€ (n : â„•), Set.Nonempty (F n)) â†’\n          (âˆ€ (n : â„•), F (n + 1) âŠ† F n) â†’ Set.Nonempty (â‹‚ (n : â„•), F n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’\n        (âˆ€ (i : â„•), IsClosed (Z i)) â†’\n          (âˆ€ (i j : â„•), i â‰¤ j â†’ Z j âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], \n  IsCountablyCompact Î± â†” \n    (âˆ€ (Z : â„• â†’ Set Î±), \n      (âˆ€ (i : â„•), IsClosed (Z i)) â†’ \n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ \n          (âˆ€ (i j : â„•), i â‰¤ j â†’ Z j âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i)) "
    ]
  },
  {
    "docString": "Show that the rationals $\\mathbb{Q}$ are not locally compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"}]\n",
    "prompt_cons": "/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ :=\n\n/-- Show that the rationals $\\mathbb{Q}$ are not locally compact. -/\ntheorem",
    "choices": [
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace Q ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„ ",
      "Â¬LocallyCompactSpace Q ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š "
    ]
  },
  {
    "docString": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. \"}]\n",
    "prompt_cons": "/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U :=\n\n/-- Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) (U : Set Î±),\n  LocallyCompactSpace Î± â†’ U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (Closure V) âˆ§ Closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ LocallyCompactSpace Î± â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (Closure V) âˆ§ Closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (Closure V) âˆ§ Closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (Closure V) âˆ§ Closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U "
    ]
  },
  {
    "docString": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- There exists a countable dense set. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Pairwise (Disjoint on S) â†’ Set.Countable S ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ pairwise (Disjoint on S) â†’ Set.Countable S ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ (âˆ€ (s t : Set Î±), s âˆˆ S â†’ t âˆˆ S â†’ s â‰  t â†’ Disjoint s t) â†’ Set.Countable S ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Pairwise (Disjoint on S) â†’ Set.Countable S ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’\n    (âˆ€ (s t : Set Î±), s âˆˆ S â†’ t âˆˆ S â†’ s â‰  t â†’ s âˆ© t = âˆ…) â†’ Set.Countable S ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ PairwiseDisjoint S â†’ Set.Countable S ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Pairwise (Disjoint on S) â†’ Set.Countable S ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ PairwiseDisjoint S â†’ Set.Countable S ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Pairwise (Disjoint on S) â†’ Set.Countable S ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Pairwise (Disjoint on S) â†’ Set.Countable S "
    ]
  },
  {
    "docString": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"}]\n",
    "prompt_cons": "/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedClosuresNhds s t ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) "
    ]
  },
  {
    "docString": "Show that a closed subspace of a normal space is normal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- Show that a closed subspace of a normal space is normal. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace {x // x âˆˆ s} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ Subspace.Normal s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace {x // x âˆˆ s} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace {x // x âˆˆ s} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace (Subtype (Î» (x : Î±), x âˆˆ s)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace (Subspace Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Subspace Î±),\n  IsClosed â†‘s â†’ NormalSpace â†‘s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Submodule Î±),\n  IsClosed â†‘s â†’ NormalSpace â†‘s "
    ]
  },
  {
    "docString": "Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"}]\n",
    "prompt_cons": "/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b :=\n\n/-- Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem",
    "choices": [
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [t : (i : Î¹) â†’ TopologicalSpace (Î± i)]\n  [T : TopologicalSpace (Î  (i : Î¹), Î± i)] [reg : T2Space (Î  (i : Î¹), Î± i)] (h : âˆ€ i, Nonempty (Î± i)),\n  (âˆ€ (i : Î¹), IsCompact (Set.Range (Î» (x : Î± i), Function.update (Î» (i : Î¹), Classical.choice (h i)) i x))) â†’\n  (âˆ€ (i : Î¹), IsRegular (t i)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] [inst_3 : T2Space Î²]\n  [inst_4 : âˆ€ (a : Î±), Nonempty Î²] [inst_5 : âˆ€ (b : Î²), Nonempty Î±], RegularSpace (Î± Ã— Î²) â†’ RegularSpace Î± âˆ§ RegularSpace Î² ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u} [_inst : âˆ€ (i : Î¹), TopologicalSpace (Î± i)] [_inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)]\n  [inst : T2Space (Î  (i : Î¹), Î± i)] (hreg : RegularSpace (Î  (i : Î¹), Î± i)) (i : Î¹), RegularSpace (Î± i) ",
      "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] [inst_1 : (a : Î±) â†’ T2Space (Î² a)]\n  [inst_2 : âˆ€ a, Nonempty (Î² a)] {Î¹ : Type u_1} [inst_3 : Semigroup Î¹]\n  {Ï€ : (a : Î±) â†’ Î¹ â†’ Î² a} [inst_4 : (a : Î±) â†’ IsInvariant (Ï€ a)],\n  (âˆ€ a, IsRegular (Ï€ a)) â†’ IsRegular (function.uncurry Ï€) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)]\n  [inst_1 : (i : Î¹) â†’ Nonempty (Î± i)] [inst_2 : T2Space (Î  (i : Î¹), Î± i)] [inst_3 : RegularSpace (Î  (i : Î¹), Î± i)],\n  (âˆ€ i, RegularSpace (Î± i)) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : (i : Î¹) â†’ T2Space (Î± i)]\n  [inst_2 : (i : Î¹) â†’ Nonempty (Î± i)] {X : (i : Î¹) â†’ Set (Î± i)},\n  (âˆ€ i, IsCompact (X i)) â†’ IsCompact (set.Pi Set.Univ X) â†’ (âˆ€ i, IsCompact (X i)) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : (i : Î¹) â†’ T2Space (Î± i)]\n  [inst_2 : Î  (i : Î¹), Nonempty (Î± i)] [inst_3 : RegularSpace (Î  (i : Î¹), Î± i)]\n  (i : Î¹), RegularSpace (Î± i) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : (i : Î¹) â†’ Nonempty (Î± i)]\n  [inst_2 : T2Space ((i : Î¹) â†’ Î± i)] [inst_3 : âˆ€ (i : Î¹), T2Space (Î± i)] [inst_4 : RegularSpace ((i : Î¹) â†’ Î± i)], \n  (âˆ€ i, RegularSpace (Î± i)) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [_inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [_inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)]\n  [inst : T2Space ((i : Î¹) â†’ Î± i)] [inst_2 : RegularSpace ((i : Î¹) â†’ Î± i)] (i : Î¹),\n  RegularSpace (Î± i) ",
      "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [_inst : (a : Î±) â†’ TopologicalSpace (Î² a)] [_inst_1 : (a : Î±) â†’ Nonempty (Î² a)]\n  [inst : (a : Î±) â†’ T2Space (Î² a)] {t : TopologicalSpace (Î  (a : Î±), Î² a)} [inst_1 : T2Space (Î  (a : Î±), Î² a)]\n  [inst_2 : âˆ€ (a : Î±), TopologicalSpace (Î  (a : Î±), Î² a)] [inst_3 : âˆ€ (a : Î±), T2Space (Î  (a : Î±), Î² a)],\n  (âˆ€ (a : Î±), IsRegularSpace (Î² a)) â†’ IsRegularSpace (Î  (a : Î±), Î² a) "
    ]
  },
  {
    "docString": "Show that every locally compact Hausdorff space is regular.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\\n  MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. \"}]\n",
    "prompt_cons": "/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\n  MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Show that every locally compact Hausdorff space is regular. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±],\n  RegularSpace Î± ",
      "forall {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  IsRegularSpace Î± ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X "
    ]
  },
  {
    "docString": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"}]\n",
    "prompt_cons": "/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f : X â†’áµ‡ â„,\n  Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X]\n  {A B : Set X}, IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ IsCompact A â†’\n  âˆƒ f : X â†’ â„, Continuous f âˆ§ Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [_inst_1 : T2Space X] [_inst_2 : TotallyDisconnectedSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ (f : X â†’â‚€ â„), Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2_space X] [inst_2 : CompletelyRegularSpace X]\n  {A B : Set X}, IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ f : X â†’áµ‡ â„, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X]\n  {A B : Set X}, IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ f : X â†’â‚›â‚—[RingHom.id â„] â„, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : T2Space X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : RegularSpace X]\n  {A B : Set X}, IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ f : X â†’áµ‡ â„, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ IsCompact A â†’\n  âˆƒ f : X â†’áµ‡ â„, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 "
    ]
  },
  {
    "docString": "Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-ÄŒech compactification of $X$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"}]\n",
    "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-ÄŒech compactification of $X$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : CompletelyRegular X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : T0Space X] [inst_3 : CompletelyRegular X],\n  ConnectedSpace (StoneCech X) â†” ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : PreconnectedSpace X] [inst_3 : CompletelyRegular X],\n  ConnectedSpace (StoneCechCompactification X) â†” ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X] [inst_3 : TotallySeparatedSpace X]\n  [inst_4 : RegularSpace X] [inst_5 : NormalSpace X],\n  ConnectedSpace (StoneCech X) â†” ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace (StoneCech X) â†” ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X] [inst_3 : CompletelyRegularSpace X],\n  ConnectedSpace (StoneCech X) â†” ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCechCompactification X) "
    ]
  },
  {
    "docString": "Prove that $-(-v) = v$ for every $v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (v : E), â†‘(reflection (Submodule.span ğ•œ {v})á—®) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"}]\n",
    "prompt_cons": "/-- The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), â†‘(reflection (Submodule.span ğ•œ {v})á—®) v = -v :=\n\n/-- If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Prove that $-(-v) = v$ for every $v \\in V$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : Ring ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {V : Type u_1} [inst : Ring ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (v : V), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v "
    ]
  },
  {
    "docString": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under subtraction \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"}]\n",
    "prompt_cons": "/-- A non-unital subring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- A non-unital subring is closed under subtraction -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$. -/\ntheorem",
    "choices": [
      "Sorry, I cannot provide an example as I can only translate the givens to Lean Theorem Prover code.",
      "I cannot provide examples or counterexamples as I am a coding assistant who translates natural language to Lean Theorem Prover code. Please ask me to translate a theorem or statement into Lean code.",
      "Sorry, I cannot provide examples or counterexamples as I am a coding assistant designed to translate natural language to Lean Theorem Prover code. Please provide another statement to be translated into Lean code.",
      "Sorry, I cannot create examples using Lean Theorem Prover code. Please provide another example for me to translate.",
      "I am an AI language model, and I cannot provide examples from real life or create theorems that are not related to Lean Theorem Prover code. However, I can help you write the code for the theorem statement that you would like to prove. Please provide a theorem statement or a specific topic, and I will do my best to help.",
      "I am an AI language model, and I can only translate natural language to Lean Theorem Prover code following given examples. This statement cannot be translated to Lean code because it is asking for an example rather than stating a theorem. Please provide a theorem statement or a different example for me to translate.",
      "Sorry, I cannot provide an example as I am designed to translate natural language to Lean Theorem Prover code. Please provide a statement that you would like me to translate into Lean code.",
      "Sorry, I cannot provide examples as I can only translate statements to Lean Theorem Prover code. Please provide another statement that you would like me to convert to Lean Theorem Prover code.",
      "I am an AI language model, and I cannot give an example as requested. However, I can help you write a theorem about a nonempty subset U of â„^2 that is closed under addition and under taking additive inverses, but U is not a subspace of â„^2.\n\n```lean\ntheorem closed_not_subspace :\n  âˆ€ {R : Type u} [inst : AddCommGroup R] (U : Set (R Ã— R)),\n  (âˆ€ {x y : R Ã— R}, x âˆˆ U â†’ y âˆˆ U â†’ x + y âˆˆ U) âˆ§\n  (âˆ€ {x : R Ã— R}, x âˆˆ U â†’ -x âˆˆ U) â†’\n  (âˆƒ u : R Ã— R, u âˆˆ U) â†’\n  Â¬(âˆ€ x : R Ã— R, x âˆˆ U â†’ âˆ€ a : R, (a, 0) * x âˆˆ U) ",
      "/-- A non-unital subring is closed under addition. -/\ntheorem non_unital_subring_add_closure {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s "
    ]
  },
  {
    "docString": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"}]\n",
    "prompt_cons": "/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  IsSubspace (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace (â‹‚ (i : Î¹), s i) :",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  âˆ€ (x y : â„™ K V) (c : K), x âˆˆ (â‹‚ (i : Î¹), Projectivization.Subspace.span (s i)) â†’ y âˆˆ (â‹‚ (i : Î¹), Projectivization.Subspace.span (s i)) â†’\n    x + y âˆˆ (â‹‚ (i : Î¹), Projectivization.Subspace.span (s i)) âˆ§ c â€¢ x âˆˆ (â‹‚ (i : Î¹), Projectivization.Subspace.span (s i)) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_3}\n  (S : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.is_subspace (â‹‚ (i : Î¹), Projectivization.Subspace.span (S i)) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Projectivization.Subspace K V),\n  IsSubspace K V (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  IsSubspace (â‹‚ (i : Î¹), Projectivization.Subspace.span (s i)) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  IsSubspace (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  IsSubspace (â‹‚ (i : Î¹), Projectivization.Subspace.span (s i)) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_3}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.intersection s = â¨… (i : Î¹), Projectivization.Subspace.span (s i) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  âˆ€ (x y : V) (c : K),\n    (âˆ€ (i : Î¹), x âˆˆ Projectivization.Subspace.span (s i)) â†’\n    (âˆ€ (i : Î¹), y âˆˆ Projectivization.Subspace.span (s i)) â†’\n    (âˆ€ (i : Î¹), x + y âˆˆ Projectivization.Subspace.span (s i)) âˆ§\n    (âˆ€ (i : Î¹), c â€¢ x âˆˆ Projectivization.Subspace.span (s i)) "
    ]
  },
  {
    "docString": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] {f : M â†’ Mâ‚‚}, IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x\",\n  \"isProp\": true,\n  \"docString\": \"A linear map preserves scalar multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†’ g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, if linear maps are inverse to each other on one side then they\\nare also inverse to each other on the other side. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 â€¢ x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- A linear map preserves scalar multiplication. -/\ntheorem âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] {f : M â†’ Mâ‚‚}, IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x :=\n\n/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†’ g * f = 1 :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 â€¢ x = x :=\n\n/-- Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [hin : FiniteDimensional.finrank K V = 1] (f : V â†’â‚—[K] V),\n  âˆƒ (a : K), âˆ€ (x : V), f x = a â€¢ x ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [h_dim : findim K V = 1] (T : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [nontrivial : Nontrivial V], FiniteDimensional.finrank K V = 1 â†’\n  âˆ€ (f : V â†’â‚—[K] V) (v : V), âˆƒ (a : K), f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : dim K V = 1] (T : V â†’â‚—[K] V) (v : V),\n  âˆƒ (a : K), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : FiniteDimensional.finrank K V = 1] {f : V â†’â‚—[K] V}, âˆƒ a : K, âˆ€ v : V, f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : FiniteDimensional.finrank K V = 1] (T : V â†’â‚—[K] V),\n  âˆƒ a : K, âˆ€ v : V, T v = a â€¢ v ",
      "âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  (h_dim : FiniteDimensional.finrank ğ•œ V = 1) (T : V â†’â‚—[ğ•œ] V), âˆƒ (a : ğ•œ), âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : HasBasisSingleOne V], âˆƒ a : K, âˆ€ v : V, (LinearMap.id - a â€¢ LinearMap.id) v = 0 ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V]\n  (h_dim : findim K V = 1) (T : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V], FiniteDimensional.finrank ğ•œ V = 1 â†’ âˆ€ (f : V â†’â‚—[ğ•œ] V), âˆƒ a : ğ•œ, âˆ€ v : V, f v = a â€¢ v "
    ]
  },
  {
    "docString": "Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card\\n        (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p)) \\\\ Multiset.toFinset (Polynomial.roots p)) +\\n      1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial `p` is at most the number of roots of its derivative\\nthat are not roots of `p` plus one. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ p` are the same. \"}]\n",
    "prompt_cons": "/-- The number of roots of a real polynomial `p` is at most the number of roots of its derivative\nthat are not roots of `p` plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card\n        (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p)) \\ Multiset.toFinset (Polynomial.roots p)) +\n      1 :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ p` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) :=\n\n/-- Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common. -/\ntheorem",
    "choices": [
      "forall {R : Type u} [inst : CommRing R] [IsDomain R] [inst_1 : CharZero R] (p : Polynomial R),\n  Polynomial.degree p = â†‘(Polynomial.natDegree p) â†’\n    ((âˆ€ (a : R), multiplicity a (Polynomial.roots p) = 1) â†”\n      Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (Polynomial.derivative p))) ",
      "âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  (Polynomial.degree p = m) â†’\n  (Multiset.Nodup (Polynomial.roots p) â†”\n    âˆ€ (a : K), Polynomial.IsRoot p a â†’ Â¬Polynomial.IsRoot (Polynomial.derivative p) a) ",
      "âˆ€ {K : Type v} [inst : Field K] [inst_1 : CharZero K] {p : Polynomial K},\n  Polynomial.degree p = â†‘(Polynomial.natDegree p) â†’\n    (Finset.card (Multiset.toFinset (Polynomial.roots p)) = Polynomial.natDegree p â†”\n       Multiset.disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p))) ",
      "âˆ€ (p : Polynomial â„‚),\n  Polynomial.natDegree p = Finset.card (Multiset.toFinset (Polynomial.roots p)) â†”\n    disjoint (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) (Multiset.toFinset (Polynomial.roots p)) ",
      "forall {R : Type u} [inst : CommRing R] [IsDomain R] [CharZero R] (p : Polynomial R),\n  Polynomial.degree p = â†‘(Polynomial.natDegree p) â†’\n    (Finset.card (Multiset.toFinset (Polynomial.roots p)) = Polynomial.natDegree p â†”\n      Multiset.disjoint (Polynomial.roots p) (Polynomial.roots (Polynomial.derivative p))) ",
      "âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  (âˆ€ a : K, multiplicity a (Polynomial.roots p) â‰¤ 1) â†”\n    Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p)) ",
      "âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  (Finset.card (Multiset.toFinset (Polynomial.roots p)) = Polynomial.natDegree p âˆ§\n    âˆ€ x, Polynomial.eval x p = 0 â†’ Polynomial.eval x (â†‘Polynomial.derivative p) â‰  0) â†”\n  Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p)) ",
      "âˆ€ (p : Polynomial â„‚), (âˆ€ x : â„‚, (Polynomial.isRoot p x â†’ Polynomial.multiplicity x p = 1) â†”\n  âˆ€ x : â„‚, (Polynomial.isRoot p x â†’ Â¬Polynomial.isRoot (Polynomial.derivative p) x)) ",
      "forall {K : Type v} [inst : Field K] {p : Polynomial K},\n  (p.nat_degree = Multiset.card (Polynomial.roots p) âˆ§ âˆ€ (a : K), Multiset.count a (Polynomial.roots p) = 1) â†”\n    âˆ€ (a : K), Polynomial.eval a p = 0 â†’ Polynomial.eval a (Polynomial.derivative p) â‰  0 ",
      "forall {R : Type u} [inst : CommRing R] [IsDomain R] [CharZero R] (p : Polynomial R),\n  (Polynomial.degree p = Polynomial.degree (Polynomial.derivative p) + 1 âˆ§\n   (âˆ€ a : R, multiplicity a (Polynomial.roots p) = 1)) â†”\n  Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (Polynomial.derivative p)) "
    ]
  },
  {
    "docString": "Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"}]\n",
    "prompt_cons": "/-- If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S)) :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  (S T : LinearMap ğ•œ V V), (S.comp T = T.comp S) â†’\n    âˆ€ (Î» : ğ•œ), LinearMap.range (LinearMap.comp S (LinearMap.projKerOfLe (T - Î» â€¢ LinearMap.id) âŠ¤ (_ : (T - Î» â€¢ LinearMap.id).ker â‰¤ âŠ¤))) = (T - Î» â€¢ LinearMap.id).ker ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (S T : LinearMap ğ•œ V V) (Î» : ğ•œ),\n  (S.comp T = T.comp S) â†’\n    âˆ€ (v : V), (T - Î» â€¢ LinearMap.id) v = 0 â†’ (T - Î» â€¢ LinearMap.id) (S v) = 0 ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (S T : LinearMap ğ•œ V V) (Î» : ğ•œ),\n  (T.comp S = S.comp T) â†’\n    (âˆ€ (x : V), (âˆƒ (c : ğ•œ), x - c â€¢ T x = Î» â€¢ x) â†’ (âˆƒ (c : ğ•œ), x - c â€¢ S T x = Î» â€¢ x)) ",
      "âˆ€ {F : Type u} [inst : Field F] {V : Type u_1} [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : LinearMap F V V),\n  (S.comp T = T.comp S) â†’ âˆ€ (Î» : F), Submodule.map S (LinearMap.nullSpace (T - C F V Î»)) = LinearMap.nullSpace (T - C F V Î») ",
      "âˆ€ {F : Type u} [inst : Field F] {V : Type u_1} [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  (S : LinearMap F V V) (T : LinearMap F V V),\n  (âˆ€ (v : V), S (T v) = T (S v)) â†’\n    âˆ€ (Î» : F), Submodule.map S (LinearMap.ker (T - Î» â€¢ LinearMap.id)) â‰¤\n      LinearMap.ker (T - Î» â€¢ LinearMap.id) ",
      "âˆ€ {F : Type u_1} {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : LinearMap F V),\n  (âˆ€ (x : V), S (T x) = T (S x)) â†’\n    âˆ€ (Î» : F), LinearMap.ker (LinearMap.sub T (coeFn (RingHom.id F) Î» * LinearMap.id)) â‰¤\n      LinearMap.ker (LinearMap.sub (S.comp (LinearMap.sub T (coeFn (RingHom.id F) Î» * LinearMap.id)))\n        (coeFn (RingHom.id F) Î» * LinearMap.id)) ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : LinearMap F V V),\n  (S.comp T = T.comp S) â†’ âˆ€ (Î» : F), LinearMap.IsInvariantSubspace S (LinearMap.nullSpace (LinearMap.sub T (coeFn (RingHom.id F) Î» * LinearMap.id))) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {S T : End ğ•œ V},\n  (S.comp T = T.comp S) â†’ âˆ€ (Î» : ğ•œ), (Submodule.map S (ker (T - Algebra.id ğ•œ V * Î»))).to_add_submonoid = (ker (T - Algebra.id ğ•œ V * Î»)).to_add_submonoid ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  (S T : End ğ•œ V) (hST : S.comp T = T.comp S),\n  âˆ€ (Î» : ğ•œ), Submodule.map S (End.nullSpace (T - Î» â€¢ 1)) â‰¤ End.nullSpace (T - Î» â€¢ 1) ",
      "âˆ€ {F : Type u_1} {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : LinearMap F V),\n  (S.comp T = T.comp S) â†’ (âˆ€ (Î» : F), LinearMap.IsInvariantSubmodule S (LinearMap.nullSpace (T - Î» â€¢ LinearMap.id))) "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (a b : M),\\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b)\",\n  \"isProp\": true,\n  \"docString\": \"The symmetric product of vectors is a scalar \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–) :=\n\n/-- The symmetric product of vectors is a scalar -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (a b : M),\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b) :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : LinearMap K V V}\n  (h_eigenvector : âˆ€ (v : V), v â‰  0 â†’ âˆƒ (a : K), T v = a â€¢ v),\n  âˆƒ (c : K), âˆ€ (v : V), T v = c â€¢ v ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : End K V},\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : K), T v = c â€¢ v) â†’ âˆƒ (a : K), T = a â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : LinearMap K V V},\n  (âˆ€ v : V, v â‰  0 â†’ âˆƒ a : K, T v = a â€¢ v) â†’ (âˆƒ c : K, âˆ€ v : V, T v = c â€¢ v) ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ a, T v = a â€¢ v) â†’ âˆƒ c, âˆ€ (v : V), T v = c â€¢ v ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] \n  (T : LinearMap K V V) (h : âˆ€ v : V, v â‰  0 â†’ âˆƒ a, T v = a â€¢ v),\n  âˆƒ a : K, T = LinearMap.smulRight a ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : LinearMap K V V) (h : âˆ€ v : V, v â‰  0 â†’ âˆƒ a, T v = a â€¢ v),\n  âˆƒ c, âˆ€ v : V, T v = c â€¢ v ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  {T : LinearMap ğ•œ V V}, (âˆ€ v : V, âˆƒ a, T v = a â€¢ v) â†’ âˆƒ a, T = a â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : LinearMap K V V), (âˆ€ v : V, âˆƒ a : K, T v = a â€¢ v) â†’ (âˆƒ c : K, T = c â€¢ LinearMap.id) ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : End K V), (âˆ€ v : V, âˆƒ a : K, T v = a â€¢ v) â†’ âˆƒ c : K, âˆ€ v : V, T v = c â€¢ v ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : End K V) (h_eigen : âˆ€ v : V, v â‰  0 â†’ âˆƒ c : K, T v = c â€¢ v),\n  âˆƒ c : K, âˆ€ v : V, T v = c â€¢ v "
    ]
  },
  {
    "docString": "Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"}]\n",
    "prompt_cons": "/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {T S : Module.End K V} (hT : Module.End.HasDistinctEigenvectors T) (hS : Module.End.HasSameEigenvectors T S),\n  T * S = S * T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T S : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E]\n  (hT : LinearMap.IsSymmetric T) (hS : LinearMap.IsSymmetric S)\n  (h_eigen : âˆ€ Î¼ : Module.End.Eigenvalues T, âˆƒ Î½ : Module.End.Eigenvalues S, Module.End.eigenspace T Î¼ = Module.End.eigenspace S Î½),\n  T.comp S = S.comp T ",
      "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] \n  (T S : Module.End K V) (hT : FiniteDimensional.finrank K V = Module.End.eigenvalues T.card) \n  (hTS : âˆ€ v : V, (âˆƒ Î¼ : K, Module.End.eigenspace T Î¼ v â‰  0) â†’ (âˆƒ Î¼ : K, Module.End.eigenspace S Î¼ v â‰  0)),\n  T * S = S * T ",
      "forall {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T S : Module.End K V}\n  (hT : FiniteDimensional.finrank K V = (Module.End.eigenvalues T).size)\n  (hTS : âˆ€ u Î¼, Module.End.HasEigenvector T (u, Î¼) â†’ Module.End.HasEigenvector S (u, Î¼)),\n  T * S = S * T ",
      "âˆ€ {K : Type u} [inst : Field K] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T S : Module.End K V}\n  [inst_3 : FiniteDimensional K V] (hT : Module.End.HasDistinctEigenvalues T) (hS : Module.End.HasSameEigenvectors T S),\n  T * S = S * T ",
      "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T S : Module.End K V}\n  (ht : LinearMap.IsDiagonalizable T) (hs : LinearMap.HasSameEigenvectors T S),\n  T * S = S * T ",
      "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T S : Module.End K V},\n  (Module.rank K V = (Module.End.eigenvalues T).card) â†’\n  (âˆ€ Î¼ : K, Module.End.eigenspace T Î¼ = Module.End.eigenspace S Î¼) â†’\n  T.comp S = S.comp T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T S : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E]\n  (hT : LinearMap.IsSymmetric T) (hS : LinearMap.EigenvaluesSameEigenvectors hT S),\n  T * S = S * T ",
      "forall {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T S : Module.End K V}\n  (hT : Module.End.HasDistinctEigenvectors T) (hS : Module.End.HasSameEigenvectors T S),\n  T * S = S * T ",
      "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {T S : Module.End K V} (h_distinct : Module.End.eigenvalues T = Finset.card (Module.rank K V))\n  (h_eigenvectors : âˆ€ v : V, Module.End.eigenspace T v âŠ† Module.End.eigenspace S v), T * S = S * T "
    ]
  },
  {
    "docString": "Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"}]\n",
    "prompt_cons": "/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$. -/\ntheorem",
    "choices": [
      "âˆ€ {F : Type u_1} {E : Type u_2} [inst : Ring F] [inst_1 : IsDomain F] [inst_2 : AddCommGroup E] [inst_3 : Module F E]\n  (u v : E),\n  InnerProductSpace.inner u v = 0 â†” âˆ€ (a : F), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] {u v : E},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] (u v : E),\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), (âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] (u v : E),\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] {u v : E},\n  (inner u v = 0) â†” (âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] {u v : E},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ”½ : Type u_1} {E : Type u_2} [inst : NondiscreteNormedField ğ”½] [inst_1 : NormedGroup E] [inst_2 : NormedSpace ğ”½ E]\n  (u v : E) (a : ğ”½), inner u v = 0 â†” âˆ€ a, âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {F : Type u_1} {E : Type u_2} [inst : LinearOrderedField F] [inst_1 : AddCommGroup E] [inst_2 : VectorSpace F E]\n  [inst_3 : Module F â„] [inst_4 : IsScalarTower F â„ (Set E)] (u v : E) (norm : E â†’ â„),\n  (âˆ€ a, norm u â‰¤ norm (u + a â€¢ v)) â†” inner u v = 0 ",
      "âˆ€ {ğ”½ : Type u_1} [inst : IsROrC ğ”½] {E : Type u_2} [inst_1 : InnerProductSpace ğ”½ E] (u v : E),\n  inner u v = 0 â†” âˆ€ (a : ğ”½), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] {u v : E},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ "
    ]
  },
  {
    "docString": "Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner x y * inner x y â‰¤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchyâ€“Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : V), â†‘f (â†‘(Orientation.rotation o Î¸) x) = â†‘(Real.Angle.expMapCircle Î¸) * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\\ncomplex-number representation of the space. \"}]\n",
    "prompt_cons": "/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im :=\n\n/-- Cauchyâ€“Schwarz inequality for real inner products. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner x y * inner x y â‰¤ inner x x * inner y y :=\n\n/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : V), â†‘f (â†‘(Orientation.rotation o Î¸) x) = â†‘(Real.Angle.expMapCircle Î¸) * â†‘f x :=\n\n/-- Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$. -/\ntheorem",
    "choices": [
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((norm (u + v))^2 - (norm (u - v))^2 + (norm (u + I â€¢ v))^2 * I - (norm (u - I â€¢ v))^2 * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((norm (u + v) ^ 2 - norm (u - v) ^ 2 + ((norm (u + I â€¢ v) ^ 2 - norm (u - I â€¢ v) ^ 2) * I)) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (norm (u + v) ^ 2 - norm (u - v) ^ 2 + (norm (u + I â€¢ v) ^ 2 - norm (u - I â€¢ v) ^ 2) * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((âˆ¥u + vâˆ¥ ^ 2 - âˆ¥u - vâˆ¥ ^ 2 + âˆ¥u + ((I : â„‚) * v)âˆ¥ ^ 2 * I - âˆ¥u - ((I : â„‚) * v)âˆ¥ ^ 2 * I) / 4) ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((âˆ¥u + vâˆ¥ ^ 2 - âˆ¥u - vâˆ¥ ^ 2) + (âˆ¥u + I â€¢ vâˆ¥ ^ 2 * I - âˆ¥u - I â€¢ vâˆ¥ ^ 2 * I)) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((norm_sq (u + v) - norm_sq (u - v) + (norm_sq (u + I â€¢ v) - norm_sq (u - I â€¢ v)) * I) / 4) ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â†‘(norm (u + v)) ^ 2 - â†‘(norm (u - v)) ^ 2 + â†‘(norm (u + I â€¢ v)) ^ 2 * I - â†‘(norm (u - I â€¢ v)) ^ 2 * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((norm (u + v) ^ 2 - norm (u - v) ^ 2 + (norm (u + I â€¢ v) ^ 2) * I - (norm (u - I â€¢ v) ^ 2) * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (((norm (u + v))^2 - (norm (u - v))^2) + (norm (u + I â€¢ v))^2 * I - (norm (u - I â€¢ v))^2 * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\ninner u v = (norm (u + v) ^ 2 - norm (u - v) ^ 2 + (norm (u + (I * v)) ^ 2 - norm (u - (I * v)) ^ 2) * I) / 4 "
    ]
  },
  {
    "docString": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from an orthogonal submodule `V` is the zero map. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\\n  dist p â†‘(â†‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance to a point's orthogonal projection is 0 iff it lies in the subspace. \"}]\n",
    "prompt_cons": "/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V :=\n\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- The distance to a point's orthogonal projection is 0 iff it lies in the subspace. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\n  dist p â†‘(â†‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s :=\n\n/-- Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$ -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  (UâŠ“V).orthogonal = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  U â‰¤ V â†’ (U.orthogonal = âŠ¥ â†” U = V) ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (U V : Submodule ğ•œ E),\n  Uá—® = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  (U âŠ“ Vá—® = âŠ¥) â†” (U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  (U.orthogonal = âŠ¥) â†” (U = V) ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  U.orthogonal = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  U.orthogonal = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (U.orthogonal = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  Uá—® = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  (U.orthogonal âŠ† (âŠ¥ : Submodule ğ•œ E)) â†” U = V "
    ]
  },
  {
    "docString": "Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (W : Submodule R M),\\n  LinearMap.range (LinearMap.dualMap (Submodule.mkQ W)) = Submodule.dualAnnihilator W\",\n  \"isProp\": true,\n  \"docString\":\n  \"That $\\\\operatorname{im}(q^* : (V/W)^* \\\\to V^*) = \\\\operatorname{ann}(W)$. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\": \"âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"}]\n",
    "prompt_cons": "/-- That $\\operatorname{im}(q^* : (V/W)^* \\to V^*) = \\operatorname{ann}(W)$. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (W : Submodule R M),\n  LinearMap.range (LinearMap.dualMap (Submodule.mkQ W)) = Submodule.dualAnnihilator W :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- **Liouville's Theorem** -/\ntheorem âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u)) :=\n\n/-- Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$ -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarModule ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V} (hT : LinearMap.IsNormal T), LinearMap.range T = LinearMap.range (LinearMap.star T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : StarModule ğ•œ V] [inst_4 : FiniteDimensional ğ•œ V] {T : V â†’SL[RingHom.id ğ•œ] V},\n  LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adj T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarModule ğ•œ V]\n  {T : V â†’SL[RingHom.id ğ•œ] V}, LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarModule ğ•œ V]\n  (T : V â†’â‚›â‚—[RingHom.id ğ•œ] V), LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.star T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] (T : V â†’â‚—[ğ•œ] V),\n  LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarModule ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V}, LinearMap.normal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : StarModule ğ•œ V] (T : V â†’â‚›â‚—[RingHom.id ğ•œ] V) [inst_4 : StarLinearIsometry T],\n  LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarModule ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V}, LinearMap.normal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {T : V â†’â‚—[ğ•œ] V}\n  [inst_3 : StarModule ğ•œ V], T.is_normal â†’ LinearMap.range T = LinearMap.range (LinearMap.star T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarModule ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V}, IsNormal T â†’ LinearMap.range T = LinearMap.range (T.star) "
    ]
  },
  {
    "docString": "Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"}]\n",
    "prompt_cons": "/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  (LinearMap.IsNormal T âˆ§ T ^ 9 = T ^ 8) â†’ (LinearMap.IsSelfAdjoint T âˆ§ T ^ 2 = T) ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSymmetric T âˆ§ T ^ 2 = T ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, T^9 = T^8 â†’ LinearMap.IsNormal T â†’ LinearMap.IsSelfAdjoint T âˆ§ T^2 = T ",
      "forall {V : Type u} [inst : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V} (hT : T * T.adjoint = T.adjoint * T),\n  (T ^ 9 = T ^ 8) -> IsSelfAdjoint T âˆ§ (T ^ 2 = T) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsNormal T â†’ (T ^ 9 = T ^ 8) â†’\n    (LinearMap.IsSymmetric T âˆ§ (T ^ 2 = T)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  (LinearMap.IsNormal T âˆ§ T ^ 9 = T ^ 8) â†’\n    (IsSelfAdjoint T âˆ§ T ^ 2 = T) "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"}]\n",
    "prompt_cons": "/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$. -/\ntheorem",
    "choices": [
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n    (âˆƒ (v : E), âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n    âˆƒ Î»' : ğ•œ, HasMem.Mem Î»' (LinearMap.IsSymmetric.eigenvalues T) âˆ§ abs (Î» - Î»') < Îµ ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î» : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’ (âˆƒ v : E, 1 = innerProductSpace.norm v âˆ§ Îµ > innerProductSpace.norm (T v - Î» â€¢ v)) â†’\n  âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue T Î»' âˆ§ IsROrC.abs (Î» - Î»') < Îµ ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n      (âˆƒ (v : E), âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n        âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) {Î» : ğ•œ} {Îµ : â„} (hÎµ : 0 < Îµ) {v : E},\n  âˆ¥vâˆ¥ = 1 â†’ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ â†’\n    âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ IsROrC.abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î» : ğ•œ} {Îµ : â„}, 0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’ âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n  (âˆƒ (v : E), âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n  âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î» : ğ•œ} {Îµ : â„}, 0 < Îµ â†’\n  (âˆƒ (v : E), âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n  (âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue T Î»' âˆ§ IsROrC.abs (Î» - Î»') < Îµ) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) {Î» : ğ•œ} {Îµ : â„} (hÎµ : 0 < Îµ) {v : E} (hvâ‚ : âˆ¥vâˆ¥ = 1) (hvâ‚‚ : âˆ¥T v - Î» vâˆ¥ < Îµ),\n  âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ âˆ¥Î» - Î»'âˆ¥ < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î» : ğ•œ} {Îµ : â„}, 0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n    âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ IsROrC.abs (Î» - Î»') < Îµ ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’\n  âˆ€ {Î» : ğ•œ} {Îµ : â„}, 0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n      âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (IsROrC.re (Î» - Î»')) < Îµ "
    ]
  },
  {
    "docString": "For all odd $n$ show that $8 \\mid n^{2}-1$.",
    "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"}]\n",
    "prompt_cons": "/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- For all odd $n$ show that $8 \\mid n^{2}-1$. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ 8 âˆ£ n ^ 2 - 1 ",
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ (n^2 - 1) % 8 = 0 ",
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "forall_odd_n_eight_divides_n_squared_minus_one : âˆ€ {n : â„•}, n % 2 = 1 â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ (n ^ 2 - 1) % 8 = 0 ",
      "âˆ€ {n : â„•}, n % 2 = 1 â†’ 8 âˆ£ n^2 - 1 ",
      "âˆ€ {n : â„•}, odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall_odd_n_eight_divides_n_squared_minus_one : âˆ€ (n : â„•), n % 2 = 1 â†’ 8 âˆ£ (n ^ 2 - 1) "
    ]
  },
  {
    "docString": "Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},\\n  2 â‰¤ k â†’\\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. \"}]\n",
    "prompt_cons": "/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. -/\ntheorem âˆ€ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},\n  2 â‰¤ k â†’\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2 :=\n\n/-- Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$. -/\ntheorem",
    "choices": [
      "divisible_by_2 : (2 : â„¤[i]) = (1 + I) ^ 2 ",
      "2 âˆ£ (1 + Complex.I) ^ 2 ",
      "2 âˆ£ (1 + Complex.I) ^ 2 ",
      "2 * (1 + Complex.I) * (1 - Complex.I) = (1 + Complex.I) ^ 2 ",
      "(2 : â„¤[i]) = (1 + I) ^ 2 ",
      "(2 : â„¤[i]) = (1 + I) ^ 2 ",
      "2 âˆ£ (1 + Complex.i) ^ 2 ",
      "divisible_by_2_pow : (2 : â„¤[i]) âˆ£ (1 + Complex.I) ^ 2 ",
      "2 âˆ£ (1 + Complex.I) * (1 + Complex.I) ",
      "(2 : â„¤[i]) = (1 + I) ^ 2 "
    ]
  },
  {
    "docString": "Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {p n r b : â„•},\\n  Nat.Prime p â†’ Nat.log p n < b â†’ (p ^ r âˆ£ Nat.factorial n â†” r â‰¤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` \"},\n {\"theorem\":\n  \"âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2`  \"},\n {\"theorem\": \"âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` -/\ntheorem âˆ€ {p n r b : â„•},\n  Nat.Prime p â†’ Nat.log p n < b â†’ (p ^ r âˆ£ Nat.factorial n â†” r â‰¤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i) :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2` -/\ntheorem âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n :=\n\n/-- Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$. -/\ntheorem",
    "choices": [
      "âˆ€ {p n : â„•},\n  (PowerSeries.coeff â„¤ n (PowerSeries.mvPowerSeriesX Nat.prime p)) = if n = 1 then Nat.log p else 0 ",
      "âˆ€ {p n : â„•}, Nat.Prime p â†’\n  (let wedge ",
      "âˆ€ {p n : â„•} (hn : n â‰  0),\n  (Finset.sum (Nat.divisors n) fun d => Moebius.moebius d * Real.log (n / d)) =\n    if (Nat.Prime p âˆ§ âˆƒ k, n = p ^ k) then Real.log p else 0 ",
      "forall {p n m d : â„•} (hprime : Nat.Prime p),\n  n â‰  0 â†’ n = p ^ m â†’ d â‰  0 â†’ (Finset.sum (Nat.divisors n) (fun d => Î¼ (n / d) * Nat.log d) = Nat.log p) ",
      "forall {p : â„•} (n : â„•), (n = p ^ (Nat.find_greatest (fun m => p ^ m âˆ£ n) n) â†’ (Finset.sum (Nat.divisors n) (Î» d => Î¼ (n / d) * Nat.log d) = Nat.log p)) ",
      "/-- Define `log_p n = log p` if `n` is a power of `p` and zero otherwise. -/\ndef log_p (p n : â„•) : â„• ",
      "forall {n : â„•}, (Finset.sum (Nat.divisors n) fun d => Moebius.moebius d * Real.log (n / d)) = ite (Nat.PrimePower n) (Real.log (Nat.minFac n)) 0 ",
      "âˆ€ (n : â„•), (Finset.sum (Nat.divisors n) fun d => (Î¼ (n / d)) * (Real.log d)) = if h : âˆƒ (p : â„•) [hp : Nat.Prime p], âˆƒ (k : â„•), p ^ k = n then Real.log (Nat.minFac n) else 0 ",
      "forall {p n : â„•} (hp : Nat.Prime p),\n  (Finset.sum (Nat.divisors n) fun d => Î¼ (n / d) * Nat.log p d) = if h : n = p^Nat.log p n then Nat.log p n else 0 ",
      "âˆ€ {p n : â„•} (hp : Nat.Prime p),\n  (Finset.sum (Finset.filter (fun d => d âˆ£ n) (Finset.range (Nat.succ n))) fun d => Î¼ (n / d) * Nat.log d) =\n    if h : p ^ Nat.log p n = n then Nat.log p else 0 "
    ]
  },
  {
    "docString": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"}]\n",
    "prompt_cons": "/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- Show that there are infinitely many primes congruent to $-1$ modulo 6 . -/\ntheorem",
    "choices": [
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ",
      "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} "
    ]
  },
  {
    "docString": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers. -/\ntheorem",
    "choices": [
      "no_solution_7x3p2_eq_y3 : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "no_sol_for_7x3_plus_2_eq_y3 : âˆ€ {x y : â„¤}, 7 * x^3 + 2 â‰  y^3 ",
      "âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "no_solution : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "no_solution : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "no_solution_seven_x_cubed_plus_two_eq_y_cubed : âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "no_int_solution : âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "no_sol : âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "no_solution_7x3_plus_2_eq_y3 : âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 "
    ]
  },
  {
    "docString": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$. -/\ntheorem",
    "choices": [
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ (n ^ (q - 1)) % (p * q) = 1 ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ (n ^ (q - 1)) â‰¡ 1 [MOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’\n  (n ^ (q - 1)) % (p * q) = 1 ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ (n^(q - 1) : â„¤) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ (n ^ (q - 1)) % (p * q) = 1 ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ (n ^ (q - 1)) % (p * q) = 1 ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (q - 1) % (p - 1) = 0 â†’ Nat.Coprime n (p * q) â†’ (n ^ (q - 1)) % (p * q) = 1 ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ (n ^ (q - 1)) % (p * q) = 1 ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ Nat.Coprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [MOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ coprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [MOD p * q] "
    ]
  },
  {
    "docString": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"}]\n",
    "prompt_cons": "/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$. -/\ntheorem",
    "choices": [
      "âˆ€ {p t a : â„•}, Nat.Prime p â†’ p = 4 * t + 3 â†’ IsPrimitiveRoot a p â†” orderOf (-a) = (p - 1) / 2 ",
      "âˆ€ {a : â„¤} {p : â„•} [hp : Fact (Nat.Prime p)], (p % 4 = 3) â†’\n  (is_primitive_root a p â†” (order_of (-a) = (p - 1) / 2)) ",
      "âˆ€ {p : â„•} [fact (Nat.Prime p)] (a : ZMod p), p % 4 = 3 â†’ is_primitive_root a p â†” a ^ ((p - 1) / 2) = -1 ",
      "âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ (primitiveRoot a p â†” (p - 1) / 2 = orderOf (-a)) ",
      "âˆ€ {p : â„•} {a : ZMod p}, Nat.Prime p â†’ (4 * (p - 3) / 4) â†’ primitiveRoot a p â†” orderOf (-a) = (p - 1) / 2 ",
      "âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ (primitiveRoot a p â†” (orderOf (-a)) = (p - 1) / 2) ",
      "âˆ€ {p : â„•} [Fact (Nat.Prime p)] [Fact (p % 4 = 3)], âˆ€ {a : ZMod p}, IsPrimitiveRoot a p â†” ((-a) ^ ((p - 1) / 2) â‰  1) ",
      "âˆ€ {a : â„¤} {p : â„•} (t : â„•), Nat.Prime p â†’ p = 4 * t + 3 â†’ (orderOf a = p - 1 â†” orderOf (-a) = (p - 1) / 2) ",
      "âˆ€ {p : â„•} {a : â„¤} (t : â„•), Nat.Prime p â†’ p = 4 * t + 3 â†’ (primitive_root_mod a â†‘p â†” order_mod (-a) â†‘p = (p - 1) / 2) ",
      "âˆ€ {a : â„¤} {t p : â„•}, Nat.Prime p â†’ p = 4 * t + 3 â†’ is_primitive_root a p â†” (-a) ^ ((p - 1) / 2) = -1 "
    ]
  },
  {
    "docString": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"}]\n",
    "prompt_cons": "/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$. -/\ntheorem",
    "choices": [
      "âˆ€ {p a : â„•}, Nat.Prime p â†’ p % 2 = 1 â†’ (primitive_root a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1 [ZMOD p])) ",
      "âˆ€ {p : â„•} (a : ZMod p) (hp : Fact (Nat.Prime p)), hp.val % 2 = 1 â†’ IsPrimitiveRoot a hp.val â†” (âˆ€ q, Nat.Prime q â†’ q âˆ£ (hp.val - 1) â†’ a ^ ((hp.val - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a : ZMod p}, (IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1)) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (âˆ€ (a : ZMod p), IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1)) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ âˆƒ a : ZMod p, a ^ ((p - 1) / q) â‰  1) â†” IsPrimitiveRoot a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ (âˆ€ (m : â„•), m < p - 1 â†’ âˆƒ n : â„•, a ^ n = â†‘m) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ (a : ZMod p), IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ (a : ZMod p), IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ IsPrimitiveRoot a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ (a : ZMod p), (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ IsPrimitiveRoot a p "
    ]
  },
  {
    "docString": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"}]\n",
    "prompt_cons": "/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 . -/\ntheorem",
    "choices": [
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "forall {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x^4 - x^2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x^4 - x^2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x^4 - x^2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x^4 - x^2 + 1) â†’ p % 12 = 1 "
    ]
  },
  {
    "docString": "Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"}]\n",
    "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$. -/\ntheorem",
    "choices": [
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime (Int.nat_abs p))] [inst_1 : Fact (Nat.Prime (Int.nat_abs q))],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬ p âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "forall {a p q : â„¤} [inst : Fact (Nat.Prime (Int.nat_abs p))] [inst_1 : Fact (Nat.Prime (Int.nat_abs q))],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬p âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p â‰¡ q [ZMOD 4 * a] â†’ Â¬p âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ (p âˆ£ a * a) âˆ§ (Â¬p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ p âˆ£ a â†’ q âˆ£ a â†’ a â‰  p * q â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 * a â†’ Â¬ (p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬(p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬p âˆ£ a â†’ Â¬q âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p â‰¡ q [ZMOD 4 * a] â†’ Â¬(p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "forall {a p q : â„¤} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬ â†‘p âˆ£ a â†’ legendreSym a p = legendreSym a q "
    ]
  },
  {
    "docString": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways. -/\ntheorem",
    "choices": [
      "smallest_cubes_sum_1729 : âˆƒ a b c d : â„•, a â‰  b âˆ§ c â‰  d âˆ§ a ^ 3 + b ^ 3 = 1729 âˆ§ c ^ 3 + d ^ 3 = 1729 ",
      "smallest_1729 : âˆƒ a b c d : â„¤, a â‰  b âˆ§ c â‰  d âˆ§ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ âˆƒ k : â„•, 1729 = k * (a ^ 3 + b ^ 3) ",
      "âˆƒ a b c d : â„•, a â‰  b âˆ§ c â‰  d âˆ§ 1729 = a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 ",
      "smallest_int_expressible_as_sum_of_two_cubes : âˆƒ a b c d : â„•, a â‰  c âˆ§ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ âˆ€ r s t u : â„•, r ^ 3 + s ^ 3 = t ^ 3 + u ^ 3 â†’ r ^ 3 + s ^ 3 â‰¥ a ^ 3 + b ^ 3 ",
      "smallest_1729 : âˆƒ a1 b1 a2 b2 : â„¤, a1 â‰  a2 âˆ§ a1 ^ 3 + b1 ^ 3 = 1729 âˆ§ a2 ^ 3 + b2 ^ 3 = 1729 ",
      "smallest_expressible_as_sum_of_two_different_integral_cubes : âˆƒ (x1 y1 x2 y2 x3 y3 x4 y4 : â„¤),\n  x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x3 â‰  x4 âˆ§ y3 â‰  y4 âˆ§\n  x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ x3 ^ 3 + y3 ^ 3 = x4 ^ 3 + y4 ^ 3 âˆ§\n  x1 ^ 3 + y1 ^ 3 = x3 ^ 3 + y3 ^ 3 âˆ§ (x1 ^ 3 + y1 ^ 3).nat_abs = 1729 ",
      "âˆƒ k : â„•, k = 1729 âˆ§ âˆƒ x y z w : â„•, x ^ 3 + y ^ 3 = k âˆ§ z ^ 3 + w ^ 3 = k âˆ§ x â‰  y âˆ§ z â‰  w ",
      "âˆƒ x y z w : â„•, x â‰  y âˆ§ z â‰  w âˆ§ x ^ 3 + y ^ 3 = 1729 âˆ§ z ^ 3 + w ^ 3 = 1729 ",
      "smallest_positive_integer_expressible_as_sum_of_two_different_integral_cubes_in_two_ways : âˆƒ a b c d, a â‰  b âˆ§ c â‰  d âˆ§ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ a ^ 3 + b ^ 3 = 1729 ",
      "âˆƒ x y z w : â„¤, x â‰  y âˆ§ z â‰  w âˆ§ x ^ 3 + y ^ 3 = z ^ 3 + w ^ 3 âˆ§ x ^ 3 + y ^ 3 = 1729 "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"}]\n",
    "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    IsOpen U â†’\n      (âˆ€ x y âˆˆ U, (f x).re = (f y).re) â†’\n        âˆ€ x y âˆˆ U, f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ (âˆ€ (x : M), x âˆˆ U â†’ (f x).re = 0) â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (âˆ€ (x : E), x âˆˆ U â†’ (f x).re = (f x).im) â†’ âˆ€ (a b : E), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ (âˆ€ (x : M), x âˆˆ U â†’ (f x).re = (f x).re) â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (âˆ€ (z : E), z âˆˆ U â†’ (f z).re = constant) â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ f z = w) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {Î© : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f Î© â†’\n    IsOpen Î© â†’ (âˆ€ (x : M), x âˆˆ Î© â†’ (f x).re = (f x).re) â†’ âˆ€ (a b : M), a âˆˆ Î© â†’ b âˆˆ Î© â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {â„¦ : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f â„¦ â†’\n    IsOpen â„¦ â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ â„¦ â†’ (f z).re = w) â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ â„¦ â†’ f z = w) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    IsPreconnected U â†’ (âˆ€ (z : E), z âˆˆ U â†’ (f z).re = 0) â†’ âˆ€ (a b : E), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n  IsPreconnected U â†’\n  (âˆ€ (z : E), z âˆˆ U â†’ (f z).re = (f z).re) â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ f z = w) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f Î© â†’\n    (âˆ€ (z : E), z âˆˆ Î© â†’ (f z).re = (f âŸ¨0, 0âŸ©).re) â†’ âˆ€ (a b : E), a âˆˆ Î© â†’ b âˆˆ Î© â†’ f a = f b "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"}]\n",
    "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "forall {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’ IsOpen U â†’\n  (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f (classical.arbitrary M)âˆ¥) â†’ âˆ€ x y âˆˆ U, f x = f y ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f (Classical.arbitrary M)âˆ¥) â†’ âˆ€ a b âˆˆ U, f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’ IsOpen U â†’\n  (âˆ€ x âˆˆ U, Complex.abs (f x) = Complex.abs (f (Classical.arbitrary M))) â†’ âˆ€ a b âˆˆ U, f a = f b ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f (classical.arbitrary M)âˆ¥) â†’ âˆ€ a b âˆˆ U, f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’ IsOpen U â†’\n  (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = const) â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’ IsOpen U â†’\n  (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f (Classical.some (_ : Classical.Nonempty M))âˆ¥) â†’ âˆ€ a b âˆˆ U, f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’ IsOpen U â†’\n  (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f (classical.arbitrary M)âˆ¥) â†’ âˆ€ a b âˆˆ U, f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {Î© : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f Î© â†’ IsOpen Î© â†’\n  IsLocallyConstant (Î» x, âˆ¥f xâˆ¥) â†’ âˆ€ (a b : M), a âˆˆ Î© â†’ b âˆˆ Î© â†’ f a = f b ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ (forall x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f aâˆ¥) â†’ f a = f b ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ (âˆ€ x âˆˆ U, âˆ¥f xâˆ¥ = âˆ¥f aâˆ¥) â†’ f a = f b "
    ]
  },
  {
    "docString": "Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"}]\n",
    "prompt_cons": "/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : IsROrC ğ•œ], \n  Summable (Î» (n : â„•), (1 / (â†‘n ^ 2)) * Complex.abs (coe (IsROrC.abs (IsROrC.i * 1)))) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ],\n  âˆ€ (z : ğ•œ), âˆ¥zâˆ¥ = 1 â†’ HasSum (Î» n => z ^ n / (â†‘n + 1) ^ 2) (PowerSeries.sum (Î» n => z ^ n / (â†‘n + 1) ^ 2)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ]\n  (z : ğ•œ), abs z = 1 â†’ HasSum (Î» n : â„•, z ^ n / (n + 1) ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] (z : ğ•œ), IsROrC.abs z = 1 â†’\n  Summable (Î» (n : â„•), (z ^ n) / ((n + 1) * (n + 1) : ğ•œ)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] [inst_1 : IsAbsoluteValue (norm : ğ•œ â†’ â„)] (z : ğ•œ),\n  abs z = 1 â†’ Summable (Î» n : â„•, z ^ n / (n ^ 2 : â„)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ]\n  (z : ğ•œ), HasSum (Î» n, z ^ n / (â†‘n ^ 2)) (Summable fun n => z ^ n / (â†‘n ^ 2)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] {R : â„}, 0 < R â†’\n  HasSum (Î» n => (R * Complex.exp (Complex.I * (â†‘n * Î±))) / (â†‘n ^ 2)) (R * (Complex.of_real Ï€ * Complex.I / 2) * (Complex.exp (Complex.I * Î±) - 1)) ",
      "forall {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {z : ğ•œ},\n  (abs z = 1) â†’ Summable (Î» n => z ^ n / (â†‘n ^ 2)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {z : ğ•œ},\n  abs z = 1 â†’ HasSum (fun n => z ^ n / n ^ 2) (Summable fun n => z ^ n / n ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] {z : ğ•œ}, Complex.abs z = 1 â†’\n  Summable (Î» (n : â„•), z ^ n / (n + 1) ^ 2) "
    ]
  },
  {
    "docString": "Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"}]\n",
    "prompt_cons": "/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {s : Set Î±}\n  [inst_3 : TopologicalSpace.OpensMeasurableSpace Î±] {f : Î± â†’ Î²} {F G : Î± â†’ Î²},\n  (âˆ€x âˆˆ s, HasDerivativeAt F (f x) x) â†’ (âˆ€x âˆˆ s, HasDerivativeAt G (f x) x) â†’ ContinuousOn f s â†’\n  âˆƒc : Î², âˆ€x âˆˆ s, F x = G x + c ",
      "âˆ€ {Î± : Type u} {E : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace E] [inst_2 : T2Space Î±] [inst_3 : NormedAddCommGroup E]\n  {f : Î± â†’ E} {F G : Î± â†’ E}, Continuous f â†’ (âˆ€ x, HasDerivativeAt F (f x) x) â†’ (âˆ€ x, HasDerivativeAt G (f x) x) â†’ âˆƒ C : E, âˆ€ x, F x = G x + C ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] [inst_3 : T2Space Î²]\n  [inst_4 : AddGroup Î²] {Î© : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f Î© â†’\n  âˆ€ {F G : Î± â†’ Î²}, HasDerivativeOn F f Î© â†’ HasDerivativeOn G f Î© â†’ Set.EqOn (Î» x, F x - G x) (Function.const Î± 0) Î© ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] [inst_3 : AddCommGroup Î²]\n  {Î© : Set Î±} {f F G : Î± â†’ Î²}, ContinuousOn f Î© â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt G (f x) Î© x) â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt F (f x) Î© x)\n  â†’ âˆƒ C : Î², âˆ€ x âˆˆ Î©, G x = F x + C ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] [inst_3 : AddCommGroup Î²]\n  {Î© : Set Î±} {f F G : Î± â†’ Î²}, ContinuousOn f Î© â†’ (âˆ€ x âˆˆ Î©, HasDerivAt F (f x) x) â†’ (âˆ€ x âˆˆ Î©, HasDerivAt G (f x) x) â†’\n  âˆƒ C : Î², âˆ€ x âˆˆ Î©, F x = G x + C ",
      "âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : MeasureTheory.MeasureSpace Î±] [inst_2 : TopologicalSpace E]\n  [inst_3 : NormedAddCommGroup E] {f g F G : Î± â†’ E} {Î© : Set Î±},\n  Continuous f â†’ Continuous g â†’ (âˆ€ x âˆˆ Î©, F x = g x - f x) â†’ (âˆ€ x âˆˆ Î©, G x = g x - f x) â†’\n  (âˆƒ C : E, âˆ€ x âˆˆ Î©, F x = G x + C) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : AddCommGroup Î²] [inst_2 : TopologicalSpace Î²]\n  [inst_3 : TopologicalAddGroup Î²] [inst_4 : T2Space Î²] {f : Î± â†’ Î²} {Fâ‚ Fâ‚‚ : Î± â†’ Î²},\n  Continuous f â†’ (âˆ€ x, Fâ‚ x = Fâ‚ xâ‚€ + âˆ« t in xâ‚€..x, f t) â†’ (âˆ€ x, Fâ‚‚ x = Fâ‚‚ xâ‚€ + âˆ« t in xâ‚€..x, f t) â†’ Fâ‚ = Fâ‚‚ ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] [inst_3 : NormedAddCommGroup Î²] {Î© : Set Î±}\n  (f : Î± â†’ Î²) (F G : Î± â†’ Î²), ContinuousOn f Î© â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt F (f x) Î© x) â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt G (f x) Î© x) â†’\n  âˆƒ C : Î², âˆ€ x âˆˆ Î©, F x = G x + C ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±]\n  [inst_3 : AddGroup Î²] [inst_4 : TopologicalAddGroup Î²] {f : Î± â†’ Î²} {Fâ‚ Fâ‚‚ : Î± â†’ Î²},\n  Continuous f â†’ (âˆ€ x : Î±, Fâ‚ x = Fâ‚‚ x + f x) â†’ (âˆ€ x : Î±, Fâ‚‚ x = Fâ‚ x + f x) â†’ Fâ‚ = Fâ‚‚ ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] [inst_3 : T2Space Î²]\n  [inst_4 : AddCommGroup Î²] [inst_5 : TopologicalAddGroup Î²] {Î© : Set Î±} {f : Î± â†’ Î²} {F G : Î± â†’ Î²},\n  ContinuousOn f Î© â†’ (âˆ€ x âˆˆ Î©, HasDerivativeAt F (f x) x) â†’ (âˆ€ x âˆˆ Î©, HasDerivativeAt G (f x) x) â†’ âˆƒ C : Î², âˆ€ x âˆˆ Î©, F x = G x + C "
    ]
  },
  {
    "docString": "Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the first quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\\n  [inst_7 : ContinuousSMul R M] (f : M â†’L[R] R), f â‰  0 â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero continuous linear functional is open. \"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C :=\n\n/-- A nonzero continuous linear functional is open. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\n  [inst_7 : ContinuousSMul R M] (f : M â†’L[R] R), f â‰  0 â†’ IsOpenMap â†‘f :=\n\n/-- Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : BoundedSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {Ï† : M â†’ M} {zâ‚€ : M},\n  MDifferentiable I (modelWithCornersSelf â„‚ M) Ï† â†’ Ï† zâ‚€ = zâ‚€ â†’\n    (mfderiv I (modelWithCornersSelf â„‚ M) Ï† zâ‚€).1 = 1 â†’ âˆ€ (a b : M), Ï† a = Ï† b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {Î© : Set M} [inst_7 : IsOpen Î©]\n  [inst_8 : IsBounded Î©] {f : M â†’ M} [inst_9 : MDifferentiable I I f] {zâ‚€ : M}, f zâ‚€ = zâ‚€ â†’\n    (df zâ‚€).mdifferentiable I I = 1 â†’ f = linear_map.id ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : BoundedSpace M]\n  [inst_8 : OpenSpace M] [inst_9 : ChartedSpace H M] [inst_10 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’\n    (âˆƒ zâ‚€ : M, f zâ‚€ = zâ‚€ âˆ§ fderiv_within_at â„‚ f (exterior M) zâ‚€ = 1) â†’\n      âˆ€ (a b : M), f (a + b) = f a + f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H} [inst_5 : ModelWithCorners.Boundaryless I]\n  {M : Type u_3} [inst_6 : TopologicalSpace M] {Î© : Set M} [inst_7 : Bounded Î©] [inst_8 : IsOpen Î©] [inst_9 : ChartedSpace H M]\n  [inst_10 : SmoothManifoldWithCorners I M] {f : M â†’ M} {zâ‚€ : M}, f zâ‚€ = zâ‚€ â†’ DerivativeAt I (modelWithCornersSelf â„‚ M) f zâ‚€ = 1 â†’\n  (âˆ€ z âˆˆ Î©, f z = z) â†’ MDifferentiable I (modelWithCornersSelf â„‚ M) f â†’ IsLinearMap â„‚ f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’\n    (âˆƒ (zâ‚€ : M), f zâ‚€ = zâ‚€ âˆ§ HasDerivAt f 1 zâ‚€) â†’ LinearIsometryEquiv â„‚ â„‚ f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {Î© : Set M} [inst_7 : IsOpen Î©]\n  [inst_8 : Bounded â„ Î©] {f : M â†’ M} {zâ‚€ : M}, f zâ‚€ = zâ‚€ â†’ IsHolomorphicOn Î© f â†’\n    (HasDerivAt f 1 zâ‚€ âˆ§ ContinuousOn f Î©) â†’ (âˆƒ (A : â„‚) (B : â„‚), âˆ€ (z : M), z âˆˆ Î© â†’ f z = A * z + B) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M] [inst_5 : CompactSpace M]\n  [inst_6 : ChartedSpace H M] [inst_7 : SmoothManifoldWithCorners I M] {f : M â†’ H},\n  MDifferentiable I (modelWithCornersSelf â„‚ H) f â†’\n  (âˆƒ zâ‚€ : M, f zâ‚€ = zâ‚€ âˆ§ MFderiv I (modelWithCornersSelf â„‚ H) f zâ‚€ = ContinuousLinearMap.id â„‚ H) â†’ IsLinearMap â„‚ f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : BoundedOpen M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ M} {zâ‚€ : M},\n  MDifferentiable I I f â†’ f zâ‚€ = zâ‚€ â†’ deriv f zâ‚€ = 1 â†’ (âˆƒ c : â„‚, âˆ€ (z : M), f z = c * z) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M â†’ M},\n  MDifferentiable I (modelWithCornersSelf â„‚ M) f â†’\n  (âˆƒ z0, f z0 = z0 âˆ§ â‡‘(MDeriv I (modelWithCornersSelf â„‚ M) f z0) = 1) â†’ âˆ€ z : M, f z = z + (z - z0) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F} {zâ‚€ : M},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ f zâ‚€ = zâ‚€ â†’ mfderiv I (modelWithCornersSelf â„‚ F) f zâ‚€ = 1 â†’\n  âˆ€ (a : M), f a = a + (a - zâ‚€) "
    ]
  },
  {
    "docString": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, âˆ)`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. -/\ntheorem âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1) :=\n\n/-- `exp (-b * x)` is integrable on `(a, âˆ)`. -/\ntheorem âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$. -/\ntheorem",
    "choices": [
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in â„, Real.cos x / (x^2 + a^2) = Ï€ * Real.exp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in (-âˆ, âˆ), (cos x) / (x^2 + a^2) = Ï€ * (rexp (-a)) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (Real.cos x) / (x^2 + a^2) = Ï€ * (Real.exp (-a)) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in â„, (cos x) / (x^2 + a^2) = Ï€ * exp (-a) / a ",
      "âˆ€ (a : â„) (h : 0 < a), âˆ« (x : â„) in Set.IntervalicSpace â„, (cos x) / (x^2 + a^2) = Ï€ * (exp (-a) / a) ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in Set.Ioo (-âˆ) âˆ, (Real.cos x) / (x^2 + a^2) = Real.pi * Real.exp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ (âˆ« (x : â„) in Set.univ, (Real.cos x) / (x^2 + a^2)) = Ï€ * (Real.exp (-a)) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in Set.Iic (-âˆ) âŠ” Set.Ici (âˆ), (Real.cos x) / (x^2 + a^2) = Ï€ * (Real.exp (-a)) / a ",
      "forall {a : â„}, 0 < a â†’\n  âˆ« (x : â„) in â„, (cos x) / (x^2 + a^2) = Ï€ * (exp (-a) / a) ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in Set.Iic (-âˆ) âˆª Set.Ici (âˆ), (cos x) / (x^2 + a^2) = Ï€ * exp (-a) / a "
    ]
  },
  {
    "docString": "Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„), Real.cos x â‰  0 â†’ deriv (fun y => Real.tan y - y) x = â†‘1 / Real.cos x ^ 2 - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. \"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x)) :=\n\n/-- The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. -/\ntheorem âˆ€ (x : â„), Real.cos x â‰  0 â†’ deriv (fun y => Real.tan y - y) x = â†‘1 / Real.cos x ^ 2 - 1 :=\n\n/-- The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n :=\n\n/-- Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$. -/\ntheorem",
    "choices": [
      "âˆ€ (a b : â„),\n  âˆ« (x : â„) in 0..1, Real.log (Real.sin (Ï€ * x)) =\n    - Real.log 2 ",
      "âˆ€ {a b : â„},\n  âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  âˆ« (x : A) in 0..1, Real.log (Real.sin (Ï€ * x)) = -Real.log 2 ",
      "âˆ€ {a b : â„},\n  âˆ« (x : â„) in a..b, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ€ {a b : â„},\n  âˆ« (x : â„) in a..b, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« x in 0..1, Real.log (Real.sin (Real.pi * x)) = - Real.log 2 ",
      "âˆ«â‚€Â¹ (Î» x => Real.log (Real.sin (Real.pi * x))) = - Real.log 2 ",
      "âˆ€ {a b : â„}, a = 0 â†’ b = 1 â†’\n  âˆ« (x : â„) in a..b, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ€ (a b : â„),\n  (âˆ« (x : â„) in 0..1, Real.log (Real.sin (real.pi * x))) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 "
    ]
  },
  {
    "docString": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\\n  0 â‰¤ R â†’\\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\\n      Set.Countable s â†’\\n        ContinuousOn f (Metric.closedBall c R) â†’\\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\n  0 â‰¤ R â†’\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\n      Set.Countable s â†’\n        ContinuousOn f (Metric.closedBall c R) â†’\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0 :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E], Â¬âˆƒ (f : â„‚ â†’ E),\n  MDifferentiableWithinAt (modelWithCornersSelf â„‚ E) f (Metric.Ball 0 1) âˆ§\n    ContinuousOn f (Metric.closedBall 0 1) âˆ§ (âˆ€ (z : â„‚), z âˆˆ Metric.Sphere 0 1 â†’ f z = 1 / z) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚},\n  MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f â†’\n    ContinuousOn f (Closure (Metric.Ball 0 1)) â†’\n      (âˆ€ (z : â„‚), HasMem.Mem z (Metric.Sphere 0 1) â†’ f z = 1 / z) â†’ False ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’\n    ContinuousOn f (Metric.Sphere (0 : â„‚) 1) â†’ (âˆ€ z âˆˆ Metric.Sphere (0 : â„‚) 1, f z = 1 / z) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’\n    ContinuousOn f (Closure (PseudoMetric.ball (0 : â„‚) 1)) â†’\n      (âˆ€ (z : â„‚), z âˆˆ PseudoMetric.ball (0 : â„‚) 1 â†’ f z = zâ»Â¹) â†’ False ",
      "nonexistent_holomorphic_on_unit_disk_extending_continuous_on_boundary_eq_inv_z :\n  Â¬âˆƒ (f : â„‚ â†’ â„‚),\n    MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f âˆ§\n      ContinuousOn f (Metric.closedBall 0 1) âˆ§\n        âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = zâ»Â¹ ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚},\n  MDifferentiable I I f â†’ ContinuousOn f (Closure (Metric.Ball 0 1)) â†’\n  (âˆ€ (z : â„‚), âˆ¥zâˆ¥ = 1 â†’ f z = zâ»Â¹) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : CompactSpace M] [inst_6 : ChartedSpace H M] [inst_7 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚},\n  MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f â†’\n    ContinuousOn f (Frontier (Metric.Ball 0 1 : Set M)) â†’\n      (âˆ€ z âˆˆ Frontier (Metric.Ball 0 1 : Set M), f z = Complex.inv z) â†’ False ",
      "âˆƒ (f : â„‚ â†’ â„‚), HolomorphicOn f (Disk 0 1) âˆ§ ContinuousOn f (Closure (Disk 0 1)) âˆ§ âˆ€ (z : â„‚), z âˆˆ Circle (0, 1) â†’ f z = 1 / z â†’ False ",
      "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E],\n  Â¬(âˆƒ (f : â„‚ â†’ E), ContinuousOn f (Metric.closedBall 0 1) âˆ§ MDifferentiableAtâ„‚ I (modelWithCornersSelf â„‚ E) f (interior (Metric.closedBall 0 1)) âˆ§ âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = 1 / z) ",
      "no_continuous_holomorphic_extends_to_boundary_unit_disc :\n  Â¬ âˆƒ (f : â„‚ â†’ â„‚) (H : ContinuousOn f (Metric.closedBall 0 1)),\n      MDifferentiable (modelWithCornersSelf â„‚ â„‚) (modelWithCornersSelf â„‚ â„‚) f âˆ§\n        âˆ€ (z : â„‚), z âˆˆ Frontier (Metric.ball (0 : â„‚) 1) â†’ f z = 1 / z "
    ]
  },
  {
    "docString": "For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$",
    "prompts": "[{\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$ -/\ntheorem",
    "choices": [
      "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚}, Complex.abs zâ‚ = 1 â†’ Complex.abs zâ‚‚ = 1 â†’ Complex.abs zâ‚ƒ = 1 â†’ Complex.abs zâ‚„ = 1 â†’ zâ‚ â‰  1 â†’ zâ‚‚ â‰  1 â†’ zâ‚ƒ â‰  1 â†’ zâ‚„ â‰  1 â†’ (3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„) â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, abs z1 = 1 â†’ z1 â‰  1 â†’ abs z2 = 1 â†’ z2 â‰  1 â†’ abs z3 = 1 â†’ z3 â‰  1 â†’ abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, \n  abs z1 = 1 â†’ z1 â‰  1 â†’\n  abs z2 = 1 â†’ z2 â‰  1 â†’\n  abs z3 = 1 â†’ z3 â‰  1 â†’\n  abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  List.TFAE [(abs zâ‚ = 1 âˆ§ zâ‚ â‰  1), (abs zâ‚‚ = 1 âˆ§ zâ‚‚ â‰  1), (abs zâ‚ƒ = 1 âˆ§ zâ‚ƒ â‰  1), (abs zâ‚„ = 1 âˆ§ zâ‚„ â‰  1)] â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, \n  (Complex.abs z1 = 1 âˆ§ z1 â‰  1) â†’ \n  (Complex.abs z2 = 1 âˆ§ z2 â‰  1) â†’ \n  (Complex.abs z3 = 1 âˆ§ z3 â‰  1) â†’ \n  (Complex.abs z4 = 1 âˆ§ z4 â‰  1) â†’ \n  (3 - z1 - z2 - z3 - z4 + (z1 * z2 * z3 * z4) â‰  0) ",
      "âˆ€ (z1 z2 z3 z4 : â„‚), abs z1 = 1 â†’ z1 â‰  1 â†’ abs z2 = 1 â†’ z2 â‰  1 â†’ abs z3 = 1 â†’ z3 â‰  1 â†’ abs z4 = 1 â†’ z4 â‰  1 â†’ (3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0) ",
      "âˆ€ (z1 z2 z3 z4 : â„‚), abs z1 = 1 â†’ z1 â‰  1 â†’ abs z2 = 1 â†’ z2 â‰  1 â†’ abs z3 = 1 â†’ z3 â‰  1 â†’ abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {j : â„•} (hj : j âˆˆ [1, 2, 3, 4]) (z : â„‚), abs z = 1 â†’ z â‰  1 â†’ 3 - (List.algebra_map â„• â„‚ [z1, z2, z3, z4]).sum â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, abs z1 = 1 â†’ abs z2 = 1 â†’ abs z3 = 1 â†’ abs z4 = 1 â†’ z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ (3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4) â‰  0 ",
      "âˆ€ (z1 z2 z3 z4 : â„‚), \n  (âˆ€ j : â„•, j âˆˆ [1, 2, 3, 4] â†’ Complex.abs (by_cases (j = 1) z1 (by_cases (j = 2) z2 (by_cases (j = 3) z3 z4))) = 1) â†’\n  (âˆ€ j : â„•, j âˆˆ [1, 2, 3, 4] â†’ by_cases (j = 1) z1 (by_cases (j = 2) z2 (by_cases (j = 3) z3 z4)) â‰  1) â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 "
    ]
  },
  {
    "docString": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\\n  0 â‰¤ R â†’\\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\\n      Set.Countable s â†’\\n        ContinuousOn f (Metric.closedBall c R) â†’\\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"}]\n",
    "prompt_cons": "/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\n  0 â‰¤ R â†’\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\n      Set.Countable s â†’\n        ContinuousOn f (Metric.closedBall c R) â†’\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0 :=\n\n/-- Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ (Finset.sum (Finset.range n) (pow z)) â‰  0 ",
      "forall (n : â„•), n > 0 â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ (Finset.sum (Finset.range n) (pow z) * (n - z * Finset.sum (Finset.range n) (pow z))) â‰  0 ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬(Polynomial.eval z (Polynomial.sumFinRangePoly n) = 0) ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬(Polynomial.sum (Finset.range n) (Î» (i : â„•), Polynomial.C (n - i) * Polynomial.x ^ i)).eval z = 0 ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬(Polynomial.eval z (Polynomial.range n) = 0) ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ {z : â„‚}, â†‘Complex.abs z â‰¤ 1 â†’ Complex.rootOfUnity n (f_n z) ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ {z : â„‚}, â†‘Complex.abs z â‰¤ 1 â†’ (Finset.sum (Finset.range n) (Î» (i : â„•), z ^ i * (n - i))) â‰  0 ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Complex.rootOfUnity (n, f_n z) ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ {z : â„‚}, â†‘Complex.abs z â‰¤ 1 â†’ Â¬(Polynomial.eval z (Polynomial.bernstein n) = 0) ",
      "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ {z : â„‚}, â†‘Complex.abs z â‰¤ 1 â†’ Â¬(Complex.poly_X_sub_C_pow (n - 1) z = 0) "
    ]
  },
  {
    "docString": "Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\\ndisc `Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\\n`Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ âˆ€ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\\nsame power series around `x + y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] (Ï† : PowerSeries R), IsUnit Ï† â†’ IsUnit (â†‘(PowerSeries.constantCoeff R) Ï†)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a formal power series is invertible, then so is its constant coefficient.\"}]\n",
    "prompt_cons": "/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\n`Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ âˆ€ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r :=\n\n/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] (Ï† : PowerSeries R), IsUnit Ï† â†’ IsUnit (â†‘(PowerSeries.constantCoeff R) Ï†) :=\n\n/-- Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational. -/\ntheorem",
    "choices": [
      "Sorry, I cannot prove this theorem as it requires proving results about irrational numbers, which is beyond the scope of Lean Theorem Prover code translation.",
      "âˆ€ {R : Type u_1} [inst : Semiring R] (f : PowerSeries R),\n  (âˆ€ i, f.coeff i = 0 âˆ¨ f.coeff i = 1) â†’\n    f.eval (2 / 3) = 3 / 2 â†’\n      Irrational (f.eval (1 / 2)) ",
      "Sorry, I cannot provide a direct Lean theorem for this specific problem as it involves proving a property about a specific function and its coefficients rather than a general theorem. However, I can suggest an outline of how you might approach proving this in Lean:\n\n1. Define the power series `f` with coefficients `c_i` as given in the problem statement.\n2. Prove that `f(2/3) = 3/2` using the power series expansion and given condition on the coefficients.\n3. Assume, for contradiction, that `f(1/2)` is rational, and derive a contradiction from this assumption using the properties of the power series and its coefficients.\n4. Conclude that `f(1/2)` must be irrational.\n\nThis outline can help you create a proof in Lean, but you'll need to fill in the details and construct the necessary intermediate theorems and lemmas.",
      "âˆ€ {R : Type u_1} [inst : Semiring R] (f : PowerSeries R),\n  (âˆ€ n, PowerSeries.coeff R n f = 0 âˆ¨ PowerSeries.coeff R n f = 1) â†’\n    f (2 / 3) = 3 / 2 â†’\n      Â¬ (âˆƒ q : â„š, f (1 / 2) = â†‘q) ",
      "I'm sorry, but I cannot prove this theorem as it involves real analysis and number theory, which are not within the scope of Lean Theorem Prover code translation. Please provide another example for me to follow.",
      "I cannot prove this theorem directly in Lean Theorem Prover, as it requires knowledge of irrational numbers which is not available in the Lean language. However, I can help you translate the statement of the theorem into Lean code:\n\ntheorem irrational_half_power_series :\n  (âˆ€ (f : â„• â†’ â„š) (x : â„š), (âˆ€ (n : â„•), f n = 0 âˆ¨ f n = 1) â†’\n    (x = 2 / 3 â†’ (âˆ‘ n in Finset.range(â„•.succ(sorry)), (f n) * (x ^ n)) = 3 / 2) â†’\n      x = 1 / 2 â†’ âˆƒ (m : â„•), (âˆ‘ n in Finset.range(â„•.succ(sorry)), (f n) * (x ^ n)) â‰  (m : â„š))) ",
      "/-- If a power series `f(x) = âˆ‘â‚™ câ‚™ xâ¿` has coefficients `câ‚™` in `{0, 1}` and `f(2/3) = 3/2`,\nthen `f(1/2)` must be irrational. -/\ntheorem irrational_f_half {f : â„• â†’ â„š} :\n  (âˆ€ n, f n = 0 âˆ¨ f n = 1) â†’\n  ((âˆ‘' n, f n * (2/3)^n) = 3/2) â†’\n  Irrational (â„š[[X]]).eval (1/2) (PowerSeries.mk f) ",
      "âˆ€ {R : Type u_1} [inst : Semiring R] (f : PowerSeries R) (hf : âˆ€ i, (PowerSeries.coeff R i f = 0) âˆ¨ (PowerSeries.coeff R i f = 1)),\n  f (2/3) = 3/2 â†’ Irrational (PowerSeries.eval R f (1/2)) ",
      "Sorry, I cannot prove this theorem as it is a non-formal mathematical statement and it cannot be directly translated into Lean Theorem Prover code. Please provide a formal mathematical statement that can be translated to Lean code.",
      "âˆ€ {R : Type u_1} [inst : Semiring R] (f : PowerSeries R),\n  (âˆ€ (i : â„•), (PowerSeries.coeff R i f = 0) âˆ¨ (PowerSeries.coeff R i f = 1)) â†’\n    (f (2 / 3) = 3 / 2) â†’\n      Irrational (f (1 / 2)) "
    ]
  },
  {
    "docString": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬(Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1)) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) "
    ]
  },
  {
    "docString": "Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1) :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), âˆƒ k, (âˆƒ xâ‚ yâ‚, k = xâ‚ ^ 2 + yâ‚ ^ 2) âˆ§ (âˆƒ xâ‚‚ yâ‚‚, k + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2) âˆ§ (âˆƒ xâ‚ƒ yâ‚ƒ, k + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
      "âˆ€ (n : â„•), âˆƒ m, (âˆƒ x y, m = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, m + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, m + 2 = r ^ 2 + s ^ 2) ",
      "âˆƒ f : â„• â†’ â„•, âˆ€ n, (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, f n + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, f n + 2 = r ^ 2 + s ^ 2) ",
      "âˆƒ N : â„• â†’ â„•, âˆ€ n, âˆƒ x y z w t u, n = N n âˆ§ N n = x ^ 2 + y ^ 2 âˆ§ N n + 1 = z ^ 2 + w ^ 2 âˆ§ N n + 2 = t ^ 2 + u ^ 2 ",
      "âˆ€ (n : â„•), âˆƒ m, (âˆƒ x y, m = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, m + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, m + 2 = r ^ 2 + s ^ 2) ",
      "âˆƒ f : â„• â†’ â„•, âˆ€ n, (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, f n + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, f n + 2 = r ^ 2 + s ^ 2) ",
      "âˆ€ (n : â„•), âˆƒ m, (âˆƒ xâ‚ yâ‚, m = xâ‚ ^ 2 + yâ‚ ^ 2) âˆ§ (âˆƒ xâ‚‚ yâ‚‚, m + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2) âˆ§ (âˆƒ xâ‚ƒ yâ‚ƒ, m + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
      "âˆƒ f : â„• â†’ â„•, âˆ€ n, (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, (f n) + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, (f n) + 2 = r ^ 2 + s ^ 2) ",
      "âˆ€ (n : â„•), âˆƒ m, (âˆƒ x y, m = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, m + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, m + 2 = r ^ 2 + s ^ 2) ",
      "âˆ€ (n : â„•), âˆƒ a b c d e f g h, n = a ^ 2 + b ^ 2 âˆ§ n + 1 = c ^ 2 + d ^ 2 âˆ§ n + 2 = e ^ 2 + f ^ 2 âˆ§ n + 3 = g ^ 2 + h ^ 2 "
    ]
  },
  {
    "docString": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\\n  DifferentiableOn â„ f s â†’\\n    ContinuousWithinAt f s a â†’\\n      s âˆˆ nhdsWithin a (Set.Ioi a) â†’\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the right of a point `a : â„`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. \"}]\n",
    "prompt_cons": "/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- If a function is differentiable on the right of a point `a : â„`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\n  DifferentiableOn â„ f s â†’\n    ContinuousWithinAt f s a â†’\n      s âˆˆ nhdsWithin a (Set.Ioi a) â†’\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Ici a) a :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C :=\n\n/-- Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆ€ x, ContinuousAt (deriv (deriv (deriv f))) x) â†’\n    âˆƒ a, HasDerivAt f (deriv (deriv (deriv f)) a / 6) a ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Continuous (deriv (deriv (deriv f))) â†’\n    âˆƒ a, deriv (deriv (deriv f)) a = 0 âˆ§ deriv (deriv f) a = 0 âˆ§ deriv f a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Continuous (deriv^[3] f) â†’ âˆƒ a, deriv^[2] f a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆƒ f''', Continuous f''') â†’\n    (âˆƒ a, HasDerivAt f (deriv (deriv (deriv f))) a) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Continuous (deriv^[3] f) â†’ âˆƒ a, deriv^[3] f a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Continuous (deriv^[3] f) â†’\n    âˆƒ a : â„, deriv^[2] f a = 0 âˆ§ deriv f a = 0 âˆ§ f a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {a : â„},\n  ContinuousOn (deriv^[3]) f Set.univ â†’ âˆƒ a, deriv^[3] f a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Continuous (fun x => deriv^[3] f x) â†’\n    âˆƒ a, deriv^[2] f a = 0 âˆ§\n          (deriv^[2] f a = deriv f a âˆ§ deriv^[2] f a = f a) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Continuous (deriv^[3] f) â†’\n    âˆƒ a, HasDerivAt f (deriv f a) a âˆ§ HasDerivAt (deriv f) (deriv^[2] f a) a âˆ§ HasDerivAt (deriv^[2] f) (deriv^[3] f a) a ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {a : â„},\n  Continuous (deriv^[3] f) â†’\n    âˆƒ a, deriv^[2] f a = 0 "
    ]
  },
  {
    "docString": "Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\\n  Function.Injective â†‘(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrder Î±] {f : Fin n â†’ Î±}, Tuple.sort f = Equiv.refl (Fin n) â†” Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The permutation that sorts `f` is the identity if and only if `f` is monotone. \"}]\n",
    "prompt_cons": "/-- An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. -/\ntheorem âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\n  Function.Injective â†‘(Con.kerLift f) :=\n\n/-- The permutation that sorts `f` is the identity if and only if `f` is monotone. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrder Î±] {f : Fin n â†’ Î±}, Tuple.sort f = Equiv.refl (Fin n) â†” Monotone f :=\n\n/-- Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±]\n  {f : â„• â†’ â„•} (hf : Function.Injective f) {p : â„• â†’ Î±} (l : Î±),\n  Filter.Tendsto p Filter.atTop (nhds l) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•} (hf : Function.Injective f),\n  Filter.Tendsto p Filter.atTop (nhds (lim at_top p)) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (lim at_top p)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’ Filter.Tendsto p Filter.atTop (nhds L) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds L) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’ (Filter.Tendsto p Filter.atTop (nhds l) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’ Filter.Tendsto p Filter.atTop (nhds (Limâ‚“ Filter.atTop p)) â†’\n  Filter.Tendsto (fun k => p (f k)) Filter.atTop (nhds (Limâ‚“ Filter.atTop p)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto p Filter.atTop (nhds a) â†’ Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•}, Function.Injective f â†’\n  Filter.Tendsto p Filter.atTop Filter.atTop â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] {f : â„• â†’ Î±} {g : â„• â†’ â„•},\n  Function.Injective g â†’ (Filter.Tendsto f Filter.atTop (nhds (x : Î±)) â†” Filter.Tendsto (f âˆ˜ g) Filter.atTop (nhds x)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} (hf : Function.Injective f) {p : â„• â†’ Î±},\n  Filter.Tendsto p Filter.atTop (Filter.atTop) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (Filter.atTop) ",
      "âˆ€ {Î± : Type} {p : â„• â†’ Î±} {f : â„• â†’ â„•} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±]\n  (hf : Function.Injective f) (lim : Filter.Tendsto p Filter.atTop (nhds (l : Î±))),\n  Filter.Tendsto (fun n => p (f n)) Filter.atTop (nhds l) "
    ]
  },
  {
    "docString": "Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"}]\n",
    "prompt_cons": "/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (F : (Set X) â†’ (Set X)), (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (F U)) âˆ§ (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (F K)) âˆ§\n    (âˆ€ (U V : Set X), IsOpen U â†’ IsOpen V â†’ F U = F V â†’ U = V) âˆ§ (âˆ€ (K L : Set X), IsClosed K â†’ IsClosed L â†’ F K = F L â†’ K = L) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (F : (Set X) â†’ (Set X)), (âˆ€ U, IsOpen U â†’ IsClosed (F U)) âˆ§ (âˆ€ K, IsClosed K â†’ âˆƒ U, IsOpen U âˆ§ F U = K) âˆ§ (âˆ€ Uâ‚ Uâ‚‚, IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ F Uâ‚ = F Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : (Set X â†’ Prop) â†’ (Set X â†’ Prop)),\n    ((âˆ€ (U : Set X), IsOpen U â†” IsClosed (f U)) âˆ§ (âˆ€ (K : Set X), IsClosed K â†” IsOpen (f K))) âˆ§\n      (âˆ€ (Uâ‚ Uâ‚‚ : Set X), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ f Uâ‚ = f Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) âˆ§\n        (âˆ€ (Kâ‚ Kâ‚‚ : Set X), IsClosed Kâ‚ â†’ IsClosed Kâ‚‚ â†’ f Kâ‚ = f Kâ‚‚ â†’ Kâ‚ = Kâ‚‚) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace X], âˆƒ (f : Set X â†’ Set X),\n  (âˆ€ (A : Set X), IsOpen A â†’ IsClosed (f A)) âˆ§\n    (âˆ€ (B : Set X), IsClosed B â†’ IsOpen (f B)) âˆ§\n      (âˆ€ (A B : Set X), IsOpen A â†’ IsClosed B â†’ f A = B â†” A = f B) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set X â†’ Set X), (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (f U)) âˆ§ (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (f K)) âˆ§\n  (âˆ€ (Uâ‚ Uâ‚‚ : Set X), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ (f Uâ‚ = f Uâ‚‚ â†” Uâ‚ = Uâ‚‚)) âˆ§\n  (âˆ€ (Kâ‚ Kâ‚‚ : Set X), IsClosed Kâ‚ â†’ IsClosed Kâ‚‚ â†’ (f Kâ‚ = f Kâ‚‚ â†” Kâ‚ = Kâ‚‚)) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X], âˆƒ (f : {s : Set X // IsOpen s} â‰ƒ {s : Set X // IsClosed s}),\n  âˆ€ (s : Set X) (hs : IsOpen s), f âŸ¨s, hsâŸ© = âŸ¨X \\ s, IsClosed.compl hsâŸ© ",
      "âˆ€ (X : Type u_1) [inst : MetricSpace X],\n  âˆƒ (f : (Set X â†’ Prop) â†’ (Set X â†’ Prop)),\n    (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (f U)) âˆ§\n      (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (f K)) âˆ§\n        (âˆ€ (U : Set X), IsOpen U â†’ f (f U) = U) âˆ§\n          (âˆ€ (K : Set X), IsClosed K â†’ f (f K) = K) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (Ï† : (Set X â†’ Set X)), (âˆ€ (U : Set X), IsOpen U â†” IsClosed (Ï† U)) âˆ§ (âˆ€ (K : Set X), IsClosed K â†” IsOpen (Ï† K)) âˆ§\n    (âˆ€ (U : Set X), Ï† (Ï† U) = U) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (F : (Set X â†’ Set X)),\n    (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (F U)) âˆ§\n    (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (F K)) âˆ§\n    (âˆ€ (U : Set X), IsOpen U â†’ F (F U) = U) âˆ§\n    (âˆ€ (K : Set X), IsClosed K â†’ F (F K) = K) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X], âˆƒ (Ïˆ : (Set X â†’ Set X)),\n  (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (Ïˆ U)) âˆ§\n    (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (Ïˆ K)) âˆ§\n      (âˆ€ (A B : Set X), Ïˆ A = Ïˆ B â†’ A = B) âˆ§\n        (âˆ€ (A B : Set X), A = B â†’ Ïˆ A = Ïˆ B) "
    ]
  },
  {
    "docString": "Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] (B : â„),\\n  Set.Finite {x | IsIntegral â„¤ x âˆ§ âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– â‰¤ B}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\\nsmaller in norm than `B` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded below \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  Metric.Bounded s â†’ IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded \"}]\n",
    "prompt_cons": "/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] (B : â„),\n  Set.Finite {x | IsIntegral â„¤ x âˆ§ âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– â‰¤ B} :=\n\n/-- A compact set is bounded below -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddBelow s :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  Metric.Bounded s â†’ IsCompact (closure s) :=\n\n/-- A compact set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ Metric.Bounded s :=\n\n/-- Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact. -/\ntheorem",
    "choices": [
      "âˆ€ {m : â„•} [inst : NormedGroup â„[m]] [inst_1 : FiniteDimensional â„ â„[m]],\n  IsCompact {x : â„[m] | âˆ¥xâˆ¥ â‰¤ 1} ",
      "âˆ€ {m : â„•} [inst : Fintype m] (f : â„ â†’ â„) [inst_1 : NormedGroup â„] [inst_2 : NormedSpace â„ â„],\n  IsCompact {x : â„^m | âˆ¥xâˆ¥ â‰¤ 1} ",
      "âˆ€ {m : â„•}, IsCompact {x : â„^m | âˆ¥xâˆ¥ â‰¤ 1} ",
      "âˆ€ {m : â„•} [inst : NormedField â„] [inst_1 : Fintype (Finâ‚“ m)] [inst_2 : NormedSpace â„ (Finâ‚“ m â†’ â„)],\n  IsCompact {x : Finâ‚“ m â†’ â„ | âˆ¥xâˆ¥ â‰¤ 1} ",
      "âˆ€ (m : â„•) (norm : â„ â†’ â„) (inst : âˆ€ (x y : â„), norm (x + y) â‰¤ norm x + norm y) (inst_1 : âˆ€ (x : â„), norm x = 0 â†” x = 0)\n  (inst_2 : âˆ€ (x : â„) (c : â„), norm (c * x) = abs c * norm x),\n  IsCompact {x : Finâ‚“ m â†’ â„ | âˆ€ (i : Finâ‚“ m), norm (x i) â‰¤ 1} ",
      "âˆ€ {m : â„•} [inst : Fintype m] [inst_1 : PseudoMetricSpace â„]\n  (norm : (Î  (_x : m), â„) â†’ â„) [inst_2 : âˆ€ (x : Î  (_x : m), â„), Isometry (Î» (y : Î  (_x : m), â„), norm (x - y))],\n  IsCompact {x : Î  (_x : m), â„ | norm x â‰¤ 1} ",
      "âˆ€ {m : â„•} [inst : Fintype (Finâ‚“ m)] [inst_1 : NormedGroup (EuclideanSpace â„ (Finâ‚“ m))],\n  IsCompact {x : EuclideanSpace â„ (Finâ‚“ m) | âˆ¥xâˆ¥ â‰¤ 1} ",
      "forall {m : â„•} (norm : â„^m â†’ â„) [inst : NormedGroup.with_norm norm] {B : Set (â„^m)},\n  B = {x | norm x â‰¤ 1} â†’ IsCompact B ",
      "âˆ€ {m : â„•} [inst : NormedGroup â„ m], IsCompact {x : â„ m | âˆ¥xâˆ¥ â‰¤ 1} ",
      "âˆ€ {m : â„•} [inst : NormedGroup (EuclideanSpace â„ m)], IsCompact {x : EuclideanSpace â„ m | âˆ¥xâˆ¥ â‰¤ 1} "
    ]
  },
  {
    "docString": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\\n  IsClosed s â†’ âˆ€ [inst_2 : DiscreteTopology â†‘s], Cardinal.continuum â‰¤ Cardinal.mk â†‘s â†’ Â¬NormalSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\\nhas cardinality at least continuum, then the ambient space is not a normal space. \"}]\n",
    "prompt_cons": "/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\nhas cardinality at least continuum, then the ambient space is not a normal space. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\n  IsClosed s â†’ âˆ€ [inst_2 : DiscreteTopology â†‘s], Cardinal.continuum â‰¤ Cardinal.mk â†‘s â†’ Â¬NormalSpace X :=\n\n/-- Show that if $S$ is connected, it is not true in general that its interior is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Â¬IsConnected (Interior Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬IsConnected (Interior s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Not (IsConnected (Interior Î±)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Â¬(IsConnected (Interior Î±)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Â¬ConnectedSpace Î± â†’ Â¬IsConnected (Interior Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Â¬IsConnected (Interior Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±],\n  Â¬(IsConnected (Interior (â‹ƒâ‚€ self.1))) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : ConnectedSpace Î±], Â¬ConnectedSpace (Interior Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±] (s : Set Î±),\n  Â¬(IsConnected (Interior s) â†” IsConnected s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬IsConnected (Interior s) "
    ]
  },
  {
    "docString": "Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"}]\n",
    "prompt_cons": "/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : T1Space â„], Set.Countable E â†’ âˆƒ p : â„, Set.Countable (E âˆ© Metric.Ball p 1) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : T1Space â„] [inst_2 : TopologicalSpace.CountableBasis â„],\n  Set.Countable E â†’ (âˆƒ p : â„, Filter.Tendsto (fun x => x) (Filter.comap coe (nhds p)) (Filter.coclosedCompact E)) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : LinearOrder â„] [inst_2 : OrderTopology â„],\n  Set.Countable E â†’ âˆƒ p : â„, âˆƒ R : â„• â†’ â„, (âˆ€ n, R n > 0) âˆ§ Filter.Tendsto R Filter.atTop (nhds 0) âˆ§ âˆ€ n, (Set.Ioo (p - R n) (p + R n) âˆ© E).Countable ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : OrderTopology â„] [inst_2 : DenseOrder â„],\n  Set.Countable E â†’ âˆƒ p : â„, âˆ€ Îµ > (0 : â„), Set.Nonempty (Set.Ioo (p - Îµ) (p + Îµ) âˆ© E) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : LinearOrder â„] [inst_2 : OrderTopology â„] [inst_3 : DenselyOrdered â„],\n  Set.Countable E â†’ âˆƒ p, âˆ€ Îµ > 0, Set.Countable (E âˆ© (Set.Ioo (p - Îµ) (p + Îµ))) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : LinearOrder â„] [inst_2 : OrderTopology â„] [inst_3 : DenselyOrdered â„],\n  Set.Countable E â†’ âˆƒ p : â„, âˆ€ s : â„•, âˆƒ x âˆˆ E, p - (1 / (s + 1)) < x âˆ§ x < p + (1 / (s + 1)) ",
      "âˆ€ (E : Set â„) [inst : TopologicalSpace â„] [inst_1 : TopologicalSpace.FirstCountableTopology â„] [inst_2 : TopologicalSpace.SecondCountableTopology â„],\n  Set.Countable E â†’ âˆƒ (p : â„), âˆ€ (U : Set â„), U âˆˆ nhds p â†’ Set.Countable (E âˆ© U) ",
      "âˆ€ {E : Set â„} [inst : Infinite E] [inst_1 : Nonempty E], âˆƒ p : â„, Set.Countable (E âˆ© Metric.Ball p 1) ",
      "âˆ€ {E : Set â„} (hE : Set.Countable Eá¶œ), âˆƒ p : â„, IsCondensationPoint E p ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : T1Space â„] [inst_2 : TopologicalSpace.CountableBasis â„]\n  [inst_3 : Uncountable E], âˆƒ p, condensation_point_of E p "
    ]
  },
  {
    "docString": "Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), Filter.Tendsto (fun x => x ^ n * rexp (-x)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x^n * exp(-x)` tends to `0` at `+âˆ`, for any natural number `n`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"}]\n",
    "prompt_cons": "/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- The function `x^n * exp(-x)` tends to `0` at `+âˆ`, for any natural number `n`. -/\ntheorem âˆ€ (n : â„•), Filter.Tendsto (fun x => x ^ n * rexp (-x)) Filter.atTop (nhds 0) :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$. -/\ntheorem",
    "choices": [
      "Filter.Tendsto (Î» n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (Î» n, Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (Î» n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) "
    ]
  },
  {
    "docString": "Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun n => x ^ (n + 1) / (â†‘n + 1)) (-Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\": \"Power series expansion of the logarithm around `1`. \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- Power series expansion of the logarithm around `1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun n => x ^ (n + 1) / (â†‘n + 1)) (-Real.log (1 - x)) :=\n\n/-- Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬Summable (fun k => 1 / â†‘k * (Real.log â†‘k) ^ p) ",
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬Summable fun k => 1 / â†‘k * (Real.log â†‘k) ^ p ",
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬ Summable (fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) ",
      "âˆ€ {p : â„}, p â‰¤ 1 â†’ Â¬Summable (Î» k => 1 / (â†‘k * Real.log (â†‘k) ^ p)) ",
      "âˆ€ {p : â„}, p â‰¤ 1 â†’ Â¬Summable (Î» k => 1 / k * (Real.log k) ^ p) ",
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬ Summable (fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) ",
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬ Summable (fun k => 1 / â†‘k * (Real.log â†‘k) ^ p) ",
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬Summable (Î» k => 1 / â†‘k * (Real.log â†‘k) ^ p) ",
      "âˆ€ {p : â„}, p â‰¤ 1 â†’ Â¬ Summable (Î» k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) ",
      "âˆ€ {p : â„•}, (p â‰¤ 1) â†’ Â¬ Summable (Î» k => 1 / â†‘k * (Real.log â†‘k) ^ p) "
    ]
  },
  {
    "docString": "Show that a group of order 5 must be abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Show that a group of order 5 must be abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 5 â†’ CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [Fintype G],\n  Fintype.card G = 5 â†’\n    âˆ€ (x y : G), x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Fintype G] [inst_1 : Group G],\n  Fintype.card G = 5 â†’ Group.IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 5 â†’ CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : Fintype.card G = 5), IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 â†’ âˆ€ (x y : G), x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] [Fintype G],\n  Fintype.card G = 5 â†’ Group.IsAbelian G ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  Fintype.card Î± = 5 â†’\n    âˆ€ (G : Type u_1) [inst_2 : Group G], Group.IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 â†’\n    âˆ€ (x y : G), x * y = y * x "
    ]
  },
  {
    "docString": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$.",
    "prompts": "[{\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem gcd_mul_right_left {a : â„¤} {m n : â„•} (H : Int.gcd a (â†‘m * â†‘n) = 1) : Int.gcd a â†‘m = 1 ",
      "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem gcd_mul_right_left {a : â„¤} {m n : â„•} :\n  Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 "
    ]
  },
  {
    "docString": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) (h' : âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5), IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) (h_1 : âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5), CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’ (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’ âˆ€ a b : G, a * b = b * a ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  Group.IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  CommGroup G "
    ]
  },
  {
    "docString": "If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (u : MË£) (x : M), SemiconjBy (â†‘u) x (â†‘u * x * â†‘uâ»Â¹)\",\n  \"isProp\": true,\n  \"docString\": \"`a` semiconjugates `x` to `a * x * aâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. \"}]\n",
    "prompt_cons": "/-- `a` semiconjugates `x` to `a * x * aâ»Â¹`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (u : MË£) (x : M), SemiconjBy (â†‘u) x (â†‘u * x * â†‘uâ»Â¹) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x :=\n\n/-- If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$ -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), (xâ»Â¹ * a * x)â»Â¹ = xâ»Â¹ * aâ»Â¹ * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate x a) = Conjugate (xâ»Â¹ * a * x) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (a * x) = (xâ»Â¹ * Conjugate a * x) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate a x) = Conjugate a (xâ»Â¹ * x) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate (xâ»Â¹ * a * x) = xâ»Â¹ * (Conjugate a) * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x a : G), ConjugatesOf xâ»Â¹ * a * x = xâ»Â¹ * ConjugatesOf a * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), ConjugatesOf xâ»Â¹ * a * x = xâ»Â¹ * ConjugatesOf a * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate (xâ»Â¹ * a * x) = xâ»Â¹ * Conjugate a * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate a x) = Conjugate a (xâ»Â¹ * x) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x : G) (a : Con G), Quot.lift (Î» (a : G), xâ»Â¹ * a * x) (Con.leftRel xâ»Â¹ * Con.rightRel x) a = xâ»Â¹ * a * x "
    ]
  },
  {
    "docString": "If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ Nat.totient n = Finsupp.prod (Nat.factorization n) fun p k => p ^ (k - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\": \"Euler's product formula for the totient function. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"}]\n",
    "prompt_cons": "/-- Euler's product formula for the totient function. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ Nat.totient n = Finsupp.prod (Nat.factorization n) fun p k => p ^ (k - 1) * (p - 1) :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function. -/\ntheorem",
    "choices": [
      "âˆ€ {a n : â„•}, a > 1 â†’ n âˆ£ Nat.totient (a^n - 1) ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a^n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ n âˆ£ Nat.totient (a ^ n - 1) ",
      "âˆ€ {a n : â„•}, a > 1 â†’ n âˆ£ Nat.totient (a ^ n - 1) ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a^n - 1) âˆ£ n ",
      "âˆ€ {a : â„•} {n : â„•}, a > 1 â†’ â†‘(Nat.totient (a ^ n - 1)) âˆ£ n ",
      "âˆ€ {a : â„•} {n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n "
    ]
  },
  {
    "docString": "Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬ p âˆ£ m â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H â†’ Subgroup.is_characteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Nat.Coprime p m â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H â†’ Subgroup.is_complement' âŠ¥ H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} (_hp : Fact (Nat.Prime p)),\n  Fintype.card G = p * m â†’ Â¬ p âˆ£ m â†’\n    âˆ€ {H : Subgroup G} [hn : H.normal],\n      Fintype.card { x // x âˆˆ H } = p â†’ âˆ€ (g : G), âˆ€ (h : H), g * h * gâ»Â¹ âˆˆ H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)] (H : Subgroup G)\n  [hH : Fintype.card { x // x âˆˆ H } = p] [hG : Fintype.card G = p * m] (hp1m : Â¬ p âˆ£ m),\n    Subgroup.characteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hG : Fintype.card G = p * m) (hH : Fintype.card { x // x âˆˆ H } = p),\n  Nat.Coprime p m â†’ Subgroup.IsCharSubgroup H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.normal H â†’ Subgroup.is_char H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’\n    Nat.Coprime p m â†’\n      âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H â†’ Subgroup.is_char H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬(p âˆ£ m) â†’\n    âˆ€ {H : Subgroup G}, (H : Set G).Normal â†’ Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.IsChar H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬ (p âˆ£ m) â†’\n    âˆ€ {H : Subgroup G} [_norm : Subgroup.Normal H],\n      Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.characteristic_subgroup H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [_hp : Fact (Nat.Prime p)],\n  Â¬ p âˆ£ m â†’ Fintype.card G = p * m â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H â†’ Subgroup.is_characteristic H "
    ]
  },
  {
    "docString": "If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 â†’ Â¬IsCommutative G â†’ Nonempty (G â‰ƒ* SymmetricGroup (Fin 3)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 â†’ (Â¬ IsCommutative G) â†’ Nonempty (G â‰ƒ* S3) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 â†’ Nonabelian G â†’ G â‰ƒ* Sâ‚ƒ ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], \n  Fintype.card G = 6 â†’\n    Â¬ IsLieAbelian G â†’\n      Nonempty (G â‰ƒ* S3) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 â†’ Â¬IsAbelian G â†’ Nonempty (G â‰ƒ* SymmetricGroup (Fin 3)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆ€ (x y : G), x * y â‰  y * x â†’ True) â†’\n  Fintype.card G = 6 â†’\n    Nonempty (G â‰ƒ* Sâ‚ƒ) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 âˆ§ Â¬IsAbelian G â†’ Nonempty (G â‰ƒ* symmetricGroup (Fin 3)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Â¬IsAbelian G â†’ Fintype.card G = 6 â†’ Nonempty (G â‰ƒ* S_3) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆ€ (x y : G), x * y â‰  y * x) â†’ Fintype.card G = 6 â†’ Nonempty (G â‰ƒ* Sâ‚ƒ) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Â¬ IsCommutativeGroup G â†’ Fintype.card G = 6 â†’ Nonempty (G â‰ƒ* Sâ‚ƒ) "
    ]
  },
  {
    "docString": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p âˆ§ K.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ H.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Subgroup.normal H âˆ§ Fintype.card { x // x âˆˆ H } = p ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p âˆ§ K.normal ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ H.normal ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ H.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p âˆ§ Subgroup.normal K ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p âˆ§ K.normal "
    ]
  },
  {
    "docString": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "prompts": "[{\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] {m n : â„•}, \n  Int.gcd m n = 1 â†’ (âˆƒ a : G, orderOf a = m) â†’ (âˆƒ b : G, orderOf b = n) â†’ âˆƒ c : G, orderOf c = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ a : G, addOrderOf a = m) â†’ (âˆƒ b : G, addOrderOf b = n) â†’ âˆƒ c : G, addOrderOf c = m * n ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ x : G, orderOf x = m) â†’ (âˆƒ y : G, orderOf y = n) â†’ âˆƒ z : G, orderOf z = m * n ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ x : G, addOrderOf x = m) â†’ (âˆƒ y : G, addOrderOf y = n) â†’ âˆƒ z : G, addOrderOf z = m * n ",
      "forall {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ x : G, addOrderOf x = m) â†’ (âˆƒ y : G, addOrderOf y = n) â†’ âˆƒ z : G, addOrderOf z = m * n ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ (x : G), orderOf x = m) â†’ (âˆƒ (y : G), orderOf y = n) â†’ âˆƒ (z : G), orderOf z = m * n ",
      " âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’\n    (âˆƒ x : G, Additive.orderOf x = m) â†’\n    (âˆƒ y : G, Additive.orderOf y = n) â†’ âˆƒ z : G, Additive.orderOf z = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ (a : G), addOrderOf a = m) â†’ (âˆƒ (b : G), addOrderOf b = n) â†’ âˆƒ (c : G), addOrderOf c = m * n ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Int.gcd m n = 1 â†’ (âˆƒ x : G, orderOf x = m) â†’ (âˆƒ y : G, orderOf y = n) â†’ âˆƒ z : G, orderOf z = m * n ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : â„•},\n  0 < m â†’ 0 < n â†’ Int.gcd m n = 1 â†’ (âˆƒ x : G, Additive.orderOf x = m) â†’ (âˆƒ y : G, Additive.orderOf y = n) â†’ âˆƒ z : G, Additive.orderOf z = m * n "
    ]
  },
  {
    "docString": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R Ã— S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean rings is nonarchimedean. \"}]\n",
    "prompt_cons": "/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G Ã— K) :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f) :=\n\n/-- The cartesian product of two nonarchimedean rings is nonarchimedean. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R Ã— S) :=\n\n/-- Prove that any two nonabelian groups of order 21 are isomorphic. -/\ntheorem",
    "choices": [
      "forall {G H : Type} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Group H] [inst_3 : Fintype H], \n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Nonabelian G â†’ Nonabelian H â†’ Isomorphic G H ",
      "forall {G H : Type u_1} [inst : Group G] [inst_1 : MulAction G] [inst_2 : Finite G] [inst_3 : NonAbelian G]\n  [inst_4 : Fintype.card G = 21] [inst_5 : Group H] [inst_6 : MulAction H] [inst_7 : Finite H] [inst_8 : NonAbelian H]\n  [inst_9 : Fintype.card H = 21], Isomorphic G H ",
      "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Nonabelian G â†’ Nonabelian H â†’ Isomorphic G H ",
      "âˆ€ {G1 : Type u_1} {G2 : Type u_2} [inst : Group G1] [inst_1 : Group G2],\n  Fintype.card G1 = 21 â†’ Fintype.card G2 = 21 â†’ NonabelianGroup G1 â†’ NonabelianGroup G2 â†’ GroupIsom G1 G2 ",
      "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Group H] [inst_3 : Fintype H],\n  Group.order G = 21 â†’ Nonabelian G â†’ Group.order H = 21 â†’ Nonabelian H â†’ Isomorphic G H ",
      "forall {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Fintype Gâ‚] [inst_3 : Fintype Gâ‚‚],\n  @group.card Gâ‚ inst inst_2 = 21 â†’ @group.card Gâ‚‚ inst_1 inst_3 = 21 â†’ Nonabelian Gâ‚ â†’ Nonabelian Gâ‚‚ â†’ Isomorphic Gâ‚ Gâ‚‚ ",
      "/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem prod_nonarchimedean_group {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K] : NonarchimedeanGroup (G Ã— K) ",
      "forall {G : Type u_1} [inst : Group G] [Fintype G] (hG : order_of G = 21) (nonabelianG : Â¬IsAbelian G)\n  {H : Type u_2} [inst_1 : Group H] [Fintype H] (hH : order_of H = 21) (nonabelianH : Â¬IsAbelian H),\n  Group.is_isomorphic G H ",
      "forall {G H : Type*} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Nonabelian G] [inst_3 : OrderOfGroup G 21]\n  [inst_4 : Group H] [inst_5 : Fintype H] [inst_6 : Nonabelian H] [inst_7 : OrderOfGroup H 21],\n  IsomorphicGroups G H ",
      "forall {G : Type u_1} [inst : Group G] (hG : Fintype.card G = 21) (hnabG : Â¬IsAbelian G)\n  {H : Type u_2} [inst_1 : Group H] (hH : Fintype.card H = 21) (hnabH : Â¬IsAbelian H),\n  G â‰ƒ H "
    ]
  },
  {
    "docString": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n m : â„•}, n â‰  m â†’ IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"}]\n",
    "prompt_cons": "/-- If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. -/\ntheorem âˆ€ {n m : â„•}, n â‰  m â†’ IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : IsCyclic Î±] [inst_3 : IsCyclic Î²] {m n : â„•} [hm : Fact (Fintype.card Î± = m)] [hn : Fact (Fintype.card Î² = n)], IsCyclic (Î± Ã— Î²) â†” Nat.Coprime m n ",
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : IsCyclic Î±] [inst_3 : IsCyclic Î²] {m n : â„•},\n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCoprime m n â†” IsCyclic (Î± Ã— Î²) ",
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : IsCyclic Î±] [inst_3 : IsCyclic Î²] {m n : â„•}, \n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCyclic (Î± Ã— Î²) â†” Nat.Coprime m n ",
      "âˆ€ {Î± Î² : Type u} [inst_1 : Group Î±] [inst_2 : Group Î²] [inst_3 : IsCyclic Î±] [inst_4 : IsCyclic Î²] {m n : â„•},\n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCoprime m n â†” IsCyclic (Î± Ã— Î²) ",
      "âˆ€ {Î± Î² : Type u} [inst : Mul Î±] [inst_1 : Fintype Î±] [inst_2 : IsCyclic Î±] [inst_3 : Mul Î²] [inst_4 : Fintype Î²] [inst_5 : IsCyclic Î²] {m n : â„•},\n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCyclic (Î± Ã— Î²) â†” Nat.Coprime m n ",
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : IsCyclic Î±] [inst_3 : IsCyclic Î²] {m n : â„•},\n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ (IsCyclic (Î± Ã— Î²) â†” Nat.Coprime m n) ",
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : Fintype Î±] [inst_3 : Fintype Î²] [inst_4 : IsCyclic Î±] [inst_5 : IsCyclic Î²] {m n : â„•}, Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCoprime m n â†” IsCyclic (Î± Ã— Î²) ",
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : IsCyclic Î±] [inst_3 : IsCyclic Î²] {m n : â„•}, Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCoprime m n â†” IsCyclic (Î± Ã— Î²) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst_1 : Group Î±] [inst_2 : Group Î²] [inst_3 : Fintype Î±] [inst_4 : Fintype Î²] [inst_5 : IsCyclic Î±] [inst_6 : IsCyclic Î²] {m n : â„•},\n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCoprime m n â†” IsCyclic (Î± Ã— Î²) ",
      "âˆ€ {Î± Î² : Type u} [inst : Group Î±] [inst_1 : Group Î²] [inst_2 : IsCyclic Î±] [inst_3 : IsCyclic Î²] {m n : â„•},\n  Fintype.card Î± = m â†’ Fintype.card Î² = n â†’ IsCyclic (Î± Ã— Î²) â†” Nat.Coprime m n "
    ]
  },
  {
    "docString": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Subgroup G) [inst_1 : Fact (Nat.Prime p)],\n  IsPSylow p { x // x âˆˆ P } â†’ P.normal â†’ âˆ€ Q, IsPSylow p { x // x âˆˆ Q } â†’ Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G},\n  IsPGroup p { x // x âˆˆ P } â†’ (âˆ€ Q : Sylow p G, P = â†‘Q) ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  IsPSylow P â†’ P.normal â†’ âˆ€ Q : Subgroup G, IsPSylow Q â†’ Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Sylow p G}, P.normal â†’ âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} [inst_1 : IsPGroup p { x // x âˆˆ P }]\n  [inst_2 : Subgroup.Normal P], (âˆ€ Q : Subgroup G, IsPGroup p { x // x âˆˆ Q } â†’ P = Q) ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ P.normal â†’ âˆ€ Q, IsPGroup p { x // x âˆˆ Q } â†’ P = Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Sylow p G}, IsPGroup p { x // x âˆˆ P } â†’ P.normal â†’ âˆ€ Q : Sylow p G, P = Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Subgroup G) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  IsPGroup p { x // x âˆˆ P } â†’ P â‰… â‹ƒâ‚€ (Sylow p G) â†’ âˆ€ Q âˆˆ Sylow p G, Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Sylow p G}, P.normal â†’ (âˆ€ Q : Sylow p G, Q = P) ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPSylow p { x // x âˆˆ P } â†’ P.normal â†’ âˆ€ Q, IsPSylow p { x // x âˆˆ Q } â†’ Q = P "
    ]
  },
  {
    "docString": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ H.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ H.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’\n  Fintype.card G = p ^ n â†’ Subgroup.normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.normal H ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ H.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ H.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.normal H "
    ]
  },
  {
    "docString": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the quaternions, as a set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a set. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the quaternions, as a type. \"},\n {\"theorem\":\n  \"âˆ€ (q : Quaternion â„), q.re = 0 â†’ exp â„ q = â†‘(Real.cos â€–qâ€–) + (Real.sin â€–qâ€– / â€–qâ€–) â€¢ q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closed form for the quaternion exponential on imaginary quaternions. \"}]\n",
    "prompt_cons": "/-- The cardinality of the quaternions, as a set. -/\ntheorem âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of the quaternions, as a type. -/\ntheorem âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4 :=\n\n/-- The closed form for the quaternion exponential on imaginary quaternions. -/\ntheorem âˆ€ (q : Quaternion â„), q.re = 0 â†’ exp â„ q = â†‘(Real.cos â€–qâ€–) + (Real.sin â€–qâ€– / â€–qâ€–) â€¢ q :=\n\n/-- Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions. -/\ntheorem",
    "choices": [
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : HasScalar R (Quaternion R)], âˆƒ (x : Quaternion R), x^2 = -1 ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], âˆƒ (x : Quaternion R), x * x = -1 ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], âˆƒ (x : Quaternion R), x * x = -1 ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : Add R] [inst_3 : Mul R] [inst_4 : Sub R] [inst_5 : HasScalar R (Quaternion R)], âˆƒ x : Quaternion R, x â‰  0 âˆ§ x^2 = -1 ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], âˆƒ (z : Quaternion R), z ^ 2 = -1 ",
      "âˆƒ (f : â„• â†’ Quaternion â„), (âˆ€ n : â„•, f n * f n = -1) âˆ§ Function.injective f ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4 â†’ Cardinal.mk {x : Quaternion R // x^2 = -1} = Cardinal.mk R ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Nonempty (Quaternion R) â†’ âˆƒ x : Quaternion R, x ^ 2 = -1 ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk {q : Quaternion R | q ^ 2 = -1} = Cardinal.mk R ^ 2 ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], âˆƒ x : Quaternion R, x â‰  (0 : Quaternion R) âˆ§ x^2 = -(1 : Quaternion R) "
    ]
  },
  {
    "docString": "Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"}]\n",
    "prompt_cons": "/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : Ring R] (h : âˆ€ (x : R), x ^ 3 = x), IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] (h : âˆ€ x : R, x^3 = x), IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] (h : âˆ€ x : R, x^3 = x), CommRing R ",
      "âˆ€ {R : Type u_1} [inst : Ring R] (h : âˆ€ x : R, x^3 = x), IsCommutative R ",
      "âˆ€ {R : Type u_1} [inst : Ring R] (h : âˆ€ x : R, x^3 = x), IsCommutative R mul ",
      "âˆ€ {R : Type u} [inst : Ring R] (h : âˆ€ x : R, x ^ 3 = x), IsCommutative R (*) ",
      "âˆ€ {R : Type u} [inst : Ring R] (h : âˆ€ x : R, x ^ 3 = x), IsCommutative R ",
      "âˆ€ {R : Type u} [inst : Ring R] (hx : âˆ€ x : R, x^3 = x), IsCommutative R ",
      "âˆ€ {R : Type u} [inst : Ring R] (h : âˆ€ x : R, x^3 = x), IsCommutative R ",
      "âˆ€ {R : Type u} [inst : Ring R] (h : âˆ€ x : R, x^3 = x), CommRing R "
    ]
  },
  {
    "docString": "Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors b â†’ a â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"}]\n",
    "prompt_cons": "/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors b â†’ a â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$. -/\ntheorem",
    "choices": [
      "âˆ€ {p a b : â„•}, Nat.Prime p â†’ Fact (p % 2 = 1) â†’ a * b = (1 + 2 + ... + (p - 1)) â†’ p âˆ£ a ",
      "forall {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’\n  âˆƒ (a b : â„•), (âˆ€ i âˆˆ Finset.range (p - 1), b * (i + 1) â‰¡ 1 [ZMOD p]) âˆ§ a â‰  0 âˆ§ b â‰  0 âˆ§ p âˆ£ a ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆƒ (a b : â„¤), a â‰  0 âˆ§ b â‰  0 âˆ§ 1 + âˆ‘ k in Finset.range (p - 1), 1 / â†‘(k + 1) = a / b âˆ§ â†‘p âˆ£ a ",
      "/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem fermat_little_theorem {p : â„•} (hp : Nat.Prime p) {n : â„¤} (hn : IsCoprime n â†‘p) : n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ a * b = (p - 1)! + (p - 2)! + ... + 1! â†’ p âˆˆ Nat.factors a ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], (p % 2 = 1) â†’ (âˆ€ {a b : â„¤}, (âˆ‘ i in Finset.range (p - 1), (1 / (â†‘i + 1))) = a / b) â†’ (â†‘p âˆ£ a) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆƒ (a b : â„¤), a â‰  0 âˆ§ b â‰  0 âˆ§ (1 / 2 + 1 / 3 + ... + 1 / (p - 1)) = a / b âˆ§ (p âˆ£ a) ",
      "forall {p : â„•} [Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆƒ (a b : â„•), (âˆ‘ i in Finset.range (p - 1), 1 / (i + 1)) = a / b âˆ§ p âˆ£ a ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆƒ a b : â„•, a â‰  0 âˆ§ b â‰  0 âˆ§ (1 + âˆ‘ k in Finset.range (p - 1), 1 / (â†‘k + 1)) = (â†‘a / â†‘b) âˆ§ p âˆ£ a ",
      "forall {p : â„•} [Fact (Nat.Prime p)], p % 2 = 1 â†’\n  (âˆƒ a b : â„¤, a â‰  0 âˆ§ b â‰  0 âˆ§ â†‘p âˆ£ a âˆ§ (1 + âˆ‘ k in Finset.range (p - 1), 1 / â†‘k) = a / b) "
    ]
  },
  {
    "docString": "Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"}]\n",
    "prompt_cons": "/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥ :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R â‰ƒ+* S), â†‘f 0 = 0 :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : CommRing R] [IsMatrixRing R] [Nontrivial R], âˆ€ (I : Ideal R), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R]\n  (h : forall (a b c d : R) (x y z w : R), Ideal.quotient.mk (Ideal.span (matrix.vec_cons (matrix.vec_cons a (matrix.vec_cons b matrix.vec_empty)) (matrix.vec_cons (matrix.vec_cons c (matrix.vec_cons d matrix.vec_empty)) matrix.vec_empty))) (matrix.vec_cons (matrix.vec_cons x (matrix.vec_cons y matrix.vec_empty)) (matrix.vec_cons (matrix.vec_cons z (matrix.vec_cons w matrix.vec_empty)) matrix.vec_empty)) = 0 â†’ a = 0 âˆ§ b = 0 âˆ§ c = 0 âˆ§ d = 0),\n  âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)},\n  I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (M : Matrix (Fin 2) (Fin 2) R),\n  Ideal M = âŠ¥ âˆ¨ Ideal M = âŠ¤ â†’\n  (âˆ€ (I : Ideal R), Ideal (Matrix.map M (Î» x, â†‘(Ideal.Quotient.mk I x))) = âŠ¥) âˆ¨ Ideal (Matrix.map M (Î» x, â†‘(Ideal.Quotient.mk I x))) = âŠ¤ ",
      "âˆ€ {R : Type u} [hâ‚ : CommRing R] [hâ‚‚ : IsDomain R] [hâ‚ƒ : Matrix.Invertible (Matrix.diagonalâ‚“ ((0 : R), 1))],\n  (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)) â†’ I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)}, I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_2 : NonUnitalNonAssocSemiring R] {I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)}, I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "forall {R : Type u_1} [inst : CommRing R] [inst_1 : RingEmbedding (RingHom.id R)] [inst_2 : CharZero R],\n  âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)),\n  I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst2 : Algebra â„ R] (I : Ideal R),\n(I = âŠ¥ âˆ¨ I = âŠ¤) â†” âˆ€ (M : Matrix (Finâ‚“ 2) (Finâ‚“ 2) R), M âˆˆ I â†’ M = 0 âˆ¨ (âˆ€ (c : R), c â€¢ 1 = c) ",
      "âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal (Matrix (Fin 2) (Fin 2) R)),\nI = âŠ¥ âˆ¨ I = âŠ¤ "
    ]
  },
  {
    "docString": "Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements. -/\ntheorem",
    "choices": [
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] (p n : â„•) [hp : Fact (Nat.Prime p)],\n  âˆ€ {q : Polynomial F}, Polynomial.degree q = n â†’ Polynomial.Irreducible q â†’\n  Fintype.card (QuotientRing (Polynomial.degree q)) = p ^ n ",
      "âˆ€ {Î± : Type u_1} [inst : Field Î±] [inst_1 : Fintype Î±] [inst_2 : DecidableEq Î±] {p : â„•} [hp : Fact (Nat.Prime p)] {n : â„•} (q : polynomial Î±),\n  Irreducible q â†’ polynomial.degree q = n â†’ Fintype.card (quotient (polynomial.maximal_ideal q)) = p ^ n ",
      "âˆ€ {F : Type u_1} [inst : Field F] {p n : â„•} [p_prime : Fact (Nat.Prime p)] [char_p : CharP F p] {q : F[X]}, \n  Polynomial.degree q = n â†’ Polynomial.irreducible q â†’ Fintype.card (Field.adjoinRoot q) = p ^ n ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p n : â„•} [hp : Fact (Nat.Prime p)], \n  âˆ€ {q : Polynomial F}, Irreducible q â†’ Polynomial.degree q = n â†’ Fintype.card (Polynomial.QuotientRing F q) = p ^ n ",
      "âˆ€ {Î± : Type u_1} [inst : Field Î±] {p : â„•} [p_prime : Fact (Nat.Prime p)] {q : Polynomial Î±} [q_irred : Irreducible q] (n : â„•),\n  Polynomial.degree q = n â†’ Fintype.card (QuotientRing.quotient (Polynomial.toIdeal q)) = p^n ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p n : â„•} [hp : Fact (Nat.Prime p)] {q : Polynomial F},\n  Irreducible q â†’ Polynomial.degree q = n â†’ (Fintype.card (QuotientRing.quotient (Ideal.span (singleton q))) = p ^ n) ",
      "âˆ€ {F : Type u_1} [inst : Field F] {p n : â„•} [inst_1 : Fact (Nat.Prime p)] {q : F[X]}, \n  Polynomial.degree q = n â†’ Polynomial.irreducible q â†’ Fintype.card (QuotientRing.quotient (Polynomial.span_singleton q)) = p ^ n ",
      "âˆ€ {Î± : Type u_1} [inst : CommRing Î±] [inst_1 : IsDomain Î±] [inst_2 : Fintype Î±] (p n : â„•) (q : Polynomial Î±),\n  Fact (Nat.Prime p) â†’ Polynomial.degree q = n â†’ Polynomial.Irreducible q â†’ Fintype.card (QuotientRing.quotient (Polynomial.span_singleton q)) = p^n ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] (p n : â„•) (q : Polynomial F),\n  Fact (Nat.Prime p) â†’ Fintype.card F = p â†’ Irreducible q â†’ Polynomial.degree q = n â†’\n  Fintype.card (QuotientRing.quotient (Polynomial.mkIdeal q)) = p^n ",
      "âˆ€ {F : Type u_1} [inst : Field F] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {n : â„•} (q : polynomial F),\n  Irreducible q â†’ polynomial.degree q = n â†’ IsField (F[x]/(q)) âˆ§ Fintype.card (F[x]/(q)) = p^n "
    ]
  },
  {
    "docString": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `cyclotomic p R = âˆ‘ i in range p, X ^ i`. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- If `p` is prime, then `cyclotomic p R = âˆ‘ i in range p, X ^ i`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i :=\n\n/-- If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [p_prime : Fact (Nat.Prime p)], Polynomial.Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "forall {p : â„•} [hp_prime : Fact (Nat.Prime p)],\n  Polynomial.IsIrreducible (Finset.sum (Finset.range p) fun i => Polynomial.C (1 : â„š) * Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} [p_prime : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.C (polynomial.X ^ i : â„š)) ",
      "forall {p : â„•} [hp : Fact (Nat.Prime p)], Polynomial.irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} [p_prime : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i : Polynomial â„š) ",
      "âˆ€ {p : â„•} [p_prime : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i : Polynomial â„š) ",
      "forall {p : â„•} [p_prime : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)], Polynomial.IsIrreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} [p_prime : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => (Polynomial.X ^ i : Polynomial â„š)) "
    ]
  },
  {
    "docString": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) ",
      "âˆƒ (s : â„• â†’ â„¤), Function.Injective s âˆ§ âˆ€ (n : â„•), Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + coe (s n)) ",
      "âˆ€ {f : Polynomial â„¤} (a : â„•), f = (C â†‘a + (X^7 + 15 * X^2 - 30 * X)) â†’ Irreducible (Polynomial.map (Int.castRingHom â„š) f) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) ",
      "âˆ€ {f : â„• â†’ Polynomial â„š}, f = (Î» n, Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + n) â†’ âˆƒ a : â„•, âˆ€ b : â„•, b â‰¥ a â†’ Irreducible (f b) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) "
    ]
  },
  {
    "docString": "Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    â†‘(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\\n    âˆ€ (f : V'' â†’â‚—[R] V),\\n      Function.Injective â†‘f â†’\\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\\n * the function `f' : V'' â†’ V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u) [inst : NontriviallyNormedField ğ•œ] (E : Type v) [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ] [inst : FiniteDimensional ğ•œ E], ProperSpace E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any finite-dimensional vector space over a proper field is proper.\\nWe do not register this as an instance to avoid an instance loop when trying to prove the\\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\\nexplicitly when needed. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    â†‘(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\n * the function `f' : V'' â†’ V'` doesn't need to be injective -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\n    âˆ€ (f : V'' â†’â‚—[R] V),\n      Function.Injective â†‘f â†’\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b) :=\n\n/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem âˆ€ (ğ•œ : Type u) [inst : NontriviallyNormedField ğ•œ] (E : Type v) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ] [inst : FiniteDimensional ğ•œ E], ProperSpace E :=\n\n/-- Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$. -/\ntheorem",
    "choices": [
      "âˆ€ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  Â¬âˆƒ (I : Type) [inst_4 : Fintype I] (S : I â†’ Submodule F V), V = â‹ƒ (i : I), â†‘(S i) ",
      "âˆ€ {F : Type u} [inst : Infinite F] {E : Type v} [inst_1 : AddCommGroup E] [inst_2 : Module F E],\n  âˆ€ (s : Î¹ â†’ Submodule F E) [inst : âˆ€ (i : Î¹), s i < âŠ¤] (hs : â†‘(Set.range s) < âŠ¤), Set.Unbounded (â‰¤) (Set.Range s) ",
      "âˆ€ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  Â¬âˆƒ (n : â„•) (s : Finâ‚“ n â†’ Submodule F V), (âˆ€ (i : Finâ‚“ n), s i < âŠ¤) âˆ§ (â‹ƒ (i : Finâ‚“ n), â†‘(s i)) = Set.Univ ",
      "âˆ€ {F : Type u} [inst : Field F] [inst_1 : Infinite F] {V : Type v} [inst_2 : AddCommGroup V] [inst_3 : Module F V]\n  (t : Finset (Submodule F V)), (âˆ€ (x : Submodule F V), x âˆˆ t â†’ x < âŠ¤) â†’ âŠ¤ âˆ‰ t.image coe ",
      "âˆ€ {F : Type u} [inst : Field F] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module F V],\n  Infinite F â†’ âˆ€ {Î¹ : Type u_1} [inst_3 : Fintype Î¹] (S : Î¹ â†’ Submodule F V),\n    (âˆ€ (i : Î¹), (S i : Set V) âŠ‚ Set.Univ) â†’ Set.Univ âŠ‚ â‹ƒ (i : Î¹), (S i : Set V) ",
      "âˆ€ {ğ•œ : Type u} [inst : Field ğ•œ] {E : Type v} [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : Infinite ğ•œ] {Î¹ : Type w} {s : Î¹ â†’ Submodule ğ•œ E} (hs : Set.Finite (Set.Range s)),\n  Â¬(Submodule.span ğ•œ (Set.Unionâ‚“ (Set.Range (Î» i : Î¹, (s i).Carrier))) = âŠ¤) ",
      "âˆ€ {F : Type u} [inst : Field F] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  (hF : Infinite F) {n : â„•} {v : V}, Â¬âˆƒ (S : Finâ‚“ (Nat.succ n) â†’ Submodule F V),\n  Set.PairwiseDisjoint (Set.Range S) âˆ§ V = Set.Unionâ‚“ (Set.Range (Î» (i : Finâ‚“ (Nat.succ n)), â†‘(S i))) ",
      "âˆ€ {F : Type u} [inst : Field F] [inst_1 : Infinite F] {E : Type v} [inst_2 : AddCommGroup E] [inst_3 : Module F E]\n  {Î¹ : Type} [Nonempty Î¹] [inst_4 : Fintype Î¹] {f : Î¹ â†’ Submodule F E}, (âˆ€ i, (f i) < âŠ¤) â†’ âŠ¤ â‰  âŠ¥ â†’ â¨† i, f i â‰  âŠ¤ ",
      "âˆ€ {F : Type u} [inst : Field F] [inst_1 : Infinite F] {V : Type v} [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  âˆ€ (t : Finset (Submodule F V)), Â¬(âˆ€ (x : Submodule F V), x âˆˆ t â†’ x < âŠ¤) â†’ â†‘(Finset.sup t id) = âŠ¤ ",
      "âˆ€ {F : Type u} [inst : Field F] [inst_1 : Infinite F] {V : Type v} [inst_2 : AddCommGroup V] [inst_3 : Module F V]\n  (b : F â†’ V), LinearIndependent F b â†’\n    âˆ€ {Î¹ : Type u_1} [_inst_5 : Fintype Î¹] (v : Î¹ â†’ V), (âˆ€ (i : Î¹), v i âˆˆ Submodule.span F (Set.Range b)) â†’\n      âˆƒ (iâ‚€ : Î¹), b = v iâ‚€ "
    ]
  },
  {
    "docString": "Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)},\\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.castSucc i)) =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.succ i))\",\n  \"isProp\": true,\n  \"docString\": \"The special case of the first cosimplicial identity \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a set. \"}]\n",
    "prompt_cons": "/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- The special case of the first cosimplicial identity -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)},\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.castSucc i)) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.succ i)) :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "cos_degree_one_is_algebraic : IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "cos_one_degree_is_algebraic : Algebraic â„ (Real.cos (Real.pi / 180)) ",
      "is_algebraic_cos_one_degree : IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "cos_one_degree_is_algebraic : IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "cos_one_degree_is_algebraic_over_Q : IsAlgebraic â„š (Complex.cos (Complex.of_real (Real.cos 1))) ",
      "cos_degree_one_is_algebraic : NumberField.Algebraic â„š (Real.cos (Real.pi / 180)) ",
      "cos_one_degree_is_algebraic : IsAlgebraic â„š (Real.cos (Real.deg 1)) ",
      "cos_one_degree_is_algebraic : IsAlgebraic â„š (Real.cos (1 * Ï€ / 180)) ",
      "â„‚.cos ((1 : â„) * Real.pi / 180) âˆˆ â„š ",
      "isAlgebraic â„š (Real.cos (Real.pi / 180)) "
    ]
  },
  {
    "docString": "Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_3_minus_3x_minus_1 : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_cubed_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x^3 - 3*Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.map â„š (Polynomial.x ^ 3 - 3 * Polynomial.x - 1)) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.map (AlgebraMap â„¤ â„š) (Polynomial.x ^ 3 - 3 * Polynomial.x - 1)) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_cubed_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.map (algebraMap â„¤ â„š) (Polynomial.x ^ 3 - 3 * Polynomial.x - 1)) "
    ]
  },
  {
    "docString": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\\n  AddSubgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b + a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive subgroup has index two if and only if there exists `a` such that\\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"}]\n",
    "prompt_cons": "/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H) :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n  AddSubgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b + a âˆˆ H) (b âˆˆ H) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {H : Subgroup G}, H = Subgroup.closure {a, b} â†’ a * b = b * a â†’ âˆ€ x y âˆˆ H, x * y = y * x ",
      "/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem index_two_iff_exists_eq_mul_or (G : Type u_1) [inst : Group G] {H : Subgroup G} : Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ IsAddGroupHom (Î» x : G, x * a * xâ»Â¹ * b) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {H : Subgroup G},\n  H = Subgroup.closure {a, b} â†’ a * b = b * a â†’ âˆ€ (x y âˆˆ H), x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ IsAddCommGroup (Additive â†¥(Subgroup.closure {a, b})) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ IsAddGroupHom (Î» (x : G), x âˆˆ Subgroup.closure {a, b}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {H : Subgroup G}, H = Subgroup.closure {a, b} â†’ a * b = b * a â†’ âˆ€ (x y : G), x âˆˆ H â†’ y âˆˆ H â†’ x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : {x : G | x âˆˆ Subgroup.closure {a, b}}), x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ IsAdditiveAbelian (Subgroup.closure ({a, b} : Set G)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ IsAddGroupHom (Î» (g : G), âŸ¦gâŸ§ âˆˆ AddSubgroup.closure ({a, b})) "
    ]
  },
  {
    "docString": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x : G, orderOf x = 2) â†’ âˆ€ x : G, orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x : G, x ^ 2 = 1) â†’ âˆ€ y : G, y ^ 2 = 1 â†’ y âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆƒ! (x : G), orderOf x = 2) â†’ âˆ€ (x : G), orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! a : G, order_of a = 2) â†’ (âˆ€ a : G, order_of a = 2 â†’ a âˆˆ Subgroup.center G) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x : G, order_of x = 2) â†’ âˆ€ x : G, order_of x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x : G, orderOf x = 2) â†’ âˆ€ x : G, x ^ 2 = 1 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x : G, orderOf x = 2) â†’ âˆ€ x : G, orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! a : G, orderOf a = 2) â†’ âˆ€ x : G, orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ!x, x âˆˆ Subgroup.orderOf 2) â†’ (âˆ€x, x âˆˆ Subgroup.orderOf 2 â†’ x âˆˆ Subgroup.center G) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x : G, orderOf x = 2) â†’ âˆ€ y : G, y^2 = 1 â†’ y âˆˆ Subgroup.center G "
    ]
  },
  {
    "docString": "Prove that a group of even order contains an element of order $2 .$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ (p' : â„•), lucasLehmerResidue (p' + 2) = 0 â†’ orderOf (LucasLehmer.Ï‰Unit (p' + 2)) = 2 ^ (p' + 2)\",\n  \"isProp\": true,\n  \"docString\": \"The order of `Ï‰` in the unit group is exactly `2^p`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"}]\n",
    "prompt_cons": "/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The order of `Ï‰` in the unit group is exactly `2^p`. -/\ntheorem âˆ€ (p' : â„•), lucasLehmerResidue (p' + 2) = 0 â†’ orderOf (LucasLehmer.Ï‰Unit (p' + 2)) = 2 ^ (p' + 2) :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- Prove that a group of even order contains an element of order $2 .$ -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type uG} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (g : G), orderOf g = 2 ",
      "âˆ€ {G : Type uG} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (a : G), orderOf a = 2 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type u} [_inst_1 : Group G] [_inst_2 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (a : G), orderOf a = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (g : G), orderOf g = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (a : G), orderOf a = 2 "
    ]
  },
  {
    "docString": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.range b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite family of vectors is linearly independent if and only if\\nits cardinality equals the dimension of its span. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"}]\n",
    "prompt_cons": "/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.range b) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†’ âˆ€ (s : Set V), LinearIndependent K Subtype.val â†’ Set.Countable s ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†’ (Exists (w : â„•), Fintype.card Î¹ = w) âˆ¨ Set.Countable (Set.range b) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : countable Î¹] {b : Î¹ â†’ V}, Submodule.span K (Set.range b) = âŠ¤ â†’ âˆ€ (s : Set V), LinearIndependent K Subtype.val â†’\n  Set.Finite s âˆ¨ countable (â†¥s) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Infinite Î¹] {b : Î¹ â†’ V}, Submodule.span K (Set.range b) = âŠ¤ â†’\n  âˆ€ {s : Set V}, LinearIndependent K Subtype.val â†’ Infinite (â†¥s) â†’ Infinite Î¹ ",
      "âˆ€ {R : Type u_2} {M : Type u_1} [inst : DivisionRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Î¹ : Type u_3}\n  (s : Î¹ â†’ M), Set.Countable (Set.range s) â†’ Submodule.span R (Set.range s) = âŠ¤ â†’ âˆ€ t : Set M,\n  LinearIndependent R Subtype.val â†’ Set.Countable t âˆ¨ Set.Finite t ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {s t : Set V}, Set.Countable s â†’ Submodule.span K s = âŠ¤ â†’ LinearIndependent K Subtype.val â†’\n  Set.Countable (t : Set V) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {s : Set V},\n  Set.Countable s â†’ Submodule.span K s = âŠ¤ â†’ âˆ€ (t : Set V), LinearIndependent K Subtype.val â†’ Set.Countable t ",
      "âˆ€ {R : Type u_2} {M : Type u_1} [inst : DivisionRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Î¹ : Type u_3}\n  [inst_3 : Infinite Î¹], (âˆƒ l : Î¹ â†’ M, Submodule.span R (Set.range l) = âŠ¤) â†’\n  âˆ€ (s : Set M), LinearIndependent R Subtype.val â†’ Set.Finite s âˆ¨ Set.Countable s ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Countable Î¹] {b : Î¹ â†’ V} (hs : Set.span K (Set.range b) = âŠ¤),\n  âˆ€ (s : Set V), LinearIndependent K Subtype.val â†’ Set.Finite s âˆ¨ Set.Countable s ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Infinite Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†’ âˆ€ (s : Set V), Set.Countable s â†’ Set.Countable (Set.filter (Î» x, x âˆˆ s) (Set.range b)) "
    ]
  },
  {
    "docString": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ G â‰… Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (G â§¸ Subgroup.center G) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ IsAddAbelian G âˆ§ G = Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ âˆ€ x y : G, x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G â§¸ Subgroup.center G) â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ G â‰… Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ G â‰… Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ G â‰ƒ+ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ G â‰ƒ+ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (G â§¸ Subgroup.center G) â†’ IsAbelian G "
    ]
  },
  {
    "docString": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "âˆ€ {G : Type u_2} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬ IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p^2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬ IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"}]\n",
    "prompt_cons": "/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G), Subgroup.mk (SetOf (Î» x, âˆƒ n m, a ^ n * b ^ m * a ^ (-n) * b ^ (-m) = x))\n  = Subgroup.mk (SetOf (Î» x, âˆƒ p q r, b * a * b ^ 2 * p * (b * a * b ^ 3) ^ q * r = x)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G), Subgroup.closure ({a, b}) = Subgroup.closure ({b * a * b^2, b * a * b^3}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure ({a, b} : Set G) = Subgroup.closure ({b * a * (b^2), b * a * (b^3)} : Set G) ",
      "forall {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure ({a, b} : Set G) = Subgroup.closure ({(b * a * b^2), (b * a * b^3)} : Set G) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * (b ^ 2), b * a * (b ^ 3)} ",
      "forall {G : Type u_1} [inst : Group G] (a b : G), Subgroup.closure ({a, b}) = Subgroup.closure ({b * a * (b ^ 2), b * a * (b ^ 3)}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G), Subgroup.closure ({a, b} : Set G) = Subgroup.closure ({b * a * b^2, b * a * b^3} : Set G) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G), Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G), Subgroup.closure ({a, b} : Set G) = Subgroup.closure ({b * a * (b ^ 2), b * a * (b ^ 3)} : Set G) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * (b ^ 2), b * a * (b ^ 3)} "
    ]
  },
  {
    "docString": "Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A â‰ƒ+* B â†’ NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²},\\n  IsRingHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Ring Î³] {g : Î² â†’ Î³}, IsRingHom g â†’ IsRingHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two ring homomorphisms is a ring homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"}]\n",
    "prompt_cons": "/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A â‰ƒ+* B â†’ NoZeroDivisors A :=\n\n/-- The composition of two ring homomorphisms is a ring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²},\n  IsRingHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Ring Î³] {g : Î² â†’ Î³}, IsRingHom g â†’ IsRingHom (g âˆ˜ f) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s) :=\n\n/-- Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  (0:R) ",
      "âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 ",
      "âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] (Râ‚‚ : Type u_2) [inst_1 : CommRing Râ‚‚] [inst_2 : Ideal.IsPrime (Râ‚‚ : Ideal Râ‚‚)] [inst_3 : Submodule.IsPrincipal (Râ‚‚ : Ideal Râ‚‚)],\n  Râ‚[x] â‰ƒ+* Râ‚‚ â†’ Ideal.span {(2 : Râ‚[x])} âŠ“ Ideal.span {(x : Râ‚[x])} = Ideal.span {(2 * x : Râ‚[x])} ",
      "âˆ€ {Î± : Type u} [inst : CommRing Î±] {x : Î±}, Ideal.span ({2} : Set Î±) âˆ© Ideal.span ({x} : Set Î±) =\n  Ideal.span ({2 * x} : Set Î±) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R], Ideal.span ({2} : Set R) âŠ“ Ideal.span ({Polynomial.x} : Set (Polynomial R)) = Ideal.span ({2 * Polynomial.x} : Set (Polynomial R)) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R], Ideal.span ({2} : Set (R[X])) âŠ“ Ideal.span ({X} : Set (R[X])) =\n  Ideal.span ({2 * X} : Set (R[X])) ",
      "forall {R : Type u_1} [inst : CommRing R] [inst_1 : Nontrivial R], \n  (Ideal.span ({2} : Set R) âŠ“ Ideal.span ({Polynomial.x} : Set (Polynomial R))) = Ideal.span ({2 * Polynomial.x} : Set (Polynomial R)) ",
      "âˆ€ (R : Type u_1) [inst : CommRing R], PrimeIdeal.span (singleton (2 : R)) âŠ“ PrimeIdeal.span (singleton (C R X)) = PrimeIdeal.span (singleton (2 * C R X)) ",
      "âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  (0 : R) ",
      "forall {R : Type u_1} [inst : CommRing R] [inst_1 : Nontrivial R], (ideal.span {2} âŠ“ ideal.span {polynomial.X} = ideal.span {2 * polynomial.X}) "
    ]
  },
  {
    "docString": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I â†’\\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"}]\n",
    "prompt_cons": "/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I â†’\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\n          P I :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥ :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\n    I = J :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’\n    let y : R â§¸ I * J ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’\n    âˆ€ (n : â„•), âˆƒ (m : â„•), (Ideal.Quotient.mk (I * J) ((I * J) ^ m)) (x ^ n) = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R) (hx : x âˆˆ I âŠ“ J),\n  âˆƒ n : â„•, (coe (x, hx) ^ n : R â§¸ I * J) = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’\n    âˆƒ (n : â„•), coeFn (Ideal.Quotient.mk (I * J)) x ^ n = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’\n    (âˆƒ (n : â„•), (Ideal.Quotient.mk (I * J)) x ^ n = 0) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R) (hx : x âˆˆ I âˆ© J),\n  IsNilpotent (Ideal.Quotient.mk (I * J) x) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’\n    âˆƒ (n : â„•), (coeFn (Ideal.Quotient.mk (I * J)) x) ^ n = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’\n    IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) ",
      "forall {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’ is_nilpotent (Ideal.Quotient.mk (I * J) x) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} {x : R},\n  x âˆˆ I âˆ© J â†’ IsNilpotent (Ideal.Quotient.mk (I * J) x) "
    ]
  },
  {
    "docString": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R â†”\\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"}]\n",
    "prompt_cons": "/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R â†”\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M :=\n\n/-- Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$. -/\ntheorem",
    "choices": [
      "âˆ€ (R : Type u) [inst : Ring R] (M : Ideal R),\n  (âˆ€ r, r âˆ‰ M â†’ IsUnit r) â†’ (âˆ€ I, Ideal.IsMaximal I â†’ I = M) âˆ§ Ideal.IsMaximal M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ J : Ideal R, J â‰  M â†’ J = âŠ¤) âˆ§ Ideal.IsMaximal M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ x âˆˆ R, x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ I : Ideal R, I â‰  âŠ¤ â†’ I â‰¤ M) âˆ§ Ideal.IsMaximal M ",
      "forall {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (N : Ideal R), Ideal.IsMaximal N â†’ N = M ",
      "âˆ€ (R : Type u) [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ J : Ideal R, J âˆˆ {M, âŠ¤}) âˆ§ Ideal.IsMaximal M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ (N : Ideal R), Ideal.IsMaximal N â†” N = M) ",
      "forall {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (N : Ideal R), Ideal.IsMaximal N â†’ N = M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (N : Ideal R), Ideal.IsMaximal N â†’ N = M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ x, x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ I : Ideal R, I â‰  âŠ¤ â†’ I â‰¤ M) âˆ§ Ideal.IsMaximal M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ x : R, x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ (I : Ideal R), Ideal.IsMaximal I â†” I = M) "
    ]
  },
  {
    "docString": "Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (x^3 + 6 * x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "x_cubed_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (algebraMap â„¤ â„š) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.map (algebraMap â„¤ â„š) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) "
    ]
  },
  {
    "docString": "Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$ -/\ntheorem",
    "choices": [
      "x_squared_plus_one_irreducible : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "Irreducible_x_pow2_plus_1_in_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "x_sq_add_one_irreducible_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "x_squared_plus_one_irreducible : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "x2_plus_1_irreducible_in_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_x_pow_plus_one_in_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "x2_plus_1_irreducible_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_x_sq_plus_one : Irreducible (Polynomial.x^2 + 1 : Polynomial (Zmod 7)) ",
      "x_square_plus_one_irreducible : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "x_squared_plus_one_irreducible_F7 :\n  Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) "
    ]
  },
  {
    "docString": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"}]\n",
    "prompt_cons": "/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - Polynomial.C (Rational.of_int p)) ",
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - Polynomial.C (coe p)) ",
      "âˆ€ {p : â„•} (hp : Nat.Prime p) {n : â„•} (hn : 0 < n),\n  Irreducible (Polynomial.x ^ n - Polynomial.C (coe p) : Polynomial â„š) ",
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - Polynomial.C (Rat.of_nat p)) ",
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - Polynomial.C (algebra_map â„• R p)) ",
      "âˆ€ {p : â„•} {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R],\n  Nat.Prime p â†’ Irreducible (Polynomial.x ^ p - Polynomial.C (coe p)) ",
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - Polynomial.C (coe p)) ",
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : FractionRing R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - coeFn Polynomial.C (coe p)) ",
      "âˆ€ {p : â„•} (hp : Nat.Prime p) {n : â„•} (hn : 0 < n),\n  Irreducible (Polynomial.x ^ n - Polynomial.C (coe p) : Polynomial â„š) ",
      "âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      Irreducible (Polynomial.x ^ n - Polynomial.C (coe p)) "
    ]
  },
  {
    "docString": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p k : â„•}, Nat.Prime p â†’ Nat.factorization (p ^ k) = Finsupp.single p k\",\n  \"isProp\": true,\n  \"docString\":\n  \"For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` \"},\n {\"theorem\":\n  \"âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {x y : â„¤} {n : â„•},\\n  2 âˆ£ x - y â†’\\n    Â¬2 âˆ£ x â†’\\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"}]\n",
    "prompt_cons": "/-- For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` -/\ntheorem âˆ€ {p k : â„•}, Nat.Prime p â†’ Nat.factorization (p ^ k) = Finsupp.single p k :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem âˆ€ {x y : â„¤} {n : â„•},\n  2 âˆ£ x - y â†’\n    Â¬2 âˆ£ x â†’\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n :=\n\n/-- Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$. -/\ntheorem",
    "choices": [
      "âˆ€ {p r k : â„•}, Nat.Prime p â†’ p = 2^r + 1 â†’ (âˆƒ k, p = 2^(2^k) + 1) ",
      "âˆ€ {p r k : â„•}, Nat.Prime p â†’ p = 2^r + 1 â†’ (âˆƒ k, r = 2^k) ",
      "âˆ€ {p r k : â„•} [inst : Fact (Nat.Prime p)], \n  p = 2^r + 1 â†’ (âˆƒ k, p = 2^(2^k) + 1) ",
      "âˆ€ {p r k : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ (âˆƒ k, p = 2 ^ (2 ^ k) + 1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 ^ (2 ^ k) + 1 â†” p = 2 ^ r + 1 âˆ§ âˆƒ k : â„•, r = 2 ^ k ",
      "âˆ€ {p r k : â„•}, Nat.Prime p â†’ p = 2^r + 1 â†’ (âˆƒ k, p = 2^(2^k) + 1) ",
      "âˆ€ {p r k : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ (âˆƒ k, r = 2 ^ k) ",
      "âˆ€ {p k : â„•}, Nat.Prime p â†’ p = 2 ^ (2 ^ k) + 1 â†’ âˆƒ r : â„•, p = 2 ^ r + 1 ",
      "âˆ€ {p k : â„•}, Nat.Prime p â†’ p = 2^(2^k) + 1 â†’ âˆƒ r : â„•, p = 2^r + 1 ",
      "âˆ€ {p k r : â„•} [inst : Fact (Nat.Prime p)], p = 2^r + 1 â†’ âˆƒ k, p = 2^(2^k) + 1 "
    ]
  },
  {
    "docString": "Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w + y) (x + z)\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations preserve addition.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of additive monoid homomorphisms is associative.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] {c : AddCon M} (x y : M), â†‘(x + y) = â†‘x + â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of an additive congruence relation\\ncommutes with addition (by definition).\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\\n  â†‘f (a + b) = â†‘f a + â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve addition. \"}]\n",
    "prompt_cons": "/-- Additive congruence relations preserve addition. -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w + y) (x + z) :=\n\n/-- Composition of additive monoid homomorphisms is associative. -/\ntheorem âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f) :=\n\n/-- The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition). -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] {c : AddCon M} (x y : M), â†‘(x + y) = â†‘x + â†‘y :=\n\n/-- Ring homomorphisms preserve addition. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\n  â†‘f (a + b) = â†‘f a + â†‘f b :=\n\n/-- Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "forall {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "forall {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) "
    ]
  },
  {
    "docString": "Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"}]\n",
    "prompt_cons": "/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬(IsGroup (Zmod n) (Function.mul (a b : Zmod n))) ",
      "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ a b : Zmod n, a * b â‰  1 ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬MulGroup (Zmod n) ",
      "âˆ€ {n : â„•}, 1 < n â†’ Â¬IsGroup (Zmod n) ",
      "âˆ€ {n : â„•}, 1 < n â†’ Â¬IsGroup (Zmod n) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬(IsGroup (Zmod n) (Function.mul : Zmod n â†’ Zmod n â†’ Zmod n)) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬(Group (Zmod n) [inst : Mul (Zmod n)] _) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬(IsGroup (Zmod n) (Î» a b : Zmod n, a * b)) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬(is_group (Zmod n) (has_mul.mul : Zmod n â†’ Zmod n â†’ Zmod n)) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬(âˆ€ a b : Zmod n, âˆƒ c : Zmod n, a * b = c) "
    ]
  },
  {
    "docString": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” (orderOf x = 1 âˆ¨ orderOf x = 2) ",
      "forall {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” (orderOf x = 1 âˆ¨ orderOf x = 2) ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 "
    ]
  },
  {
    "docString": "Let $x$ and $y$ be elements of $G$. Prove that $xy=yx$ if and only if $y^{-1}xy=x$ if and only if $x^{-1}y^{-1}xy=1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} {x1 : Î±} {b1 : Bool} {x2 : Î±} {b2 : Bool},\\n  (x1, b1) â‰  (x2, b2) â†’ FreeGroup.Red ((x1, b1) :: Lâ‚) ((x2, b2) :: Lâ‚‚) â†’ FreeGroup.Red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are distinct letters and `wâ‚ wâ‚‚` are words such that `xwâ‚` reduces to `ywâ‚‚`, then\\n`wâ‚` reduces to `xâ»Â¹ywâ‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g â€¢ x = y`. \"}]\n",
    "prompt_cons": "/-- If `x` and `y` are distinct letters and `wâ‚ wâ‚‚` are words such that `xwâ‚` reduces to `ywâ‚‚`, then\n`wâ‚` reduces to `xâ»Â¹ywâ‚‚`. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} {x1 : Î±} {b1 : Bool} {x2 : Î±} {b2 : Bool},\n  (x1, b1) â‰  (x2, b2) â†’ FreeGroup.Red ((x1, b1) :: Lâ‚) ((x2, b2) :: Lâ‚‚) â†’ FreeGroup.Red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x :=\n\n/-- There is `g` such that `g â€¢ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y :=\n\n/-- Let $x$ and $y$ be elements of $G$. Prove that $xy=yx$ if and only if $y^{-1}xy=x$ if and only if $x^{-1}y^{-1}xy=1$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x âˆ§ xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x âˆ§ xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 "
    ]
  },
  {
    "docString": "If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (g * a)) â†’ (âˆ€ (a : G), P a â†’ P (gâ»Â¹ * a)) â†’ âˆ€ (n : â„¤), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `gâ»Â¹` on the left. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_left`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (a * g)) â†’ (âˆ€ (a : G), P a â†’ P (a * gâ»Â¹)) â†’ âˆ€ (n : â„¤), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `gâ»Â¹` on the right. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_right`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ Function.LeftInverse g f â†’ Function.IsFixedPt g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\\npoint of `g`. \"}]\n",
    "prompt_cons": "/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `gâ»Â¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. -/\ntheorem âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (g * a)) â†’ (âˆ€ (a : G), P a â†’ P (gâ»Â¹ * a)) â†’ âˆ€ (n : â„¤), P (g ^ n) :=\n\n/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `gâ»Â¹` on the right. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_right`. -/\ntheorem âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (a * g)) â†’ (âˆ€ (a : G), P a â†’ P (a * gâ»Â¹)) â†’ âˆ€ (n : â„¤), P (g ^ n) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\npoint of `g`. -/\ntheorem âˆ€ {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ Function.LeftInverse g f â†’ Function.IsFixedPt g x :=\n\n/-- If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] (x g : G), order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] (g x : G), add_order_of x = add_order_of (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] (x g : G), order_of x = order_of (gâ»Â¹ * x * g) "
    ]
  },
  {
    "docString": "Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x ^ 2 = 1) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x ^ 2 = 1) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x ^ 2 = 1) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ âˆ€ (x y : G), x * y = y * x "
    ]
  },
  {
    "docString": "If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x â‰  0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `n * x = 0`, but `n/p * x â‰  0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (m n : â„¤), x ^ m = x ^ n â†” m = n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfInfOrder x â†’ âˆ€ m n : â„¤, m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G},\n  orderOf x = 0 â†’ âˆ€ (m n : â„¤), m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x : G), Â¬IsOfFinOrder x â†’ âˆ€ n m : â„¤, x ^ n = x ^ m â†’ n = m ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfInfOrder x â†’ âˆ€ m n : â„¤, m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfInfOrder x â†’ âˆ€ (m n : â„¤), x ^ m = x ^ n â†’ m = n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬ IsOfFinOrder x â†’ âˆ€ (m n : â„¤), m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (m n : â„¤), m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfInfOrder x â†’ âˆ€ (m n : â„¤), m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G},\n  Â¬IsOfFinOrder x â†’ âˆ€ (n m : â„¤), n â‰  m â†’ x ^ n â‰  x ^ m "
    ]
  },
  {
    "docString": "Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n R` is different from `0`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"}]\n",
    "prompt_cons": "/-- `cyclotomic n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0 :=\n\n/-- `cyclotomic' n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0 :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : DivisionRing G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] {K : Type u_2}\n  [inst_3 : DivisionRing K] [inst_4 : TopologicalSpace K] [inst_5 : TopologicalGroup K], G â‰  K â†’ Nonempty (G â‰ƒ* K) â†’ False ",
      "Â¬ âˆƒ (f : â„â‚€ â†’*â‚€ â„‚â‚€), Function.Bijective (â‡‘f) ",
      "not_isomorphic_real_complex_units : Â¬(Units â„ â‰ƒ* Units â„‚) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], nonIsomorphic (R - 0) (Complex - 0) ",
      "not_real_complex_mul_group_iso : Â¬(GroupEquiv â„â‚€ â„‚â‚€) ",
      "Â¬âˆƒ (Ï† : Units â„ â†’* Units â„‚), Function.bijective Ï† ",
      "Â¬ âˆƒ (Ï• : MulEquiv (â„â‚€) (â„‚â‚€)), True ",
      "not_isomorphic_Real_complex_multiplicative_groups : Â¬GroupIsom (units â„) (units â„‚) ",
      "not_isomorphic_real_complex_units : Â¬MulEquiv (units â„) (units â„‚) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2} [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : NonarchimedeanGroup H], Â¬IsGroupHom (â„ â†’*â‚€ â„‚) "
    ]
  },
  {
    "docString": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"}]\n",
    "prompt_cons": "/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹ :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (Î» a : Î±, aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (fun a => aâ»Â¹) â†” IsCommGroup Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±],\n  IsGroupHom (Î» (a : Î±), aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {Î± : Type u} [inst : Group Î±],\n  IsGroupHom (Î» a : Î±, aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (fun a : Î± => aâ»Â¹) â†” IsCommutativeGroup Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (fun a : Î± => aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (fun a : Î± => aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (Î» a : Î±, aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (Î» a : Î±, aâ»Â¹) â†” IsCommGroup Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom (fun a : Î± => aâ»Â¹) â†” âˆ€ (a b : Î±), a * b = b * a "
    ]
  },
  {
    "docString": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’\n    n > 2 â†’\n      Â¬ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = n - 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  2 < Fintype.card G â†’ Â¬ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = Fintype.card G - 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’ n > 2 â†’ (âˆ€ H : Subgroup G, Fintype.card { x // x âˆˆ H } â‰  (n - 1)) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’ n > 2 â†’ Â¬ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = n - 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’ n > 2 â†’ âˆ€ H : Subgroup G, Fintype.card { x // x âˆˆ H } â‰  n - 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  2 < n â†’ Fintype.card G = n â†’ Â¬âˆƒ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = n - 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : â„•),\n  n = Fintype.card G â†’ n > 2 â†’ âˆ€ H : Subgroup G, Fintype.card { x // x âˆˆ H } â‰  n - 1 ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’ n > 2 â†’\n  Â¬ (âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = n - 1) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  2 < Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } â‰  Fintype.card G - 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’ n > 2 â†’\n    Â¬âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = n - 1 "
    ]
  },
  {
    "docString": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"}]\n",
    "prompt_cons": "/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (coe H - singleton 1) ",
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (coe H - {1}) ",
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H \\ {1}) ",
      "forall {G : Type u} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (SetOf (Î» g, g â‰  (1 : G)) âˆ© H) ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (SetOf fun g => g âˆˆ H âˆ§ g â‰  1) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (coe H \\ {1}) "
    ]
  },
  {
    "docString": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"}]\n",
    "prompt_cons": "/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Show that the subgroup of all rotations in a dihedral group is a maximal subgroup. -/\ntheorem",
    "choices": [
      "theorem âˆ€ {G : Type u_1} [inst : Group G], DihedralGroup G â†’ âˆ€ (H : Subgroup G), IsRotationSubgroup H â†’ IsCoatom H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), IsDihedral G â†’ IsRotationSubgroup H â†’ IsMaximal H ",
      "forall {n : â„•} {G : Type u_1} [inst : Fintype G] [inst2 : Group G] (H : Subgroup G), IsDihedral G n â†’ IsRotationSubgroup H â†’ IsCoatom H ",
      "âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] [DihedralGroup n G], IsCoatom (DihedralGroup.all_rotations n G) ",
      "âˆ€ {n : â„•} {D : Type u_1} [inst : Group D] (R : Subgroup D), DihedralGroup n R â†’ IsMaximalSubgroup R ",
      "forall {n : â„•} (hn : 0 < n), IsCoatom (DihedralGroup.rSubgroup n hn) ",
      "âˆ€ {n : â„•} (hn : n > 0), IsCoatom (Dihedral.Ï n hn) ",
      "âˆ€ {n : â„•} {R : Type u_1} [inst : Group R] (D : DihedralGroup n R), IsCoatom (DihedralGroup.rotSubgroup D) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (n : â„•) (H : Subgroup G), IsDihedralGroup G n â†’ IsCyclic H â†’ IsCoatom H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G], DihedralGroup G â†’ âˆ€ (H : Subgroup G), IsCyclic H â†’ IsCoatom H â†’ Subgroup.Normal H "
    ]
  },
  {
    "docString": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"}]\n",
    "prompt_cons": "/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian. -/\ntheorem",
    "choices": [
      " âˆ€ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), IsComm (A â§¸ B) ",
      "forall {A : Type u_1} [inst : CommGroup A] (B : Subgroup A),\n  CommGroup (QuotientGroup.Quotient B) ",
      "âˆ€ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), IsCommGroup (A / B) ",
      "âˆ€ {A : Type u_1} [inst : CommGroup A] {B : Subgroup A}, IsCommutative (A â§¸ B) (@Mul.mul (A â§¸ B) _) ",
      "âˆ€ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), IsCommGroup (A â§¸ B) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommGroup A] [inst_1 : SetLike B A] [hAB : SubgroupClass B A] (H : B)\n  (x y : QuotientGroup.Quotient H), x * y = y * x ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommGroup A] [inst_1 : Group B] [hAB : SubgroupClass B A],\n  CommGroup (A / B) ",
      "âˆ€ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), IsCommutative (A / B) ",
      "forall {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), is_commutative (A â§¸ B) ",
      "âˆ€ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), IsCommutative (A â§¸ B) (@HMul.hMul (A â§¸ B) _) "
    ]
  },
  {
    "docString": "Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"}]\n",
    "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable). -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ H âˆˆ S, Subgroup.Normal H) â†’ Set.Nonempty S â†’ Subgroup.Normal (Inf S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ âˆƒ (H : Subgroup G), Subgroup.Normal H âˆ§ âˆ€ (K : Subgroup G), K âˆˆ S â†’ H â‰¤ K ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ N âˆˆ S, Subgroup.Normal N) â†’ Set.Nonempty S â†’ Subgroup.Normal (Subgroup.Inter S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (âˆ€ H âˆˆ S, Subgroup.Normal H) â†’ S â‰  âˆ… â†’ Subgroup.Normal (Subgroup.Inter S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ Set.Nonempty S â†’ Subgroup.Normal (Subgroup.Inter S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ Set.Nonempty S â†’ Subgroup.Normal (â¨… H âˆˆ S, H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), \n  (âˆ€ (N : Subgroup G), N âˆˆ S â†’ Subgroup.Normal N) â†’ (âˆƒ (Nâ‚€ : Subgroup G), Nâ‚€ âˆˆ S) â†’ Subgroup.Normal (â‹‚â‚€ S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ (S â‰  âˆ…) â†’ Subgroup.Normal (Subgroup.Inter S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ N âˆˆ S, Subgroup.Normal N) â†’ Set.Nonempty S â†’ Subgroup.Normal (Subgroup.Inter S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ Set.Nonempty S â†’ Subgroup.Normal (Subgroup.Inter S) "
    ]
  },
  {
    "docString": "Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F) :=\n\n/-- Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite). -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’ K â‰¤ G â†’\n  Cardinal.mk (G â§¸ H) = Cardinal.mk (G â§¸ K) * Cardinal.mk (K â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Exists (Î» (d : â„•), Subgroup.index H = d * Subgroup.index K * Subgroup.index (Subgroup.comap (Subgroup.subtype K) H)) ",
      "forall {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  H â‰¤ K â†’ K â‰¤ G â†’\n  card (G â§¸ H) = card (G â§¸ K) * card (K â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Cardinal.mk (G â§¸ H) = Cardinal.mk (G â§¸ K) * Cardinal.mk (K â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’ K â‰¤ G â†’\n  Cardinal.mk (G â§¸ H) = Cardinal.mk (G â§¸ K) * Cardinal.mk (K â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Nonempty (quotient_group.quotient K) â†’ cardinal.mk (quotient_group.quotient H) = cardinal.mk (quotient_group.quotient K) * cardinal.mk (quotient_group.quotient (Subgroup.comap (Subgroup.subtype K) H)) ",
      "forall {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  H â‰¤ K â†’ K â‰¤ âŠ¤ â†’ (Subgroup.index H) = (Subgroup.index K) * (Subgroup.index (Subgroup.comap K H)) ",
      "forall {G : Type u_1} [inst : Group G] {H K : Subgroup G} (hH : H â‰¤ K) (hK : K â‰¤ âŠ¤),\n  Cardinal.mk (quotient_group.quotient K) * Cardinal.mk (quotient_group.quotient H) = Cardinal.mk (quotient_group.quotient (âŠ¤ : Subgroup G)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Nonempty (QuotientGroup.quotient H â‰ƒ QuotientGroup.quotient K Ã— (K // H)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  G â§¸ K â‰ƒ H â§¸ (K âŠ“ H) â†’ (G â§¸ H â‰ƒ G â§¸ K Ã— H â§¸ (K âŠ“ H)) "
    ]
  },
  {
    "docString": "Prove that $\\mathbb{Q}$ has no proper subgroups of finite index.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- Prove that $\\mathbb{Q}$ has no proper subgroups of finite index. -/\ntheorem",
    "choices": [
      "âˆ€ {Q : Type u_1} [inst : Field Q] [inst_1 : NoProperSubgroups Q] (H : Subgroup Q),\n  Subgroup.FiniteIndex H â†’ Subgroup.index H = 1 ",
      "âˆ€ {R : Type u_1} [inst : Field R] [inst_1 : Field.IsRational R] {H : Subgroup R} [self : Subgroup.FiniteIndex H], H = âŠ¤ ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : DivisionRing G] (H : Subgroup G), Subgroup.FiniteIndex H â†’ H = âŠ¤ ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hQ : G â‰ƒ â„š] [inst_1 : Subgroup.FiniteIndex H],\n  H = âŠ¤ ",
      "âˆ€ {Q : Type u_1} [inst : Field Q] [inst_1 : RatEmbedding Q], (âˆ€ (H : Subgroup Q), Subgroup.FiniteIndex H â†’ H = âŠ¤) ",
      "âˆ€ {R : Type u_1} [inst : Field R] [inst_1 : IsFractionRing â„š R] (H : Subgroup R) [inst_2 : Subgroup.FiniteIndex H],\n  H = âŠ¤ ",
      "âˆ€ {Q : Type u_1} [inst : Field Q] (H : Subgroup Q) [inst_1 : Subgroup.FiniteIndex H], H = âŠ¤ ",
      "âˆ€ (H : Subgroup â„š) [subgroup_finite_index : Subgroup.FiniteIndex H], H = Subgroup.top â„š ",
      "âˆ€ {Q : Type u_1} [inst : Field Q] [inst_1 : DiscreteValuationRing Q] (H : Subgroup Q) [inst_2 : Subgroup.FiniteIndex H],\n  H = âŠ¤ ",
      "âˆ€ {G : Type u_1} [inst : Field G] (H : Subgroup G) [inst_1 : IsFractionRing â„¤ G] [self : Subgroup.FiniteIndex H], Subgroup.index H = 1 "
    ]
  },
  {
    "docString": "Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group). -/\ntheorem",
    "choices": [
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [IsSimpleGroup G],\n  âˆƒ p [Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : IsSimpleGroup G'],\n  âˆƒ p, Fact (Nat.Prime p) âˆ§ Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [h : IsSimpleAddGroup G],\n  âˆƒ p [Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [simple_group : IsSimpleAddGroup G],\n  âˆƒ p, Nat.Prime p âˆ§ Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [is_simple : IsSimpleGroup (Multiplicative G)], \n  âˆƒ (p : â„•) (hp : Fact (Nat.Prime p)), Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : IsSimpleAddGroup G],\n  âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : IsSimpleAddGroup G],\n  âˆƒ p, Fact (Nat.Prime p) âˆ§ Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : IsSimpleAddGroup G],\n  âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : IsSimpleAddGroup G],\n  âˆƒ (p : â„•) (hp : Fact (Nat.Prime p)), Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : IsSimpleAddGroup G], âˆƒ p [_inst_2 : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) "
    ]
  },
  {
    "docString": "Prove that subgroups of a solvable group are solvable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"}]\n",
    "prompt_cons": "/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- Prove that subgroups of a solvable group are solvable. -/\ntheorem",
    "choices": [
      "forall {G : Type u_1} [inst : Group G] [h : IsSolvable G], âˆ€ (H : Subgroup G), IsSolvable H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G], âˆ€ (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "forall {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G), IsSolvable {x // x âˆˆ H} ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G], âˆ€ (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G], âˆ€ (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hSolvable : IsSolvable G] (H : Subgroup G), IsSolvable H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G), IsSolvable H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsSolvable G â†’ âˆ€ (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } "
    ]
  },
  {
    "docString": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"}]\n",
    "prompt_cons": "/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] {H : Subgroup G} (hn : Subgroup.normal H) (hnt : Nontrivial { x // x âˆˆ H }),\n  âˆƒ A : Subgroup G, A â‰¤ H âˆ§ Subgroup.normal A âˆ§ IsAbelian A âˆ§ Nontrivial { x // x âˆˆ A } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G) [hn : Subgroup.Normal H],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ (A : Subgroup G), Nontrivial { x // x âˆˆ A } âˆ§ A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [IsSolvable G] {H : Subgroup G} [Subgroup.Normal H],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ A : Subgroup G, Nontrivial { x // x âˆˆ A } âˆ§ A.normal G âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] {H : Subgroup G} (hH : H.normal),\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ (A : Subgroup G), A.normal âˆ§ IsAbelian A âˆ§ Nontrivial { x // x âˆˆ A } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [is_solvable : IsSolvable G] (H : Subgroup G) [h : Subgroup.Normal H],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ A : Subgroup G, Nontrivial { x // x âˆˆ A } âˆ§ Subgroup.Normal A âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G) [hH : Subgroup.Normal H],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ A : Subgroup G, A âŠ† H âˆ§ Subgroup.Normal A âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G) [hH : H.normal],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ (A : Subgroup G), A â‰¤ H âˆ§ Nontrivial { x // x âˆˆ A } âˆ§ A.normal âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G) [hn : Subgroup.Normal H] [ht : Nontrivial { x // x âˆˆ H }],\n  âˆƒ A : Subgroup G, A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G) [_inst_1 : Subgroup.Normal H] (hH : Nontrivial {x // x âˆˆ H}),\n  âˆƒ A : Subgroup G, A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian ({x // x âˆˆ A}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G) [hn : Subgroup.Normal H] [ht : Nontrivial { x // x âˆˆ H }],\n  âˆƒ A : Subgroup G, A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian { x // x âˆˆ A } "
    ]
  },
  {
    "docString": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"}]\n",
    "prompt_cons": "/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [hT : Transitive G] [hA : Nonempty A] [h1 : Fintype.card A > 1], âˆƒ Ïƒ : G, âˆ€ a : A, Ïƒ â€¢ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] (A : Set G) [inst_1 : Fintype A] [hN : Fintype.card A > 1], IsTransitive G A â†’ âˆƒ Ïƒ : G, âˆ€ a âˆˆ A, Ïƒ * a â‰  a ",
      "âˆ€ (G : Type u_1) (A : Type u_2) [inst : Fintype A] [inst_1 : Group G] [hN : Fintype.card A > 1] [mul_action : MulAction G A], Transitive G A â†’ âˆƒ Ïƒ : G, âˆ€ a : A, MulAction.acts_on Ïƒ a â‰  a ",
      "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G] (A : Type u_2) [inst_2 : Fintype A] [hA : Fintype.card A > 1] [MulAction G A] [hG : MulAction.IsTransitive G A], âˆƒ Ïƒ : G, âˆ€ a : A, Ïƒ â€¢ a â‰  a ",
      "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G] (A : Type u_2) [inst_2 : Fintype A] [inst_3 : Nonempty A] [hN : Fintype.card A > 1], IsTransitive G A â†’ âˆƒ Ïƒ : G, (âˆ€ a : A, Ïƒ â€¢ a â‰  a) ",
      "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G] [inst_2 : MulAction G (fin n)] (a : fin n), n > 1 â†’ âˆƒ Ïƒ âˆˆ G, âˆ€ a : fin n, Ïƒ â€¢ a â‰  a ",
      "âˆ€ (G : Type u_1) [inst : Group G] [finA : Fintype G] [transG : Transitive G] (A : Type u_2) [inst_1 : Fintype A] [inst_2 : Nonempty A], Fintype.card A > 1 â†’ âˆƒ Ïƒ : G, âˆ€ a : A, Ïƒ â‰  a ",
      "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fintype (perm G)] (A : set G) [hA : Fintype A] (h1 : card A > 1) (h2 : âˆ€ (a : G), âˆƒ Ïƒ âˆˆ perm G, Ïƒ a â‰  a),\n  âˆƒ Ïƒ : G â†’ G, Ïƒ âˆˆ perm G âˆ§ âˆ€ a âˆˆ A, Ïƒ a â‰  a ",
      "âˆ€ (G : Type u_1) [inst : Group G] (A : Type u_2) [instA : Fintype A] [hA : Fintype.card A > 1], Transitive G A â†’ âˆƒ (Ïƒ : G), âˆ€ (a : A), Ïƒ â€¢ a â‰  a ",
      "âˆ€ (G : Type u_1) [inst : Group G] (A : Type u_2) [inst_1 : Fintype A] [inst_2 : Fintype G], Transitive G A â†’ (âˆ€ a : A, âˆƒ Ïƒ : G, Ïƒ * a â‰  a) "
    ]
  },
  {
    "docString": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„•}, 0 < a â†’ ((âˆƒ k, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\\nelement, then `S` is dense `G`. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- `n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. -/\ntheorem âˆ€ (n : â„•) {a : â„•}, 0 < a â†’ ((âˆƒ k, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n) :=\n\n/-- Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S :=\n\n/-- Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  Fintype.card G = n â†’ n â‰  1 â†’ (âˆ€ k, k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card H = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•} (hn : 0 < n) [h : Fact (Â¬Nat.Prime n)],\n  (âˆ€ k, 0 < k â†’ k âˆ£ n â†’ âˆƒ K : Subgroup G, Fintype.card â†¥K = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•} (hn : 0 < n) (hG : Fintype.card G = n),\n  (âˆ€ k, 0 < k â†’ k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  (âˆ€ k, k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card H = k) â†’ Nat.Prime n â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : â„•),\n  Fintype.card G = n â†’ Nat.Composite n â†’ (âˆ€ k, 0 < k â†’ k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•} (hn : 1 < n) [inst_2 : Fact (n âˆ£ Fintype.card G)],\n  (âˆ€ k, 1 â‰¤ k â†’ k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•}, n â‰  0 â†’ (âˆ€ k, k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k) â†’\n  Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•}, 0 < n â†’ Fintype.card G = n â†’ Â¬Nat.Prime n â†’\n  (âˆ€ k, 0 < k â†’ k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•} (hn : Fintype.card G = n),\n  (âˆ€ k : â„•, k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•} [hn : Fact (0 < n)] (h : âˆ€ k, 0 < k â†’ k âˆ£ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = k),\n  Nat.Prime n â†’ Â¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that characteristic subgroups are normal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"}]\n",
    "prompt_cons": "/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Prove that characteristic subgroups are normal. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H "
    ]
  },
  {
    "docString": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’ Subgroup.characteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’\n      Subgroup.IsCharSubgroup H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’\n      Subgroup.IsCharacteristic G H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’ H.char G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’\n      Subgroup.charact_of_unique_card H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  (âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = Fintype.card { x // x âˆˆ H } â†’ K = H) â†’\n    Subgroup.characteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} {H : Subgroup G},\n  (âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = Fintype.card { x // x âˆˆ H } â†’ K = H) â†’\n    Subgroup.IsCharSubgroup H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n  (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’\n  Subgroup.IsChar H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’\n      Subgroup.charact H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = p ^ n â†’ K = H) â†’\n      Subgroup.characteristic H "
    ]
  },
  {
    "docString": "Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} (H : Subgroup G),\n  P âˆˆ Sylow p G â†’ (âˆ€ x, x âˆˆ P â†’ x âˆˆ H) â†’ P âˆˆ Sylow p { x // x âˆˆ H } ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} (H : Subgroup G),\n  P âˆˆ Sylow p G â†’ P â‰¤ H â†’ P âˆˆ Sylow p { x // x âˆˆ H } ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} (H : Subgroup G),\n  P âˆˆ Sylow p G â†’ P âˆˆ Sylow p { x // x âˆˆ H } ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} (H : Subgroup G) [inst_1 : SylowPGroup p G P],\n  P â‰¤ H â†’ âˆƒ Q : Subgroup { x // x âˆˆ H }, SylowPGroup p H Q âˆ§ P = â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G} (hSyl : IsSylow p P) (hPH : P â‰¤ H),\n  IsSylow p { x // x âˆˆ H } ",
      "forall {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) (P : Subgroup G),\n  IsPGroup p { x // x âˆˆ P } â†’ P âˆˆ Sylow p G â†’ P âˆˆ Sylow p { x // x âˆˆ H } ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) (P : Subgroup G), P âˆˆ Sylow p G â†’ P â‰¤ H â†’ P âˆˆ Sylow p { x // x âˆˆ H } ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G}, \n  IsPGroup p { x // x âˆˆ P } â†’ P â‰¤ H â†’ âˆƒ Q : Sylow p { x // x âˆˆ H }, P â‰¤ â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} (H : Subgroup G),\n  IsSylow p P â†’ P â‰¤ H â†’ IsSylow p {x // x âˆˆ P} ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) (P : Sylow p G),\n  P.1 â‰¤ H â†’ Sylow p { x // x âˆˆ H } "
    ]
  },
  {
    "docString": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’ âˆƒ p [hp : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, P.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = 312 â†’ âˆƒ K : Subgroup G, Subgroup.normal K âˆ§ Fintype.card { x // x âˆˆ K } = p ^ n ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p [inst_2 : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, Sylow.normal P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’ âˆƒ p, âˆƒ K : Sylow p G, âˆ€ H : Sylow p G, H = K ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p K, Fact (Nat.Prime p) âˆ§ p âˆ£ Fintype.card G âˆ§ IsPGroup p { x // x âˆˆ K } âˆ§ Subgroup.Normal K ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p K [inst_2 : Fact (Nat.Prime p)], Fintype.card { x // x âˆˆ K } = p âˆ§ IsNormalSubgroup K ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’\n  âˆƒ p, Fact (Nat.Prime p) âˆ§ p âˆ£ 312 âˆ§ âˆƒ (P : Sylow p G), Subgroup.normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p [Fact (Nat.Prime p)] (P : Sylow p G), IsNormalSubgroup P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’ âˆƒ p : â„•, âˆƒ [inst_2 : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, P.normal ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’ âˆƒ p K, Fact (Nat.Prime p) âˆ§ p âˆ£ Fintype.card G âˆ§ is_normal_subgroup K âˆ§ Fintype.card { x // x âˆˆ K } = p "
    ]
  },
  {
    "docString": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (Sylow.exists_normal p G) âˆ¨ (Sylow.exists_normal q G) âˆ¨ (Sylow.exists_normal r G) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (âˆƒ P : Sylow p G, Subgroup.Normal P) âˆ¨ (âˆƒ Q : Sylow q G, Subgroup.Normal Q) âˆ¨ (âˆƒ R : Sylow r G, Subgroup.Normal R) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (p < q) â†’ (q < r) â†’ (âˆƒ K : Sylow p G, is_normal G K) âˆ¨ (âˆƒ L : Sylow q G, is_normal G L) âˆ¨ (âˆƒ M : Sylow r G, is_normal G M) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (p < q) â†’ (q < r) â†’ âˆƒ P, IsPGroup p { x // x âˆˆ P } âˆ§ Subgroup.Normal P âˆ¨\n                                  âˆƒ Q, IsPGroup q { x // x âˆˆ Q } âˆ§ Subgroup.Normal Q âˆ¨\n                                  âˆƒ R, IsPGroup r { x // x âˆˆ R } âˆ§ Subgroup.Normal R ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (âˆƒ M, is_normal (Sylow p G) M) âˆ¨ (âˆƒ N, is_normal (Sylow q G) N) âˆ¨ (âˆƒ O, is_normal (Sylow r G) O) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  p < q â†’ q < r â†’ Fintype.card G = p * q * r â†’ âˆƒ P : Sylow p G, IsNormal P âˆ¨ âˆƒ Q : Sylow q G, IsNormal Q âˆ¨ âˆƒ R : Sylow r G, IsNormal R ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (âˆƒ P : Sylow p G, Subgroup.normal P) âˆ¨ (âˆƒ Q : Sylow q G, Subgroup.normal Q) âˆ¨ (âˆƒ R : Sylow r G, Subgroup.normal R) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (âˆƒ P : Sylow p G, P.normal) âˆ¨ (âˆƒ Q : Sylow q G, Q.normal) âˆ¨ (âˆƒ R : Sylow r G, R.normal) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  p < q âˆ§ q < r âˆ§ Fintype.card G = p * q * r â†’ (âˆƒ P : Sylow p G, is_normal P) âˆ¨ (âˆƒ Q : Sylow q G, is_normal Q) âˆ¨ (âˆƒ R : Sylow r G, is_normal R) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)] [inst_4 : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ (âˆƒ P : Sylow p G, IsNormal P) âˆ¨ (âˆƒ Q : Sylow q G, IsNormal Q) âˆ¨ (âˆƒ R : Sylow r G, IsNormal R) "
    ]
  },
  {
    "docString": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Prove that a group of order 200 has a normal Sylow 5-subgroup. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 200),\n  âˆƒ (P : Sylow 5 G), IsNormalSubgroup â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200),\n  âˆƒ (P : Sylow 5 G), IsNormalSubgroup (â†‘P : Set G) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200),\n  Exists (Î» P : Sylow 5 G, Subgroup.Normal (â†‘P)) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200), âˆƒ Q : Sylow 5 G, IsNormalSubgroup (â†‘Q) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 200),\n  âˆƒ (P : Sylow 5 G), IsNormalSubgroup (â†‘P) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [h : Fintype.card G = 200],\n  âˆƒ P : Sylow 5 G, IsNormalSubgroup (â†¥â†‘P) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200),\n  âˆƒ (P : Sylow 5 G), IsNormalSubgroup â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [hG : Fintype G] (h : Fintype.card G = 200),\n  âˆƒ (P : Sylow 5 G), IsNormalSubgroup â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200),\n  âˆƒ (P : Sylow 5 G), IsNormalSubgroup (â†‘P) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [hG : Fintype.card G = 200], âˆƒ Q : Sylow 5 G, IsNormalSubgroup (Q : Subgroup G) "
    ]
  },
  {
    "docString": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- Prove that if $|G|=1365$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [Fintype G],\n  Fintype.card G = 1365 â†’ (Â¬IsSimpleGroup G) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hN : Nontrivial G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [Nonempty G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that if $|G|=132$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- Prove that if $|G|=132$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] {hG : Fintype G}, Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : Fintype G], fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G] [hG : Nontrivial G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "forall {G : Type u_1} [inst : Group G] [hN : Fact (fintype.card G = 132)], Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\\n      Nonempty\\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\n      Nonempty\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)] :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’ AddCommGroup.IsAddAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      Group.IsAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      IsAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    âˆ€ {P : Sylow 3 G}, Subgroup.Normal â†‘P â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    âˆ€ (P3 : Sylow 3 G), Subgroup.Normal â†‘P3 â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      Group.IsAbelian G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      IsAbelian G ",
      "forall {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (forall {P : Sylow 3 G}, Subgroup.Normal â†‘P â†’ Group.IsAbelian G) ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’ Group.IsAbelian G "
    ]
  },
  {
    "docString": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” Subgroup.commSubgroup G H â‰¤ H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” Subgroup.comap (MulEquiv.toMonoidHom (commutator G H)) H â‰¤ H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” Subgroup.commutator G H â‰¤ H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” Subgroup.to_submonoid (Subgroup.commutator G H) â‰¤ Subgroup.to_submonoid H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  H.normal â†” Subgroup.comm_group H â‰¤ H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” Subgroup.comap (MulAut.conjL.to_monoid_hom) H â‰¤ H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” âˆ€ (a : G), âˆ€ (b : G),\n    H (a * b * aâ»Â¹) â†’ H (b * a * bâ»Â¹) ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  (Subgroup.normal H â†” Subgroup.comm_group G H â‰¤ H) ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G},\n  Subgroup.normal H â†” Subgroup.IsSubgroup { x // x âˆˆ Subgroup.commG G H } H ",
      "âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G),\n  Subgroup.normal H â†” Subgroup.comm_subgroup G H â‰¤ H "
    ]
  },
  {
    "docString": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand x is an element of an A-algebra that is integral over A, then x is integral over R.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\\n  Polynomial.Monic gâ‚ â†’\\n    Polynomial.Monic gâ‚‚ â†’\\n      IsCoprime gâ‚ gâ‚‚ â†’\\n        âˆƒ q râ‚ râ‚‚,\\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\\ndeg(râ‚‚) < deg(gâ‚‚).\\n\"}]\n",
    "prompt_cons": "/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x :=\n\n/-- Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\ndeg(râ‚‚) < deg(gâ‚‚). -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\n  Polynomial.Monic gâ‚ â†’\n    Polynomial.Monic gâ‚‚ â†’\n      IsCoprime gâ‚ gâ‚‚ â†’\n        âˆƒ q râ‚ râ‚‚,\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚ :=\n\n/-- Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$. -/\ntheorem",
    "choices": [
      "âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] (x : R),\n  x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  x^2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (x : R), x^2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x^2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (x : R),\n  x^2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x * x = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 "
    ]
  },
  {
    "docString": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"}]\n",
    "prompt_cons": "/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- Multiplication in a boolean ring is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] [self : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±], IsCommutative Î± (*) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] [h : âˆ€ a : R, a * a = a], IsCommutative R ",
      "âˆ€ {R : Type u_1} [self : Ring R] (h : âˆ€ (a : R), a * a = a), IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : âˆ€ (a : R), a * a = a], IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R mul ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±], IsCommutative Î± (*) ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], âˆ€ (a b : R), a * b = b * a "
    ]
  },
  {
    "docString": "Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\\n  AddSubgroup.Normal H â†’ âˆ€ (n : A), n âˆˆ H â†’ âˆ€ (g : A), g + n + -g âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"`N` is closed under additive conjugation \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) (Î² : Type v) [inst : AddGroup Î±] [inst_1 : AddAction Î± Î²] [inst_2 : Fintype Î±]\\n  [inst_3 : (a : Î±) â†’ Fintype â†‘(AddAction.fixedBy Î± Î² a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel Î± Î²))],\\n  (Finset.sum Finset.univ fun a => Fintype.card â†‘(AddAction.fixedBy Î± Î² a)) =\\n    Fintype.card (Quotient (AddAction.orbitRel Î± Î²)) * Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\\nthe average number of elements fixed by each `g âˆˆ G` is the number of orbits. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G) :=\n\n/-- `N` is closed under additive conjugation -/\ntheorem âˆ€ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\n  AddSubgroup.Normal H â†’ âˆ€ (n : A), n âˆˆ H â†’ âˆ€ (g : A), g + n + -g âˆˆ H :=\n\n/-- **Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\nthe average number of elements fixed by each `g âˆˆ G` is the number of orbits. -/\ntheorem âˆ€ (Î± : Type u) (Î² : Type v) [inst : AddGroup Î±] [inst_1 : AddAction Î± Î²] [inst_2 : Fintype Î±]\n  [inst_3 : (a : Î±) â†’ Fintype â†‘(AddAction.fixedBy Î± Î² a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel Î± Î²))],\n  (Finset.sum Finset.univ fun a => Fintype.card â†‘(AddAction.fixedBy Î± Î² a)) =\n    Fintype.card (Quotient (AddAction.orbitRel Î± Î²)) * Fintype.card Î± :=\n\n/-- Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} {G : Type u_2} [inst : Semiring R] [inst_1 : Group G] [inst_2 : Fintype G],\n  (Finset.sum Finset.univ fun a => a) âˆˆ Subgroup.center (GroupRing R G) ",
      "âˆ€ {R : Type u} [inst : Semiring R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N : R[G] ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "âˆ€ {R : Type u_1} {G : Type u_2} [inst : Semiring R] [inst_2 : Group G] [inst_3 : Fintype G],\n  let N ",
      "âˆ€ {R : Type u_1} [inst : Ring R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G], \n  let N ",
      "âˆ€ {R : Type u} {G : Type v} [inst : Semiring R] [inst_1 : Group G] [inst_2 : Fintype G] [inst_3 : MulSemiringAction R G],\n  let N : R[G] ",
      "âˆ€ {R : Type u} {G : Type v} [inst : Semiring R] [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "âˆ€ {R : Type u_1} [inst : Semiring R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Fintype G] [inst_2 : Mul G] [inst_3 : One G],\n  (Finset.sum Finset.univ (fun g => g)) âˆˆ Subgroup.center (GroupRing R G) ",
      "forall {R : Type u} {G : Type v} [inst : Semiring R] [inst_1 : Group G] [inst_2 : Fintype G]\n  [inst_3 : MulSemiringAction G R], (Finset.sum Finset.univ fun g => g) âˆˆ Subgroup.center (GroupRing R G) "
    ]
  },
  {
    "docString": "An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G â§¸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)] [inst_1 : Finite Î·]\\n  [inst_2 : âˆ€ (i : Î·), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"n-ary products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- A quotient of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G â§¸ H) :=\n\n/-- A p-group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G :=\n\n/-- n-ary products of nilpotent groups are nilpotent -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)] [inst_1 : Finite Î·]\n  [inst_2 : âˆ€ (i : Î·), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : Î·) â†’ Gs i) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$. -/\ntheorem",
    "choices": [
      "âˆ€ {p m : â„•} [hp : Fact (Nat.Prime p)] [hm : 1 â‰¤ m], Ideal.IsNilpotent (Ideal.span ({p} : Set (Zmod (p ^ m)))) ",
      "/-- A quotient of a nilpotent group is nilpotent -/\ntheorem quotient_nilpotent {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G] :\n  Group.IsNilpotent (G â§¸ H) ",
      "âˆ€ {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {p} : Ideal (Zmod (p^m))) ",
      "âˆ€ {R : Type u_1} [comm_ring R] [is_domain R] {p m : â„•} [hp : Fact (Nat.Prime p)], \n  Ideal.IsNilpotent (Ideal.span {p} : Ideal (R â§¸ (Ideal.span {p ^ m}))) ",
      "forall (p m : â„•) [hp : Fact (Nat.Prime p)] [hm : 0 < m],\n  IsNilpotentIdeal (Ideal_span ({p} : Set (Zmod (p ^ m)))) ",
      "âˆ€ {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)], Ring.IsNilpotentIdeal (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      "âˆ€ {p m : â„•} [hp : Fact (Nat.Prime p)], \n  Ideal.IsNilpotent (Ideal.span {(p : Zmod (p ^ m))}) ",
      "{p : â„•} [hp : Fact (Nat.Prime p)] {m : â„•} (m_pos : 0 < m) :\n  Ring.Ideal.IsNilpotent (Ideal.span (singleton (coe p)) : Ideal (Zmod (p ^ m))) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R) [inst_2 : Ideal.IsPrincipal I] {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)],\n  (I = Ideal.span ({p ^ m})) â†’ Ideal.IsNilpotent (I â§¸ (Ideal.span ({p ^ (m - 1)}))) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (N : Ideal R) [inst_1 : Ideal.IsNilpotent N], IsNilpotentIdeal (N â§¸ N) "
    ]
  },
  {
    "docString": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"}]\n",
    "prompt_cons": "/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$. -/\ntheorem",
    "choices": [
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M : â„¤} {d : â„•}, Int.gcd M â†‘N = 1 â†’ Int.gcd d (Nat.totient N) = 1 â†’ âˆ€ (M_1 : â„¤), M_1 â‰¡ M ^ d [MOD â†‘N] â†’ âˆƒ (d' : â„•), d * d' â‰¡ 1 [MOD Nat.totient N] âˆ§ M â‰¡ M_1 ^ d' [MOD â†‘N] ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M : â„¤}, Int.gcd M â†‘N = 1 â†’ âˆ€ {d : â„•}, Int.gcd d (nat.totient N) = 1 â†’ âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ M ^ d [MOD â†‘N] â†’ âˆƒ (d' : â„•), d * d' â‰¡ 1 [MOD nat.totient N] âˆ§ M â‰¡ Mâ‚ ^ d' [MOD â†‘N] ",
      "âˆ€ {N : â„•} (hN : N â‰  0) {M : â„¤} {d : â„•}, Int.gcd M â†‘N = 1 â†’ Int.gcd â†‘d (Euler.phi N) = 1 â†’ âˆ€ {M1 : â„¤}, M1 â‰¡ M ^ â†‘d [MOD â†‘N] â†’ âˆƒ (dp : â„•), dp â‰¡ dâ»Â¹ [MOD Euler.phi N] âˆ§ M â‰¡ M1 ^ â†‘dp [MOD â†‘N] ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M d : â„¤}, Int.gcd M â†‘N = 1 â†’ Int.gcd d (nat.totient N) = 1 â†’ âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ M^d [MOD â†‘N] â†’ âˆƒ (d' : â„¤), d * d' â‰¡ 1 [MOD nat.totient N] âˆ§ M â‰¡ Mâ‚^d' [MOD â†‘N] ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M d : â„¤}, Int.gcd M â†‘N = 1 â†’ Int.gcd d (Int.natAbs (Euler.phi N)) = 1 â†’\n  âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ (M^d) [MOD â†‘N] â†’ âˆƒ (d' : â„¤), d * d' â‰¡ 1 [MOD (Int.natAbs (Euler.phi N))] âˆ§ M â‰¡ (Mâ‚^d') [MOD â†‘N] ",
      "âˆ€ {N M d Mâ‚ : â„•}, N > 0 â†’ Int.gcd M N = 1 â†’ Int.gcd d (nat.totient N) = 1 â†’ (Mâ‚ â‰¡ (M ^ d) [MOD N]) â†’ âˆƒ (d' : â„•), (d * d') % nat.totient N = 1 âˆ§ (M â‰¡ (Mâ‚ ^ d') [MOD N]) ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M : â„¤}, Int.gcd M â†‘N = 1 â†’ âˆ€ {d : â„¤}, Int.gcd d (Int.natAbs (Euler.phi N)) = 1 â†’\n  âˆ€ {M1 : â„¤}, M1 â‰¡ (M ^ d) [ZMOD â†‘N] â†’\n  âˆƒ (d' : â„¤), d * d' â‰¡ 1 [ZMOD (Int.natAbs (Euler.phi N))] âˆ§ M â‰¡ (M1 ^ d') [ZMOD â†‘N] ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M d : â„¤}, Int.gcd M â†‘N = 1 â†’ Int.gcd d (Int.ofNat (Nat.totient N)) = 1 â†’ âˆ€ {M1 : â„¤}, M1 â‰¡ (M ^ d) [ZMOD â†‘N] â†’ âˆƒ (d' : â„¤), d * d' â‰¡ 1 [ZMOD (Int.ofNat (Nat.totient N))] â†’ M â‰¡ (M1 ^ d') [ZMOD â†‘N] ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M : â„¤}, Int.gcd M â†‘N = 1 â†’ âˆ€ {d : â„•}, Int.gcd â†‘d (Nat.totient N) = 1 â†’ âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ M ^ d [MOD â†‘N] â†’ âˆƒ (d' : â„•), d * d' â‰¡ 1 [MOD Nat.totient N] âˆ§ M â‰¡ Mâ‚ ^ d' [MOD â†‘N] ",
      "âˆ€ {N : â„•} (hn : N > 0) {M : â„¤} (hM : Int.gcd M â†‘N = 1) {d : â„•} (hd : Int.gcd (â†‘d) (nat.totient N) = 1) {Mâ‚ : â„¤}, Mâ‚ â‰¡ M ^ d [ZMOD â†‘N] â†’ âˆƒ (d' : â„•), (â†‘d * â†‘d') % nat.totient N = 1 âˆ§ M â‰¡ Mâ‚ ^ d' [ZMOD â†‘N] "
    ]
  },
  {
    "docString": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„¤}, âˆƒ x y : â„š, n = x ^ 2 + y ^ 2 â†’ âˆƒ r s : â„¤, n = r ^ 2 + s ^ 2 ",
      "âˆ€ {n : â„¤}, (âˆƒ x y : â„š, n = x ^ 2 + y ^ 2) â†’ âˆƒ r s : â„¤, n = r ^ 2 + s ^ 2 ",
      "âˆ€ {k : â„¤}, (âˆƒ x y : â„š, k = x ^ 2 + y ^ 2) â†’ âˆƒ r s : â„¤, k = r ^ 2 + s ^ 2 ",
      "âˆ€ {n : â„¤}, (âˆƒ (x y : â„š), n = x ^ 2 + y ^ 2) â†’ âˆƒ (a b : â„¤), n = a ^ 2 + b ^ 2 ",
      "âˆ€ {z : â„¤}, (âˆƒ p q r s : â„š, z = (p * p + q * q) âˆ§ z = (r * r + s * s)) â†’ âˆƒ x y, z = x ^ 2 + y ^ 2 ",
      "âˆ€ {x y z : â„š}, z = x ^ 2 + y ^ 2 â†’ âˆƒ m n : â„•, z = (m ^ 2 + n ^ 2) ",
      "âˆ€ {z : â„¤}, âˆƒ p q : â„š, z = p ^ 2 + q ^ 2 â†’ âˆƒ x y : â„¤, z = x ^ 2 + y ^ 2 ",
      "âˆ€ {m : â„¤}, (âˆƒ x y : â„š, m = x ^ 2 + y ^ 2) â†’ âˆƒ r s : â„¤, m = r ^ 2 + s ^ 2 ",
      "âˆ€ {n : â„¤}, (âˆƒ x y : â„š, n = x ^ 2 + y ^ 2) â†’ âˆƒ r s : â„¤, n = r ^ 2 + s ^ 2 ",
      "âˆ€ {z : â„¤}, âˆƒ x y : â„š, z = x ^ 2 + y ^ 2 â†’ âˆƒ r s : â„¤, z = r ^ 2 + s ^ 2 "
    ]
  },
  {
    "docString": "Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"}]\n",
    "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R :=\n\n/-- Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2. -/\ntheorem",
    "choices": [
      "quotient_Zi_by_1_plus_i_is_field_of_order_2 : IsField (â„¤[i] â§¸ Ideal.span [(1 + I)]) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span [(1 + I)]) = 2 ",
      "Ideal.Quotient.mk (Ideal.span {(1 + I)} : Ideal â„¤[i]) = ideal.quotient.mk (Ideal.span {(1 + I)}),\nInst : Field (â„¤[i] â§¸ Ideal.span {(1 + I)}) ",
      "Ideal.QuotientIsFieldOfOrderTwo : âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (I : Ideal R),\n  Ideal.IsMaximal I â†’ Fintype.card (R â§¸ I) = 2 â†’ IsField (R â§¸ I) ",
      "IsField (â„¤[i] â§¸ (1 + I)) âˆ§ Fintype.card (â„¤[i] â§¸ (1 + I)) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 + I)}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 + I)}) = 2 ",
      "âˆ€ {I : Ideal â„¤[i]}, I = Ideal.span {(1 : â„¤[i]) + I} â†’ IsField (â„¤[i] â§¸ I) âˆ§ Fintype.card (â„¤[i] â§¸ I) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 + I)}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 + I)}) = 2 ",
      "inst_1 : Fintype (â„¤[i] â§¸ (1 + I)),\nIsField (â„¤[i] â§¸ (1 + I)) âˆ§ Fintype.card (â„¤[i] â§¸ (1 + I)) = 2 ",
      "QuotientRing_Zi_Field : âˆƒ (I : Ideal â„¤[i]), Ideal.IsMaximal I âˆ§ Fintype.card (â„¤[i] â§¸ I) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 + I)} : Type u_1) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 + I)}) = 2 "
    ]
  },
  {
    "docString": "Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$. -/\ntheorem",
    "choices": [
      "âˆ€ (Q : Type u_1) [inst : Field Q], Â¬IsPrincipalIdealRing (Q[x, y]) ",
      "âˆ€ (Q : Type u_1) [inst : Field Q], Â¬IsPrincipalIdealRing (Q[X, Y]) ",
      "âˆ€ (R : Type u_1) [inst : Field R] [inst_1 : CommRing (Polynomial R)], Â¬IsPrincipalIdealRing (Polynomial R Ã— Polynomial R) ",
      "âˆ€ (Q : Type) (x y : Q) [inst : Field Q], Â¬IsPrincipalIdealRing (Q[x, y]) ",
      "âˆ€ (Q : Type u_1) [inst : Field Q] {x y : Q[X]}, Â¬IsPrincipalIdealRing (Q[X, y]) ",
      "âˆ€ (R : Type u_1) (S : Type u_2) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : IsDomain R] [inst_3 : IsDomain S] [inst_4 : Algebra R S],\nÂ¬IsPrincipalIdealRing (R Ã— S) ",
      "âˆ€ (x y : Rat.Polynomial) [inst : CommRing Rat.Polynomial], Â¬IsPrincipalIdealRing (Rat.Polynomial Ã— Rat.Polynomial) ",
      "not_principal_ideal_Qxy : âˆ€ (x y : â„š[X]), Â¬IsPrincipalIdealRing (x, y) ",
      "âˆ€ (Q : Type u_1) [inst : Field Q] (x y : Polynomial Q), Â¬IsPrincipalIdealRing (Polynomial Q Ã— Polynomial Q) ",
      "NotPrincipalIdeal.exists_xy (QX : Type u_1) [inst : CommRing QX] [inst_1 : IsDomain QX] [inst_2 : Algebra â„š QX] (x y : QX) : Â¬IsPrincipalIdealRing QX "
    ]
  },
  {
    "docString": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\\n  Polynomial.Monic gâ‚ â†’\\n    Polynomial.Monic gâ‚‚ â†’\\n      IsCoprime gâ‚ gâ‚‚ â†’\\n        âˆƒ q râ‚ râ‚‚,\\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\\ndeg(râ‚‚) < deg(gâ‚‚).\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_2} {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : MonoidWithZeroHomClass F â„š Mâ‚€] {f g : F},\\n  (âˆ€ (m : â„¤), â†‘f â†‘m = â†‘g â†‘m) â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` agree on the integers then they are equal `Ï†`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"}]\n",
    "prompt_cons": "/-- Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\ndeg(râ‚‚) < deg(gâ‚‚). -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\n  Polynomial.Monic gâ‚ â†’\n    Polynomial.Monic gâ‚‚ â†’\n      IsCoprime gâ‚ gâ‚‚ â†’\n        âˆƒ q râ‚ râ‚‚,\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚ :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I :=\n\n/-- If `f` and `g` agree on the integers then they are equal `Ï†`. -/\ntheorem âˆ€ {F : Type u_2} {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : MonoidWithZeroHomClass F â„š Mâ‚€] {f g : F},\n  (âˆ€ (m : â„¤), â†‘f â†‘m = â†‘g â†‘m) â†’ f = g :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {f g : Polynomial R} (hf : âˆ€ (n : â„•), â†‘(Polynomial.coeff f n) âˆˆ â„¤) (hg : âˆ€ (n : â„•), â†‘(Polynomial.coeff g n) âˆˆ â„¤),\nâˆ€ (m n : â„•), â†‘(Polynomial.coeff f m) * â†‘(Polynomial.coeff g n) âˆˆ â„¤ ",
      "âˆ€ {f g : Polynomial â„š} (hf : âˆ€ (n : â„•), Polynomial.coeff f n âˆˆ â„¤) (hg : âˆ€ (n : â„•), Polynomial.coeff g n âˆˆ â„¤),\n  âˆ€ (i j : â„•), Polynomial.coeff f i * Polynomial.coeff g j âˆˆ â„¤ ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (f g : Polynomial â„š),\n  (âˆ€ (m : â„•), Polynomial.coeff (f * g) m âˆˆ â„¤) â†’\n    âˆ€ (i j : â„•), â†‘(Polynomial.coeff f i) * â†‘(Polynomial.coeff g j) âˆˆ â„¤ ",
      "âˆ€ {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f g : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff (f * g) n âˆˆ â„¤) â†’\n    (âˆ€ (i j : â„•), Polynomial.coeff f i * Polynomial.coeff g j âˆˆ â„¤) ",
      "âˆ€ {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K] [inst_4 : IsFractionRing (Polynomial R) K] (f g : Polynomial R),\n  (âˆ€ (n : â„•), (Polynomial.coeff (f * g) n).is_integer) â†’\n    âˆ€ (i j : â„•), ((Polynomial.coeff f i) * (Polynomial.coeff g j)).is_integer ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Algebra R â„š] (f g : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff (f * g) n âˆˆ â„¤) â†’\n    âˆ€ (m n : â„•), Polynomial.coeff f m * Polynomial.coeff g n âˆˆ â„¤ ",
      "âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (Q : Type) [inst_2 : DivisionRing Q] [inst_3 : Algebra R Q]\n  [inst_4 : IsFractionRing R Q] (f g : Polynomial R) (hf : âˆ€ (n : â„•), (Polynomial.coeff f n) * (Polynomial.coeff g n) âˆˆ R),\n  âˆ€ i j, (Polynomial.coeff f i) * (Polynomial.coeff g j) âˆˆ R ",
      "âˆ€ {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] (f g : Polynomial â„•),\n  (âˆ€ (n : â„•), Polynomial.coeff (f * g) n âˆˆ â„¤) â†’\n    (âˆ€ (i j : â„•), (Polynomial.coeff f i) * (Polynomial.coeff g j) âˆˆ â„¤) ",
      "âˆ€ {f g : Polynomial â„š},\n  (âˆ€ (m : â„•), Polynomial.coeff (f * g) m âˆˆ â„¤) â†’\n  âˆ€ {i j : â„•}, â†‘(Polynomial.coeff f i) * â†‘(Polynomial.coeff g j) âˆˆ â„¤ ",
      "âˆ€ {f g : Polynomial â„š} (hf : âˆ€ (n : â„•), Polynomial.coeff f n âˆˆ â„¤) (hg : âˆ€ (n : â„•), Polynomial.coeff g n âˆˆ â„¤),\n  âˆ€ (m n : â„•), (Polynomial.coeff f m * Polynomial.coeff g n) âˆˆ â„¤ "
    ]
  },
  {
    "docString": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_6 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_plus_30x_pow_5_minus_15x_pow_3_plus_6x_minus_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_poly : Irreducible (Poly.mk (6 :: -15 :: 0 :: 30 :: 0 :: 0 :: 1)) ",
      "theorem x_pow_6_irreducible : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_plus_30x_pow_5_minus_15x_pow_3_plus_6x_minus_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "example : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120 : Polynomial â„¤) ",
      "example : Irreducible (Polynomial.x^6 + (30 : â„¤) * Polynomial.x^5 - (15 : â„¤) * Polynomial.x^3 + (6 : â„¤) * Polynomial.x - (120 : â„¤)) ",
      "irreducible_X_pow_6_add_30_X_pow_5_sub_15_X_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "example : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_30x_pow_5_minus_15x_pow_3_plus_6x_minus_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) "
    ]
  },
  {
    "docString": "Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L]\\n  [hpri : Fact (Nat.Prime â†‘p)] [hcyc : IsCyclotomicExtension {p} K L],\\n  IsPrimitiveRoot Î¶ â†‘p â†’ Irreducible (Polynomial.cyclotomic (â†‘p) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (Î¶ - 1) = â†‘â†‘p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic p K)` (in particular for `K = â„š`) and `p` is an odd prime,\\nthen the norm of `Î¶ - 1` is `p`. \"}]\n",
    "prompt_cons": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `Irreducible (cyclotomic p K)` (in particular for `K = â„š`) and `p` is an odd prime,\nthen the norm of `Î¶ - 1` is `p`. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L]\n  [hpri : Fact (Nat.Prime â†‘p)] [hcyc : IsCyclotomicExtension {p} K L],\n  IsPrimitiveRoot Î¶ â†‘p â†’ Irreducible (Polynomial.cyclotomic (â†‘p) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (Î¶ - 1) = â†‘â†‘p :=\n\n/-- Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible ((Polynomial.x + 2) ^ p - (2 ^ p) / Polynomial.x) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.x_pow_add_C_nat p 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.map (Int.castRingHom â„š) (((Polynomial.x + 2)^p - 2^p) /â‚˜ Polynomial.x)) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.x_pow_add_C_div (p : â„•) 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.eval (x+2)^p - 2^p / x) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.x_add_mul (2 ^ p) (x + 2) ^ p - 2 ^ p) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.map (Int.castRingHom â„¤) ((X + 2)^p - 2^p) / X) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible ((X + 2)^p - 2^p / X) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.x_pow_sub (Polynomial.C 2) p) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’\n  Irreducible (Polynomial.xgcd (Polynomial.map â„¤ (Polynomial.pow_mod (Polynomial.x + 2) p - Polynomial.pow_mod 2 p)) (Polynomial.x)) "
    ]
  },
  {
    "docString": "Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"}]\n",
    "prompt_cons": "/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$. -/\ntheorem",
    "choices": [
      "Irreducible (Polynomial.map (Polynomial.algebraMap â„š[x] â„š) (x ^ 2 + y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š[â„š]) ",
      "Irreducible (Polynomial.map (algebra_map â„š (Polynomial â„š)) (Polynomial.map (algebra_map â„š (Polynomial â„š)) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1))) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š[â„•]) ",
      "Irreducible (Polynomial.map (Polynomial.evalâ‚‚_ring_hom (Polynomial.evalâ‚‚_ring_hom (algebra_map â„š (FractionRing â„š[X])) Polynomial.x) Polynomial.y) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible ((Polynomial.x ^ 2 + Polynomial.y ^ 2) - 1 : Polynomial â„š) ",
      "Irreducible (Polynomial.x^2 + Polynomial.y^2 - 1 : Polynomial â„š) ",
      "Irreducible (Polynomial.evalâ‚‚ (RingHom.id â„š) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.mapâ‚‚ â„š â„š (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.map (algebraMap â„š (Polynomial â„š)) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) "
    ]
  }
]