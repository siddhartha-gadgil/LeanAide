[
  {
    "docString": "Every ring is a field.",
    "prompts": "[{\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"}]\n",
    "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- Every ring is a field. -/\ntheorem",
    "choices": [
      "Sorry, the statement \"Every ring is a field\" is incorrect, and therefore I cannot provide a theorem for it.",
      "This statement is incorrect and cannot be proven. Not every ring is a field.",
      "This statement is incorrect and cannot be proven. Not every ring is a field. Please provide a correct statement.",
      "Sorry, I cannot create that theorem because it is not correct. Not every ring is a field.",
      "This statement is incorrect and cannot be proven. Not every ring is a field. A correct statement would be \"Every field is a ring.\"",
      "Sorry, I cannot write a theorem that contradicts the established mathematical facts. Every ring is not a field.",
      "Sorry, the last statement is incorrect and cannot be proven in Lean Theorem Prover. Every ring is NOT a field. A field is a special case of a ring where every nonzero element has a multiplicative inverse.",
      "This statement is not true, so I cannot provide a theorem for it. Not every ring is a field.",
      "I cannot complete this request as it contradicts the previous examples and it is not true that every ring is a field.",
      "This statement is incorrect, as every ring is not a field. Please provide a correct statement to translate."
    ]
  },
  {
    "docString": "Every vector space is finite dimensional.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"}]\n",
    "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem",
    "choices": [
      "Sorry, I cannot write a theorem that says \"Every vector space is finite dimensional.\" as it is not true in general. Vector spaces can be infinite-dimensional as well. Please provide a different statement or example for me to follow.",
      "I'm sorry, but I cannot generate a theorem stating that \"every vector space is finite dimensional\" as it is not true in general. There are infinite-dimensional vector spaces, so I cannot provide a Lean theorem stating otherwise. However, if you need help with any other theorems or examples, feel free to ask!",
      "Sorry, I cannot prove the statement \"Every vector space is finite dimensional\" as it is not true in general. There exist infinite-dimensional vector spaces, such as the space of all continuous functions on a given interval.",
      "This statement is incorrect and cannot be proven in Lean. Not every vector space is finite-dimensional. Please provide a correct statement to translate into Lean code.",
      "I'm sorry, but I cannot create a theorem stating that \"Every vector space is finite dimensional\" as it is not true in general. There are infinite-dimensional vector spaces, like the space of all real-valued functions on the real line. Please provide another theorem for me to translate.",
      "I'm sorry, but the statement \"Every vector space is finite dimensional\" is not true in general. There are infinite-dimensional vector spaces. Therefore, I cannot provide a theorem for this statement in Lean theorem prover code.",
      "I'm sorry, but the statement \"Every vector space is finite dimensional\" is not true in general. There exist infinite-dimensional vector spaces. Please provide a different statement or example for me to translate into Lean code.",
      "I'm sorry, but I cannot create a theorem stating that \"Every vector space is finite dimensional\" since it is not true in general. There are many infinite-dimensional vector spaces, such as the space of all functions from ℝ to ℝ, or the space of all sequences of real numbers. However, I can provide you with Lean code for the previous theorems you specified. Here they are:\n\n```lean\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem finite_basis_implies_finite_dim {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Basis ι K V → FiniteDimensional K V ",
      "I'm sorry, but I cannot generate the theorem \"Every vector space is finite dimensional.\" as it is not true in general. There are infinite-dimensional vector spaces, so I cannot provide a Lean code for this statement. If you have any other theorem or statement to be translated into Lean code, please let me know.",
      "I'm sorry, but I cannot provide a theorem stating that every vector space is finite-dimensional, as it is not true. There are infinite-dimensional vector spaces, such as the space of all continuous functions on the real line, or the space of all sequences of real numbers. If you need help with a different theorem, feel free to ask!"
    ]
  },
  {
    "docString": "Every group is a torsion monoid.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"}]\n",
    "prompt_cons": "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Every group is a torsion monoid. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem sub_torsion_of_torsion {G : Type u_1} [inst : Group G] (torsion : Monoid.IsTorsion G) (H : Subgroup G) : Monoid.IsTorsion { x // x ∈ H } ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "theorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem subgroups_of_torsion_are_torsion {G : Type u_1} [inst : Group G] (ht : Monoid.IsTorsion G) (H : Subgroup G) : Monoid.IsTorsion { x // x ∈ H } ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
      "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "
    ]
  },
  {
    "docString": "Every finite simple group has prime order.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Every finite simple group has prime order. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  IsSimpleGroup α → ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ (p : ℕ) [hp : Fact (Nat.Prime p)], Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  IsSimpleGroup α → ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ {p : ℕ}, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [hs : IsSimpleGroup α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ p [hp : Fact (Nat.Prime p)], Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [is_simple : IsSimpleGroup α],\n  ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ p [hp : Fact (Nat.Prime p)], Fintype.card α = p "
    ]
  },
  {
    "docString": "Every finite group is simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Every finite group is simple. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α ",
      "Sorry, I cannot provide a theorem stating that every finite group is simple, as that statement is not true in general.",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α ",
      "This statement is incorrect and cannot be translated into Lean Theorem Prover code. Not every finite group is simple.",
      "This statement is incorrect and cannot be translated to Lean code. Not every finite group is simple, only those of prime order are.",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α ",
      "This statement is incorrect, and thus, there is no Lean code for it.",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α "
    ]
  },
  {
    "docString": "Every finite group has prime order.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- Every finite group has prime order. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → ∀ (G : α), ∃ n : ℕ, n * order_of G = Fintype.card α ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ (p : ℕ) [hp : Fact (Nat.Prime p)], Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p "
    ]
  },
  {
    "docString": "Every set has Lebesgue measure zero.",
    "prompts": "[{\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"}]\n",
    "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0 :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem",
    "choices": [
      "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0 ",
      "Sorry, I cannot provide a theorem that states \"Every set has Lebesgue measure zero\" because it is not a correct statement. There are many sets with non-zero Lebesgue measures.",
      "I'm sorry, but the statement \"Every set has Lebesgue measure zero\" is not true, so I cannot provide a theorem for it.",
      "↑↑MeasureTheory.volume {x | Liouville x} = 0 ",
      "This statement is incorrect. Please provide a correct statement to translate.",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 ",
      "MeasureTheory.volume (s : Set ℝ) = 0 ",
      "This statement is incorrect, as not every set has Lebesgue measure zero. A correct statement would be: \"Every set of Lebesgue measure zero is measurable.\" Here's the Lean code for that statement:\n\ntheorem every_set_of_measure_zero_is_measurable {α : Type u_1} [inst : MeasurableSpace α] (s : Set α) :\n  ↑↑MeasureTheory.volume s = 0 → MeasurableSet s ",
      "MeasureTheory.volume {x | Liouville x} = 0 ",
      "Sorry, I cannot generate a theorem that states \"every set has Lebesgue measure zero\" as it is not true in general. The Lebesgue measure is a measure defined on subsets of the real line (or higher-dimensional real spaces) that assigns a non-negative extended real number to each set, and it is not zero for every set. For example, the Lebesgue measure of an interval is equal to the length of the interval, which is not zero for non-empty intervals."
    ]
  },
  {
    "docString": "If a topological space is compact, then every subset is compact.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α},\n  IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] {s : Set α}, IsCompact s "
    ]
  },
  {
    "docString": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
    "prompts": "[{\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"}]\n",
    "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : MeasurableSpace α] [inst_3 : BorelSpace α] [inst_4 : MeasureTheory.MeasureSpace α],\n  (s : Set α), MeasurableSet s → ¬ BorelSpace.is_borel_measurable s → ↑↑MeasureTheory.volume s = 0 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : TopologicalSpace.SecondCountableTopology α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ¬ BorelMeasurableSpace.MeasurableSet' s → ↑↑μ s = 0 ",
      "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : MeasureTheory.Measure α] (s : Set α), MeasurableSet s → ¬ Borel.MeasurableSet s → ↑↑MeasureTheory.volume s = 0 ",
      "forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : NormedSet α] [inst_2 : BorelSpace α]\n  [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure (MeasureTheory.volume : MeasureTheory.Measure α)] (s : Set α),\n  MeasurableSet s → ¬ BorelSet s → ↑↑MeasureTheory.volume s = 0 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasureTheory.MeasureSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  MeasurableSet s ∧ ¬BorelMeasurable s → ↑↑MeasureTheory.volume s = 0 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ¬ BorelMeasurable s → ↑↑μ s = 0 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s ∧ ¬ BorelMeasurable s → ↑↑μ s = 0 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ¬ BorelMeasurable s → ↑↑μ s = 0 ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] (m : MeasureTheory.Measure α)\n  [inst_2 : BorelSpace α] (s : Set α), MeasurableSet s → ¬ BorelSpace.MeasurableEq m → ↑↑m s = 0 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s → ¬ BorelMeasurable α s → ↑↑μ s = 0 "
    ]
  },
  {
    "docString": "A finitely-presented group containing a torsion element is finite.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A → Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"}]\n",
    "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem ∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  Algebra.FinitePresentation R A → Algebra.FiniteType R A :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Algebra.FinitePresentation (Units G) G → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∃ (x : G) (n : ℕ), n ≠ 0 ∧ x ^ n = 1 → Group.FinitePresentation G → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], (Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) →\n  Algebra.FinitePresentation G → ∃ (x : G), Monoid.IsTorsion G x → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], (∃ x ∈ G, Monoid.IsTorsion G) → Algebra.FinitePresentation G → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → (∃ x : G, HasTorsion x) → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], (∃ x : G, Monoid.Torsion x) → Group.FinitePresentation G → Group.Finite G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.HasTorsion G → Group.FinitePresentation G → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], (Monoid.ContainsTorsion G → Algebra.FinitePresentation G) → ∀ (x : G), Monoid.torsion x → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], Group.FinitelyPresented G → (∃ a ∈ G, Monoid.IsTorsionElement a) → Finite G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FinitePresentation G → Finite G "
    ]
  },
  {
    "docString": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"}]\n",
    "prompt_cons": "/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem",
    "choices": [
      "forall {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x, x ∈ s → ∃ t : Set α, x ∈ t ∧ IsClosed t) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ∈ s, IsClosed t ∧ x ∈ t) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ⊆ s, x ∈ t ∧ IsClosed t) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t) → IsClosed s "
    ]
  },
  {
    "docString": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"}]\n",
    "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (λ x : X, (x, x)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α], IsOpenMap (fun (x : α) => (x, x)) ↔ T2Space α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α],\n  IsOpenMap ((λ x, (x, x)) : α → α × α) ↔ T2Space α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α],\n  IsOpenMap (λ x : α, (x, x)) ↔ T2Space α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α],\n  IsOpenMap (λ x : α, (x, x)) ↔ T2Space α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α],\n  IsOpenMap (Diagonal.diagonal : α → α × α) ↔ T2Space α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α],\n  T2Space α ↔ IsOpenMap (λ x : α, (x, x)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α], IsOpenMap (λ x : α, (x, x)) ↔ T2Space α ",
      "∀ {α : Type u} [inst : TopologicalSpace α],\n  (T2Space α ↔ IsOpenMap (@Prod.diagonal α α)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  T2Space α ↔ IsOpenMap (fun x : α => (x, x)) "
    ]
  },
  {
    "docString": "Any finite order element in a group is equal to the identity.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"}]\n",
    "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x^orderOf x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → orderOf x = 1 → x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 "
    ]
  },
  {
    "docString": "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"}]\n",
    "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], (∃ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G], (∃ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G], (∃ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G], (∃ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G], (∃ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G "
    ]
  },
  {
    "docString": "Every injective homomorphism from a finitely generated free group to itself is surjective.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"}]\n",
    "prompt_cons": "/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R →\n    ∀ (ps : ι → MvPolynomial ι R),\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] [inst_2 : Fintype G],\n  ∀ (f : G → G), IsGroupHom f → Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fg α] {f : α → α}, \n  IsGroupHom f → Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α}, IsGroupHom f →\n  Function.Injective f → Function.Surjective f ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : FgFree G] {f : G → G},\n  IsGroupHom f → Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : FgFree α] {f : α → α},\n  IsGroupHom f → Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α}, IsGroupHom f →\n  Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : FgFree α] {f : α → α}, IsGroupHom f →\n  Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : FgFree α] (f : α →* α),\n  Function.Injective ↑f → Function.Surjective ↑f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] {f : α → α},\n  IsGroupHom f → Function.Injective f → Function.Surjective f ",
      "∀ {α : Type u} [inst : Group α] [inst_1 : IsFinitelyGenerated α] [inst_2 : IsFree α],\n  ∀ (f : α → α), IsGroupHom f → Function.Injective f → Function.Surjective f "
    ]
  },
  {
    "docString": "Every division ring is either a field or finite.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"}]\n",
    "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem ∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\n  [inst_2 : Valued K Γ₀], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem",
    "choices": [
      "∀ (K : Type u) [inst : DivisionRing K], Nonempty (Fintype K) ∨ Field K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], is_field K ∨ fintype K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], is_field K ∨ fintype K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], is_field K ∨ fintype K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], Field K ∨ Nonempty (Fintype K) ",
      "∀ {K : Type u_1} [inst : DivisionRing K], Field K ∨ Finite K ",
      "∀ {K : Type u_1} [inst : DivisionRing K], Or (Field K) (Finite K) ",
      "∀ (K : Type u) [inst : DivisionRing K], Nontrivial K → Field K ∨ Fintype K "
    ]
  },
  {
    "docString": "Every natural number is the product of two primes.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), ∃ (p q : ℕ), Prime p ∧ Prime q ∧ n = p * q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), (n = p * q) ∧ Prime p ∧ Prime q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), Prime p ∧ Prime q ∧ n = p * q ",
      "∀ (n : ℕ), ∃ p q : ℕ, n = p * q ∧ Nat.Prime p ∧ Nat.Prime q ",
      "∀ (n : ℕ), ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), n = p * q ∧ Nat.Prime p ∧ Nat.Prime q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), n = p * q ∧ Nat.Prime p ∧ Nat.Prime q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), n = p * q ∧ Nat.Prime p ∧ Nat.Prime q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), n = p * q ∧ Nat.Prime p ∧ Nat.Prime q ",
      "∀ (n : ℕ), ∃ (p q : ℕ), n = p * q ∧ Prime p ∧ Prime q "
    ]
  },
  {
    "docString": "Every even number is the square of a natural number.",
    "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ∀ (a b c d x y z w : ℕ),\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), 2 ∣ n → ∃ (k : ℕ), n = 2 * k ^ 2 ",
      "∀ (n : ℕ), even n → ∃ (k : ℕ), n = 2 * k ^ 2 ",
      "∀ {n : ℕ}, n % 2 = 0 → ∃ (m : ℕ), n = 2 * m ^ 2 ",
      "∀ {n : ℕ}, Even n → ∃ k, n = k ^ 2 ",
      "∀ {n : ℕ}, n % 2 = 0 → ∃ (k : ℕ), n = (2 * k) ^ 2 ",
      "∀ {n : ℕ}, n % 2 = 0 → ∃ (a : ℕ), a ^ 2 = n ",
      "∀ {n : ℕ}, n % 2 = 0 → ∃ r, n = (2 * r) ^ 2 ",
      "∀ (n : ℕ), 2 ∣ n → ∃ (m : ℕ), n = (2 * m) ^ 2 ",
      "∀ (n : ℕ), 2 ∣ n → ∃ (k : ℕ), n = (2 * k) ^ 2 ",
      "∀ {n : ℕ}, n % 2 = 0 → ∃ (a : ℕ), n = (2 * a) ^ 2 "
    ]
  },
  {
    "docString": "Every normal subgroup of a group has finite index.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0 :=\n\n/-- The additive subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0 :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ∈ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H ",
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hN : Subgroup.Normal H], Subgroup.FiniteIndex H ",
      "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [hN : Subgroup.Normal N], Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G), Subgroup.Normal N → Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [N.normal : Subgroup.Normal N], Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.FiniteIndex N ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [self : Subgroup.Normal H], Subgroup.FiniteIndex H "
    ]
  },
  {
    "docString": "The characteristic polynomial of every matrix has real roots.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] {A : Matrix n n α},\\n  Matrix.IsHermitian A → (fun i => ↑(↑IsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"}]\n",
    "prompt_cons": "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] {A : Matrix n n α},\n  Matrix.IsHermitian A → (fun i => ↑(↑IsROrC.re (Matrix.diag A i))) = Matrix.diag A :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem ∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ (p : Polynomial ℝ),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1 :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem",
    "choices": [
      "forall {α : Type u_1} [inst : IsROrC α] {n : Type u_2} {A : Matrix n n α},\n  ∃ p : Polynomial ℝ, ∀ z, Polynomial.IsRoot p z ↔ ∃ μ, Polynomial.IsRoot (Matrix.charpoly A) μ ∧ ↑(starRingEnd α) μ = z ",
      "∀ {n : Type u_1} {α : Type u_2} [inst : CommRing α] [IsDomain α] [DecidableEq n] [Fintype n] {M : Matrix n n α},\n  ∃ λ, Polynomial.IsRoot (Matrix.charpoly M) (coeFn (algebraMap α ℝ) λ) ",
      "∀ {α : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [IsROrC α] {A : Matrix n n α},\n  ∃ λ : ℝ, Polynomial.IsRoot (Matrix.charpoly A) (IsROrC.ofReal λ) ",
      "∀ {α : Type u_1} [inst : IsROrC α] {n : Type u_2} {A : Matrix n n α},\n  ∃ p : Polynomial ℝ, Polynomial.degree p = Polynomial.degree (Matrix.charpoly A) ∧\n    ∀ z, Polynomial.IsRoot (Matrix.charpoly A) z → Polynomial.IsRoot p (IsROrC.re z) ",
      "∀ {α : Type u_1} {n : Type u_2} [inst : IsROrC α] {A : Matrix n n α},\n  ∃ λ : ℝ, Polynomial.IsRoot (Matrix.charpoly A) (IsROrC.of_real α λ) ",
      "∀ {α : Type u_1} [inst : IsROrC α] {n : Type u_2} [inst_1 : DecidableEq n] [inst_2 : Fintype n] {A : Matrix n n α},\n  ∃ r : Polynomial ℝ, Polynomial.roots r = Multiset.map (fun x => ↑IsROrC.re x) (Polynomial.roots (Matrix.charpoly A)) ",
      "∀ {n : Type u_1} {α : Type u_2} [inst : IsROrC α] {A : Matrix n n α},\n  ∃ p : Polynomial ℝ, ∀ z, Polynomial.IsRoot (↑p) z ↔ Module.End.HasEigenvalue (Matrix.toLin' A) (↑z) ",
      "∀ {α : Type u_1} {n : Type u_2} [inst : CommRing α] [inst_1 : Nontrivial n] {A : Matrix n n α},\n  ∃ (real_roots : Multiset ℝ), (fun t => ↑(Polynomial.map (algebraMap α ℝ) (Matrix.charpoly A) t)) = Multiset.map coe real_roots ",
      "∀ {α : Type u_1} [_inst_1 : CommRingₓ α] [_inst_2 : IsDomain α] {n : Type u_2} [_inst_3 : Fintype n] [_inst_4 : DecidableEq n] (M : Matrix n n α),\n  ∃ r, Polynomial.IsRoot (Matrix.charpoly M) r ",
      "∀ {α : Type u_1} {n : Type u_2} [inst : CommRing α] [inst_1 : IsDomain α] {A : Matrix n n α},\n  ∃ p : Polynomial ℝ, Polynomial.roots (Matrix.charpoly A) = Polynomial.roots p "
    ]
  },
  {
    "docString": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} → ∀ {I : Ideal R}, IsUnit ↑I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"}]\n",
    "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} → ∀ {I : Ideal R}, IsUnit ↑I → Submodule.IsPrincipal I :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ",
      "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ",
      "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ⊆ M ",
      "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P],\n  ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ",
      "∀ {R : Type u} [inst : CommRing R], (∀ (P : Ideal R), Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M) ",
      "∀ {R : Type u} [inst : CommRing R], (∀ (P : Ideal R), Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M) ",
      "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ",
      "forall {R : Type u} [inst : CommRing R], (∀ (P : Ideal R), Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M) ",
      "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ",
      "∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M) "
    ]
  },
  {
    "docString": "Every continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"}]\n",
    "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β}\n  [inst_2 : TopologicalSpace α], Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f "
    ]
  },
  {
    "docString": "Every uniformly continuous function is bounded above.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : TopologicalSpace β] [inst_2 : LinearOrder β] [inst_3 : OrderClosedTopology β]\n  [inst_4 : CompactSpace α] [inst_5 : Nonempty α] {f : α → β}, UniformContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : TopologicalSpace α] [inst_2 : Nonempty α] [inst_3 : LinearOrder β]\n  [inst_4 : OrderClosedTopology β] [inst_5 : TopologicalSpace β] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : MetricSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : MetricSpace β] [inst_2 : CompactSpace α] [inst_3 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : TopologicalSpace β] [inst_2 : LinearOrder β] [inst_3 : OrderClosedTopology β]\n  [inst_4 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : TopologicalSpace β] [inst_2 : LinearOrder β]\n  [inst_3 : OrderClosedTopology β] [inst_4 : Nonempty α] {f : α → β},\n  UniformlyContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : MetricSpace α] [inst_1 : MetricSpace β] [inst_2 : Nonempty α] {f : α → β},\n  UniformlyContinuous f → BddAbove (Set.range f) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : LinearOrder β] [inst_2 : TopologicalSpace β]\n  [inst_3 : OrderClosedTopology β] {f : α → β} (hf : UniformContinuous f), BddAbove (Set.range f) ",
      "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : MetricSpace β] [inst_2 : CompactSpace α] [inst_3 : Nonempty β] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) "
    ]
  },
  {
    "docString": "If every compact subset of a topological space is closed, then the space is compact.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ s : Set α, IsCompact s → IsClosed s), CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (K : Set α), IsCompact K → IsClosed K) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (s : Set α), IsCompact s → IsClosed s), CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α "
    ]
  },
  {
    "docString": "In a commutative ring, the sum of idempotent elements is idempotent.",
    "prompts": "[{\"theorem\": \"∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"}]\n",
    "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem ∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e}) :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → a * b = 0 → IsIdempotentElem (a + b) ",
      "∀ {α : Type u_1} [inst : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
      "∀ {α : Type u_1} [self : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
      "∀ {α : Type u_1} [self : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
      "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ",
      "∀ {α : Type u_1} [self : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
      "∀ {α : Type u_1} [inst : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
      "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ",
      "∀ {α : Type u_1} [inst : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
      "∀ {α : Type u_1} [self : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) "
    ]
  },
  {
    "docString": "The number of partitions of a finite set is a prime number.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"}]\n",
    "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Part.card (Set α)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Partitions (Fintype.card α)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Fintype.card (Partition α)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Fintype.card (Set (Set α))) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Fintype.card (Finset.partitions α)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Fintype.card (Finset.Partition α)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Fintype.card (Finset.Partition α)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Partitions.partitions (Fintype.card α)) ",
      "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α], IsPrime (Fintype.card (Finset α →₀ ℕ)) ",
      "∀ {α : Type u_1} [inst : Fintype α], Nat.Prime (Fintype.card (Partition α)) "
    ]
  },
  {
    "docString": "If a poset has a maximal element, then it has a unique minimal element.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"}]\n",
    "prompt_cons": "/-- A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem ∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a :=\n\n/-- A greatest element of a set is the supremum of this set. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → sSup s = a :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, (∃ m, ∀ a, a ≤ m) → (∃! b, ∀ a, b ≤ a) ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, (∃ m : α, ∀ x : α, x ≤ m) → ∃! b : α, ∀ x : α, b ≤ x ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, IsMaximal a → IsMinimal b → a = b ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {m : α}, (∃ M, IsMaximal M) → ∃! m, IsMinimal m ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {s : Set α} {a b : α}, IsMaximal s a → IsMinimal s b → a = b ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, (∃ b, ∀ c, c ≤ b) → (∃! d, ∀ c, d ≤ c) ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, (∃ b : α, ∀ x : α, x ≤ b) → (∃! a : α, ∀ x : α, a ≤ x) ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, IsMaximal a → IsMinimal b → a = b ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, ∃! b, IsMaximal a → IsMinimal b ",
      "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, IsMaximal a → IsMinimal b → a = b "
    ]
  },
  {
    "docString": "The automorphism group of an Abelian group is cyclic.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : Fintype α], IsCyclic (AddAut α) ",
      "∀ {G : Type u} [inst : AddGroup G] [inst_1 : IsAddCyclic G], IsCyclic (AddAut G) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : Fintype α], IsCyclic (AddAut α) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [IsCyclic α], IsCyclic (AddAut α) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : Fintype α], IsAddCyclic (AddAut α) ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : IsAddCyclic G], IsAddCyclic (AddAut G) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : Fintype α], IsAddCyclic (AddAut α) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [IsAddCyclic α], IsAddCyclic (AddAut α) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : Fintype (AddAut α)],\n  IsAddCyclic (AddAut α) ",
      "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : Fintype α], IsAddCyclic (Aut α) "
    ]
  },
  {
    "docString": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"∀ {f : Ordinal.{u} → Ordinal.{u}}, Ordinal.IsNormal f → Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"}]\n",
    "prompt_cons": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem ∀ {f : Ordinal.{u} → Ordinal.{u}}, Ordinal.IsNormal f → Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem ∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : BoundedOrder α] {f : α → α},\n  (∃ x, Function.IsFixedPt f x) → ∀ (n : ℕ), n ≠ 0 → ∃ x, Function.IsPeriodicPt f n x ",
      "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α] {f : α → α},\n  HasSubset.Subset (Set.Icc (0 : α) 1) (Set.Range f) →\n  ∃ (x : α), Function.IsFixedPt f x →\n  ∀ (n : ℕ), n > 0 → ∃ (y : α), Function.IsPeriodicPt f n y ",
      "∀ {f : ℝ → ℝ} (hf : ∀ x ∈ Icc (0 : ℝ) (1 : ℝ), f x ∈ Icc (0 : ℝ) (1 : ℝ)) {x : ℝ} (hx : x ∈ Icc (0 : ℝ) (1 : ℝ)) (hfx : f x = x),\n  ∀ (n : ℕ) (hn : 0 < n), ∃ y ∈ Icc (0 : ℝ) (1 : ℝ), Function.IsPeriodicPt f n y ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] {f : α → α} {x : α},\n  Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x ",
      "∀ {f : ℝ → ℝ} (hf : ∀ x ∈ Set.Icc (0 : ℝ) 1, f x ∈ Set.Icc (0 : ℝ) 1) (x₀ : ℝ) (hx₀ : Function.IsFixedPt f x₀),\n  ∀ (n : ℕ) (hn : 0 < n), ∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f n x ",
      "∀ {f : ℝ → ℝ} {x : ℝ}, Function.IsFixedPt f x → (0 ≤ x ∧ x ≤ 1) → ∀ (n : ℕ), n > 0 → ∃ (y : ℝ), Function.IsPeriodicPt f n y ∧ 0 ≤ y ∧ y ≤ 1 ",
      "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α] {f : α → α},\n  HasSubset.Subset (Set.Icc (0 : α) 1) (Set.Range f) → Function.HasFixedPoint f (Set.Icc (0 : α) 1) →\n  ∀ (n : ℕ), n > 0 → ∃ x ∈ Set.Icc (0 : α) 1, Function.IsPeriodicPt f n x ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  Function.fixedPointExists f → ∀ (n : ℕ), n > 0 → Function.positivePeriodicPointExists f n ",
      "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → (∃ x, Function.IsFixedPt f x) → ∀ (n : ℕ), n > 0 → ∃ x, Function.IsPeriodicPt f n x ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [_inst_2 : TopologicalSpace α]\n  [_inst_3 : OrderTopology α] [_inst_4 : FloorRing α] {f : α → α},\n  (∃ x, HasMem.Mem x (Set.Icc (0 : α) 1) ∧ Function.IsFixedPt f x) →\n  ∀ (n : ℕ), n > 0 → ∃ x, HasMem.Mem x (Set.Icc (0 : α) 1) ∧ Function.IsPeriodicPt f n x "
    ]
  },
  {
    "docString": "The complement of the union of two sets contains the union of their complements.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\\n  (hμt : ↑↑μ t ≠ ⊤),\\n  s ∩ t = ∅ →\\n    ∀ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"}]\n",
    "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t) :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\n  (hμt : ↑↑μ t ≠ ⊤),\n  s ∩ t = ∅ →\n    ∀ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ "
    ]
  },
  {
    "docString": "The square root of an rational number is rational.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"}]\n",
    "prompt_cons": "/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2} :=\n\n/-- The square root of an rational number is rational. -/\ntheorem",
    "choices": [
      "∀ (q : ℚ), ∃ r : ℚ, (r * r = q) ∨ (q < 0) ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
      "∀ (q : ℚ), ∃ r : ℚ, r * r = q "
    ]
  },
  {
    "docString": "If a module over a ring is free, then the ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ↔ Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} (R : Type u) [inst : Semiring R] (M : ι → Type u_2) [inst_1 : Finite ι]\\n  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R (M i)]\\n  [inst_4 : ∀ (i : ι), Module.Free R (M i)], Module.Free R ((i : ι) → M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"}]\n",
    "prompt_cons": "/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V ↔ Module.Finite K V :=\n\n/-- The product of finitely many free modules is free. -/\ntheorem ∀ {ι : Type u_1} (R : Type u) [inst : Semiring R] (M : ι → Type u_2) [inst_1 : Finite ι]\n  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R (M i)]\n  [inst_4 : ∀ (i : ι), Module.Free R (M i)], Module.Free R ((i : ι) → M i) :=\n\n/-- The lattice of submodules of a module over a division ring is atomistic. -/\ntheorem ∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsAtomistic (Submodule K V) :=\n\n/-- Modules over the trivial ring are Noetherian. -/\ntheorem ∀ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) ",
      "∀ {R : Type u} (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) ",
      "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) ",
      "∀ (R : Type u) {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (∗) ",
      "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Add ",
      "∀ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Mul ",
      "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Mul ",
      "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (λ x y, x * y) ",
      "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) ",
      "∀ (R : Type u) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) "
    ]
  },
  {
    "docString": "If the set of units of a ring forms a group then the ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Units R)], IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Units R)], IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : Group (Units R)], IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Units R)], IsCommutative R (*) ",
      "∀ {R : Type u_1} [inst : Ring R], IsGroup (Units R) → IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Units R)], IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : Group (Units R)], IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (GroupOfUnits R)], IsCommRing R ",
      "∀ {R : Type u_1} [inst : Ring R] (h : IsGroup (Units R)), IsCommutative R Mul ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : Group R], (∀ x y, IsUnit x → IsUnit y → IsUnit (x * y)) → Comm R "
    ]
  },
  {
    "docString": "Every natural number larger than `10` is the sum of a square and a prime.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem ∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ {n : ℕ}, n > 10 → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ",
      "∀ n : ℕ, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ n : ℕ, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ n : ℕ, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
      "∀ {n : ℕ}, n > 10 → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y "
    ]
  },
  {
    "docString": "The initial object of a category is isomorphic to its terminal object.",
    "prompts": "[{\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (Y ⟶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (X ⟶ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"}]\n",
    "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (Y ⟶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (X ⟶ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem",
    "choices": [
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.IsIsomorphic (CategoryTheory.Limits.initial C) (CategoryTheory.Limits.terminal C) ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C], \n  CategoryTheory.Limits.InitialObject C ≅ CategoryTheory.Limits.TerminalObject C ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C]\n  [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.initial C) →\n  ∃ (I : C), CategoryTheory.IsIso (CategoryTheory.Limits.initial.to I) ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Limits.InitialObject C ≅ CategoryTheory.Limits.TerminalObject C ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [h₁ : CategoryTheory.Limits.HasInitial C] [h₂ : CategoryTheory.Limits.HasTerminal C],\n  Nonempty (CategoryTheory.Iso (CategoryTheory.Limits.initial C) (CategoryTheory.Limits.terminal C)) ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Iso (⊤_ C) (⊥_ C)) ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [h : CategoryTheory.Limits.HasInitial C]\n  [h_1 : CategoryTheory.Limits.HasTerminal C], Nonempty (CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C) ",
      "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C "
    ]
  },
  {
    "docString": "If the composition of two functions is continuous, then each of them is continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => ‖g x‖) → MeasureTheory.Integrable f → Continuous g → Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"}]\n",
    "prompt_cons": "/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\n  BddAbove (Set.range fun x => ‖g x‖) → MeasureTheory.Integrable f → Continuous g → Continuous (convolution f g L) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s)) :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ],\n  ∀ {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {s : Set α} (h : ContinuousOn (g ∘ f) s),\n  ContinuousOn f s → ContinuousOn g (f '' s) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g "
    ]
  },
  {
    "docString": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
    "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"}]\n",
    "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c) :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem",
    "choices": [
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
      "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c "
    ]
  },
  {
    "docString": "If an element maps to zero under a ring homomorphism, then it is zero.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), ↑f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  (∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0) →\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"}]\n",
    "prompt_cons": "/-- Ring homomorphisms map zero to zero. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ≃+* S), ↑f 0 = 0 :=\n\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\n  (∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0) →\n    CategoryTheory.Mono f :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0 :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β] (f : α →+* β),\n  (f 0 = 0) → (0 : α) = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), (a : α), f a = 0 → a = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), (a : α), f a = 0 → a = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), f 0 = 0 → 0 = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), (a : α), f a = 0 → a = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  (f 0 = 0) → (0 = 0) ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
      "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 "
    ]
  },
  {
    "docString": "Implication `→` is symmetric. If `P → Q` then `Q → P`.",
    "prompts": "[{\"theorem\": \"∀ {p q r : Prop}, (p → q) → (q → r) → p → r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. \"},\n {\"theorem\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor Cᵒᵖ D)\\n  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P ⟶ P⁺)⁺ = P⁺ ⟶ P⁺⁺` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"}]\n",
    "prompt_cons": "/-- Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. -/\ntheorem ∀ {p q r : Prop}, (p → q) → (q → r) → p → r :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem ∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x :=\n\n/-- `(P ⟶ P⁺)⁺ = P⁺ ⟶ P⁺⁺` -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D]\n  [inst_2 :\n    ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  (P : CategoryTheory.Functor Cᵒᵖ D)\n  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D],\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P) :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- Implication `→` is symmetric. If `P → Q` then `Q → P`. -/\ntheorem",
    "choices": [
      "This statement is incorrect, as implication `→` is not symmetric. The correct statement is called contrapositive: If `P → Q` then `¬Q → ¬P`. The corresponding code for the contrapositive is:\n\ntheorem ∀ {p q : Prop}, (p → q) → (¬q → ¬p) ",
      "This statement is incorrect, as implication is not symmetric. You may have meant to ask for the contrapositive, which states that if `¬Q → ¬P`, then `P → Q`. Here is the correct theorem for the contrapositive:\n\n/-- Implication `→` is contrapositive. If `¬Q → ¬P` then `P → Q`. -/\ntheorem ∀ {p q : Prop}, (¬q → ¬p) → p → q ",
      "This statement is incorrect, as implication `→` is not symmetric. In general, if `P → Q`, it does not imply `Q → P`.",
      "This statement is incorrect. Implication `→` is not symmetric. The correct statement is: If `P ↔ Q` then `Q ↔ P`. Here's the code for that theorem:\n\n/-- If `P ↔ Q`, then `Q ↔ P`. -/\ntheorem ∀ {p q : Prop}, (p ↔ q) → (q ↔ p) ",
      "Please note that the statement \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\" is incorrect. Implication is not symmetric. However, I can provide the code for the correct statement: \"Implication `→` is contrapositive. If `P → Q` then `¬Q → ¬P`.\"\n\n/-- Implication `→` is contrapositive. If `P → Q` then `¬Q → ¬P`. -/\ntheorem contrapositive {P Q : Prop} (h : P → Q) : ¬Q → ¬P ",
      "This statement is incorrect as implication is not symmetric. Implication `→` is transitive, but not symmetric. So, there is no theorem for this statement.",
      "Sorry, the statement \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\" is not true, so I cannot provide a theorem for it. The correct property for implication is transitive, but not symmetric.",
      "This statement is incorrect, as implication `→` is not symmetric. Instead, you may be interested in the contrapositive: If `P → Q` then `¬Q → ¬P`. Here's the theorem for that:\n\n/-- If `P → Q`, then `¬Q → ¬P`. -/\ntheorem contrapositive {p q : Prop} (h : p → q) : ¬q → ¬p ",
      "This statement is incorrect, as implication `→` is not symmetric.",
      "This statement is incorrect. Implication `→` is not symmetric. Please provide a correct statement to translate into Lean code."
    ]
  },
  {
    "docString": "Two natural numbers are equal if and only if they are both divisible by some prime number.",
    "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"}]\n",
    "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ∀ {a b : ℕ}, a ∣ b → b < a → b = 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem ∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem",
    "choices": [
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ (p ∣ m ∧ p ∣ n)) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ (p ∣ m ∧ p ∣ n)) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), nat.prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), nat.prime p ∧ (p ∣ m ∧ p ∣ n)) ↔ m = n ",
      "∀ {m n : ℕ}, (∃ (p : ℕ), prime p ∧ (p ∣ m ∧ p ∣ n)) ↔ m = n "
    ]
  }
]