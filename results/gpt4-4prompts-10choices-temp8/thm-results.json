[
  {
    "docString": "If every proper closed subset of a topological space is compact, then the space itself is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- If every proper closed subset of a topological space is compact, then the space itself is compact. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±) (h1 : IsClosed K) (h2 : K â‰  univ), IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], (âˆ€ (C : Set Î±), IsClosed C âˆ§ C â‰  univ â†’ IsCompact C) â†’ CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K âˆ§ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K âˆ§ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ K : Set Î±, IsClosed K âˆ§ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), K â‰  univ â†’ IsClosed K â†’ IsCompact K), CompactSpace Î± "
    ]
  },
  {
    "docString": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ x y, x ^ 2 + y ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ x y, x ^ 2 + y ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ x y, x ^ 2 + y ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰¡ 1 [MOD 4] â†’ âˆƒ x y, x ^ 2 + y ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ x y, x ^ 2 + y ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ x y, x ^ 2 + y ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p "
    ]
  },
  {
    "docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem",
    "choices": [
      "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
      "âˆ€ {u v xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ : â„•}, u = xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 â†’ v = yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 â†’ âˆƒ râ‚ râ‚‚ râ‚ƒ râ‚„, u * v = râ‚ ^ 2 + râ‚‚ ^ 2 + râ‚ƒ ^ 2 + râ‚„ ^ 2 ",
      "âˆ€ {a b x y u v m n : â„•}, a = x ^ 2 + y ^ 2 + m ^ 2 + n ^ 2 â†’ b = u ^ 2 + v ^ 2 + m ^ 2 + n ^ 2 â†’ âˆƒ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ",
      "âˆ€ {a b x y z w u v s t : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 â†’ âˆƒ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ",
      "âˆ€ {a b x y z w u v s t : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 â†’ âˆƒ râ‚ râ‚‚ râ‚ƒ râ‚„, a * b = râ‚ ^ 2 + râ‚‚ ^ 2 + râ‚ƒ ^ 2 + râ‚„ ^ 2 ",
      "âˆ€ {a b x y z w u v s t : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 â†’ âˆƒ râ‚ râ‚‚ râ‚ƒ râ‚„, a * b = râ‚ ^ 2 + râ‚‚ ^ 2 + râ‚ƒ ^ 2 + râ‚„ ^ 2 ",
      "âˆ€ {a b x y z w u v t s : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 â†’ âˆƒ râ‚ râ‚‚ râ‚ƒ râ‚„, a * b = râ‚ ^ 2 + râ‚‚ ^ 2 + râ‚ƒ ^ 2 + râ‚„ ^ 2 ",
      "âˆ€ {a b x y u v p q : â„•}, a = x ^ 2 + y ^ 2 + p ^ 2 + q ^ 2 â†’ b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
      "âˆ€ {a b x y z w u v s t : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 â†’ âˆƒ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ",
      "âˆ€ {a b x y z w u v t s : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 â†’ âˆƒ râ‚ râ‚‚ râ‚ƒ râ‚„, a * b = râ‚ ^ 2 + râ‚‚ ^ 2 + râ‚ƒ ^ 2 + râ‚„ ^ 2 "
    ]
  },
  {
    "docString": "A ring with all elements idempotent is commutative.",
    "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"}]\n",
    "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- A ring with all elements idempotent is commutative. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [self : Mul Î±] [add_self : âˆ€ a : Î±, a * a = a], CommSemigroup Î± ",
      "âˆ€ {Î± : Type u_1} [self : Mul Î±] [self_1 : Add Î±] (h : âˆ€ a : Î±, a * a = a), Commutative Mul.mul ",
      "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] (H : âˆ€ (x : Î±), x * x = x), CommRing Î± ",
      "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±], IsCommutative Î± (*) ",
      "âˆ€ {Î± : Type u_1} [self : Ring Î±] (h : âˆ€ (a : Î±), a * a = a), CommRing Î± ",
      "âˆ€ {Î± : Type u_1} [self : Mul Î±] [inst : Add Î±] (h : âˆ€ (a : Î±), a * a = a), IsCommutative Î± (*) ",
      "âˆ€ {Î± : Type u_1} [inst : Mul Î±] [inst_1 : Add Î±] [inst_2 : Zero Î±] [inst_3 : One Î±] (a b : Î±) (h : âˆ€ (c : Î±), c * c = c), a * b = b * a ",
      "âˆ€ {Î± : Type u_1} [self : Ring Î±] (âˆ€ a : Î±, a * a = a), IsCommutative Î± Mul ",
      "âˆ€ {Î± : Type u_1} [self : Semiring Î±] (H : âˆ€ (a : Î±), a * a = a), CommSemiring Î± ",
      "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±], IsCommutative Î± (*) "
    ]
  },
  {
    "docString": "There are infinitely many pairs of primes that differ exactly by `2`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"}]\n",
    "prompt_cons": "/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- There are infinitely many pairs of primes that differ exactly by `2`. -/\ntheorem",
    "choices": [
      "âˆƒ f : â„• â†’ â„•, IsPrimePair f âˆ§ âˆ€ (n : â„•), f n + 2 â‰  f (n + 1) ",
      "âˆƒ (f : â„• â†’ â„•), (âˆ€ n, Nat.Prime (f n)) âˆ§ (âˆ€ n, f (n + 1) - f n = 2) ",
      "âˆƒ f : â„• â†’ â„•, âˆ€ n, âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ q - p = 2 âˆ§ f n = q ",
      "âˆƒ (f : â„• â†’ â„• Ã— â„•), (âˆ€ (n : â„•), Nat.Prime (f n).fst âˆ§ Nat.Prime (f n).snd âˆ§ (f n).snd - (f n).fst = 2) âˆ§ Function.Injective f ",
      "Exists (Î» (n : â„•), âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p - q = 2 * n) ",
      "âˆƒ (f : â„• â†’ â„• Ã— â„•), âˆ€ (n : â„•), âˆƒ (m : â„•) (H : m > n), Nat.Prime (f m).fst âˆ§ Nat.Prime (f m).snd âˆ§ (f m).snd - (f m).fst = 2 ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p < q â†’ p + 2 = q â†’ âˆƒ k : â„•, âˆƒ a b : â„•, a â‰  b âˆ§ Nat.Prime a âˆ§ Nat.Prime b âˆ§ a + 2 = b âˆ§ a > p ",
      "ExistsInfinitelyManyPairsOfPrimesWithDiff2 : âˆƒ p q, p â‰  q âˆ§ (p - q = 2 âˆ¨ q - p = 2) âˆ§ Nat.Prime p âˆ§ Nat.Prime q ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 2 = 1 âˆ§ q % 2 = 1 â†’ âˆƒ n, âˆ€ m â‰¥ n, âˆƒ pâ‚ qâ‚, Fact (Nat.Prime pâ‚) âˆ§ Fact (Nat.Prime qâ‚) âˆ§ pâ‚ % 2 = 1 âˆ§ qâ‚ % 2 = 1 âˆ§ pâ‚ + 2 = qâ‚ âˆ§ pâ‚ > m ",
      "âˆ€ (n : â„•), âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p - q = 2 âˆ§ p > n "
    ]
  },
  {
    "docString": "Every finite division ring is a field.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"}]\n",
    "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- Every finite division ring is a field. -/\ntheorem",
    "choices": [
      "âˆ€ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ",
      "âˆ€ {R : Type u_1} [inst : DivisionRing R] [inst_1 : Fintype R], Field R ",
      "âˆ€ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DivisionRing Î±], Field Î± ",
      "âˆ€ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DivisionRing Î±], Field Î± ",
      "âˆ€ {D : Type u_1} [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
      "âˆ€ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ",
      "âˆ€ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R "
    ]
  },
  {
    "docString": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {Mâ‚ : Type v} {Mâ‚‚ : Type v'} [inst_1 : AddCommMonoid Mâ‚] [inst_2 : Module R Mâ‚]\\n  [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R Mâ‚‚] {f : Mâ‚ â†’â‚—[R] Mâ‚‚},\\n  Function.Surjective â†‘f â†’ Function.Injective â†‘(LinearMap.dualMap f)\",\n  \"isProp\": true,\n  \"docString\": \"If a linear map is surjective, then its dual is injective. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ð•œ] F),\\n  Continuous â†‘e â†’ Continuous â†‘(LinearEquiv.symm e)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : { x // x âˆˆ LinearMap.ker f } â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’\\n    LinearMap.ker f = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : Type u} (f : X âŸ¶ Y), CategoryTheory.IsIso f â†” Function.Bijective f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"}]\n",
    "prompt_cons": "/-- If a linear map is surjective, then its dual is injective. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {Mâ‚ : Type v} {Mâ‚‚ : Type v'} [inst_1 : AddCommMonoid Mâ‚] [inst_2 : Module R Mâ‚]\n  [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R Mâ‚‚] {f : Mâ‚ â†’â‚—[R] Mâ‚‚},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘(LinearMap.dualMap f) :=\n\n/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\ntheorem âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ð•œ] F),\n  Continuous â†‘e â†’ Continuous â†‘(LinearEquiv.symm e) :=\n\n/-- A monomorphism is injective. -/\ntheorem âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\n  (âˆ€ (u v : { x // x âˆˆ LinearMap.ker f } â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’\n    LinearMap.ker f = âŠ¥ :=\n\n/-- A morphism in `Type u` is an isomorphism if and only if it is bijective. -/\ntheorem âˆ€ {X Y : Type u} (f : X âŸ¶ Y), CategoryTheory.IsIso f â†” Function.Bijective f :=\n\n/-- If each of two types can be mapped injectively into the other, then there is a bijection between them. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2}, (âˆƒ (f : Î± â†’ Î²), Function.Injective f) â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’\n  Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {Î± : Type u} {Î² : Type v}, \n  (âˆƒ (f : Î± â†’ Î²), Function.Injective f) â†’ \n  (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’ \n  (âˆƒ (h : Î± â‰ƒ Î²), True) ",
      "âˆ€ {Î± Î² : Type u}, (âˆƒ (f : Î± â†ª Î²), âˆƒ (g : Î² â†ª Î±)) â†’ Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {X Y : Type u},\n  (Nonempty (Function.Embedding X Y) âˆ§ Nonempty (Function.Embedding Y X)) â†’\n  Nonempty (X â‰ƒ Y) ",
      "âˆ€ {Î± : Type u} {Î² : Type v},\n  (âˆƒ (f : Î± â†’ Î²), Function.Injective f) â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’ Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {Î± : Type u} {Î² : Type v}, (âˆƒ (f : Î± â†’ Î²), Function.Injective f) â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’\n  Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {Î± : Type u} {Î² : Type u'} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†ª Î²) (g : Î² â†ª Î±),\n  Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {Î± Î² : Type u}, (âˆƒ (f : Î± â†’ Î²), Function.Injective f) â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’ Nonempty (Î± â‰ƒ Î²) ",
      "âˆ€ {Î± : Type u} {Î² : Type v}, (âˆƒ (f : Î± â†’ Î²), Function.Injective f) â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’\n  Nonempty (Î± â‰ƒ Î²) "
    ]
  },
  {
    "docString": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.minDegree G â‰¤ SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimum degree in the graph is at most the degree of any particular vertex. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"}]\n",
    "prompt_cons": "/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\n  SimpleGraph.minDegree G â‰¤ SimpleGraph.degree G v :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices. -/\ntheorem",
    "choices": [
      "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (u v : V), u â‰  v â†’ âˆƒ! (w : V), SimpleGraph.Adj G u w âˆ§ SimpleGraph.Adj G v w) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ",
      "âˆ€ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj], (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (z : V), SimpleGraph.Adj G v z âˆ§ SimpleGraph.Adj G w z) â†’ âˆƒ (x : V), âˆ€ (y : V), y â‰  x â†’ SimpleGraph.Adj G x y ",
      "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G u v âˆ§ SimpleGraph.Adj G u w) â†’\n  âˆƒ (x : V), âˆ€ (v : V), v â‰  x â†’ SimpleGraph.Adj G x v ",
      "âˆ€ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (x : V), SimpleGraph.Adj G v x âˆ§ SimpleGraph.Adj G w x) â†’\n  âˆƒ (x : V), âˆ€ (v : V), v â‰  x â†’ SimpleGraph.Adj G x v ",
      "âˆ€ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! x, SimpleGraph.Adj G x v âˆ§ SimpleGraph.Adj G x w) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ",
      "âˆ€ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : SimpleGraph.OneCommonNeighbor G],\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ",
      "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (u v : V), u â‰  v â†’ âˆƒ! (w : V), G.Adj u w âˆ§ G.Adj v w) â†’ âˆƒ (y : V), âˆ€ (x : V), x â‰  y â†’ SimpleGraph.Adj G x y ",
      "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ ExistsUnique (Î» (x : V), SimpleGraph.Adj G v x âˆ§ SimpleGraph.Adj G w x)) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ",
      "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (u v : V), u â‰  v â†’ (âˆƒ! w, G.Adj u w âˆ§ G.Adj v w)) â†’ âˆƒ x, âˆ€ y, x â‰  y â†’ G.Adj x y ",
      "âˆ€ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ (Finset.card (SimpleGraph.commonNeighbors G v w) = 1)) â†’\n  âˆƒ (v : V), SimpleGraph.isUniversal G v "
    ]
  },
  {
    "docString": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\\n  {G : SimpleGraph Î±} {Îµ : â„},\\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\\n    Â¬Finpartition.IsUniform P G Îµ â†’\\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The increment partition has a prescribed (very big) size in terms of the original partition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition â†‘f.parts\",\n  \"isProp\": true,\n  \"docString\": \"A finpartition gives rise to a setoid partition \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} {r : Setoid Î±} (a : Î±), âˆƒ! b x, a âˆˆ b\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence classes partition the type. \"}]\n",
    "prompt_cons": "/-- The increment partition has a prescribed (very big) size in terms of the original partition. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph Î±} {Îµ : â„},\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\n    Â¬Finpartition.IsUniform P G Îµ â†’\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts) :=\n\n/-- The partition is supremum-independent -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- A finpartition gives rise to a setoid partition -/\ntheorem âˆ€ {Î± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition â†‘f.parts :=\n\n/-- Equivalence classes partition the type. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Setoid Î±} (a : Î±), âˆƒ! b x, a âˆˆ b :=\n\n/-- The number of partitions with odd parts is equal to the number of partitions with distinct parts. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P},\n  Finset.card (Finpartition.oddParts P).parts = Finset.card (Finpartition.distinctParts P).parts ",
      "âˆ€ {n : â„•}, Nat.partitions_odds_card n = Nat.partitions_distinct_card n ",
      "âˆ€ {n : â„•}, Nat.Partition.odd_parts (n : â„•) = Nat.Partition.distinct_parts (n : â„•) ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph Î±} {Îµ : â„},\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\n    Â¬Finpartition.IsUniform P G Îµ â†’\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts) ",
      "forall {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph Î±} {Îµ : â„},\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± ->\n    Â¬Finpartition.IsUniform P G Îµ ->\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts) ",
      "âˆ€ {n : â„•}, odd_partit n = distinct_partit n ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n    (O : â„• â†’ â„•) (D : â„• â†’ â„•),\n    (âˆ€ n, P.oddPartsCount n = O n) â†’\n    (âˆ€ n, P.distinctPartsCount n = D n) â†’\n      âˆ€ n, O n = D n ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±],\n  Finset.card (Finpartition.oddParts Finset.univ) = Finset.card (Finpartition.distinctParts Finset.univ) ",
      "âˆ€ (n : â„•), num_partitions_odd_parts n = num_partitions_distinct_parts n ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P},\n  Finset.card (oddParts P) = Finset.card (distinctParts P) "
    ]
  },
  {
    "docString": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\\nthere is a maximal element.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : Set Î±}, IsChain r c â†’ âˆƒ M, IsMaxChain r M âˆ§ c âŠ† M\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\\n  c âŠ† nonPrincipals R â†’\\n    IsChain (fun x x_1 => x â‰¤ x_1) c â†’\\n      âˆ€ {K : Ideal R}, K âˆˆ c â†’ âˆƒ I, I âˆˆ nonPrincipals R âˆ§ âˆ€ (J : Ideal R), J âˆˆ c â†’ J â‰¤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any chain in the set of non-principal ideals has an upper bound which is non-principal.\\n(Namely, the union of the chain is such an upper bound.)\\n\"}]\n",
    "prompt_cons": "/-- A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : Set Î±}, IsChain r c â†’ âˆƒ M, IsMaxChain r M âˆ§ c âŠ† M :=\n\n/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.) -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\n  c âŠ† nonPrincipals R â†’\n    IsChain (fun x x_1 => x â‰¤ x_1) c â†’\n      âˆ€ {K : Ideal R}, K âˆˆ c â†’ âˆƒ I, I âˆˆ nonPrincipals R âˆ§ âˆ€ (J : Ideal R), J âˆˆ c â†’ J â‰¤ I :=\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ",
      "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m "
    ]
  },
  {
    "docString": "A group whose automorphism group is cyclic is Abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A group whose automorphism group is cyclic is Abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsCommutative G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsCyclic (Aut G) â†’ IsAbelian G ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] (h : IsCyclic (Aut Î±)), IsAbelian Î± ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsCyclic (Aut G) â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] (C : Cyclic (Aut Î±)), IsAbelian Î± ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsCyclic (Aut G)], IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] \n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst_1 : UniformSpace Î±] [inst_2 : UniformSpace Î²] [inst_3 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [UniformSpace Î±] [UniformSpace Î²] [UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [UniformSpace Î±] [UniformSpace Î²] [UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "
    ]
  },
  {
    "docString": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"}]\n",
    "prompt_cons": "/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” \n  (âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±], NormalSpace Î± â†”\n  (âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ (âˆ€ (x : Î±), HasMem.Mem x s â†’ f x = 0) âˆ§ (âˆ€ (x : Î±), HasMem.Mem x t â†’ f x = 1) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±], NormalSpace Î± â†”\n  (âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ (âˆ€ (x : Î±), HasMem.Mem x s â†’ f x = 0) âˆ§ (âˆ€ (x : Î±), HasMem.Mem x t â†’ f x = 1)) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ (âˆ€ x : Î±, x âˆˆ s â†’ f x = 0) âˆ§ (âˆ€ x : Î±, x âˆˆ t â†’ f x = 1) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) "
    ]
  },
  {
    "docString": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points lie in the affine span of two points, the first three points are collinear. \"}]\n",
    "prompt_cons": "/-- Any point is a periodic point of period `0`. -/\ntheorem âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ} :=\n\n/-- If a function from the unit interval to itself has a point of period three, then it has points of all positive periods. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : â„â‰ƒoÎ±] (f : Icc (0 : â„) 1 â†’ Icc (0 : â„) 1),\n  (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, n > 0 â†’ âˆƒ x, Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : MeasurableSpace Î±] [inst_4 : BorelSpace Î±]\n  (f : I â†’ I) (hf : âˆ€ x âˆˆ I, f x âˆˆ I) (hf' : Continuous f) (h : âˆƒ x, Function.IsPeriodicPt f 3 x),\n  âˆ€ (n : â„•), n > 0 â†’ âˆƒ x, Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [Preorder Î±] [_inst_1 : TopologicalSpace Î±] [_inst_2 : OrderTopology Î±] {f : Î± â†’ Î±} (hf : Continuous f)\n  (hâ‚€ : âˆ€ x, x â‰¤ f x) (hâ‚ : âˆ€ x, f x â‰¤ 1) {xâ‚€ : Î±}, Function.IsPeriodicPt f 3 xâ‚€ â†’ âˆ€ (n : â„•), âˆƒ x, Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [_inst_1 : LinearOrderedField Î±] {_inst_2 : TopologicalSpace Î±} {_inst_3 : OrderTopology Î±}\n  (f : Î± â†’ Î±) (hfâ‚€ : Continuous f) (hfâ‚ : âˆ€ x, x âˆˆ set.Icc (0 : Î±) 1 â†’ f x âˆˆ set.Icc (0 : Î±) 1) (x : Î±),\n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (n : â„•), n > 0 â†’ âˆƒ y, Function.IsPeriodicPt f n y ",
      "âˆ€ {Î± : Type u_1} [_inst_1 : LinearOrderedField Î±] [inst : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  (f : (Î± Ã— Î±) â†’ Î± Ã— Î±), (âˆ€ x : Î± Ã— Î±, x âˆˆ Set.Icc (0, 0) (1, 1) â†’ f x âˆˆ Set.Icc (0, 0) (1, 1)) â†’\n  (âˆƒ x : Î± Ã— Î±, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n : â„•, n > 0 â†’ âˆƒ x : Î± Ã— Î±, Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  (f : Icc (0 : Î±) 1 â†’ Icc (0 : Î±) 1) (hf : ContinuousOn f (Set.Icc 0 1)), (âˆƒ (x : Icc (0 : Î±) 1), Function.IsPeriodicPt f 3 x) â†’\n  âˆ€ (n : â„•), n > 0 â†’ âˆƒ (x : Icc (0 : Î±) 1), Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {f : Î± â†’ Î±} (hâ‚€ : âˆ€ x, 0 â‰¤ x â†’ x â‰¤ 1 â†’ 0 â‰¤ f x â†’ f x â‰¤ 1)\n  (hâ‚ : âˆƒ x, Function.IsPeriodicPt f 3 x), âˆ€ n, âˆƒ x, Function.IsPeriodicPt f (n + 1) x ",
      "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] {f : Î± â†’ Î±} (hf : Continuous f) {x : Î±},\n  (âˆƒ (hxâ‚€ : HasMem.Mem x (Set.Icc (0 : Î±) 1)), Function.IsPeriodicPt f 3 x) â†’ âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ (x : Î±), Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [_inst_1 : LinearOrderedField Î±] [_inst_2 : TopologicalSpace Î±] [_inst_3 : OrderTopology Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ (âˆ€ x : Î±, 0 â‰¤ x â†’ x â‰¤ 1 â†’ f x âˆˆ Set.Icc 0 1) â†’ (âˆƒ x : Î±, Function.IsPeriodicPt f 3 x) â†’\n  âˆ€ (n : â„•), n > 0 â†’ âˆƒ x : Î±, Function.IsPeriodicPt f n x ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ f 0 = 0 â†’ f 1 = 1 â†’\n  (âˆƒ x : Î±, x âˆˆ set.Icc (0 : Î±) 1 âˆ§ Function.IsPeriodicPt f 3 x) â†’\n  âˆ€ n : â„•, n > 0 â†’ âˆƒ x : Î±, x âˆˆ set.Icc (0 : Î±) 1 âˆ§ Function.IsPeriodicPt f n x "
    ]
  },
  {
    "docString": "A terminal object in a category is unique up to unique isomorphism.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"}]\n",
    "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f :=\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\ntheorem",
    "choices": [
      "forall {C : Type uâ‚} [inst : CategoryTheory.Category C] (X Y : C) [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X Y : C) [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n    CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ",
      "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X â‰… Y) "
    ]
  },
  {
    "docString": "The complement of the union of two sets is the intersection of their complements.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"}]\n",
    "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t) :=\n\n/-- The complement of the union of two sets is the intersection of their complements. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
      "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ "
    ]
  },
  {
    "docString": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first and third points are not\\nequal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first two points are not\\nequal. \"}]\n",
    "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- If the sign of the angle between three points is positive, the first two points are not\nequal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\ntheorem",
    "choices": [
      "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x * x * x + y * y * y â‰  z * z * z ",
      "âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ m^3 + n^3 â‰  k^3 ",
      "âˆ€ {n m k : â„•}, n > 0 â†’ m > 0 â†’ n * n * n + m * m * m â‰  k * k * k ",
      "âˆ€ {n m k : â„•}, 0 < n â†’ 0 < m â†’ n * n * n + m * m * m â‰  k * k * k ",
      "âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ m * m * m + n * n * n â‰  k * k * k ",
      "âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ m * m * m + n * n * n â‰  k * k * k ",
      "âˆ€ {n m k : â„•}, 0 < n â†’ 0 < m â†’ n * n * n + m * m * m â‰  k * k * k ",
      "âˆ€ {n m k : â„•}, n > 0 â†’ m > 0 â†’ n * n * n + m * m * m â‰  k * k * k ",
      "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x * x * x + y * y * y â‰  z * z * z ",
      "âˆ€ {n m l : â„•}, 0 < n â†’ 0 < m â†’ n * n * n + m * m * m â‰  l * l * l "
    ]
  },
  {
    "docString": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
    "prompts": "[{\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n",
    "prompt_cons": "/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ (a : G), a * a = 1), âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ (x : G), x * x = 1), âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ (x : G), x ^ 2 = 1), âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ (x : G), x * x = 1), âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y "
    ]
  },
  {
    "docString": "The product of two consecutive natural numbers is even.",
    "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"}]\n",
    "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- The product of two consecutive natural numbers is even. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), even (n * (n + 1)) ",
      "âˆ€ (n : â„•), 2 âˆ£ (n * (n + 1)) "
    ]
  },
  {
    "docString": "Every index 2 subgroup of a group is normal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Every index 2 subgroup of a group is normal. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H = â‚‚ â†’ Subgroup.Normal H ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} (cond : Subgroup.index H = 2), Subgroup.Normal H "
    ]
  },
  {
    "docString": "Every free group is torsion free.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"}]\n",
    "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Every free group is torsion free. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst : Monoid.FreeGroup G Î±], Monoid.IsTorsionFree G ",
      "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst : Fintype Î±], FreeGroup.IsFree G Î± â†’ Monoid.IsTorsionFree G ",
      "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsFree G â†’ Monoid.IsTorsionFree G ",
      "forall {Î± : Type u_1} {G : Type u_2} [inst : Group G] [F : FreeGroup Î± â†’ G], Monoid.IsTorsionFree G ",
      "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G], Monoid.FreeFunctor Î± G â†’ Monoid.IsTorsionFree G ",
      "forall {G : Type u_1} [inst : Group G] [inst2 : IsFreeGroup G], Monoid.IsTorsionFree G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [Free : Group.IsFree G], Monoid.IsTorsionFree G ",
      "forall {G : Type u_1} [inst : Group G], Monoid.FreeGroup G â†’ Monoid.IsTorsionFree G ",
      "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G],\n  (Î± â†’ G) â†’ Monoid.IsTorsionFree G ",
      "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G], Monoid.Free G Î± â†’ Monoid.IsTorsionFree G "
    ]
  },
  {
    "docString": "Every natural number greater than `1` is divisible by a prime number.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- Every natural number greater than `1` is divisible by a prime number. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ (âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n) ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ",
      "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n "
    ]
  },
  {
    "docString": "A finite torsion-free group is trivial",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"}]\n",
    "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G â†’ G â‰ƒ Unit ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Monoid.Trivial G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ G â‰ƒ Unit ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Monoid.IsTrivial G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ G â‰ƒ Unit ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G "
    ]
  },
  {
    "docString": "Every finite division ring is a field.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"}]\n",
    "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- Every finite division ring is a field. -/\ntheorem",
    "choices": [
      "âˆ€ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
      "âˆ€ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ {D : Type u_1} [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
      "âˆ€ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
      "âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : Fintype R] [inst_2 : Nontrivial R] [inst_3 : DivisionRing R], Field R ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DivisionRing Î±], Field Î± ",
      "âˆ€ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
      "âˆ€ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R "
    ]
  },
  {
    "docString": "Every finite topological space is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- A compact discrete space is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î± :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Every finite topological space is compact. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± "
    ]
  },
  {
    "docString": "Every surjective homomorphism from a finitely generated free group to itself is injective.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"}]\n",
    "prompt_cons": "/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fg Î±] [inst_2 : IsFreeGroup Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : FgFreeGroup Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsFreeGroup Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : FgFree Î±] {f : Î± â†’ Î±}, IsGroupHom f â†’\n  Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsFreeGroup Î±] {f : Î± â†’* Î±},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFg Î±] [inst_2 : IsFreeGroup Î±] (f : Î± â†’ Î±),\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsFreeGroup Î±] {f : Î± â†’* Î±},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f "
    ]
  },
  {
    "docString": "Every positive even integer can be written as the sum of two primes.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- Every positive even integer can be written as the sum of two primes. -/\ntheorem",
    "choices": [
      "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} ",
      "âˆ€ (n : â„•), n > 0 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "âˆ€ {n : â„•}, n > 0 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), n = p + q âˆ§ Nat.Prime p âˆ§ Nat.Prime q ",
      "âˆ€ {n : â„•}, n > 0 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "âˆ€ (n : â„•), n > 0 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "Goldbach's_conjecture : âˆ€ (n : â„•), n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ",
      "âˆ€ (n : â„•), n > 0 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q "
    ]
  },
  {
    "docString": "Every matrix satisfies its own characteristic polynomial.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : Fintype Î¹]\\n  (b : Basis Î¹ R M), Matrix.charpoly (â†‘(LinearMap.toMatrix b b) f) = LinearMap.charpoly f\",\n  \"isProp\": true,\n  \"docString\":\n  \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. \"}]\n",
    "prompt_cons": "/-- Every identity matrix is diagonal. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1 :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : Fintype Î¹]\n  (b : Basis Î¹ R M), Matrix.charpoly (â†‘(LinearMap.toMatrix b b) f) = LinearMap.charpoly f :=\n\n/-- Every matrix satisfies its own characteristic polynomial. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M), (LinearMap.charpoly f).eval f = 0 ",
      "âˆ€ {n : Type u} {R : Type v} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  Polynomial.evalM M (Matrix.charpoly M) = 0 ",
      "âˆ€ {n : Type u_1} {R : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R]\n  (M : Matrix n n R), Polynomial.eval M (Matrix.charpoly M) = 0 ",
      "âˆ€ {n : Type u} {R : Type v} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  Polynomial.eval M (Matrix.charpoly M) = 0 ",
      "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : Fintype Î¹]\n  (b : Basis Î¹ R M), Matrix.eval (â†‘(LinearMap.toMatrix b b) f) (LinearMap.charpoly f) = 0 ",
      "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M),\n  (LinearMap.charpoly f).eval (LinearMap.toMatrix (Module.Free.chooseBasis R M) (Module.Free.chooseBasis R M) f) = 0 ",
      "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : Fintype Î¹]\n  (b : Basis Î¹ R M), (Matrix.charpoly (â†‘(LinearMap.toMatrix b b) f)).eval (â†‘(LinearMap.toMatrix b b) f) = 0 ",
      "âˆ€ {n : Type u} {R : Type v} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  Polynomial.eval (Matrix.det (M - (Matrix.scalar n (Polynomial.x)))) (Matrix.charpoly M) = 0 ",
      "âˆ€ {R : Type u} {n : Type w} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : Fintype n] [inst_3 : DecidableEq n]\n  (M : Matrix n n R), Matrix.charpoly_eval M (Matrix.charpoly M) = 0 ",
      "âˆ€ {n : Type u_1} {Î± : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Î±] (A : Matrix n n Î±),\n  Matrix.IsDiag (Matrix.charpoly A â€¢ 1 - Matrix.map A (â‡‘Polynomial.c)) "
    ]
  },
  {
    "docString": "The square root of an irrational number is irrational.",
    "prompts": "[{\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"}]\n",
    "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- The square root of an irrational number is irrational. -/\ntheorem",
    "choices": [
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ",
      "âˆ€ {a : â„}, Irrational a â†’ Irrational (Real.sqrt a) "
    ]
  },
  {
    "docString": "If the square of a number is even, the number itself is even.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"}]\n",
    "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- If the square of a number is even, the number itself is even. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•}, n * n % 2 = 0 â†’ n % 2 = 0 ",
      "âˆ€ {n : â„•}, (n * n) % 2 = 0 â†’ n % 2 = 0 ",
      "âˆ€ {n : â„•}, n ^ 2 % 2 = 0 â†’ n % 2 = 0 ",
      "âˆ€ {a : â„•}, a ^ 2 % 2 = 0 â†” a % 2 = 0 ",
      "âˆ€ {n : â„•}, n ^ 2 % 2 = 0 â†” n % 2 = 0 ",
      "âˆ€ {n : â„•}, n ^ 2 % 2 = 0 â†’ n % 2 = 0 ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ",
      "âˆ€ {n : â„•}, n ^ 2 % 2 = 0 â†’ n % 2 = 0 ",
      "âˆ€ {n : â„•}, n ^ 2 % 2 = 0 â†’ n % 2 = 0 ",
      "âˆ€ {n : â„•}, n ^ 2 % 2 = 0 â†” n % 2 = 0 "
    ]
  },
  {
    "docString": "In a finite commutative ring, all prime ideals are maximal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"}]\n",
    "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- In a finite commutative ring, all prime ideals are maximal. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [Finsupp : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ",
      "âˆ€ {R : Type u} [inst : CommRing R] [hf : Fintype R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) "
    ]
  },
  {
    "docString": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"}]\n",
    "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- The **Heineâ€“Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], IsClosed (Set.Diagonal Î±) â†” T2Space Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Set.Diagonal Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (IdRel.diag Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±],\n  IsClosed (Set.Diagonal Î±) â†” T2Space Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Set.Diagonal Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Diagonal Î±) "
    ]
  },
  {
    "docString": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"}]\n",
    "prompt_cons": "/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤ :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s :=\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U : Set Î±, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U : Set Î±, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U : Set Î±, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† t) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U : Set Î±, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U : Set Î±, x âˆˆ U âˆ§ IsOpen U âˆ§ U âŠ† s) â†’ IsOpen s "
    ]
  },
  {
    "docString": "Every non-identity element of a free group is of infinite order.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"}]\n",
    "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g :=\n\n/-- Every non-identity element of a free group is of infinite order. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], âˆ€ (x : G), x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {G : Type u_1} [inst : Group G], FreeGroup G â†’ âˆ€ (x : G), x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] (g : Î±), g â‰  1 â†’ Â¬IsOfFinOrder g ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {f : FreeGroup Î±} (x : Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {Î± : Type u_1} [inst : FreeGroup Î±] (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {Î± : Type u_1} [inst : Group Î±] [IsFreeGroup Î±] (a : Î±), a â‰  1 â†’ Â¬IsOfFinOrder a ",
      "âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±], âˆ€ x : FreeGroup Î±, x â‰  1 â†’ Â¬IsOfFinOrder x ",
      "âˆ€ {Î± : Type u_1} (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x "
    ]
  },
  {
    "docString": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\\n  (âˆƒ p, Irreducible p) â†’ (âˆ€ â¦ƒp q : Râ¦„, Irreducible p â†’ Irreducible q â†’ Associated p q) â†’ DiscreteValuationRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unique factorization domain with at least one irreducible element\\nin which all irreducible elements are associated\\nis a discrete valuation ring.\\n\"}]\n",
    "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0 :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0 :=\n\n/-- A unique factorization domain with at least one irreducible element\nin which all irreducible elements are associated\nis a discrete valuation ring. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\n  (âˆƒ p, Irreducible p) â†’ (âˆ€ â¦ƒp q : Râ¦„, Irreducible p â†’ Irreducible q â†’ Associated p q) â†’ DiscreteValuationRing R :=\n\n/-- An element of a discrete valuation ring is a unit if and only if it has a valuation of zero. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x â†” DiscreteValuationRing.HasValuation R x = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R],\n  âˆ€ (x : R), IsUnit x â†” DiscreteValuationRing.valuation R x = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  {Î“â‚€ : Type u_2} [inst_3 : LinearOrderedCommMonoidWithZero Î“â‚€] [inst_4 : Nontrivial Î“â‚€] (v : Valuation R Î“â‚€)\n  {x : R}, IsUnit x â†” â†‘v x = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R],\n  âˆ€ (x : R), IsUnit x â†” DiscreteValuationRing.valuation R x = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x â†” DiscreteValuationRing.valuation R x = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (Ï– : DiscreteValuationRing.Ï– R), âˆ€ (u : R), IsUnit u â†” DiscreteValuationRing.valuation R Ï– u = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x â†” DiscreteValuationRing.valuation R x = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R],\n  (x : R), x âˆˆ Units R â†” DiscreteValuationRing.valuation R x = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x â†” DiscreteValuationRing.valuation R x = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x â†” DiscreteValuationRing.valuation R x = 0 "
    ]
  },
  {
    "docString": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b : â„¤}, a â‰  0 â†’ IsLeast {n | 0 < n âˆ§ âˆƒ x y, â†‘n = a * x + b * y} (Int.gcd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•},\\n  a â‰  0 â†’ b â‰  0 â†’ List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) âˆª List.toFinset (Nat.factors b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` \"}]\n",
    "prompt_cons": "/-- For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem âˆ€ {a b : â„¤}, a â‰  0 â†’ IsLeast {n | 0 < n âˆ§ âˆƒ x y, â†‘n = a * x + b * y} (Int.gcd a b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` -/\ntheorem âˆ€ {a b : â„•},\n  a â‰  0 â†’ b â‰  0 â†’ List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) âˆª List.toFinset (Nat.factors b) :=\n\n/-- For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\ntheorem",
    "choices": [
      "âˆ€ {a b : â„•}, Nat.gcd a b = 1 â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ",
      "âˆ€ {a b : â„•},\n  Nat.Coprime a b â†’ âˆƒ N, âˆ€ n â‰¥ N, âˆƒ x y : â„•, n = a * x + b * y ",
      "forall {a b N : â„•}, Nat.gcd a b = 1 â†’ a â‰  0 â†’ b â‰  0 â†’ N â‰¥ a * b - a - b â†’ âˆƒ x y : â„•, N = a * x + b * y ",
      "âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ Nat.Coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ",
      "âˆ€ {a b : â„•}, Nat.gcd a b = 1 â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ",
      "âˆ€ {a b : â„•}, Nat.gcd a b = 1 â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ",
      "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ",
      "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ",
      "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆƒ N, âˆ€ n â‰¥ N, âˆƒ x y : â„•, n = a * x + b * y ",
      "âˆ€ {a b : â„•}, Nat.gcd a b = 1 â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y "
    ]
  },
  {
    "docString": "Every field is a ring.",
    "prompts": "[{\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"}]\n",
    "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- Every field is a ring. -/\ntheorem",
    "choices": [
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K ",
      "âˆ€ (K : Type u) [inst : Field K], Ring K "
    ]
  },
  {
    "docString": "The set of units in a ring forms a group.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n",
    "prompt_cons": "/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The set of units in a ring forms a group. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : Ring R], IsGroup (Units R) ",
      "âˆ€ {R : Type u_1} [inst : Monoid R], IsGroup {x | IsUnit x} ",
      "âˆ€ {R : Type u_1} [inst : Ring R], IsGroup {x | IsUnit x} ",
      "âˆ€ {R : Type u_1} [inst : Ring R], IsGroup {x | IsUnit x} ",
      "forall {R : Type u_1} [inst : Monoid R], Group (Units R) ",
      "âˆ€ {R : Type u_1} [inst : Ring R], Group (RË£) ",
      "âˆ€ {R : Type u_1} [inst : Ring R], Group (RË£) ",
      "âˆ€ {R : Type u_1} [inst : Monoid R], IsGroup {x | IsUnit x} ",
      "âˆ€ {R : Type u_1} [inst : Monoid R], Group {x | IsUnit x} ",
      "âˆ€ {R : Type u_1} [inst : Ring R], Group (RË£) "
    ]
  },
  {
    "docString": "If the direct product of two groups is torsion free then each of the groups is torsion free.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"}]\n",
    "prompt_cons": "/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\ntheorem",
    "choices": [
      "forall {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ",
      "âˆ€ {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ",
      "âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) â†’ âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i) ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ",
      "forall {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ "
    ]
  }
]