{"docString": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.", "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `x * r`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\\nit suffices to show it holds when `x â‰  y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"}]\n", "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x) :=\n\n/-- The product `x * r`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\nit suffices to show it holds when `x â‰  y`. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational. -/\ntheorem", "choices": ["âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "forall {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) ", "âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r * x) "]}
{"docString": "Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : DenselyOrdered Î±] [inst_2 : NoMinOrder Î±] [inst_3 : NoMaxOrder Î±]\\n  [nonem : Nonempty Î±] (lo hi : Finset Î±),\\n  (âˆ€ (x : Î±), x âˆˆ lo â†’ âˆ€ (y : Î±), y âˆˆ hi â†’ x < y) â†’ âˆƒ m, (âˆ€ (x : Î±), x âˆˆ lo â†’ x < m) âˆ§ âˆ€ (y : Î±), y âˆˆ hi â†’ m < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Î±` is a nonempty dense linear order without endpoints, and\\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\\nbefore `hi`. Then there is an element of `Î±` strictly between `lo`\\nand `hi`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ† B â†’ Finset.toColex A â‰¤ Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A âŠ† B`, then `A â‰¤ B` in the colex order. Note the converse does not hold, as `âŠ†` is not a\\nlinear order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, s âŠ† t â†’ Metric.Bounded t â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a bounded set are also bounded \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : SeminormedRing ğ•œ] [inst_1 : SMul ğ•œ E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E}, sâ‚ âŠ† sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of bounded sets are bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type v} {Î¹' : Type v'} {f : Î¹ â†’ Cardinal.{w}} {f' : Î¹' â†’ Cardinal.{w'}},\\n  BddAbove (Set.range f) â†’\\n    BddAbove (Set.range f') â†’\\n      âˆ€ {g : Î¹ â†’ Î¹'},\\n        (âˆ€ (i : Î¹), Cardinal.lift (f i) â‰¤ Cardinal.lift (f' (g i))) â†’ Cardinal.lift (iSup f) â‰¤ Cardinal.lift (iSup f')\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove an inequality between the lifts to a common universe of two different supremums,\\nit suffices to show that the lift of each cardinal from the smaller supremum\\nif bounded by the lift of some cardinal from the larger supremum.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ‚ B â†’ Finset.toColex A < Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A âŠ‚ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\\n`âŠ†` is not a linear order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"}]\n", "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s :=\n\n/-- Suppose `Î±` is a nonempty dense linear order without endpoints, and\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\nbefore `hi`. Then there is an element of `Î±` strictly between `lo`\nand `hi`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : DenselyOrdered Î±] [inst_2 : NoMinOrder Î±] [inst_3 : NoMaxOrder Î±]\n  [nonem : Nonempty Î±] (lo hi : Finset Î±),\n  (âˆ€ (x : Î±), x âˆˆ lo â†’ âˆ€ (y : Î±), y âˆˆ hi â†’ x < y) â†’ âˆƒ m, (âˆ€ (x : Î±), x âˆˆ lo â†’ x < m) âˆ§ âˆ€ (y : Î±), y âˆˆ hi â†’ m < y :=\n\n/-- If `A âŠ† B`, then `A â‰¤ B` in the colex order. Note the converse does not hold, as `âŠ†` is not a\nlinear order. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ† B â†’ Finset.toColex A â‰¤ Finset.toColex B :=\n\n/-- It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, s âŠ† t â†’ Metric.Bounded t â†’ Metric.Bounded s :=\n\n/-- Subsets of bounded sets are bounded. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : SeminormedRing ğ•œ] [inst_1 : SMul ğ•œ E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E}, sâ‚ âŠ† sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚ :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- To prove an inequality between the lifts to a common universe of two different supremums,\nit suffices to show that the lift of each cardinal from the smaller supremum\nif bounded by the lift of some cardinal from the larger supremum. -/\ntheorem âˆ€ {Î¹ : Type v} {Î¹' : Type v'} {f : Î¹ â†’ Cardinal.{w}} {f' : Î¹' â†’ Cardinal.{w'}},\n  BddAbove (Set.range f) â†’\n    BddAbove (Set.range f') â†’\n      âˆ€ {g : Î¹ â†’ Î¹'},\n        (âˆ€ (i : Î¹), Cardinal.lift (f i) â‰¤ Cardinal.lift (f' (g i))) â†’ Cardinal.lift (iSup f) â‰¤ Cardinal.lift (iSup f') :=\n\n/-- If `A âŠ‚ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`âŠ†` is not a linear order. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ‚ B â†’ Finset.toColex A < Finset.toColex B :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t :=\n\n/-- Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {a b : Î±},\n  Set.Nonempty s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ a â‰¤ x) â†’ (âˆ€ (y : Î±), y âˆˆ s â†’ y â‰¤ b) â†’ a â‰¤ b ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {E : Set Î±} (lb : Î±) (ub : Î±),\n  Set.Nonempty E â†’ (âˆ€ (x : Î±), x âˆˆ E â†’ lb â‰¤ x) â†’ (âˆ€ (x : Î±), x âˆˆ E â†’ x â‰¤ ub) â†’ lb â‰¤ ub ", "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : SemilatticeSup Î±] {E : Set Î±} {Î±_1 Î² : Î±},\n  Set.Nonempty E â†’ (âˆ€ (a : Î±), a âˆˆ E â†’ Î±_1 â‰¤ a) â†’ (âˆ€ (b : Î±), b âˆˆ E â†’ b â‰¤ Î²) â†’ Î±_1 â‰¤ Î² ", "forall {Î± : Type u_1} [inst : Preorder Î±] {E : Set Î±} (Î±_ : Î±) (Î² : Î±),\n  Set.Nonempty E â†’ (âˆ€ e : Î±, e âˆˆ E â†’ Î±_ â‰¤ e) â†’ (âˆ€ e : Î±, e âˆˆ E â†’ e â‰¤ Î²) â†’ Î±_ â‰¤ Î² ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {E : Set Î±} (Î±_lower : âˆ€ x âˆˆ E, Î± â‰¤ x) (Î²_upper : âˆ€ x âˆˆ E, x â‰¤ Î²),\n  Set.Nonempty E â†’ Î± â‰¤ Î² ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {E : Set Î±},\n  Set.Nonempty E â†’ (âˆƒ a : Î±, âˆ€ (x : Î±), x âˆˆ E â†’ a â‰¤ x) â†’ (âˆƒ b : Î±, âˆ€ (y : Î±), y âˆˆ E â†’ y â‰¤ b) â†’ âˆƒ (a b : Î±), a â‰¤ b ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {E : Set Î±} (Î±l : Î±) (Î²u : Î±),\n  Set.Nonempty E â†’ (âˆ€ a âˆˆ E, Î±l â‰¤ a) â†’ (âˆ€ a âˆˆ E, a â‰¤ Î²u) â†’ Î±l â‰¤ Î²u ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} (a b : Î±),\n  Set.Nonempty s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ a â‰¤ x) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ x â‰¤ b) â†’ a â‰¤ b ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {E : Set Î±} (Î±Î² : Î±),\n  Set.Nonempty E â†’ (âˆ€ (x : Î±), x âˆˆ E â†’ Î±Î².1 â‰¤ x) â†’ (âˆ€ (x : Î±), x âˆˆ E â†’ x â‰¤ Î±Î².2) â†’ Î±Î².1 â‰¤ Î±Î².2 ", "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {a b : Î±},\n  Set.Nonempty s â†’ a âˆˆ LowerBounds s â†’ b âˆˆ UpperBounds s â†’ a â‰¤ b "]}
{"docString": "Prove that no order can be defined in the complex field that turns it into an ordered field.", "prompts": "[{\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] [inst_2 : LinearOrderedField Î²],\\n  Subsingleton (Î± â‰ƒ+*o Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\\nlinear ordered field. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : LinearOrderedField Î²] [inst_2 : Archimedean Î²],\\n  Subsingleton (Î± â‰ƒ+*o Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\\nlinear ordered field. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\\n  [inst : T2Space Î±], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible Tâ‚‚ space. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : LinearOrderedField Î²] [inst_2 : Archimedean Î²],\\n  Subsingleton (Î± â†’+*o Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring homomorphism from a linear ordered field to an archimedean\\nlinear ordered field. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x : L}, x âˆˆ S â†’ -x âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under negation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"}]\n", "prompt_cons": "/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\nlinear ordered field. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] [inst_2 : LinearOrderedField Î²],\n  Subsingleton (Î± â‰ƒ+*o Î²) :=\n\n/-- There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\nlinear ordered field. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : LinearOrderedField Î²] [inst_2 : Archimedean Î²],\n  Subsingleton (Î± â‰ƒ+*o Î²) :=\n\n/-- There does not exist a nontrivial preirreducible Tâ‚‚ space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\n  [inst : T2Space Î±], False :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g :=\n\n/-- There is at most one ordered ring homomorphism from a linear ordered field to an archimedean\nlinear ordered field. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : LinearOrderedField Î²] [inst_2 : Archimedean Î²],\n  Subsingleton (Î± â†’+*o Î²) :=\n\n/-- An intermediate field is closed under negation. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x : L}, x âˆˆ S â†’ -x âˆˆ S :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î± :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g :=\n\n/-- Prove that no order can be defined in the complex field that turns it into an ordered field. -/\ntheorem", "choices": ["Â¬âˆƒ (r : â„‚ â†’ â„‚ â†’ Prop), OrderedField â„‚ ", "Â¬âˆƒ (r : â„ â†’+*o â„‚), True ", "Â¬ Nonempty (Complex â†’+*o â„) ", "Â¬âˆƒ (r : â„‚ â†’ â„‚ â†’ Prop), OrderedRing.mk r _ _ _ _ _ _ ", "Â¬Nonempty (Complex â‰ƒ+*o â„) ", "Â¬âˆƒ (r : Lâ„‚ r), IsLinearOrder â„‚ r ", "Â¬(âˆƒ (r : â„‚ â†’ â„‚ â†’ Prop), IsLinearOrder â„‚ r) ", "Â¬Nonempty (Complex â‰ƒo â„) ", "Â¬âˆƒ (r : â„‚ â†’ â„‚ â†’ Prop), OrderedField â„‚ ", "Â¬Nonempty (Complex â‰ƒ+*o â„) "]}
{"docString": "If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 0 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆ‘á¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on the summands.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 0 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on summands.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type v} {s : Finset Î±} {M : Type u_1} [inst : AddCommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop),\\n  (âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) â†’\\n    Finset.Nonempty s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (Finset.sum s fun x => f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a sum, it suffices to prove that\\nthe property is additive and holds on summands.\"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : DecidableEq Î±] (A B C : Finset Î±),\\n  Finset.card (A + C) * Finset.card B â‰¤ Finset.card (A + B) * Finset.card (B + C)\",\n  \"isProp\": true,\n  \"docString\": \"**Ruzsa's triangle inequality**. Addition version.\"},\n {\"theorem\":\n  \"âˆ€ {a b : â„},\\n  a â‰¤ 0 â†’\\n    âˆ€ {z : â„‚},\\n      |z.im| â‰¤ b â†’\\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] [inst : DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ â„¤) (n : â„•),\\n  (Finset.sum s fun i => Int.natAbs (f i)) â‰¤ n â†’\\n    âˆƒ Î² x sgn g,\\n      (âˆ€ (b : Î²), Â¬g b âˆˆ s â†’ sgn b = 0) âˆ§\\n        Fintype.card Î² = n âˆ§ âˆ€ (a : Î±), a âˆˆ s â†’ (Finset.sum Finset.univ fun i => if g i = a then â†‘(sgn i) else 0) = f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. \"}]\n", "prompt_cons": "/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on the summands. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 0 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆ‘á¶  (i : Î±), f i) :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on summands. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 0 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands. -/\ntheorem âˆ€ {Î± : Type v} {s : Finset Î±} {M : Type u_1} [inst : AddCommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop),\n  (âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) â†’\n    Finset.Nonempty s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (Finset.sum s fun x => f x) :=\n\n/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- **Ruzsa's triangle inequality**. Addition version. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : DecidableEq Î±] (A B C : Finset Î±),\n  Finset.card (A + C) * Finset.card B â‰¤ Finset.card (A + B) * Finset.card (B + C) :=\n\n/-- A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem âˆ€ {a b : â„},\n  a â‰¤ 0 â†’\n    âˆ€ {z : â„‚},\n      |z.im| â‰¤ b â†’\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] [inst : DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ â„¤) (n : â„•),\n  (Finset.sum s fun i => Int.natAbs (f i)) â‰¤ n â†’\n    âˆƒ Î² x sgn g,\n      (âˆ€ (b : Î²), Â¬g b âˆˆ s â†’ sgn b = 0) âˆ§\n        Fintype.card Î² = n âˆ§ âˆ€ (a : Î±), a âˆˆ s â†’ (Finset.sum Finset.univ fun i => if g i = a then â†‘(sgn i) else 0) = f a :=\n\n/-- If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$. -/\ntheorem", "choices": ["âˆ€ {n : â„•} (z : Finâ‚“ n â†’ â„‚), â†‘Complex.abs (Finset.sum Finset.univ fun i => z i) â‰¤ Finset.sum Finset.univ fun i => â†‘Complex.abs (z i) ", "âˆ€ {n : â„•} (z : â„• â†’ â„‚), â†‘Complex.abs (Finset.sum (Finset.range n) fun i => z i) â‰¤ Finset.sum (Finset.range n) fun i => â†‘Complex.abs (z i) ", "âˆ€ {n : â„•} (z : Fin n â†’ â„‚),\n  â†‘Complex.abs (Finset.sum Finset.univ fun i => z i) â‰¤ Finset.sum Finset.univ fun i => â†‘Complex.abs (z i) ", "âˆ€ {n : â„•} (z : Finâ‚“ n â†’ â„‚), â†‘Complex.abs (Finâ‚“.sum (Finâ‚“.range n) z) â‰¤ Finâ‚“.sum (Finâ‚“.range n) (Î» i, â†‘Complex.abs (z i)) ", "âˆ€ {n : â„•} {z : Fin n â†’ â„‚}, â†‘Complex.abs (âˆ‘á¶  (i : Fin n), z i) â‰¤ âˆ‘á¶  (i : Fin n), â†‘(Complex.abs (z i)) ", "âˆ€ (z : â„• â†’ â„‚), â†‘Complex.abs (Finset.sum (Finset.range (n + 1)) z) â‰¤ Finset.sum (Finset.range (n + 1)) (Î» i, â†‘Complex.abs (z i)) ", "âˆ€ {n : â„•} {z : Finâ‚“ n â†’ â„‚}, â†‘Complex.abs (âˆ‘á¶  (i : Finâ‚“ n), z i) â‰¤ âˆ‘á¶  (i : Finâ‚“ n), â†‘Complex.abs (z i) ", "âˆ€ (z : â„• â†’ â„‚) (n : â„•), Complex.abs (Finset.sum (Finset.range n) z) â‰¤ Finset.sum (Finset.range n) (Complex.abs âˆ˜ z) ", "âˆ€ {n : â„•} (z : Finâ‚“ n â†’ â„‚), â†‘Complex.abs (Finset.sum Finset.univ fun i => z i) â‰¤ Finset.sum Finset.univ fun i => â†‘Complex.abs (z i) ", "âˆ€ (z : List â„‚), â†‘Complex.abs (List.sum z) â‰¤ List.sum (List.map (Î» x, â†‘Complex.abs x) z) "]}
{"docString": "If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.", "prompts": "[{\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„š),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\": \"Cardinal.mk â†‘Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {x y z : â„¤},\\n  PythagoreanTriple x y z â†’\\n    Int.gcd x y = 1 â†’\\n      x % 2 = 1 â†’\\n        0 < z â†’\\n          âˆƒ m n,\\n            x = m ^ 2 - n ^ 2 âˆ§\\n              y = 2 * m * n âˆ§\\n                z = m ^ 2 + n ^ 2 âˆ§ Int.gcd m n = 1 âˆ§ (m % 2 = 0 âˆ§ n % 2 = 1 âˆ¨ m % 2 = 1 âˆ§ n % 2 = 0) âˆ§ 0 â‰¤ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\\nthe Pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2`\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"}]\n", "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem âˆ€ (p : Polynomial â„š),\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\n      Finset.card\n        (Equiv.Perm.support\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe)))) :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk â†‘Set.univ = Cardinal.continuum :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\nthe Pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2` -/\ntheorem âˆ€ {x y z : â„¤},\n  PythagoreanTriple x y z â†’\n    Int.gcd x y = 1 â†’\n      x % 2 = 1 â†’\n        0 < z â†’\n          âˆƒ m n,\n            x = m ^ 2 - n ^ 2 âˆ§\n              y = 2 * m * n âˆ§\n                z = m ^ 2 + n ^ 2 âˆ§ Int.gcd m n = 1 âˆ§ (m % 2 = 0 âˆ§ n % 2 = 1 âˆ¨ m % 2 = 1 âˆ§ n % 2 = 0) âˆ§ 0 â‰¤ m :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$. -/\ntheorem", "choices": ["forall (z : â„‚), Complex.normSq z = 1 -> Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : â„‚), Complex.abs z = 1 -> Complex.abs (1 + z)^2 + Complex.abs (1 - z)^2 = 2 ", "forall (z : â„‚), Complex.normSq z = 1 -> Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "âˆ€ (z : â„‚), Complex.normSq z = 1 â†’ Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : â„‚), Complex.abs z = 1 -> Complex.abs (1 + z)^2 + Complex.abs (1 - z)^2 = 2 ", "forall (z : â„‚), Complex.normSq z = 1 -> Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : â„‚), Complex.normSq z = 1 -> Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : â„‚), abs z = 1 â†’ abs (1 + z)^2 + abs (1 - z)^2 = 2 ", "âˆ€ (z : â„‚), z * â†‘(starRingEnd â„‚) z = 1 â†’ (â†‘Complex.normSq (1 + z) + â†‘Complex.normSq (1 - z)) = 2 ", "forall (z : â„‚), Complex.normSq z = 1 -> Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 "]}
{"docString": "Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (a x y : E),\\n  inner a x * inner a y + â†‘(â†‘(Orientation.areaForm o) a) x * â†‘(â†‘(Orientation.areaForm o) a) y = â€–aâ€– ^ 2 * inner x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For vectors `a x y : E`, the identity `âŸªa, xâŸ« * âŸªa, yâŸ« + Ï‰ a x * Ï‰ a y = â€–aâ€– ^ 2 * âŸªx, yâŸ«`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (a x y : E),\\n  inner a x * â†‘(â†‘(Orientation.areaForm o) a) y - â†‘(â†‘(Orientation.areaForm o) a) x * inner a y =\\n    â€–aâ€– ^ 2 * â†‘(â†‘(Orientation.areaForm o) x) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For vectors `a x y : E`, the identity `âŸªa, xâŸ« * Ï‰ a y - Ï‰ a x * âŸªa, yâŸ« = â€–aâ€– ^ 2 * Ï‰ x y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\\n  â€–xâ€– = â€–yâ€– â†’ â€–x + yâ€– = â€–xâ€– + â€–yâ€– â†’ x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\\ntheir sum is equal to the sum of their norms, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : CommSemiring Î±] (x y : Î±) (n : â„•),\\n  (Finset.sum (Finset.range n) fun i => (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"$x^n-y^n = (x-y) \\\\sum x^ky^{n-1-k}$ reformulated without `-` signs. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  â€–x + yâ€– = â€–x - yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the sum of two vectors equals the norm of their difference if and only if\\nthe angle between them is Ï€/2. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\\n  (âˆ€ (r : R),\\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"}]\n", "prompt_cons": "/-- For vectors `a x y : E`, the identity `âŸªa, xâŸ« * âŸªa, yâŸ« + Ï‰ a x * Ï‰ a y = â€–aâ€– ^ 2 * âŸªx, yâŸ«`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (a x y : E),\n  inner a x * inner a y + â†‘(â†‘(Orientation.areaForm o) a) x * â†‘(â†‘(Orientation.areaForm o) a) y = â€–aâ€– ^ 2 * inner x y :=\n\n/-- For vectors `a x y : E`, the identity `âŸªa, xâŸ« * Ï‰ a y - Ï‰ a x * âŸªa, yâŸ« = â€–aâ€– ^ 2 * Ï‰ x y`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (a x y : E),\n  inner a x * â†‘(â†‘(Orientation.areaForm o) a) y - â†‘(â†‘(Orientation.areaForm o) a) x * inner a y =\n    â€–aâ€– ^ 2 * â†‘(â†‘(Orientation.areaForm o) x) y :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\ntheir sum is equal to the sum of their norms, then they are equal. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\n  â€–xâ€– = â€–yâ€– â†’ â€–x + yâ€– = â€–xâ€– + â€–yâ€– â†’ x = y :=\n\n/-- $x^n-y^n = (x-y) \\sum x^ky^{n-1-k}$ reformulated without `-` signs. -/\ntheorem âˆ€ {Î± : Type u} [inst : CommSemiring Î±] (x y : Î±) (n : â„•),\n  (Finset.sum (Finset.range n) fun i => (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- The norm of the sum of two vectors equals the norm of their difference if and only if\nthe angle between them is Ï€/2. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  â€–x + yâ€– = â€–x - yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\n  (âˆ€ (r : R),\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$. -/\ntheorem", "choices": ["âˆ€ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : InnerProductSpace â„ k] (x y : k),\n  â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * (â€–xâ€– * â€–xâ€–) + 2 * (â€–yâ€– * â€–yâ€–) ", "âˆ€ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : InnerProductSpace â„ k] (x y : k),\n  â€–x + yâ€– ^ 2 + â€–x - yâ€– ^ 2 = 2 * â€–xâ€– ^ 2 + 2 * â€–yâ€– ^ 2 ", "âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] (x y : Î  (_x : Fin k), R),\n  (Finset.sum Finset.univ fun i => (x i + y i) ^ 2) +\n    Finset.sum Finset.univ (fun i => (x i - y i) ^ 2) =\n      2 * Finset.sum Finset.univ (fun i => x i ^ 2) + 2 * Finset.sum Finset.univ (fun i => y i ^ 2) ", "âˆ€ {R : Type u_1} [inst : NormedAddCommGroup R] [inst_1 : InnerProductSpace â„ R] (x y : R),\n  â€–x + yâ€– ^ 2 + â€–x - yâ€– ^ 2 = 2 * â€–xâ€– ^ 2 + 2 * â€–yâ€– ^ 2 ", "âˆ€ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : InnerProductSpace â„ k] (x y : k),\n  â€–x + yâ€– ^ 2 + â€–x - yâ€– ^ 2 = 2 * â€–xâ€– ^ 2 + 2 * â€–yâ€– ^ 2 ", "âˆ€ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : InnerProductSpace â„ k] (x y : k),\n  â€–x + yâ€– ^ 2 + â€–x - yâ€– ^ 2 = 2 * â€–xâ€– ^ 2 + 2 * â€–yâ€– ^ 2 ", "âˆ€ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : InnerProductSpace â„ k] (x y : k),\n  â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) ", "âˆ€ {R : Type u_1} [inst : NormedAddCommGroup R] [inst_1 : InnerProductSpace â„ R] (x y : R),\n  â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * â€–xâ€– * â€–xâ€– + 2 * â€–yâ€– * â€–yâ€– ", "âˆ€ {R : Type u_1} [inst : NormedAddCommGroup R] [inst_1 : InnerProductSpace â„ R] (x y : R),\n  â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * â€–xâ€– * â€–xâ€– + 2 * â€–yâ€– * â€–yâ€– ", "âˆ€ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : InnerProductSpace â„ k] (x y : k),\n  â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * â€–xâ€– * â€–xâ€– + 2 * â€–yâ€– * â€–yâ€– "]}
{"docString": "If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ (k : â„•) {r : â„}, |r| < 1 â†’ Filter.Tendsto (fun n => â†‘n ^ k * r ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection Ká—®] {v : E}, v âˆˆ K â†’ â†‘(orthogonalProjection Ká—®) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `Ká—®` of an element of `K` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, v âˆˆ Ká—® â†’ â†‘(orthogonalProjection K) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `K` of an element of `Ká—®` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\\n`x : M` such that `B x x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k â†‘V = 1 â†’ CategoryTheory.Simple V\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. \"}]\n", "prompt_cons": "/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem âˆ€ (k : â„•) {r : â„}, |r| < 1 â†’ Filter.Tendsto (fun n => â†‘n ^ k * r ^ n) Filter.atTop (nhds 0) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A) :=\n\n/-- The orthogonal projection onto `Ká—®` of an element of `K` is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection Ká—®] {v : E}, v âˆˆ K â†’ â†‘(orthogonalProjection Ká—®) v = 0 :=\n\n/-- The orthogonal projection onto `K` of an element of `Ká—®` is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, v âˆˆ Ká—® â†’ â†‘(orthogonalProjection K) v = 0 :=\n\n/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x â‰  0`. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x :=\n\n/-- Any `k`-algebra module which is 1-dimensional over `k` is simple. -/\ntheorem âˆ€ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\n  FiniteDimensional.finrank k â†‘V = 1 â†’ CategoryTheory.Simple V :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M :=\n\n/-- If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$ -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] {x : R},\n  Â¬(âˆƒ y : R, y â‰  0 âˆ§ (Î» a b : R, a * b) x y = 0) ", "âˆ€ {R : Type u_1} [inst : Ring R] {x : R}, Â¬(âˆƒ y : R, y â‰  0 âˆ§ x * y = 0) ", "âˆ€ {R : Type u_1} [inst : CommRing R] {x : R}, Â¬(âˆƒ y : R, y â‰  0 âˆ§ x * y = 0) ", "âˆ€ {R : Type u_1} [inst : Ring R] {x : R},\n  Â¬(âˆƒ y, y â‰  0 âˆ§ x * y = 0) ", "âˆ€ {R : Type u_1} [inst : Ring R] {x : R}, Â¬âˆƒ (y : R), y â‰  0 âˆ§ x * y = 0 ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  (âˆƒ y : R, y â‰  0 âˆ§ x * y = 0) â†’ x = 0 ", "forall {R : Type u_1} [inst : Ring R] (x : R), Â¬(âˆƒ y : R, y â‰  0 âˆ§ x * y = 0) ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  (âˆƒ y : R, y â‰  0 âˆ§ x * y = 0) â†’ x = 0 ", "âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : Nontrivial R] (x : R), x â‰  0 â†’ Â¬(âˆƒ y, y â‰  0 âˆ§ x * y = 0) ", "âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] {x : R}, x â‰  0 â†’ Â¬âˆƒ y : R, y â‰  0 âˆ§ x * y = 0 "]}
{"docString": "If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x y : Î±},\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : MeasurableSpace Î±]\\n  [inst_3 : OpensMeasurableSpace Î±] {s t : Set Î±},\\n  MeasureTheory.AnalyticSet s â†’ MeasureTheory.AnalyticSet t â†’ Disjoint s t â†’ MeasureTheory.MeasurablySeparable s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\\ndisjoint Borel sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : UniformSpace Î±] [inst_1 : SeparatedSpace Î±] {s : Set Î±}, IsComplete s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a separated space, a complete set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"}]\n", "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x y : Î±},\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\ndisjoint Borel sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : MeasurableSpace Î±]\n  [inst_3 : OpensMeasurableSpace Î±] {s t : Set Î±},\n  MeasureTheory.AnalyticSet s â†’ MeasureTheory.AnalyticSet t â†’ Disjoint s t â†’ MeasureTheory.MeasurablySeparable s t :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²) :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- In a separated space, a complete set is closed. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : UniformSpace Î±] [inst_1 : SeparatedSpace Î±] {s : Set Î±}, IsComplete s â†’ IsClosed s :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ (U V : Set Î±), IsOpen U âˆ§ IsOpen V âˆ§ A âŠ† U âˆ§ B âŠ† V âˆ§ Disjoint U V ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {X : Type u} [inst : MetricSpace X] {A B : Set X},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ Separated A B "]}
{"docString": "Prove that every compact metric space $K$ has a countable base.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\\n  IsCompact s â†’ âˆ€ {e : â„}, 0 < e â†’ âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ (x : Î±) (_ : x âˆˆ t), Metric.ball x e\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any compact set in a pseudometric space can be covered by finitely many balls of a given\\npositive radius \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A proper pseudo metric space is sigma compact, and therefore second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"}]\n", "prompt_cons": "/-- In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\n  IsCompact s â†’ âˆ€ {e : â„}, 0 < e â†’ âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ (x : Î±) (_ : x âˆˆ t), Metric.ball x e :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- A proper pseudo metric space is sigma compact, and therefore second countable. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- Prove that every compact metric space $K$ has a countable base. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±],\n  TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±], TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [self : CompactSpace Î±],\n  TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±], TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±], TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±], TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±],\n  TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±],\n  TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [self : CompactSpace Î±], TopologicalSpace.SecondCountableTopology Î± ", "âˆ€ {K : Type u_1} [inst : TopologicalSpace K] [inst_1 : CompactSpace K] [inst_2 : MetricSpace K],\n  TopologicalSpace.SecondCountableTopology K "]}
{"docString": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\\n  Monotone f â†’\\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\\n      Set.Countable {x | Â¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where a monotone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\\n  Antitone f â†’\\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\\n      Set.Countable {x | Â¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where an antitone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_1 : MeasureTheory.SigmaFinite Î¼] {As : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’ Pairwise (Disjoint on As) â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Ïƒ-finite space, among disjoint measurable sets, only countably many can have positive\\nmeasure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\\n  (s : Set Î²),\\n  IsCompact s â†’\\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\\n      IsClosed A â†’\\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"}]\n", "prompt_cons": "/-- In a second countable space, the set of points where a monotone function is not continuous\nis at most countable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\n  Monotone f â†’\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\n      Set.Countable {x | Â¬ContinuousAt f x} :=\n\n/-- In a second countable space, the set of points where an antitone function is not continuous\nis at most countable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\n  Antitone f â†’\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\n      Set.Countable {x | Â¬ContinuousAt f x} :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- In a Ïƒ-finite space, among disjoint measurable sets, only countably many can have positive\nmeasure. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_1 : MeasureTheory.SigmaFinite Î¼] {As : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’ Pairwise (Disjoint on As) â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)} :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- There exists a countable dense set. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\n  (s : Set Î²),\n  IsCompact s â†’\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\n      IsClosed A â†’\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A :=\n\n/-- Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {E : Set Î±} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±],\n  Set.Uncountable E â†’ Set.Countable (E \\ Set.CondensationPoints E) ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  {E : Set Î±} [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±],\n  Set.Countable E â†’ Set.Countable {x | x âˆˆ E âˆ§ Â¬IsCondensationPoint x E} ", "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {E : Set Î±},\n  Set.Countable E â†’ Set.Countable {x âˆˆ E | Â¬IsCondensationPoint x} ", "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {E : Set Î±},\n  Set.Uncountable E â†’\n    âˆƒ P, IsClosed P âˆ§ (âˆ€ x, x âˆˆ P â†” IsCondensationPoint Î± â„ E x) âˆ§ Set.Countable (E \\ P) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : TopologicalSpace.FirstCountableTopology Î±],\n  âˆ€ {s : Set Î±}, Set.Countable s â†’ Set.Countable {x | x âˆˆ s âˆ§ Â¬ClusterPt x (Filter.principal s)} ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±]\n  [inst_3 : OrderTopology Î±],\n  âˆ€ (s : Set Î±), Set.Countable s â†’ Set.Countable {x âˆˆ s | Â¬IsCondensationPoint x s} ", "âˆ€ {Î± : Type u_1} {k : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder k]\n  [inst_2 : TopologicalSpace k] [inst_3 : OrderTopology k] [inst_4 : MetricSpace Î±] [inst_5 : TopologicalSpace.SecondCountableTopology k],\n  Set.Uncountable E â†’\n    let P ", "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {E : Set Î±},\n  Set.Uncountable E â†’\n    âˆ€ {P : Set Î±}, P = {x | âˆ€ (U : Set Î±), x âˆˆ U â†’ IsOpen U â†’ Set.Countable (E âˆ© U) â†’ Set.Nonempty (E âˆ© Uá¶œ)} â†’\n      Set.Countable (E \\ P) ", "âˆ€ {E : Set â„} [TopologicalSpace â„] [TopologicalSpace.SeparableSpace â„],\n  Set.Uncountable E â†’\n    âˆƒ P, P âŠ† E âˆ§ IsGÎ´ P âˆ§ Set.Countable (E \\ P) ", "âˆ€ {Î± : Type u_1} [_inst_1 : TopologicalSpace Î±] [_inst_2 : TopologicalSpace.SecondCountableTopology Î±] {E : Set Î±},\n  Set.Countable E â†’ Set.Countable (E \\ {x | IsCondensationPoint x E}) "]}
{"docString": "Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\\n    Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\ncountably many members of the union whose measure is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’ Pairwise (Disjoint on As) â†’ âˆ‘' (i : Î¹), â†‘â†‘Î¼ (As i) â‰¤ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of\\nthe measures of the sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {I : Set Î²} {s : Î² â†’ Set Î±},\\n  Set.Finite I â†’ (Metric.Bounded (â‹ƒ (i : Î²) (_ : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ Metric.Bounded (s i))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of bounded sets is bounded \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {Îµ : ENNReal},\\n  0 < Îµ â†’\\n    âˆ€ {As : Î¹ â†’ Set Î±},\\n      (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\\n        Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Finite {i | Îµ â‰¤ â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\nfinitely many members of the union whose measure exceeds any given positive number. \"}]\n", "prompt_cons": "/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\n    Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)} :=\n\n/-- The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of\nthe measures of the sets. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’ Pairwise (Disjoint on As) â†’ âˆ‘' (i : Î¹), â†‘â†‘Î¼ (As i) â‰¤ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) :=\n\n/-- A finite union of bounded sets is bounded -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {I : Set Î²} {s : Î² â†’ Set Î±},\n  Set.Finite I â†’ (Metric.Bounded (â‹ƒ (i : Î²) (_ : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ Metric.Bounded (s i)) :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {Îµ : ENNReal},\n  0 < Îµ â†’\n    âˆ€ {As : Î¹ â†’ Set Î±},\n      (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\n        Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Finite {i | Îµ â‰¤ â†‘â†‘Î¼ (As i)} :=\n\n/-- Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  âˆ€ {s : Set Î±}, IsOpen s â†’ âˆƒ U, Set.Countable U âˆ§ (âˆ€ (u : Set Î±), u âˆˆ U â†’ IsOpen u âˆ§ Set.Nonempty u) âˆ§\n    Pairwise (Disjoint on U) âˆ§ s = â‹ƒâ‚€ U ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±] {s : Set Î±}, IsOpen s â†’\n  âˆƒ (t : Set (Set Î±)), Set.Countable t âˆ§ (âˆ€ (b : Set Î±), b âˆˆ t â†’ IsOpen b âˆ§ Set.Nonempty b) âˆ§ Set.PairwiseDisjoint t id âˆ§ s = â‹ƒâ‚€ t ", "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : LinearOrder Î±] [inst_1 : OrderTopology Î±] [inst_2 : DenselyOrdered Î±] [TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  IsOpen s â†’ âˆƒ B : Set (Set Î±), Set.Countable B âˆ§ (âˆ€ (b : Set Î±), b âˆˆ B â†’ IsOpen b) âˆ§ Set.PairwiseDisjoint B id âˆ§ s = â‹ƒâ‚€ B ", "âˆ€ {s : Set â„}, IsOpen s â†’ âˆƒ f : â„• â†’ Set â„, (âˆ€ (n : â„•), IsOpen (f n)) âˆ§ Pairwise Disjoint\tf âˆ§ s = â‹ƒ (n : â„•), f n ", "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : TopologicalSpace.SecondCountableTopology Î±],\n  âˆ€ (U : Set Î±), IsOpen U â†’ âˆƒ (a b : Î± â†’ Î±), Set.Countable {i : Î± | (a i, b i).Nonempty} âˆ§ U = â‹ƒ (i : Î±), (a i, b i) ", "forall {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {s : Set Î±},\n  IsOpen s ->\n  (âˆƒ (a b : Î± â†’ Î±), Set.PairwiseDisjoint (Set.Range a) (Function.onFun Disjoint (Set.Interval (a n) (b n))) âˆ§\n    s = â‹ƒ (n : Î±), Set.Interval (a n) (b n) âˆ§ Set.Countable (Set.Range a)) ", "âˆ€ {s : Set â„} (hs : IsOpen s),\n  âˆƒ (U : â„ â†’ Set â„), (âˆ€ (x : â„), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint â„ U âˆ§ s = â‹ƒ (x : â„) (_ : x âˆˆ s), U x ", "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {s : Set Î±},\n  IsOpen s â†’ âˆƒ A, Set.Countable A âˆ§ (â‹ƒ (I : Î± Ã— Î±) (_ : I âˆˆ A), Set.Ioo (I.fst) (I.snd)) = s ", "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {s : Set Î±},\n  IsOpen s â†’ âˆƒ T, Set.Countable T âˆ§ s = â‹ƒâ‚€ {Set.Ioo x.1 x.2 | x âˆˆ T} ", "âˆ€ {Î³ : Type u_1} [inst : LinearOrder Î³] [inst_1 : TopologicalSpace Î³] [inst_2 : OrderTopology Î³] [inst_3 : DenselyOrdered Î³] {U : Set Î³},\n  IsOpen U â†’ âˆƒ C, Set.Countable C âˆ§ (â‹ƒ (x : Î³) (_ : x âˆˆ C), ({x} : Set Î³)) = U "]}
{"docString": "Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$.", "prompts": "[{\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’ CauchySeq f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\": \"Real.Gamma (1 / 2) = Real.sqrt Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The special-value formula `Î“(1/2) = âˆšÏ€`, which is equivalent to the Gaussian integral. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’\\n    âˆ€ {a : Î±}, Filter.Tendsto f Filter.atTop (nhds a) â†’ âˆ€ (n : â„•), dist (f n) a â‰¤ C / 2 ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\\n`f n` to the limit of `f` is bounded above by `C / 2^n`. \"}]\n", "prompt_cons": "/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’ CauchySeq f :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The special-value formula `Î“(1/2) = âˆšÏ€`, which is equivalent to the Gaussian integral. -/\ntheorem Real.Gamma (1 / 2) = Real.sqrt Real.pi :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C / 2^n`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’\n    âˆ€ {a : Î±}, Filter.Tendsto f Filter.atTop (nhds a) â†’ âˆ€ (n : â„•), dist (f n) a â‰¤ C / 2 ^ n :=\n\n/-- Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$. -/\ntheorem", "choices": ["Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n^2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => Real.sqrt (â†‘n ^ 2 + â†‘n) - â†‘n) Filter.atTop (nhds (1 / 2)) "]}
{"docString": "For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E]\\n  {a b : â„} [inst_3 : Countable Î¹] {f : Î¹ â†’ C(â„, E)},\\n  (Summable fun i =>\\n      â€–ContinuousMap.restrict (â†‘{ carrier := Set.uIcc a b, isCompact' := (_ : IsCompact (Set.uIcc a b)) }) (f i)â€–) â†’\\n    HasSum (fun i => âˆ« (x : â„) in a..b, â†‘(f i) x) (âˆ« (x : â„) in a..b, âˆ‘' (i : Î¹), â†‘(f i) x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Interval integrals commute with countable sums, when the supremum norms are summable (a\\nspecial case of the dominated convergence theorem). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] (a b : Î±), a â‰¤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a â‰¤ a + b` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} {Î³ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Î³]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : OrderTopology Î³] [inst_4 : ContinuousAdd Î³] {f g : Î± â†’ Î³},\\n  UpperSemicontinuousAt f x â†’ UpperSemicontinuousAt g x â†’ UpperSemicontinuousAt (fun z => f z + g z) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\\naddition, for application to `EReal`. \"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : MeasureTheory.IsProbabilityMeasure Î¼]\\n  {s : â„• â†’ Set Î©},\\n  (âˆ€ (n : â„•), MeasurableSet (s n)) â†’\\n    ProbabilityTheory.iIndepSet s â†’ âˆ‘' (n : â„•), â†‘â†‘Î¼ (s n) = âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\\n`âˆ‘ n, Î¼ sâ‚™ = âˆ`, `limsup sâ‚™` has measure 1. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±},\\n  Dense s â†’\\n    (âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) â†’\\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) f u) _autoâœ â†’\\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¥ x_1) f u) _autoâœÂ¹ â†’ âˆƒ c, Filter.Tendsto u f (nhds c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\\nworks if `a` and `b` are restricted to a dense subset.\\n\"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} {Î³ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Î³]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : OrderTopology Î³] {f g : Î± â†’ Î³},\\n  UpperSemicontinuousAt f x â†’\\n    UpperSemicontinuousAt g x â†’\\n      ContinuousAt (fun p => p.fst + p.snd) (f x, g x) â†’ UpperSemicontinuousAt (fun z => f z + g z) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\\nthe lemma uses `[ContinuousAdd]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OrderTopology Î±] {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [inst_3 : Filter.NeBot f],\\n  Filter.Tendsto u f (nhds a) â†’ Filter.limsup u f = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a limit, then its limsup coincides with its limit. \"}]\n", "prompt_cons": "/-- Interval integrals commute with countable sums, when the supremum norms are summable (a\nspecial case of the dominated convergence theorem). -/\ntheorem âˆ€ {Î¹ : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E]\n  {a b : â„} [inst_3 : Countable Î¹] {f : Î¹ â†’ C(â„, E)},\n  (Summable fun i =>\n      â€–ContinuousMap.restrict (â†‘{ carrier := Set.uIcc a b, isCompact' := (_ : IsCompact (Set.uIcc a b)) }) (f i)â€–) â†’\n    HasSum (fun i => âˆ« (x : â„) in a..b, â†‘(f i) x) (âˆ« (x : â„) in a..b, âˆ‘' (i : Î¹), â†‘(f i) x) :=\n\n/-- For any `a` and `b`, `a â‰¤ a + b` -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] (a b : Î±), a â‰¤ a + b :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} {Î³ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Î³]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : OrderTopology Î³] [inst_4 : ContinuousAdd Î³] {f g : Î± â†’ Î³},\n  UpperSemicontinuousAt f x â†’ UpperSemicontinuousAt g x â†’ UpperSemicontinuousAt (fun z => f z + g z) x :=\n\n/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\n`âˆ‘ n, Î¼ sâ‚™ = âˆ`, `limsup sâ‚™` has measure 1. -/\ntheorem âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : MeasureTheory.IsProbabilityMeasure Î¼]\n  {s : â„• â†’ Set Î©},\n  (âˆ€ (n : â„•), MeasurableSet (s n)) â†’\n    ProbabilityTheory.iIndepSet s â†’ âˆ‘' (n : â„•), â†‘â†‘Î¼ (s n) = âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 1 :=\n\n/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±},\n  Dense s â†’\n    (âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) â†’\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) f u) _autoâœ â†’\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¥ x_1) f u) _autoâœÂ¹ â†’ âˆƒ c, Filter.Tendsto u f (nhds c) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} {Î³ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Î³]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : OrderTopology Î³] {f g : Î± â†’ Î³},\n  UpperSemicontinuousAt f x â†’\n    UpperSemicontinuousAt g x â†’\n      ContinuousAt (fun p => p.fst + p.snd) (f x, g x) â†’ UpperSemicontinuousAt (fun z => f z + g z) x :=\n\n/-- If a function has a limit, then its limsup coincides with its limit. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [inst_3 : Filter.NeBot f],\n  Filter.Tendsto u f (nhds a) â†’ Filter.limsup u f = a :=\n\n/-- For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$. -/\ntheorem", "choices": ["âˆ€ {Î² : Type u_2} {u v : Î² â†’ â„} {f : Filter Î²} [inst : Filter.NeBot f],\n  Filter.limsup (fun n => u n + v n) f â‰¤ Filter.limsup u f + Filter.limsup v f ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] {f : Filter Î²} {u v : Î² â†’ Î±} [inst_3 : Filter.NeBot f],\n  Filter.limsup (fun x => u x + v x) f â‰¤ Filter.limsup u f + Filter.limsup v f ", "âˆ€ {Î± : Type u} {u v : Î± â†’ â„},\n  Filter.limsup (fun n => u n + v n) Filter.atTop â‰¤ Filter.limsup u Filter.atTop + Filter.limsup v Filter.atTop ", "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  {a b : Filter Î±}, Filter.limsup (Filter.map (fun p => p.fst + p.snd) (a Ã—á¶  b)) â‰¤ Filter.limsup a + Filter.limsup b ", "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : OrderClosedTopology Î±] {f g : Filter Î±} [inst_4 : Filter.NeBot f] [inst_5 : Filter.NeBot g],\n  Filter.limsup (Filter.map (fun p => p.fst + p.snd) (Filter.prod f g)) â‰¤\n    Filter.limsup f + Filter.limsup g ", "âˆ€ {Î² : Type u_2} {u v : Î² â†’ â„} {f : Filter Î²} [inst : Filter.NeBot f],\n  Â¬(Filter.limsup u f = âŠ¤ âˆ§ Filter.limsup v f = -âŠ¤) â†’\n    Â¬(Filter.limsup u f = -âŠ¤ âˆ§ Filter.limsup v f = âŠ¤) â†’\n      Filter.limsup (Î» n => u n + v n) f â‰¤ Filter.limsup u f + Filter.limsup v f ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] {f : Filter Î²} {u v : Î² â†’ Î±} [inst_3 : Filter.NeBot f],\n  Filter.limsup (fun x => u x + v x) f â‰¤ Filter.limsup u f + Filter.limsup v f ", "âˆ€ {Î² : Type u_2} {u v : Î² â†’ â„},\n  Filter.limsup (fun n => u n + v n) Filter.atTop â‰¤ Filter.limsup u Filter.atTop + Filter.limsup v Filter.atTop ", "forall {u v : â„• â†’ â„}, Filter.limsup (Filter.atTop) (fun n => u n + v n) â‰¤ Filter.limsup (Filter.atTop) u + Filter.limsup (Filter.atTop) v ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] {f : Filter Î²} {ua ub : Î² â†’ Î±} [inst_3 : Filter.NeBot f],\n  Filter.limsup (fun x => ua x + ub x) f â‰¤ Filter.limsup ua f + Filter.limsup ub f "]}
{"docString": "Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"}]\n", "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {f : â„• â†’ Î±},\n  (âˆ€ (i : â„•), 0 â‰¤ f i) â†’ Summable f â†’ Summable (fun i => Real.sqrt (f i) / â†‘(i + 1)) ", "âˆ€ {a : â„• â†’ â„}, (âˆ€ (n : â„•), 0 â‰¤ a n) â†’ Summable a â†’ Summable (Î» n => Real.sqrt (a n) / (n + 1)) ", "âˆ€ {Î± : Type u_1} {a : â„• â†’ Î±} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  (âˆ€ (n : â„•), 0 â‰¤ a n) â†’ Summable a â†’ Summable (Î» n => Real.sqrt (a n) / (n + 1)) ", "âˆ€ {Î± : Type u_1} [inst : OrderedSemiring Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  Summable (Î» (n : â„•), â†‘(n : â„•)) â†’ Summable (Î» (n : â„•), (â†‘n ^ (1 / 2) : Î±) / (â†‘n : Î±)) ", "âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : TopologicalAddGroup Î±] [inst_3 : OrderClosedTopology Î±] {f : â„• â†’ Î±},\n  (âˆ€ (n : â„•), 0 â‰¤ f n) â†’ Summable f â†’ Summable (Î» n => (Real.sqrt (f n)) / (n + 1)) ", "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {a : â„• â†’ Î±},\n  (âˆ€ (n : â„•), 0 â‰¤ a n) â†’ Summable a â†’ Summable (Î» n, Real.sqrt (a n) / (n + 1)) ", "âˆ€ {Î± : Type u_1} [inst : OrderedSemiring Î±] [inst_1 : Archimedean Î±] {f : â„• â†’ Î±},\n  (Summable fun i => f i) â†’ (âˆ€ i, 0 â‰¤ f i) â†’ Summable fun i => (Real.sqrt (f i)) / (i + 1) ", "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : Archimedean Î±]\n  {a : â„• â†’ Î±}, (âˆ€ (n : â„•), 0 â‰¤ a n) â†’ Summable a â†’ Summable (Î» n => (Real.sqrt (a n)) / (â†‘n + 1)) ", "âˆ€ {Î² : Type u_1} {a : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ a b) â†’ Summable a â†’ Summable (Î» n => sqrt (a n) / (n + 1)) ", "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderedAddCommGroup Î±] [inst_3 : HasContinuousAdd Î±] {a : Î±} {f : â„• â†’ Î±},\n  (âˆ€ (i : â„•), 0 â‰¤ f i) â†’ HasSum f a â†’ HasSum (fun n => Real.sqrt (f n) / n) "]}
{"docString": "Prove that the Cauchy product of two absolutely convergent series converges absolutely.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"}]\n", "prompt_cons": "/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Prove that the Cauchy product of two absolutely convergent series converges absolutely. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : HasContinuousAdd Î±]\n  [inst_3 : AddCommMonoid Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : HasContinuousAdd Î²] [inst_6 : AddCommMonoid Î³]\n  [inst_7 : TopologicalSpace Î³] [inst_8 : HasContinuousAdd Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} {u : Î± â†’ Î±} {v : Î² â†’ Î²} {w : Î³ â†’ Î³},\n  Summable u â†’ Summable v â†’ Summable w â†’ (âˆ€ (x : Î±), HasSum (fun (y : Î²) => f x * g y) (w x)) â†’\n    HasSum (fun x => âˆ‘' (y : Î²), f x * g y) (âˆ‘' (x : Î±), w x) ", "âˆ€ {Î± : Type u} [inst : Semiring Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalRing Î±] [inst_3 : CompleteSpace Î±]\n  {f g : â„• â†’ Î±}, Summable f â†’ Summable g â†’ Summable (f * g) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : AddCommGroup Î³] [inst_1 : TopologicalSpace Î³] [inst_2 : UniformSpace Î³]\n  [inst_3 : CompleteSpace Î³] {f : Î± â†’ Î³} {g : Î² â†’ Î³},\n  Summable f â†’ Summable g â†’ Summable (Î» (p : Î± Ã— Î²), f p.1 * g p.2) ", "âˆ€ {Î± : Type u_1} [inst : OrderedCommMonoid Î±] {Î² : Type u_2} [inst_1 : Semiring Î²] {f g : Î² â†’ Î±},\n  Summable (abs âˆ˜ f) â†’ Summable (abs âˆ˜ g) â†’ Summable (abs âˆ˜ (f * g)) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [_inst_1 : Ring Î±] [_inst_2 : Ring Î²] [_inst_3 : Ring Î³] {f : â„• â†’ Î±} {g : â„• â†’ Î²}\n  {h : â„• â†’ Î³} (hf : Summable (abs âˆ˜ f)) (hg : Summable (abs âˆ˜ g)) (hfg : âˆ€ (n : â„•), h n = Finset.sum (Finset.range (n + 1))\n    (Î» (x : â„•), f x * g (n - x))), Summable (abs âˆ˜ h) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : Ring Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalRing Î±]\n  [inst_3 : AddCommGroup Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : AddCommGroup Î³] [inst_6 : TopologicalSpace Î³]\n  {f : Î² â†’ Î±} {g : Î³ â†’ Î±}, Summable f â†’ Summable g â†’ Summable (f âŠ—â‚œ g) ", "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {Î² : Type u_2} [inst_1 : Semiring Î²] {f g : â„• â†’ Î±}\n  {a : Î± â†’ Î²} [inst_2 : LinearOrderedField Î²] [inst_3 : IsAbsoluteValue a],\n  Summable (Î» n => a (f n)) â†’ Summable (Î» n => a (g n)) â†’ Summable (Î» n => a (f * g n)) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DiscreteLinearOrderedField Î±] [inst_1 : Ring Î²] [inst_2 : NoZeroDivisors Î²]\n  {f g : â„• â†’ Î²}, Summable (Î» (n : â„•), abs (f n)) â†’ Summable (Î» (n : â„•), abs (g n)) â†’\n    Summable (Î» (n : â„•), abs (Finset.sum (Finset.range n) (Î» (i : â„•), f i * g (n - i - 1)))) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Ring Î±] [inst_1 : Ring Î²] {f g : â„• â†’ Î±} {hf : Summable f} {hg : Summable g},\n  Summable (fun (n : â„•) => Finset.sum (Finset.range (n + 1)) (Î» (x : â„•), f x * (g (n - x)))) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Ring Î±] [inst_1 : LinearOrderedField Î²] {abv : Î± â†’ Î²} [inst_2 : IsAbsoluteValue abv]\n  (hf hg : â„• â†’ Î±), Summable (Î» n, abv (hf n)) â†’ Summable (Î» n, abv (hg n)) â†’ Summable (Î» n, abv (finset.sum (finset.range (n + 1)) (Î» i, hf i * hg (n - i)))) "]}
{"docString": "If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\\n    (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\\n      (âˆ€ (N : â„•), Set.Nonempty (â‹‚ (n : â„•) (_ : n â‰¤ N), s n)) â†’\\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ Set.Nonempty (â‹‚ (n : â„•), s n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, if a family of closed sets with diameter tending to `0` is such that each\\nfinite intersection is nonempty, then the total intersection is also nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.Bounded s â†” EMetric.diam s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst : LinearOrder Î¹]\\n  [inst_1 : TopologicalSpace Î¹] [inst_2 : OrderTopology Î¹] [inst_3 : DenselyOrdered Î¹]\\n  [inst_4 : TopologicalSpace.FirstCountableTopology Î¹] {s : Î¹ â†’ Set Î±} {a : Î¹},\\n  (âˆ€ (r : Î¹), r > a â†’ MeasurableSet (s r)) â†’\\n    (âˆ€ (i j : Î¹), a < i â†’ i â‰¤ j â†’ s i âŠ† s j) â†’\\n      (âˆƒ r, r > a âˆ§ â†‘â†‘Î¼ (s r) â‰  âŠ¤) â†’\\n        Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) (nhdsWithin a (Set.Ioi a)) (nhds (â†‘â†‘Î¼ (â‹‚ (r : Î¹) (_ : r > a), s r)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of the intersection of a decreasing sequence of measurable\\nsets indexed by a linear order with first countable topology is the limit of the measures. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\\n  Set.Nonempty s â†’ âˆ€ {C : â„}, (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ dist x y â‰¤ C) â†’ Metric.diam s â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between any two points in a nonempty set is bounded by some constant,\\nthis constant bounds the diameter. \"},\n {\"theorem\":\n  \"âˆ€ {t : Set GromovHausdorff.GHSpace} {C : â„} {u : â„• â†’ â„} {K : â„• â†’ â„•},\\n  Filter.Tendsto u Filter.atTop (nhds 0) â†’\\n    (âˆ€ (p : GromovHausdorff.GHSpace), p âˆˆ t â†’ Metric.diam Set.univ â‰¤ C) â†’\\n      (âˆ€ (p : GromovHausdorff.GHSpace),\\n          p âˆˆ t â†’\\n            âˆ€ (n : â„•),\\n              âˆƒ s,\\n                Cardinal.mk â†‘s â‰¤ â†‘(K n) âˆ§\\n                  Set.univ âŠ† â‹ƒ (x : GromovHausdorff.GHSpace.Rep p) (_ : x âˆˆ s), Metric.ball x (u n)) â†’\\n        TotallyBounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\\na uniformly bounded diameter, and for all `Îµ` the number of balls of radius `Îµ` required\\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\\ninteresting direction that these conditions imply compactness. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : UniformSpace Î±] {s : Set Î±}, TotallyBounded s â†’ TotallyBounded (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a totally bounded set is totally bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : Countable Î¹]\\n  [inst : SemilatticeSup Î¹] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (n : Î¹), MeasurableSet (s n)) â†’\\n    Antitone s â†’ (âˆƒ i, â†‘â†‘Î¼ (s i) â‰  âŠ¤) â†’ Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) Filter.atTop (nhds (â†‘â†‘Î¼ (â‹‚ (n : Î¹), s n)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Continuity from above: the measure of the intersection of a decreasing sequence of measurable\\nsets is the limit of the measures. \"}]\n", "prompt_cons": "/-- In a complete space, if a family of closed sets with diameter tending to `0` is such that each\nfinite intersection is nonempty, then the total intersection is also nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n      (âˆ€ (N : â„•), Set.Nonempty (â‹‚ (n : â„•) (_ : n â‰¤ N), s n)) â†’\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ Set.Nonempty (â‹‚ (n : â„•), s n) :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.Bounded s â†” EMetric.diam s â‰  âŠ¤ :=\n\n/-- The measure of the intersection of a decreasing sequence of measurable\nsets indexed by a linear order with first countable topology is the limit of the measures. -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst : LinearOrder Î¹]\n  [inst_1 : TopologicalSpace Î¹] [inst_2 : OrderTopology Î¹] [inst_3 : DenselyOrdered Î¹]\n  [inst_4 : TopologicalSpace.FirstCountableTopology Î¹] {s : Î¹ â†’ Set Î±} {a : Î¹},\n  (âˆ€ (r : Î¹), r > a â†’ MeasurableSet (s r)) â†’\n    (âˆ€ (i j : Î¹), a < i â†’ i â‰¤ j â†’ s i âŠ† s j) â†’\n      (âˆƒ r, r > a âˆ§ â†‘â†‘Î¼ (s r) â‰  âŠ¤) â†’\n        Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) (nhdsWithin a (Set.Ioi a)) (nhds (â†‘â†‘Î¼ (â‹‚ (r : Î¹) (_ : r > a), s r))) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- If the distance between any two points in a nonempty set is bounded by some constant,\nthis constant bounds the diameter. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\n  Set.Nonempty s â†’ âˆ€ {C : â„}, (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ dist x y â‰¤ C) â†’ Metric.diam s â‰¤ C :=\n\n/-- Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\na uniformly bounded diameter, and for all `Îµ` the number of balls of radius `Îµ` required\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\ninteresting direction that these conditions imply compactness. -/\ntheorem âˆ€ {t : Set GromovHausdorff.GHSpace} {C : â„} {u : â„• â†’ â„} {K : â„• â†’ â„•},\n  Filter.Tendsto u Filter.atTop (nhds 0) â†’\n    (âˆ€ (p : GromovHausdorff.GHSpace), p âˆˆ t â†’ Metric.diam Set.univ â‰¤ C) â†’\n      (âˆ€ (p : GromovHausdorff.GHSpace),\n          p âˆˆ t â†’\n            âˆ€ (n : â„•),\n              âˆƒ s,\n                Cardinal.mk â†‘s â‰¤ â†‘(K n) âˆ§\n                  Set.univ âŠ† â‹ƒ (x : GromovHausdorff.GHSpace.Rep p) (_ : x âˆˆ s), Metric.ball x (u n)) â†’\n        TotallyBounded t :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ :=\n\n/-- The closure of a totally bounded set is totally bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : UniformSpace Î±] {s : Set Î±}, TotallyBounded s â†’ TotallyBounded (closure s) :=\n\n/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the limit of the measures. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : Countable Î¹]\n  [inst : SemilatticeSup Î¹] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (n : Î¹), MeasurableSet (s n)) â†’\n    Antitone s â†’ (âˆƒ i, â†‘â†‘Î¼ (s i) â‰  âŠ¤) â†’ Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) Filter.atTop (nhds (â†‘â†‘Î¼ (â‹‚ (n : Î¹), s n))) :=\n\n/-- If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ âˆƒ x, âˆ€ n, x âˆˆ s n ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (i j : â„•), i â‰¤ j â†’ s i âŠ† s j) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’\n            âˆƒ x, âˆ€ (n : â„•), x âˆˆ s n ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n      (âˆ€ (n : â„•), s n â‰  âˆ…) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ âˆƒ x, âˆ€ y, y âˆˆ â‹‚ (n : â„•), s n â†’ y = x ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ âˆƒ x, âˆ€ n, x âˆˆ s n ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’\n            âˆƒ x, âˆ€ â¦ƒy : Î±â¦„, y âˆˆ (â‹‚ (n : â„•), s n) â†” y = x ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ âˆƒ a, a âˆˆ â‹‚ (n : â„•), s n âˆ§ âˆ€ b, b âˆˆ â‹‚ (n : â„•), s n â†’ a = b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (i j : â„•), i â‰¤ j â†’ s i âŠ† s j) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ (â‹‚ (n : â„•), s n) = Set.singleton (â‹‚ (n : â„•), Classical.some (s n)) ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’\n            âˆƒ x, âˆ€ n, x âˆˆ s n ", "forall {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n      (âˆ€ (n : â„•), s n â‰  âˆ…) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’ âˆƒ x, âˆ€ n, x âˆˆ s n ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsClosed (s n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (s n)) â†’\n      (âˆ€ (n : â„•), Metric.Bounded (s n)) â†’\n        (âˆ€ (n : â„•), s n âŠ‡ s (n + 1)) â†’\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) â†’\n            âˆƒ x, âˆ€ (i : â„•), x âˆˆ s i "]}
{"docString": "Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : DecidableEq Î¹] (i : Î¹),\\n  Continuous fun f => Function.update f.fst i f.snd\",\n  \"isProp\": true,\n  \"docString\": \"`Function.update f i x` is continuous in `(f, x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„¤ â†’ Î±},\\n  Monotone f â†’ âˆ€ (n : â„¤) {x : Î±}, f n < x â†’ x < f (n + 1) â†’ âˆ€ (a : â„¤), f a â‰  x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `â„¤` to a preorder and `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"}]\n", "prompt_cons": "/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- `Function.update f i x` is continuous in `(f, x)`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : DecidableEq Î¹] (i : Î¹),\n  Continuous fun f => Function.update f.fst i f.snd :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- If `f` is a monotone function from `â„¤` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„¤ â†’ Î±},\n  Monotone f â†’ âˆ€ (n : â„¤) {x : Î±}, f n < x â†’ x < f (n + 1) â†’ âˆ€ (a : â„¤), f a â‰  x :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous. -/\ntheorem", "choices": ["âˆƒ (f : â„ â†’ â„), (âˆ€ (x : â„), filter.tendsto (Î» h, f (x + h) - f (x - h)) (ğ“ 0) (ğ“ 0)) âˆ§ Â¬Continuous f ", "Exists {f : â„ â†’ â„}, (âˆ€ x : â„, Filter.Tendsto (Î» h => f (x + h) - f (x - h)) (ğ“ 0) (ğ“ 0)) âˆ§ Â¬Continuous f ", "ExistsCounterexampleOfFunctionNotContinuous\n  : âˆƒ (f : â„ â†’ â„), (âˆ€ (x : â„), filter.tendsto (Î» (h : â„), f (x + h) - f (x - h)) (ğ“ 0) (ğ“ 0)) âˆ§ Â¬Continuous f ", "I am an AI designed to translate natural language into Lean code. I cannot prove theorems or answer theoretical questions directly, but I can help you translate the statement you want to prove into Lean code. \n\nHere's the statement you provided translated into Lean:\n\n```\ntheorem not_continuous_function : \n  Â¬(âˆ€ (f : â„ â†’ â„), (âˆ€ (x : â„), filter.tendsto (Î» h, f (x + h) - f (x - h)) (nhds 0) (nhds 0)) â†’ continuous f) ", "Sorry, I can only translate natural language to Lean code. I cannot prove or disprove statements in natural language.", "not_continuous_but_limit_exists :\n  âˆƒ (f : â„ â†’ â„), (âˆ€ x : â„, filter.tendsto (Î» h, f (x + h) - f (x - h)) (nhds 0) (nhds 0)) âˆ§ Â¬Continuous f ", "exists_non_continuous_fun_with_lim_zero : âˆƒ (f : â„ â†’ â„),\n  (âˆ€ x : â„, Filter.Tendsto (Î» h => f (x + h) - f (x - h)) (ğ“[Set.Ioi 0] 0) (ğ“ 0)) âˆ§ Â¬Continuous f ", "Â¬ (âˆ€ {f : â„ â†’ â„}, (âˆ€ x, filter.tendsto (Î» h => f (x + h) - f (x - h)) (nhds 0) (nhds 0)) â†’ Continuous f) ", "{X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f ", "âˆƒ (f : â„ â†’ â„), (âˆ€ x, Filter.Tendsto (fun h => f (x + h) - f (x - h)) (Filter.tendsto_id 0) (nhds 0)) âˆ§ Â¬Continuous f "]}
{"docString": "Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {Î¼ : MeasureTheory.Measure Î±},\\n  p â‰  0 â†’\\n    p â‰  âŠ¤ â†’\\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\\nsets and is closed under addition (of functions with disjoint support). \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"}]\n", "prompt_cons": "/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0 :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {Î¼ : MeasureTheory.Measure Î±},\n  p â‰  0 â†’\n    p â‰  âŠ¤ â†’\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed. -/\ntheorem", "choices": ["âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace â„] {f : X â†’ â„},\n  Continuous f â†’ IsClosed (f â»Â¹' {0}) ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {f : X â†’ â„} [_inst : TopologicalSpace â„],\n  Continuous f â†’ IsClosed {x : X | f x = 0} ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X â†’ â„},\n  Continuous f â†’ IsClosed (f â»Â¹' {0}) ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {f : X â†’ â„}, Continuous f â†’ IsClosed (SetOf (Î» (x : X), f x = 0)) ", "âˆ€ {X : Type u_2} [inst : MetricSpace X] {f : X â†’ â„} [inst_1 : TopologicalSpace â„],\n  Continuous f â†’ IsClosed (SetOf (Î» (x : X), f x = 0)) ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {f : X â†’ â„} [inst_1 : TopologicalSpace â„],\n  Continuous f â†’ IsClosed (f â»Â¹' {0}) ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {f : X â†’ â„}, Continuous f â†’ IsClosed (SetOf fun x => f x = 0) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X â†’ â„},\n  Continuous f â†’ IsClosed {x : X | f x = 0} ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {f : X â†’ â„} [inst_1 : TopologicalSpace â„],\n  Continuous f â†’ IsClosed (f â»Â¹' {0}) ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {f : X â†’ â„} [inst_1 : TopologicalSpace â„] [_inst : TopologicalSpace X],\n  Continuous f â†’ IsClosed (Function.zeroSet f) "]}
{"docString": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two continuous functions to a t2-space that agree on the dense range of a function are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"}]\n", "prompt_cons": "/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] [inst_2 : T2Space Y] {E : Set X}\n  {f g : X â†’ Y},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Set.EqOn f g E â†’ f = g ", "âˆ€ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] [inst_2 : T2Space Y] {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Set.EqOn f g E â†’ f = g ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Set.EqOn f g E â†’ f = g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MetricSpace Î±] [inst_1 : MetricSpace Î²] {f g : Î± â†’ Î²} {s : Set Î±},\n  Dense s â†’ Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g ", "âˆ€ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y] {E : Set X} {f g : X â†’ Y},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Set.EqOn f g E â†’ f = g ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  [inst_4 : T2Space Y] {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Set.EqOn f g E â†’ f = g ", "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h "]}
{"docString": "Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\\n            UpperSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\\n            LowerSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"}]\n", "prompt_cons": "/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\n            UpperSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\n            LowerSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$. -/\ntheorem", "choices": ["âˆƒ (E : Set â„) (f : E â†’ â„) (hf : ContinuousOn f E), âˆ€ (g : â„ â†’ â„), Continuous g â†’ Â¬Set.EqOn g f E ", "âˆƒ (E : Set â„) (f : E â†’ â„),\n  Continuous f âˆ§ âˆ€ (g : â„ â†’ â„), Continuous g â†’ Â¬Set.EqOn g f E ", "âˆƒ E : Set â„, âˆƒ f : E â†’ â„, Continuous f âˆ§ âˆ€ g : â„ â†’ â„, Continuous g â†’ Â¬ Set.EqOn (g âˆ˜ coe) f E ", "âˆƒ (E : Set â„) (f : â„ â†’ â„), (âˆƒ (g : â„ â†’ â„), Continuous g âˆ§ Set.EqOn f g E) â†’ False ", "âˆƒ (E : Set â„) (f : â„ â†’ â„), ContinuousOn f E âˆ§ âˆ€ (g : â„ â†’ â„), Continuous g â†’ Not (Set.EqOn g f E) ", "âˆƒ (E : Set â„) (f : â„ â†’ â„), IsSubset E â„ âˆ§ ContinuousOn f E âˆ§ âˆ€ (g : â„ â†’ â„), Continuous g â†’ Â¬Set.EqOn g f E ", "âˆƒ (E : Set â„) (f : E â†’ â„) (hf : ContinuousOn f E),\n  âˆ€ (g : â„ â†’ â„), Continuous g â†’ âˆƒ (x : â„), x âˆˆ E âˆ§ g x â‰  f x ", "âˆƒ (E : Set â„) (f : â„ â†’ â„),\n  IsClosed E âˆ§ ContinuousOn f E âˆ§\n    âˆ€ {g : â„ â†’ â„}, Continuous g â†’ Â¬Set.EqOn g f E ", "âˆƒ (E : Set â„) (f : E â†’ â„), ContinuousOn f E âˆ§ âˆ€ (g : â„ â†’ â„), Continuous g â†’ Â¬ Set.EqOn g f E ", "âˆƒ (E : Set â„) (f : â„ â†’ â„),\n  (âˆ€ x âˆˆ E, ContinuousWithinAt f E x) âˆ§\n    (âˆ€ (g : â„ â†’ â„), Continuous g â†’ Â¬Set.EqOn g f E) "]}
{"docString": "Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {R : NNReal} {f : Î± â†’ â„},\\n  (âˆ€áµ (x : Î±) âˆ‚Î¼, |f x| â‰¤ â†‘R) â†’ âˆ€áµ (x : Î±) âˆ‚Î¼, |MeasureTheory.condexp m Î¼ f x| â‰¤ â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\\nexpectation. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E}, DiffContOnCl â„‚ f (Metric.ball c â†‘R) â†’ 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on an open disc of positive radius and is continuous\\non its closure, then it is analytic on the open disc with coefficients of the power series given by\\nCauchy integral formulas. \"}]\n", "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\nexpectation. -/\ntheorem âˆ€ {Î± : Type u_1} {m m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {R : NNReal} {f : Î± â†’ â„},\n  (âˆ€áµ (x : Î±) âˆ‚Î¼, |f x| â‰¤ â†‘R) â†’ âˆ€áµ (x : Î±) âˆ‚Î¼, |MeasureTheory.condexp m Î¼ f x| â‰¤ â†‘R :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E}, DiffContOnCl â„‚ f (Metric.ball c â†‘R) â†’ 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderClosedTopology Î±] [inst_3 : MetricSpace Î±]\n  {f : Î± â†’ â„} {E : Set Î±}, Metric.Bounded E â†’ UniformContinuousOn f E â†’ BddAbove (f '' E) âˆ§ BddBelow (f '' E) ", "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : LinearOrder â„] [inst_2 : OrderTopology â„],\n  IsBounded E â†’ UniformContinuous f â†’ Bounded (f '' E) ", "âˆ€ {E : Set â„} [inst : UniformSpace â„] [inst_1 : UniformAddGroup â„] {f : â„ â†’ â„},\n  Metric.Bounded E â†’ UniformContinuous f â†’ BddAbove (f '' E) âˆ§ BddBelow (f '' E) ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderClosedTopology Î±] [inst_3 : MetricBounded Î±] {f : Î± â†’ â„},\n  UniformContinuous f â†’ Bdd (f '' Metric.BoundedSpace Î±) ", "âˆ€ {E : Set â„} {f : â„ â†’ â„},\n  Metric.Bounded E â†’\n  UniformContinuousOn f E â†’\n  BddAbove (f '' E) âˆ§ BddBelow (f '' E) ", "âˆ€ {E : Set â„} [inst : MetricSpace â„] {f : â„ â†’ â„},\n  Bounded E â†’ UniformContinuous f â†’ BddAbove (f '' E) âˆ§ BddBelow (f '' E) ", "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : MetricSpace â„] [inst_2 : Bounded E] {f : â„ â†’ â„},\n  ContinuousOn f E â†’ Metric.Bounded (f '' E) ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±] [inst_3 : Nonempty Î±]\n  {f : Î± â†’ â„} {E : Set Î±}, IsBounded E â†’ UniformContinuousOn f E â†’ BddRange f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {E : Set Î²},\n  Metric.Bounded E â†’ UniformContinuous f â†’ BddAbove (f '' E) âˆ§ BddBelow (f '' E) ", "âˆ€ {E : Set â„},\n  Bounded E â†’\n  (âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ (Î´ : â„), 0 < Î´ âˆ§ âˆ€ {x y : â„}, x âˆˆ E â†’ y âˆˆ E â†’ abs (x - y) < Î´ â†’ abs (f x - f y) < Îµ) â†’\n  Bounded (f '' E) "]}
{"docString": "Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹}\\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s â†’ x âˆˆ s â†’ Cauchy (Filter.map (fun i => F i x) p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\\na Cauchy sequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\\n  UniformContinuous g â†’ UniformCauchySeqOn F p s â†’ UniformCauchySeqOn (fun n => g âˆ˜ F n) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform Cauchy sequences \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²]\\n  {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : Set Î³},\\n  UniformCauchySeqOn F Filter.atTop s â†”\\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ dist (F m x) (F n x) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\\neventually, the distance between all its elements is uniformly, arbitrarily small \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"}]\n", "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹}\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s â†’ x âˆˆ s â†’ Cauchy (Filter.map (fun i => F i x) p) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\n  UniformContinuous g â†’ UniformCauchySeqOn F p s â†’ UniformCauchySeqOn (fun n => g âˆ˜ F n) p s :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\neventually, the distance between all its elements is uniformly, arbitrarily small -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²]\n  {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : Set Î³},\n  UniformCauchySeqOn F Filter.atTop s â†”\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ dist (F m x) (F n x) < Îµ :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ UniformContinuous f :=\n\n/-- Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ (u : â„• â†’ Î±), CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ {u : â„• â†’ Î±}, CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f : Î± â†’ Î²}, UniformContinuous f â†’ âˆ€ {u : â„• â†’ Î±}, CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {Î³ : Type u_1} {F : Î³ â†’ Î±} {f : Î± â†’ Î²} {p : Filter Î³},\n  CauchySeq F â†’ UniformContinuous f â†’ CauchySeq (f âˆ˜ F) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ (u : â„• â†’ Î±), CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ {u : â„• â†’ Î±}, CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ {u : â„• â†’ Î±}, CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ {u : â„• â†’ Î±}, CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ âˆ€ {u : â„• â†’ Î±}, CauchySeq u â†’ CauchySeq (f âˆ˜ u) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {Î³ : Type u_1}\n  [inst_2 : SemilatticeSup Î³] {f : Î± â†’ Î²} {u : Î³ â†’ Î±},\n  CauchySeq u â†’ UniformContinuous f â†’ CauchySeq (f âˆ˜ u) "]}
{"docString": "Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²}, Monotone f â†’ Function.Surjective f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monotone surjective function with a densely ordered codomain is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X â†’ Y},\\n  Continuous f â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function is monotone with respect to the specialization preorders on the domain and\\nthe codomain. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Mul Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±} {s : Set Î²}\\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1]\\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\\n  StrictMonoOn f s â†’ MonotoneOn g s â†’ StrictMonoOn (fun x => f x * g x) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a strictly monotone function and a monotone function is strictly monotone. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : SemilatticeSup Î²] {f g : Î± â†’ Î²},\\n  Antitone f â†’ Antitone g â†’ Antitone (f âŠ” g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pointwise supremum of two monotone functions is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Mul Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²]\\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1] {f g : Î² â†’ Î±},\\n  Monotone f â†’ StrictMono g â†’ StrictMono fun x => f x * g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a monotone function and a strictly monotone function is strictly monotone. \"}]\n", "prompt_cons": "/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- A monotone surjective function with a densely ordered codomain is continuous. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²}, Monotone f â†’ Function.Surjective f â†’ Continuous f :=\n\n/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X â†’ Y},\n  Continuous f â†’ Monotone f :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- The product of a strictly monotone function and a monotone function is strictly monotone. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Mul Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±} {s : Set Î²}\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1]\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s â†’ MonotoneOn g s â†’ StrictMonoOn (fun x => f x * g x) s :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- Pointwise supremum of two monotone functions is a monotone function. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : SemilatticeSup Î²] {f g : Î± â†’ Î²},\n  Antitone f â†’ Antitone g â†’ Antitone (f âŠ” g) :=\n\n/-- The product of a monotone function and a strictly monotone function is strictly monotone. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Mul Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²]\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1] {f g : Î² â†’ Î±},\n  Monotone f â†’ StrictMono g â†’ StrictMono fun x => f x * g x :=\n\n/-- Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±] [inst_3 : OrderTopology Î±]\n  {f : Î± â†’ Î±}, IsOpenMap f â†’ Continuous f â†’ Monotone f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedRing Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrderedRing Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²],\n  IsOpenMap (f : Î± â†’ Î²) â†’ Continuous f â†’ Monotone f ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±], IsOpenMap (id : Î± â†’ Î±) â†’ Continuous (id : Î± â†’ Î±) â†’ Monotone (id : Î± â†’ Î±) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrderedField Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Monotone f âˆ¨ Antitone f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrderedField Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ IsOpenMap f â†’ Monotone f âˆ¨ Antitone f ", "âˆ€ {f : â„ â†’ â„} [inst : TopologicalSpace â„], Continuous f â†’ IsOpenMap f â†’ Monotone f âˆ¨ Antitone f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] [inst_3 : LinearOrderedField Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²]\n  {f : Î± â†’ Î²}, IsOpenMap f â†’ Continuous f â†’ Monotone f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î±]\n  [inst_3 : OrderTopology Î±] [inst_4 : LinearOrder Î²] [inst_5 : OrderTopology Î²],\n  Continuous fun x => Î± â†’ Î² â†’ IsOpenMap x â†’ Monotone x ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : OrderTopology Î±] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ IsOpenMap f â†’ Monotone f âˆ¨ Antitone f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Monotone f "]}
{"docString": "Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : MetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth Ïƒ-compact manifold with extended distance. Let `K : Î¹ â†’ Set M` be a locally\\nfinite family of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for\\nall `i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and\\n`x âˆˆ K i`, we have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\\n    p âˆ… â†’\\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\\\ U)) â†’\\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a measure is inner regular (using closed or compact sets), then every measurable set of\\nfinite measure can by approximated by a (closed or compact) subset. \"}]\n", "prompt_cons": "/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : MetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `M` be a smooth Ïƒ-compact manifold with extended distance. Let `K : Î¹ â†’ Set M` be a locally\nfinite family of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for\nall `i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and\n`x âˆˆ K i`, we have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ :=\n\n/-- If a measure is inner regular (using closed or compact sets), then every measurable set of\nfinite measure can by approximated by a (closed or compact) subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\n    p âˆ… â†’\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\ U)) â†’\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤ :=\n\n/-- Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {K F : Set Î±},\n  IsCompact K â†’\n    IsClosed F â†’\n      K âˆ© F = âˆ… â†’\n        âˆƒ Î´, âˆ€ (p âˆˆ K) (q âˆˆ F), Î´ < Metric.dist p q ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {K F : Set Î±},\n  IsCompact K â†’\n    IsClosed F â†’\n      Disjoint K F â†’\n        âˆƒ Î´ > 0, âˆ€ p âˆˆ K, âˆ€ q âˆˆ F, Î´ â‰¤ dist p q ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {K F : Set Î±},\n  IsCompact K â†’\n    IsClosed F â†’\n      K âˆ© F = âˆ… â†’\n        âˆƒ Î´ > 0, âˆ€ (p âˆˆ K) (q âˆˆ F), dist p q â‰¥ Î´ ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K â†’\n    IsClosed F â†’\n      K âˆ© F = âˆ… â†’\n        âˆƒ Î´, 0 < Î´ âˆ§ âˆ€ (p : X) (q : X), p âˆˆ K â†’ q âˆˆ F â†’ Î´ â‰¤ Metric.dist p q ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K â†’\n    IsClosed F â†’\n      K âˆ© F = âˆ… â†’\n        âˆƒ Î´, (âˆ€ (p : X), 0 < Î´) âˆ§ âˆ€ (p âˆˆ K) (q âˆˆ F), Metric.dist p q > Î´ ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K â†’\n    IsClosed F â†’\n      Disjoint K F â†’ âˆƒ Î´, 0 < Î´ âˆ§ âˆ€ (p : X) (q : X), p âˆˆ K â†’ q âˆˆ F â†’ Î´ < Metric.dist p q ", "âˆ€ {X : Type u} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K â†’\n    IsClosed F â†’\n      K âˆ© F = âˆ… â†’\n        âˆƒ Î´, 0 < Î´ âˆ§ âˆ€ (p : X), p âˆˆ K â†’ âˆ€ (q : X), q âˆˆ F â†’ Î´ < Metric.dist p q ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K â†’\n    IsClosed F â†’\n      (K âˆ© F = âˆ…) â†’\n        âˆƒ Î´ > 0, âˆ€ (p : X), p âˆˆ K â†’ âˆ€ (q : X), q âˆˆ F â†’ Î´ < Metric.dist p q ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {K F : Set Î±},\n  IsCompact K â†’\n    IsClosed F â†’\n      Disjoint K F â†’\n        âˆƒ Î´, 0 < Î´ âˆ§ âˆ€ (p âˆˆ K) (q âˆˆ F), Î´ < Metric.dist p q ", "âˆ€ {X : Type u} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K â†’\n    IsClosed F â†’\n      K âˆ© F = âˆ… â†’\n        âˆƒ Î´, 0 < Î´ âˆ§ âˆ€ (p âˆˆ K) (q âˆˆ F), Î´ â‰¤ dist p q "]}
{"docString": "Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant.", "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±},\\n  ContractingWith K f â†’\\n    âˆ€ (g : Î± â†’ Î±) {x y : Î±},\\n      Function.IsFixedPt f x â†’\\n        Function.IsFixedPt g y â†’ âˆ€ {C : â„}, (âˆ€ (z : Î±), dist (f z) (g z) â‰¤ C) â†’ dist x y â‰¤ C / (1 - â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y â‰¤ C / (1 - K)`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C < deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C < f'`, then `f` grows faster than\\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"}]\n", "prompt_cons": "/-- Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y â‰¤ C / (1 - K)`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±},\n  ContractingWith K f â†’\n    âˆ€ (g : Î± â†’ Î±) {x y : Î±},\n      Function.IsFixedPt f x â†’\n        Function.IsFixedPt g y â†’ âˆ€ {C : â„}, (âˆ€ (z : Î±), dist (f z) (g z) â‰¤ C) â†’ dist x y â‰¤ C / (1 - â†‘K) :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C < f'`, then `f` grows faster than\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C < deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x < y â†’ C * (y - x) < f y - f x :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ f y - f x < C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant. -/\ntheorem", "choices": ["âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y)^2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ x y : â„, abs (f x - f y) â‰¤ (x - y) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y) ^ 2) â†’\n  âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y)^2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y)^2) â†’ âˆ€ (x y : â„), f x = f y ", "forall {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y)^2) â†’ âˆ€ (x y : â„), f x = f y ", "forall {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y)^2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f x - f y) â‰¤ (x - y) ^ 2) â†’ âˆ€ (x y : â„), f x = f y "]}
{"docString": "Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\\n            UpperSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\\n            LowerSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼]\\n  (f : MeasureTheory.SimpleFunc Î± NNReal),\\n  âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰  âŠ¤ â†’\\n    âˆ€ {Îµ : ENNReal},\\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), g x â‰¤ â†‘f x) âˆ§ UpperSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `â„â‰¥0`, there exists an upper semicontinuous\\nfunction `g â‰¤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {A : E â†’L[â„] E} {Î´ : NNReal},\\n  ApproximatesLinearOn f A s Î´ â†’\\n    MeasurableSet s â†’\\n      âˆ€ (f' : E â†’ E â†’L[â„] E),\\n        (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\\n          âˆ€áµ (x : E) âˆ‚MeasureTheory.Measure.restrict Î¼ s, â€–f' x - Aâ€–â‚Š â‰¤ Î´\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `Î´`,\\nthen at almost every `x` in `s` one has `â€–f' x - Aâ€– â‰¤ Î´`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ NNReal),\\n  Measurable f â†’\\n    âˆ€ {Îµ : ENNReal},\\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a measurable function `f` with values in `â„â‰¥0` in a sigma-finite space, there exists a\\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] (f : MeasureTheory.SimpleFunc Î± NNReal)\\n  {Îµ : ENNReal},\\n  Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `â„â‰¥0`, there exists a lower semicontinuous\\nfunction `g â‰¥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ NNReal),\\n  AEMeasurable f â†’\\n    âˆ€ {Îµ : ENNReal},\\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an almost everywhere measurable function `f` with values in `â„â‰¥0` in a sigma-finite space,\\nthere exists a lower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n", "prompt_cons": "/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼ :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\n            UpperSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\n            LowerSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Given a simple function `f` with values in `â„â‰¥0`, there exists an upper semicontinuous\nfunction `g â‰¤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼]\n  (f : MeasureTheory.SimpleFunc Î± NNReal),\n  âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰  âŠ¤ â†’\n    âˆ€ {Îµ : ENNReal},\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), g x â‰¤ â†‘f x) âˆ§ UpperSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ :=\n\n/-- If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `Î´`,\nthen at almost every `x` in `s` one has `â€–f' x - Aâ€– â‰¤ Î´`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {A : E â†’L[â„] E} {Î´ : NNReal},\n  ApproximatesLinearOn f A s Î´ â†’\n    MeasurableSet s â†’\n      âˆ€ (f' : E â†’ E â†’L[â„] E),\n        (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\n          âˆ€áµ (x : E) âˆ‚MeasureTheory.Measure.restrict Î¼ s, â€–f' x - Aâ€–â‚Š â‰¤ Î´ :=\n\n/-- Given a measurable function `f` with values in `â„â‰¥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ NNReal),\n  Measurable f â†’\n    âˆ€ {Îµ : ENNReal},\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ :=\n\n/-- Given a simple function `f` with values in `â„â‰¥0`, there exists a lower semicontinuous\nfunction `g â‰¥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] (f : MeasureTheory.SimpleFunc Î± NNReal)\n  {Îµ : ENNReal},\n  Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ + Îµ :=\n\n/-- Given an almost everywhere measurable function `f` with values in `â„â‰¥0` in a sigma-finite space,\nthere exists a lower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ NNReal),\n  AEMeasurable f â†’\n    âˆ€ {Îµ : ENNReal},\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough. -/\ntheorem", "choices": ["âˆ€ {g : â„ â†’ â„} {M Îµ : â„} (hM : 0 â‰¤ M),\n  (âˆ€ (x : â„), âˆƒ (y : â„), HasDerivAt g y x âˆ§ abs y â‰¤ M) â†’\n    0 < Îµ â†’ Îµ < 1 / M â†’\n      Function.Injective (Î» x, x + Îµ * g x) ", "âˆ€ {g : â„ â†’ â„} {M : â„}, BoundedDerivative g M â†’\n  âˆ€ {Îµ : â„}, 0 < Îµ â†’ Îµ < 1 / M â†’\n    Function.Injective (Î» x : â„, x + Îµ * g x) ", "âˆ€ {g : â„ â†’ â„} {M : â„} (Îµ : â„),\n  (âˆ€ (x : â„), âˆ¥deriv g xâˆ¥ â‰¤ M) â†’\n  0 < Îµ â†’ Îµ < 1 / M â†’\n  injective (Î» x, x + Îµ * g x) ", "âˆ€ (g : â„ â†’ â„) (M : â„) (Îµ : â„),\n  (âˆ€ (x : â„), âˆƒ (g' : â„), HasDerivAt g g' x âˆ§ abs g' â‰¤ M) â†’\n  0 < Îµ â†’ Îµ < 1 / M â†’\n  Function.Injective (Î» x, x + Îµ * g x) ", "âˆ€ {M : â„} (g : â„ â†’ â„) {Îµ : â„},\n  0 < Îµ â†’\n  (âˆ€ (x : â„), DifferentiableAt â„ g x âˆ§ âˆ¥deriv g xâˆ¥ â‰¤ M) â†’\n  (âˆ€ (x y : â„), x â‰  y â†’ Îµ * (g x - g y) + (x - y) â‰  0) ", "forall (g : â„ â†’ â„) (M : â„) (Îµ : â„), 0 < Îµ â†’ (âˆ€ (x : â„), abs (deriv g x) â‰¤ M) â†’ (âˆ€ (x y : â„), x â‰  y â†’ x + Îµ * g x â‰  y + Îµ * g y) ", "âˆ€ {g : â„ â†’ â„} {M : â„},\n  (âˆ€ (x : â„), âˆƒ (C : â„â‰¥0), HasDerivAt g (C : â„) x âˆ§ (C : â„) â‰¤ M) â†’\n  âˆ€ {Îµ : â„}, 0 < Îµ â†’ Îµ * M < 1 â†’ Injective (Î» (x : â„), x + Îµ * g x) ", "âˆ€ {g : â„ â†’ â„} {M : â„} {Î´ : â„},\n  (âˆ€ (x : â„), âˆ¥Derivative.derivative g xâˆ¥ â‰¤ M) â†’\n    0 < Î´ â†’\n      Î´ â‰¤ (1 / (1 + M)) â†’\n        Function.Injective (Î» x, x + Î´ * g x) ", "âˆ€ {M Îµ : â„} (g : â„ â†’ â„),\n  (âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥deriv g xâˆ¥ â‰¤ C) â†’\n    0 < Îµ â†’\n      Îµ < 1 / M â†’\n        Function.Injective (Î» (x : â„), x + Îµ * g x) ", "âˆ€ {g : â„ â†’ â„} {M : â„} (hg : âˆ€ x, âˆ¥deriv g xâˆ¥ â‰¤ M) {Îµ : â„} (hÎµM : 0 < Îµ âˆ§ Îµ * M < 1),\n  Function.Injective (Î» x, x + Îµ * g x) "]}
{"docString": "Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {T : â„} {g : â„ â†’ â„},\\n  Function.Periodic g T â†’\\n    (âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.volume tâ‚ tâ‚‚) â†’\\n      0 < âˆ« (x : â„) in 0 ..T, g x â†’ 0 < T â†’ Filter.Tendsto (fun t => âˆ« (x : â„) in 0 ..t, g x) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : â„ â†’ â„` is periodic with period `T > 0` and `0 < âˆ« x in 0..T, g x`, then\\n`t â†¦ âˆ« x in 0..t, g x` tends to `âˆ` as `t` tends to `âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â†’L[ğ•œ] F} {x : E} {s : Set E},\\n  HasFDerivWithinAt f f' s x â†’\\n    âˆ€ {Î± : Type u_4} (l : Filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E},\\n      (âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) â†’\\n        Filter.Tendsto (fun n => â€–c nâ€–) l Filter.atTop â†’\\n          Filter.Tendsto (fun n => c n â€¢ d n) l (nhds v) â†’\\n            Filter.Tendsto (fun n => c n â€¢ (f (x + d n) - f x)) l (nhds (â†‘f' v))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\\ntangent cone related discussions. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} {g : â„ â†’ â„},\\n  Function.Periodic g T â†’\\n    (âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.volume tâ‚ tâ‚‚) â†’\\n      0 < âˆ« (x : â„) in 0 ..T, g x â†’ 0 < T â†’ Filter.Tendsto (fun t => âˆ« (x : â„) in 0 ..t, g x) Filter.atBot Filter.atBot\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : â„ â†’ â„` is periodic with period `T > 0` and `0 < âˆ« x in 0..T, g x`, then\\n`t â†¦ âˆ« x in 0..t, g x` tends to `-âˆ` as `t` tends to `-âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} {g : â„ â†’ â„},\\n  Function.Periodic g T â†’\\n    (âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.volume tâ‚ tâ‚‚) â†’\\n      (âˆ€ (x : â„), 0 < g x) â†’ 0 < T â†’ Filter.Tendsto (fun t => âˆ« (x : â„) in 0 ..t, g x) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : â„ â†’ â„` is periodic with period `T > 0` and `âˆ€ x, 0 < g x`, then `t â†¦ âˆ« x in 0..t, g x`\\ntends to `âˆ` as `t` tends to `âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’\\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. \"}]\n", "prompt_cons": "/-- If `g : â„ â†’ â„` is periodic with period `T > 0` and `0 < âˆ« x in 0..T, g x`, then\n`t â†¦ âˆ« x in 0..t, g x` tends to `âˆ` as `t` tends to `âˆ`. -/\ntheorem âˆ€ {T : â„} {g : â„ â†’ â„},\n  Function.Periodic g T â†’\n    (âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.volume tâ‚ tâ‚‚) â†’\n      0 < âˆ« (x : â„) in 0 ..T, g x â†’ 0 < T â†’ Filter.Tendsto (fun t => âˆ« (x : â„) in 0 ..t, g x) Filter.atTop Filter.atTop :=\n\n/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â†’L[ğ•œ] F} {x : E} {s : Set E},\n  HasFDerivWithinAt f f' s x â†’\n    âˆ€ {Î± : Type u_4} (l : Filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E},\n      (âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) â†’\n        Filter.Tendsto (fun n => â€–c nâ€–) l Filter.atTop â†’\n          Filter.Tendsto (fun n => c n â€¢ d n) l (nhds v) â†’\n            Filter.Tendsto (fun n => c n â€¢ (f (x + d n) - f x)) l (nhds (â†‘f' v)) :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `g : â„ â†’ â„` is periodic with period `T > 0` and `0 < âˆ« x in 0..T, g x`, then\n`t â†¦ âˆ« x in 0..t, g x` tends to `-âˆ` as `t` tends to `-âˆ`. -/\ntheorem âˆ€ {T : â„} {g : â„ â†’ â„},\n  Function.Periodic g T â†’\n    (âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.volume tâ‚ tâ‚‚) â†’\n      0 < âˆ« (x : â„) in 0 ..T, g x â†’ 0 < T â†’ Filter.Tendsto (fun t => âˆ« (x : â„) in 0 ..t, g x) Filter.atBot Filter.atBot :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- If `g : â„ â†’ â„` is periodic with period `T > 0` and `âˆ€ x, 0 < g x`, then `t â†¦ âˆ« x in 0..t, g x`\ntends to `âˆ` as `t` tends to `âˆ`. -/\ntheorem âˆ€ {T : â„} {g : â„ â†’ â„},\n  Function.Periodic g T â†’\n    (âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.volume tâ‚ tâ‚‚) â†’\n      (âˆ€ (x : â„), 0 < g x) â†’ 0 < T â†’ Filter.Tendsto (fun t => âˆ« (x : â„) in 0 ..t, g x) Filter.atTop Filter.atTop :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n\n/-- Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. -/\ntheorem", "choices": ["âˆ€ {f : â„ â†’ â„}, (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’ Filter.Tendsto (deriv f) Filter.atTop (nhds 0) â†’\n  Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (x : â„), 0 < x â†’ DifferentiableAt â„ f x) â†’\n    Filter.Tendsto (deriv f) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆ€ (x : â„), 0 < x â†’ DifferentiableAt â„ f x) â†’\n    Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’\n    Filter.Tendsto (fun x => Fderiv â„ f x) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’\n  Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) â†’\n    Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆ€ (x : â„), 0 < x â†’ DifferentiableAt â„ f x) â†’\n    Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆ€ (x : â„), 0 < x â†’ DifferentiableAt â„ f x) â†’\n    Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’\n    Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {xâ‚ xâ‚‚ : â„},\n  (âˆ€ (x : â„), 0 < x â†’ HasDerivAt f (fderiv â„ f x) x) â†’\n    Filter.Tendsto (fderiv â„ f) Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [Asymptotics.IsOâ‚“ â„ ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â†’L[ğ•œ] F},\n  (âˆ€ (x : E), x > 0 â†’ HasDerivAt f (f' x) x) â†’\n    Filter.Tendsto f' Filter.atTop (nhds 0) â†’\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) "]}
{"docString": "Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’\\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {l : Filter Î¹} {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ]\\n  [inst_2 : NormedSpace ğ•œ E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] {f : Î¹ â†’ E â†’ G}\\n  {g : E â†’ G} {f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G} {g' : E â†’ E â†’L[ğ•œ] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) â†’\\n    (âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) â†’\\n      (âˆ€á¶  (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) â†’\\n        TendstoUniformlyOnFilter (fun n y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’\\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends locally uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {x a c d : â„} {l : Filter â„},\\n  l â‰¤ nhdsWithin x {x}á¶œ â†’\\n    Filter.Tendsto (fun y => (f y - d) / (y - x)) l (nhds a) â†’\\n      Filter.Tendsto (fun y => y + c * (y - x) ^ 2) l l â†’\\n        Filter.Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(f y - f x) / (y - x)` converges to a limit as `y` tends to `x`, then the same goes if\\n`y` is shifted a little bit, i.e., `f (y + (y-x)^2) - f x) / (y - x)` converges to the same limit.\\nThis lemma contains a slightly more general version of this statement (where one considers\\nconvergence along some subfilter, typically `ğ“[<] x` or `ğ“[>] x`) tailored to the application\\nto almost everywhere differentiability of monotone functions. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\\n  (âˆ€ (Z : C) (g : Y âŸ¶ Z), CategoryTheory.CategoryStruct.comp f g = 0 â†’ g = 0) â†’ CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f â‰« g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’\\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"}]\n", "prompt_cons": "/-- If `Fâ‚™` tends uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` -/\ntheorem âˆ€ {Î¹ : Type u_3} {l : Filter Î¹} {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ]\n  [inst_2 : NormedSpace ğ•œ E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] {f : Î¹ â†’ E â†’ G}\n  {g : E â†’ G} {f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G} {g' : E â†’ E â†’L[ğ•œ] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) â†’\n    (âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) â†’\n      (âˆ€á¶  (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) â†’\n        TendstoUniformlyOnFilter (fun n y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l\n          (nhds x) :=\n\n/-- If `Fâ‚™` tends locally uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- If `(f y - f x) / (y - x)` converges to a limit as `y` tends to `x`, then the same goes if\n`y` is shifted a little bit, i.e., `f (y + (y-x)^2) - f x) / (y - x)` converges to the same limit.\nThis lemma contains a slightly more general version of this statement (where one considers\nconvergence along some subfilter, typically `ğ“[<] x` or `ğ“[>] x`) tailored to the application\nto almost everywhere differentiability of monotone functions. -/\ntheorem âˆ€ {f : â„ â†’ â„} {x a c d : â„} {l : Filter â„},\n  l â‰¤ nhdsWithin x {x}á¶œ â†’\n    Filter.Tendsto (fun y => (f y - d) / (y - x)) l (nhds a) â†’\n      Filter.Tendsto (fun y => y + c * (y - x) ^ 2) l l â†’\n        Filter.Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (nhds a) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If `f â‰« g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\n  (âˆ€ (Z : C) (g : Y âŸ¶ Z), CategoryTheory.CategoryStruct.comp f g = 0 â†’ g = 0) â†’ CategoryTheory.Epi f :=\n\n/-- If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$ -/\ntheorem", "choices": ["forall {f g : â„ â†’ â„} {x : â„},\n  DifferentiableAt â„ f x â†’\n    DifferentiableAt â„ g x â†’\n      f x = 0 â†’ g x = 0 â†’ deriv â„ g x â‰  0 â†’\n        Filter.Tendsto (Î» t => f t / g t) (nhds x) (nhds (deriv â„ f x / deriv â„ g x)) ", "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedGroup E] [inst_2 : NormedSpace ğ•œ E]\n  {F : Type u_3} [inst_3 : NormedGroup F] [inst_4 : NormedSpace ğ•œ F] {f g : E â†’ F} {f' g' : E â†’L[ğ•œ] F} {x : E},\n  HasDerivAt f f' x â†’\n    HasDerivAt g g' x â†’ g' â‰  0 â†’ f x = 0 â†’ g x = 0 â†’\n      Filter.Tendsto (Î» t, (f t) / (g t)) (ğ“[{x}á¶œ] x) (nhds (f' x / g' x)) ", "âˆ€ {f g : â„ â†’ â„} {f' g' x : â„},\n  HasDerivAt f f' x â†’\n  HasDerivAt g g' x â†’\n  g' â‰  0 â†’\n  f x = 0 â†’\n  g x = 0 â†’\n  Filter.Tendsto (Î» t => f t / g t) (nhdsWithin x ({x}á¶œ)) (nhds (f' / g')) ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ] [inst_2 : NormedSpace ğ•œ E] {f g : E â†’ ğ•œ}\n  {x : E} {f' g' : E â†’L[ğ•œ] ğ•œ},\n  HasDerivAt f f' x â†’\n    HasDerivAt g g' x â†’ g' x â‰  0 â†’ f x = 0 â†’ g x = 0 â†’\n      Filter.Tendsto (fun t => f t / g t) (nhdsWithin x {x}á¶œ) (nhds (f' x / g' x)) ", "âˆ€ {ğ•œ : Type u} [inst : NondiscreteNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {x : ğ•œ},\n  DifferentiableAt ğ•œ f x â†’\n    DifferentiableAt ğ•œ g x â†’\n      f x = 0 â†’ g x = 0 â†’ DerivativeAt ğ•œ g x â‰  0 â†’\n        Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (DerivativeAt ğ•œ f x / DerivativeAt ğ•œ g x)) ", "âˆ€ {ğ•œ : Type u} [inst : NondiscreteNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' g' x : ğ•œ},\n  HasDerivAt f f' x â†’ HasDerivAt g g' x â†’ g' â‰  0 â†’ f x = 0 â†’ g x = 0 â†’\n    Filter.Tendsto (fun t => f t / g t) (ğ“[{x}á¶œ] x) (nhds (f' / g')) ", "âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedGroup E] [inst_1 : TopologicalSpace E] [inst_2 : NormedGroup F] {ğ•œ : Type u_3}\n  [inst_3 : NondiscreteNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ F] {f g : E â†’ F} {x : E}\n  {f' g' : F},\n  DifferentiableAt ğ•œ f x â†’\n    DifferentiableAt ğ•œ g x â†’\n      f x = 0 â†’\n        g x = 0 â†’ g' â‰  0 â†’ HasDerivAt f f' x â†’ HasDerivAt g g' x â†’\n          Filter.Tendsto (fun t => f t / g t) (ğ“[{x}á¶œ] x) (nhds (f' / g')) ", "âˆ€ {E : Type u} {F : Type v} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„ F] {x : â„} {f g : â„ â†’ E} {f' g' : E},\n  DifferentiableAt â„ f x â†’\n    DifferentiableAt â„ g x â†’ g' â‰  0 â†’ f x = g x â†’ f' = deriv f x â†’ g' = deriv g x â†’\n      Filter.Tendsto (fun t => f t / g t) (nhdsWithin x {x}á¶œ) (nhds (f' / g')) ", "âˆ€ {E : Type u_1} {ğ•œ : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : IsROrC ğ•œ] [inst_2 : NormedSpace ğ•œ E] {f g : E â†’ ğ•œ} {x : E},\n  HasDerivAt f (deriv f x) x â†’\n    HasDerivAt g (deriv g x) x â†’\n      g x = 0 â†’ f x = 0 â†’ deriv g x â‰  0 â†’\n        Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (deriv f x / deriv g x)) ", "âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedGroup E] [inst_1 : NormedGroup F] [inst_2 : NontriviallyNormedField â„]\n  [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace â„ F] {x : â„} {fâ‚€ gâ‚€ : â„ â†’ E} {fâ‚ gâ‚ : E â†’ F},\n  HasDerivAt fâ‚€ (fâ‚ x) x â†’\n    HasDerivAt gâ‚€ (gâ‚ x) x â†’ fâ‚€ x = 0 â†’ gâ‚€ x = 0 â†’ gâ‚ x â‰  0 â†’\n      Filter.Tendsto (fun t => fâ‚ (fâ‚€ t) / gâ‚ (gâ‚€ t)) (nhds x) (nhds (fâ‚ (fâ‚€ x) / gâ‚ (gâ‚€ x))) "]}
{"docString": "Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  ConcaveOn ğ•œ s f â†’ âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ ğ•œ` is concave, then for any three points `x < y < z` the slope of the secant line of\\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  StrictConcaveOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is strictly concave iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  StrictConcaveOn ğ•œ s f â†’ âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ ğ•œ` is strictly concave, then for any three points `x < y < z` the slope of the\\nsecant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f g : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      DiffContOnCl â„‚ g (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n        (âˆƒ c,\\n            c < 2 âˆ§\\n              âˆƒ B,\\n                g =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n                  rexp (B * â†‘Complex.abs z ^ c)) â†’\\n          (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) â†’\\n            (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = g (â†‘x * Complex.I)) â†’ Set.EqOn f g {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f g : â„‚ â†’ E` be functions such that\\n\\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\\n* `â€–f zâ€–` and `â€–g zâ€–` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\\n  quadrant for some `A`, `B`, and `c < 2`;\\n* `f` is equal to `g` on the boundary of the third quadrant.\\n\\nThen `f` is equal to `g` on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  ConcaveOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is concave iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  StrictConvexOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is strictly convex iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"}]\n", "prompt_cons": "/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- If `f : ğ•œ â†’ ğ•œ` is concave, then for any three points `x < y < z` the slope of the secant line of\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  ConcaveOn ğ•œ s f â†’ âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x) :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  StrictConcaveOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C :=\n\n/-- If `f : ğ•œ â†’ ğ•œ` is strictly concave, then for any three points `x < y < z` the slope of the\nsecant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  StrictConcaveOn ğ•œ s f â†’ âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f g : â„‚ â†’ E` be functions such that\n\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\n* `â€–f zâ€–` and `â€–g zâ€–` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the third quadrant.\n\nThen `f` is equal to `g` on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f g : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      DiffContOnCl â„‚ g (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n        (âˆƒ c,\n            c < 2 âˆ§\n              âˆƒ B,\n                g =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n                  rexp (B * â†‘Complex.abs z ^ c)) â†’\n          (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) â†’\n            (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = g (â†‘x * Complex.I)) â†’ Set.EqOn f g {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is concave iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  ConcaveOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is strictly convex iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  StrictConvexOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$. -/\ntheorem", "choices": ["âˆ€ {f : â„ â†’ â„},\n  (âˆ€ x, DifferentiableAt â„ f x) â†’\n    (âˆ€ x, TimesContDiffAt â„ (3 - 1) (deriv f) x) â†’ f (-1) = 0 â†’ f 0 = 0 â†’ f 1 = 1 â†’ deriv f 0 = 0 â†’ âˆƒ x, -1 < x âˆ§ x < 1 âˆ§ 3 â‰¤ deriv^[3] f x ", "âˆƒ (x : â„), -1 < x âˆ§ x < 1 âˆ§ (deriv^[3] f x) â‰¥ 3 ", "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Icc (-1) 1) â†’\n    DifferentiableOn â„ f (Set.Ioo (-1) 1) â†’\n      f (-1) = 0 â†’ f 0 = 0 â†’ f 1 = 1 â†’ deriv f 0 = 0 â†’\n        (âˆƒ x âˆˆ Set.Ioo (-1) 1, deriv^[3] f x â‰¥ 3) ", "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Icc (-1) 1) â†’\n    DifferentiableOn â„ f (Set.Ioo (-1) 1) â†’\n      TimesContDiffOn â„ 3 f (Set.Ioo (-1) 1) â†’\n        f (-1) = 0 â†’ f 0 = 0 â†’ f 1 = 1 â†’ deriv f 0 = 0 â†’ âˆƒ x, x âˆˆ Set.Ioo (-1) 1 âˆ§ (deriv^[3] f) x â‰¥ 3 ", "âˆƒ (x : â„), x âˆˆ Ioo (-1) 1 âˆ§ HasDerivAt f (3 : â„) x ", "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„[3] f (Set.Icc (-1) 1) â†’\n    f (-1) = 0 â†’ f 0 = 0 â†’ f 1 = 1 â†’ deriv f 0 = 0 â†’\n      (âˆƒ x âˆˆ Set.Ioo (-1) 1, (deriv^[3] f) x â‰¥ 3) ", "âˆƒ (x : â„), x âˆˆ Ioo (-1 : â„) 1 âˆ§ 3 â‰¤ deriv^[3] (fun x => f x) x ", "âˆƒ (x : â„), -1 < x âˆ§ x < 1 âˆ§ deriv^[3] f x â‰¥ 3 ", "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (set.interval (-1) 1) â†’\n    DifferentiableOn â„ f (interior (set.interval (-1) 1)) â†’\n      f (-1) = 0 â†’ f 0 = 0 â†’ f 1 = 1 â†’ deriv f 0 = 0 â†’\n        (âˆƒ x âˆˆ interior (set.interval (-1) 1), 3 â‰¤ deriv^[3] f x) ", "âˆƒ (x : â„), -1 < x âˆ§ x < 1 âˆ§ (fun x => â„) 3 â‰¤ fderiv â„ (fderiv â„ (fderiv f)) x "]}
{"docString": "Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], affineSpan k âˆ… = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"The span of the empty set is `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  Â¬Continuous â†‘CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite type with cofinite topology is an irreducible topological space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, Set.Nonempty s â†’ EMetric.hausdorffEdist s âˆ… = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The Haudorff edistance to the empty set is infinite \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"}]\n", "prompt_cons": "/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤ :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\n  TendstoUniformlyOn F f p âˆ… :=\n\n/-- The span of the empty set is `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k âˆ… = âŠ¥ :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  Â¬Continuous â†‘CofiniteTopology.of.symm :=\n\n/-- An infinite type with cofinite topology is an irreducible topological space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±) :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- The Haudorff edistance to the empty set is infinite -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, Set.Nonempty s â†’ EMetric.hausdorffEdist s âˆ… = âŠ¤ :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$. -/\ntheorem", "choices": ["âˆ€ {X : Type u_1} [inst : Infinite X], Â¬TopologicalSpace.generateFrom {U : Set X | X - U = âˆ… âˆ¨ Infinite (X - U) âˆ¨ X - U = X} = âŠ¤ ", "âˆ€ {X : Type u_1} [inst : Infinite X], Â¬TopologicalSpace.IsTopologicalBasis {T : TopologicalSpace.Opens X | T = âŠ¥ âˆ¨ T = âŠ¤ âˆ¨ Set.Finite (X - â†‘T)} ", "âˆ€ {X : Type u_1} [inst : Infinite X],\n  Â¬ TopologicalSpace.IsTopologicalBasis {U : TopologicalSpace.Opens X | U = âŠ¥ âˆ¨ â†‘Uá¶œ = âŠ¤ âˆ¨ Set.Infinite â†‘Uá¶œ} ", "âˆ€ {X : Type u_1} [inst : Infinite X], Â¬TopologicalSpace.IsTopologicalBasis (SetOf (fun s => s = âˆ… âˆ¨ Set.Infinite (X \\ s) âˆ¨ s = Set.univ)) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], âˆƒ U V : Set X, \n  (Set.Infinite (X \\ U) âˆ¨ U = âˆ… âˆ¨ U = X) âˆ§ (Set.Infinite (X \\ V) âˆ¨ V = âˆ… âˆ¨ V = X) âˆ§\n  Â¬(Set.Infinite (X \\ (U âˆ© V)) âˆ¨ (U âˆ© V) = âˆ… âˆ¨ (U âˆ© V) = X) ", "âˆƒ {X : Type u_1} [inst : TopologicalSpace X],\n  let T_inf ", "âˆ€ {X : Type u_1} (T_inf : TopologicalSpace X),\n  (âˆ€ (U : Set X), U = âˆ… âˆ¨ U = Set.univ âˆ¨ Set.Infinite (Set.á¶œ U)) â†’ Â¬ TopologicalSpace.IsTopologicalBasis (BasisOf T_inf) ", "âˆ€ {X : Type u_1} [inst : Infinite X], Â¬(TopologicalSpace X ", "âˆƒ {X : Type u_1} [inst : Infinite X], Â¬ TopologicalSpace.IsTopologicalBasis\n  {U : TopologicalSpace.Opens X | Set.Finite (SetOf (Î» x, Â¬ x âˆˆ U)) âˆ¨ U = âŠ¥ âˆ¨ U = âŠ¤} ", "âˆƒ {X : Type u_1} (T_inf : TopologicalSpace X), Â¬TopologicalSpace.IsTopologicalBasis (Î» (U : Set X), Set.Finite (X \\ U) âˆ¨ U = âˆ… âˆ¨ U = X) "]}
{"docString": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, Setoid.IsPartition c â†’ âˆ€ {s : Set Î±}, s âˆˆ c â†’ Set.Nonempty s\",\n  \"isProp\": true,\n  \"docString\": \"A partition of `Î±` does not contain the empty set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  Â¬Continuous â†‘CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  [inst_3 : Nonempty Î¹] [inst_4 : TopologicalSpace E] {p : SeminormFamily ğ•œ E Î¹},\\n  WithSeminorms p â†’ ((âˆ€ (x : E), x â‰  0 â†’ âˆƒ i, â†‘(p i) x â‰  0) â†” T1Space E)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family of seminorms is separating iff it induces a Tâ‚ topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"}]\n", "prompt_cons": "/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- A partition of `Î±` does not contain the empty set. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, Setoid.IsPartition c â†’ âˆ€ {s : Set Î±}, s âˆˆ c â†’ Set.Nonempty s :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  Â¬Continuous â†‘CofiniteTopology.of.symm :=\n\n/-- A family of seminorms is separating iff it induces a Tâ‚ topology. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : Nonempty Î¹] [inst_4 : TopologicalSpace E] {p : SeminormFamily ğ•œ E Î¹},\n  WithSeminorms p â†’ ((âˆ€ (x : E), x â‰  0 â†’ âˆƒ i, â†‘(p i) x â‰  0) â†” T1Space E) :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$. -/\ntheorem", "choices": ["This statement is not a theorem, it is just an observation. Theorems in Lean are written for statements that can be proved, while this statement is providing an example that the union of a family of topologies is not necessarily a topology. This can be shown by constructing a counterexample, but it is not a theorem in the formal sense.", "Sorry, but I cannot create a theorem based on the given statement. Theorems in Lean are written to prove specific mathematical statements, and the provided statement is not a precise mathematical claim. Please provide a clear and specific mathematical statement for me to encode into Lean.", "This is not a theorem, as it is a statement about the non-existence of a specific structure, so it cannot be translated to Lean code.", "Sorry, I can only provide translations to Lean code for examples given in natural language. Please provide an example in natural language, and I will do my best to translate it into Lean code for you.", "This statement is not a theorem, as it is not always true that the union of a family of topologies is not a topology. The statement cannot be translated into Lean Theorem Prover code as a theorem. Instead, consider providing a counterexample or a different statement to be translated.", "This statement is not a valid theorem, as it is not asserting a mathematical property but rather giving an example or counterexample. Lean Theorem Prover is designed for proving theorems and not providing examples or counterexamples.", "Existential quantifiers are not allowed in theorems. Please provide a different statement.", "There is no general theorem to prove this statement, as it depends on the specific family of topologies being considered. However, one can provide a counterexample that demonstrates that the union of a family of topologies does not necessarily form a topology on the given type.\n\nFor example, consider the following two topologies on â„•:\n\nTâ‚ ", "This is not a valid theorem statement, as it does not follow the pattern of the given examples. Please provide a theorem statement that follows the pattern of the given examples.", "This is not a theorem, as it is a statement about a counterexample. Theorems in Lean must have provable statements."]}
{"docString": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module ğ•œ E] [inst_3 : Nonempty Î¹] [inst_4 : Countable Î¹] {p : SeminormFamily ğ•œ E Î¹}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p â†’ TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\\n  ContinuousMap.compactOpen =\\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\\n  (F : Î¹ â†’ C(Î±, Î²)),\\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"}]\n", "prompt_cons": "/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ğ•œ E] [inst_3 : Nonempty Î¹] [inst_4 : Countable Î¹] {p : SeminormFamily ğ•œ E Î¹}\n  [inst_5 : TopologicalSpace E], WithSeminorms p â†’ TopologicalSpace.FirstCountableTopology E :=\n\n/-- The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  ContinuousMap.compactOpen =\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\n  (F : Î¹ â†’ C(Î±, Î²)),\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$. -/\ntheorem", "choices": ["âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (t : TopologicalSpace X), âˆ€ (i : Î¹), t â‰¤ T i ", "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace Î±),\n  âˆƒ (T' : TopologicalSpace Î±), (âˆ€ (i : Î¹), T' â‰¤ T i) âˆ§ âˆ€ (T'' : TopologicalSpace Î±), (âˆ€ (i : Î¹), T'' â‰¤ T i) â†’ T'' â‰¤ T' ", "âˆ€ {Î± : Type u} {Î¹ : Type v} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [Nonempty Î¹],\n  âˆƒ (t : TopologicalSpace Î±), âˆ€ (i : Î¹), t â‰¤ inst i âˆ§ âˆ€ (t' : TopologicalSpace Î±), (âˆ€ (i : Î¹), t' â‰¤ inst i) â†’ t' â‰¤ t ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace Î±),\n  âˆƒ (T' : TopologicalSpace Î±), (âˆ€ (i : Î¹), T' â‰¤ T i) âˆ§ âˆ€ (Z : TopologicalSpace Î±), (âˆ€ (i : Î¹), Z â‰¤ T i) â†’ Z â‰¤ T' ", "âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ Tsup, TopologicalSpace.Sup T âˆ§ âˆ€ (i : Î¹), Tsup â‰¤ T i ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace Î±), âˆƒ!t, âˆ€ (i : Î¹), t â‰¤ T i ", "âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), Tâ‚€ â‰¤ T i ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : Nonempty Î¹] {T : Î¹ â†’ TopologicalSpace Î±],\n  âˆƒ! (t : TopologicalSpace Î±), âˆ€ (i : Î¹), TopologicalSpace.isSubTopology t (T i) ", "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace Î±),\n  âˆƒ (S : TopologicalSpace Î±), IsLargest S {B : Set (Set Î±) | âˆƒ (i : Î¹), B = TopologicalSpace.topologicalSpace (T i)} ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace Î±),\n  âˆƒ t : TopologicalSpace Î±, (âˆ€ (i : Î¹), t â‰¤ T i) âˆ§ âˆ€ (u : TopologicalSpace Î±), (âˆ€ (i : Î¹), u â‰¤ T i) â†’ u â‰¤ t "]}
{"docString": "Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\\n  TopologicalSpace.IsTopologicalBasis s â†’\\n    âˆ€ {t : Set (Set Î²)},\\n      TopologicalSpace.IsTopologicalBasis t â†’\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {P : Submodule R M} (b : Basis Î¹ R { x // x âˆˆ P }) {x : M}, x âˆˆ P â†” âˆƒ c, x = Finsupp.sum c fun i x => x â€¢ â†‘(â†‘b i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the submodule `P` has a basis, `x âˆˆ P` iff it is a linear combination of basis vectors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x * x_1) â»Â¹' â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `x : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `B' * x` is in `B`. \"}]\n", "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    âˆ€ {t : Set (Set Î²)},\n      TopologicalSpace.IsTopologicalBasis t â†’\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t) :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- If the submodule `P` has a basis, `x âˆˆ P` iff it is a linear combination of basis vectors. -/\ntheorem âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {P : Submodule R M} (b : Basis Î¹ R { x // x âˆˆ P }) {x : M}, x âˆˆ P â†” âˆƒ c, x = Finsupp.sum c fun i x => x â€¢ â†‘(â†‘b i) :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s :=\n\n/-- For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `B' * x` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x * x_1) â»Â¹' â†‘(B i) :=\n\n/-- Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.generate_from A = Inf {t : TopologicalSpace Î± | A âŠ† t.2} ", "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.generateFrom A = â‹‚â‚€ {t : Set (Set Î±) | TopologicalSpace.generateFrom A â‰¤ TopologicalSpace.generateFrom t} ", "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.generateFrom A = â¨… t, @Inf.TopologicalSpace Î± (A â‰¤ t) ", "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.is_open_set} ", "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† t.sets} ", "âˆ€ {Î± : Type u} {s : Set (Set Î±)}, TopologicalSpace.generateFrom s = Inf {t : TopologicalSpace Î± | s âŠ† SetOf t.IsOpen} ", "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.is_open_set} ", "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† t.opens} ", "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.is_open_set} ", "âˆ€ {Î± : Type u} {s : Set (Set Î±)},\n  TopologicalSpace.generateFrom s = Inf {t : TopologicalSpace Î± | s âŠ† t.1} "]}
{"docString": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V) id\",\n  \"isProp\": true,\n  \"docString\": \"Open elements of `ğ“¤ Î±` form a basis of `ğ“¤ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {Î“â‚€ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€),\\n  RingSubgroupsBasis fun Î³ => Valuation.ltAddSubgroup v Î³\",\n  \"isProp\": true,\n  \"docString\":\n  \"The basis of open subgroups for the topology on a ring determined by a valuation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_3} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) {Î¹ : Type u_1} [inst_4 : DecidableEq Î¹] [inst_5 : Fintype Î¹]\\n  (bS : Basis Î¹ R S) (a : S) {y : â„¤},\\n  (âˆ€ (k : Î¹), â†‘abv (â†‘(â†‘bS.repr a) k) â‰¤ y) â†’\\n    â†‘abv (â†‘(Algebra.norm R) a) â‰¤ ClassGroup.normBound abv bS * y ^ Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `R`-integral element `a : S` has coordinates `â‰¤ y` with respect to some basis `b`,\\nits norm is less than `normBound abv b * y ^ dim S`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\\n  IsUnit (Algebra.discr K â†‘b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. \"}]\n", "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼)) :=\n\n/-- Open elements of `ğ“¤ Î±` form a basis of `ğ“¤ Î±`. -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V) id :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n) :=\n\n/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {Î“â‚€ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€),\n  RingSubgroupsBasis fun Î³ => Valuation.ltAddSubgroup v Î³ :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- If the `R`-integral element `a : S` has coordinates `â‰¤ y` with respect to some basis `b`,\nits norm is less than `normBound abv b * y ^ dim S`. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_3} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) {Î¹ : Type u_1} [inst_4 : DecidableEq Î¹] [inst_5 : Fintype Î¹]\n  (bS : Basis Î¹ R S) (a : S) {y : â„¤},\n  (âˆ€ (k : Î¹), â†‘abv (â†‘(â†‘bS.repr a) k) â‰¤ y) â†’\n    â†‘abv (â†‘(Algebra.norm R) a) â‰¤ ClassGroup.normBound abv bS * y ^ Fintype.card Î¹ :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\n  IsUnit (Algebra.discr K â†‘b) :=\n\n/-- Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$. -/\ntheorem", "choices": ["basis_rat_open_pos ", "RationalBasisForStandardTopologyOnReal :\n  TopologicalSpace.IsTopologicalBasis\n    (SetOf (fun s => âˆƒ (a b : â„š), a < b âˆ§ s = Set.Ioo (a : â„) b)) ", ": âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  TopologicalSpace.IsTopologicalBasis {ab : Î± Ã— Î± | ab.1 < ab.2 âˆ§ is_rat ab.1 âˆ§ is_rat ab.2} ", "real_basis_rat_rat : TopologicalSpace.IsTopologicalBasis (SetOf fun s => âˆƒ a b : â„š, a < b âˆ§ s = Set.Ioo (a : â„) (b : â„)) ", "real_standard_topology_basis :\n  TopologicalSpace.IsTopologicalBasis (SetOf (Î» (I : Set â„), âˆƒ a b (h : a < b) (ha : a âˆˆ â„š) (hb : b âˆˆ â„š), I = Set.Ioo a b)) ", "real_standard_topology_basis : TopologicalSpace.IsTopologicalBasis {s : Set â„ | âˆƒ (a b : â„š), a < b âˆ§ s = Set.Ioo (a : â„) (b : â„)} ", "basis_rat_open_separated :\n  TopologicalSpace.IsTopologicalBasis\n    {s : Set â„ | âˆƒ (a : â„š) (b : â„š), a < b âˆ§ s = Set.Ioo (a : â„) (b : â„)} ", "is_basis_rat_lt_rat :\n  TopologicalSpace.IsTopologicalBasis\n    (SetOf (Î» s, âˆƒ a b : â„š, a < b âˆ§ s = Set.Ioo (a : â„) (b : â„))) ", "real_standard_topology_basis_rat :\n  TopologicalSpace.IsTopologicalBasis\n    {U : Set â„ | âˆƒ (a b : â„š), a < b âˆ§ U = Set.Ioo (a : â„) (b : â„)} ", "Real.topological_space = TopologicalSpace.generateFrom {s : Set â„ | âˆƒ (a b : â„š), a < b âˆ§ s = Set.Ioo a b} "]}
{"docString": "Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\\n  {f : X â†’ Y}, Embedding f â†’ DiscreteTopology X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced under an inclusion `f : X â†’ Y` from the discrete topological space `Y`\\nis the discrete topology on `X`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V},\\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points in projective space is contained in a subspace, and that subspace is\\ncontained in the span of the set of points, then the span of the set of points is equal to\\nthe subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"}]\n", "prompt_cons": "/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S) :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- The topology induced under an inclusion `f : X â†’ Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\n  {f : X â†’ Y}, Embedding f â†’ DiscreteTopology X :=\n\n/-- If a set of points in projective space is contained in a subspace, and that subspace is\ncontained in the span of the set of points, then the span of the set of points is equal to\nthe subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V},\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$. -/\ntheorem", "choices": ["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : Y â†’ X} {A : Set Y},\n  Embedding f â†’ (Subspace.topologicalSpace A : TopologicalSpace { x // x âˆˆ A }) = Subspace.topologicalSpace (f '' A) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : Y â†’ X} {A : Set Y},\n  Embedding f â†’ IsSubspaceTopology A f â†’ IsSubspaceTopology A (Î» x, f x) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y}\n  (f : Y â†’ X), Embedding f â†’ (TopologicalSpace.induced f inst = inst_1) â†’ TopologicalSpace.induced (f âˆ˜ coe) inst = TopologicalSpace.induced coe inst_1 ", "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {Y_sub_X : Y âŠ† X} {A : Set Y},\n  TopologicalSpace.induced (coe : Y â†’ X) inst = TopologicalSpace.induced (coe âˆ˜ (coe : A â†’ Y)) inst_1 ", "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y} {f : Y â†’ X},\n  (âˆ€ y, f y âˆˆ A) â†’ Embedding f â†’ TopologicalSpace.induced f inst = TopologicalSpace.induced (f âˆ˜ coe) (TopologicalSpace.induced coe inst_1) ", "âˆ€ {X : Type u_1} {Y : Type u_2} {A : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {f : Y â†’ X} {g : A â†’ Y}, Embedding f â†’ Embedding g â†’ TopologicalSpace.induced g (TopologicalSpace.induced f inst) = TopologicalSpace.induced (f âˆ˜ g) inst ", "âˆ€ {X : Type u_1} {Y : Type u_2} {A : Type u_3} [inst_X : TopologicalSpace X] [inst_Y : TopologicalSpace Y] [inst_A : TopologicalSpace A]\n  {f_XY : Y â†’ X} {f_AX : A â†’ X} {f_AY : A â†’ Y}, \n  Embedding f_XY â†’ Embedding f_AX â†’ Embedding f_AY â†’\n  âˆ€ (hâ‚ : âˆ€ a : A, f_XY (f_AY a) = f_AX a) (hâ‚‚ : âˆ€ a : A, f_XY (f_AY a) = f_AX a),\n  TopologicalSpace.induced f_AY inst_Y = TopologicalSpace.induced f_AX inst_X ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : Y â†’ X} {A : Set Y},\n  Embedding f â†’ IsOpen A â†” IsOpen (f '' A) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y}\n  {f : Y â†’ X}, Embedding f â†’ (Subtype.topologicalSpace : TopologicalSpace { x // x âˆˆ A }) = TopologicalSpace.induced f Subtype.topologicalSpace ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y} {f : Y â†’ X},\n  Embedding f â†’ f '' A = coe A â†’ TopologicalSpace.induced f inst_1 = TopologicalSpace.induced (f âˆ˜ coe) inst "]}
{"docString": "Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\": \"Cardinal.mk â†‘Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the reals, as a set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\\n  IsUnit (Algebra.discr K â†‘b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\\n  n â‰  0 â†’ âˆ€ {x y : Î±}, x < y â†’ 0 < y â†’ âˆƒ q, 0 < q âˆ§ x < â†‘q ^ n âˆ§ â†‘q ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"}]\n", "prompt_cons": "/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼)) :=\n\n/-- The cardinality of the reals, as a set. -/\ntheorem Cardinal.mk â†‘Set.univ = Cardinal.continuum :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\n  IsUnit (Algebra.discr K â†‘b) :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  n â‰  0 â†’ âˆ€ {x y : Î±}, x < y â†’ 0 < y â†’ âˆƒ q, 0 < q âˆ§ x < â†‘q ^ n âˆ§ â†‘q ^ n < y :=\n\n/-- Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$. -/\ntheorem", "choices": ["IsTopologicalBasis (Set.Union\n    (Î» a : â„š, Set.Union\n      (Î» b : â„š, Set.Union\n        (Î» c : â„š, Set.Union\n          (Î» d : â„š, Set.Union\n            (Î» hâ‚ : a < b, Set.Union\n              (Î» hâ‚‚ : c < d, Set.Singleton ((Set.Ioo a b) Ã—Ë¢ (Set.Ioo c d))))))))) ", "Real.basis_rat_rat : TopologicalSpace.IsTopologicalBasis (SetOf (Î» (U : Set â„ Ã— â„), âˆƒ (a b c d : â„š), a < b âˆ§ c < d âˆ§ U = Set.Prod (Set.Ioo â†‘a â†‘b) (Set.Ioo â†‘c â†‘d))) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : Archimedean Î±] [inst_4 : LinearOrderedField Î²] [inst_5 : TopologicalSpace Î²] [inst_6 : OrderTopology Î²]\n  [inst_7 : Archimedean Î²], TopologicalSpace.IsTopologicalBasis (SetOf fun s => âˆƒ (a b c d : â„š), (a < b âˆ§ c < d) âˆ§ s = (Set.Ioo a b).prod (Set.Ioo c d)) ", "Real.two_countable_basis : TopologicalSpace.IsTopologicalBasis (Real.countable_basis Ã—Ë¢ Real.countable_basis) ", "Real.basis_rat_rat ", "RealBasis : TopologicalSpace.IsTopologicalBasis\n  {U : Set (â„ Ã— â„) | âˆƒ (a b c d : â„š), a < b âˆ§ c < d âˆ§ U = Set.Prod (Set.Ioo â†‘a â†‘b) (Set.Ioo â†‘c â†‘d)} ", "Real.basis_rat_rat_is_topological_basis : TopologicalSpace.IsTopologicalBasis (Set.Range (Prod.map (Î» p, (p.1 : â„, p.2 : â„)) (Set.Ioo Rat.cast Rat.cast))) ", "Real.basis_rat_rat ", "Real.borel_eq_generate_from_rat_rat ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : Archimedean Î±] [inst_4 : LinearOrderedField Î²] [inst_5 : TopologicalSpace Î²] [inst_6 : OrderTopology Î²]\n  [inst_7 : Archimedean Î²], TopologicalSpace.IsTopologicalBasis ((Î» (p : Set (Î± Ã— Î²)), Set.prod (Set.Ioo (p.fst.fst) (p.fst.snd)) (Set.Ioo (p.snd.fst) (p.snd.snd))) '' SetOf (Î» (p : Set (Î± Ã— Î²)), p âˆˆ SetOf (Î» (a : Set Î± Ã— Set Î²), Set.Ioo (a.fst.fst) (a.fst.snd) âˆˆ DenseRange Rat.cast âˆ§ Set.Ioo (a.snd.fst) (a.snd.snd) âˆˆ DenseRange Rat.cast))) "]}
{"docString": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LE Î²] {f g : Î± â†’ Î²} {a : Î±},\\n  f â‰¤á¶ [nhds a] g â†’ âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\\n`f x â‰¤ g x` in a neighbourhood of `y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [self : OrderClosedTopology Î±],\\n  IsClosed {p | p.fst â‰¤ p.snd}\",\n  \"isProp\": true,\n  \"docString\": \"The set `{ (x, y) | x â‰¤ y }` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\\n  [inst_6 : OrderClosedTopology Î´] {s : Set Î±} [hs : Set.OrdConnected s] {f : Î± â†’ Î´},\\n  ContinuousOn f s â†’ âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.SurjOn f s (Set.uIcc (f a) (f b))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f g : Î± â†’ Î±}, Monotone g â†’ f â‰¤ g â†’ âˆ€ (n : â„•), f^[n] â‰¤ g^[n]\",\n  \"isProp\": true,\n  \"docString\": \"If `f â‰¤ g` and `g` is monotone, then `f^[n] â‰¤ g^[n]`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\\n  {f : X â†’ Y}, Embedding f â†’ DiscreteTopology X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced under an inclusion `f : X â†’ Y` from the discrete topological space `Y`\\nis the discrete topology on `X`. \"}]\n", "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x â‰¤ g x` in a neighbourhood of `y`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LE Î²] {f g : Î± â†’ Î²} {a : Î±},\n  f â‰¤á¶ [nhds a] g â†’ âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g :=\n\n/-- The set `{ (x, y) | x â‰¤ y }` is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [self : OrderClosedTopology Î±],\n  IsClosed {p | p.fst â‰¤ p.snd} :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\n  [inst_6 : OrderClosedTopology Î´] {s : Set Î±} [hs : Set.OrdConnected s] {f : Î± â†’ Î´},\n  ContinuousOn f s â†’ âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.SurjOn f s (Set.uIcc (f a) (f b)) :=\n\n/-- If `f â‰¤ g` and `g` is monotone, then `f^[n] â‰¤ g^[n]`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f g : Î± â†’ Î±}, Monotone g â†’ f â‰¤ g â†’ âˆ€ (n : â„•), f^[n] â‰¤ g^[n] :=\n\n/-- The topology induced under an inclusion `f : X â†’ Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\n  {f : X â†’ Y}, Embedding f â†’ DiscreteTopology X :=\n\n/-- Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$. -/\ntheorem", "choices": ["forall {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : TopologicalSpace Î²] [inst_3 : OrderClosedTopology Î²]\n  {f g : Î± â†’ Î²}, Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î²] [t : OrderClosedTopology Î²]\n  [inst_2 : TopologicalSpace Î±] {f g : Î± â†’ Î²} {s : Set Î±},\n  IsClosed s â†’ Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "âˆ€ {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] [Preorder Y] [OrderTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : Preorder Y] [t : OrderClosedTopology Y]\n  [inst_2 : TopologicalSpace Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : Preorder Y] [inst_2 : TopologicalSpace Y] [t : OrderClosedTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "forall {X : Type u_1} {Y : Type u_2} [tX : TopologicalSpace X] [inst : Preorder Y] [tY : TopologicalSpace Y] [inst_1 : OrderTopology Y]\n  {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : Preorder Y] [t : OrderClosedTopology Y]\n  [inst_2 : TopologicalSpace Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î²] [t : OrderClosedTopology Î²]\n  [inst_2 : TopologicalSpace Î±] {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "forall {X Y : Type} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : Preorder Y] [inst_3 : OrderClosedTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} ", "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : Preorder Y] [inst_2 : OrderClosedTopology Y]\n  [inst_3 : TopologicalSpace Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ IsClosed {x | f x â‰¤ g x} "]}
{"docString": "Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {f : Î± â†’ Î²},\\n  Function.Injective f â†’ Continuous f â†’ T2Space Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X â†’ Y}\\n  {s : Set X}, HolderOnWith C r f s â†’ 0 < r â†’ UniformContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\": \"A HÃ¶lder continuous function is uniformly continuous \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {K : NNReal} {f : X â†’ Y},\\n  LipschitzWith K f â†’ dimH (Set.range f) â‰¤ dimH Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the\\nHausdorff dimension of its domain. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"}]\n", "prompt_cons": "/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {f : Î± â†’ Î²},\n  Function.Injective f â†’ Continuous f â†’ T2Space Î± :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- A HÃ¶lder continuous function is uniformly continuous -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X â†’ Y}\n  {s : Set X}, HolderOnWith C r f s â†’ 0 < r â†’ UniformContinuousOn f s :=\n\n/-- If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the\nHausdorff dimension of its domain. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {K : NNReal} {f : X â†’ Y},\n  LipschitzWith K f â†’ dimH (Set.range f) â‰¤ dimH Set.univ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s)) :=\n\n/-- Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : Set Î±} {f : A â†’ Î²} {s : Subtype A},\n  Continuous f â†’ Continuous s â†’ Function.extend f s = s ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : Set Î±}\n  {fâ‚ fâ‚‚ : Î± â†’ Î²}, ContinuousOn fâ‚ A â†’ ContinuousOn fâ‚‚ A â†’ Continuous fâ‚ â†’ Continuous fâ‚‚ â†’\n    (âˆ€ (x : Î±), x âˆˆ A â†’ fâ‚ x = fâ‚‚ x) â†’ fâ‚ = fâ‚‚ ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²]\n  {A : Set Î±} {f : A â†’ Î²} {g gâ‚ : Closure A â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous gâ‚ â†’ (âˆ€ (a : Î±), a âˆˆ A â†’ g (Subtype.mk a _) = f a) â†’\n  (âˆ€ (a : Î±), a âˆˆ A â†’ gâ‚ (Subtype.mk a _) = f a) â†’ g = gâ‚ ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : Set Î±} {f : A â†’ Î²} {gâ‚ gâ‚‚ : C(Î±, Î²)},\n  ContinuousOn f A â†’ gâ‚.restrict A = gâ‚‚.restrict A â†’ gâ‚ = gâ‚‚ ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {s : Set Î±} {f : s â†’ Î²} {x : Î±} {y : Î²},\n  ContinuousWithinAt f s x â†’ x âˆˆ Closure s â†’ ContinuousWithinAt (Function.extend s f y) univ x â†’\n    (Function.extend s f y) x = f âŸ¨x, x âˆˆ sâŸ© ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : Set Î±}\n  {f : Î± â†’ Î²} (H : ContinuousOn f A) {f' : Î± â†’ Î²}, ContinuousOn f' (closure A) â†’\n  Set.eq_on f f' A â†’ f' = f ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : Set Î±} {f : Î± â†’ Î²} {Y : Set Î²},\n  ContinuousOn f A â†’ A âŠ† Closure Y â†’\n  (âˆ€ (gâ‚ gâ‚‚ : Î± â†’ Î²), ContinuousOn gâ‚ (Closure Y) â†’ ContinuousOn gâ‚‚ (Closure Y) â†’ âˆ€ (x : Î±), x âˆˆ A â†’ gâ‚ x = gâ‚‚ x) â†’\n  (âˆ€ (x : Î±), x âˆˆ Closure Y â†’ (âˆƒ! (y : Î²), âˆ€ (g : Î± â†’ Î²), ContinuousOn g (Closure Y) â†’ g x = y)) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {f : Subtype A â†’ Î²}\n  [inst_2 : T2Space Î²],\n  Continuous f â†’\n  âˆ€ (gâ‚ gâ‚‚ : {x // IsClosed A x} â†’ Î²), Continuous gâ‚ â†’ Continuous gâ‚‚ â†’ (âˆ€ (a : Subtype A), gâ‚ a = f a) â†’ (âˆ€ (a : Subtype A), gâ‚‚ a = f a) â†’ gâ‚ = gâ‚‚ ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : set Î±} {f gâ‚ gâ‚‚ : Î± â†’ Î²},\n  ContinuousOn f A â†’ ContinuousOn gâ‚ (closure A) â†’ ContinuousOn gâ‚‚ (closure A) â†’\n    (âˆ€ (x : Î±), x âˆˆ A â†’ gâ‚ x = f x) â†’ (âˆ€ (x : Î±), x âˆˆ A â†’ gâ‚‚ x = f x) â†’ gâ‚ = gâ‚‚ ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {A : Set Î±}\n  {f : Î± â†’ Î²}, ContinuousOn f A â†’\n  âˆ€ (gâ‚ gâ‚‚ : Î± â†’ Î²), ContinuousOn gâ‚ (closure A) â†’ ContinuousOn gâ‚‚ (closure A) â†’\n  (âˆ€ (x : Î±), x âˆˆ A â†’ gâ‚ x = f x) â†’ (âˆ€ (x : Î±), x âˆˆ A â†’ gâ‚‚ x = f x) â†’ gâ‚ = gâ‚‚ "]}
{"docString": "Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners â„ E H â†’\\n    âˆ€ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Ïƒ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Urysohn's metrization theorem* (Tychonoff's version): a Tâ‚ƒ topological space with second\\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\\nsame topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.MetrizableSpace Î²] [inst_3 : BorelSpace Î²]\\n  [inst_4 : TopologicalSpace.SecondCountableTopology Î²], MeasureTheory.StronglyMeasurable f â†” Measurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, strongly measurable and measurable are equivalent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : Preorder Î±] [inst_2 : CompactIccSpace Î±] {s : Set Î±},\\n  BddAbove s â†’ BddBelow s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudo metric space with a conditionally complete linear order such that the order and the\\nmetric structure give the same topology, any order-bounded set is metric-bounded. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m m' : MetricSpace Î±}, PseudoMetricSpace.toDist = PseudoMetricSpace.toDist â†’ m = m'\",\n  \"isProp\": true,\n  \"docString\": \"Two metric space structures with the same distance coincide. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\\n  [inst_2 : TopologicalSpace.MetrizableSpace Y] {f : X â†’ Y}, Embedding f â†’ TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an embedding of a topological space into a metrizable space, the source space is also\\nmetrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} {x : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasurableSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.AEStronglyMeasurable f Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies ae strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"}]\n", "prompt_cons": "/-- A Ïƒ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners â„ E H â†’\n    âˆ€ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f :=\n\n/-- *Urysohn's metrization theorem* (Tychonoff's version): a Tâ‚ƒ topological space with second\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\nsame topology. -/\ntheorem âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  TopologicalSpace.MetrizableSpace X :=\n\n/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.MetrizableSpace Î²] [inst_3 : BorelSpace Î²]\n  [inst_4 : TopologicalSpace.SecondCountableTopology Î²], MeasureTheory.StronglyMeasurable f â†” Measurable f :=\n\n/-- In a pseudo metric space with a conditionally complete linear order such that the order and the\nmetric structure give the same topology, any order-bounded set is metric-bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : Preorder Î±] [inst_2 : CompactIccSpace Î±] {s : Set Î±},\n  BddAbove s â†’ BddBelow s â†’ Metric.Bounded s :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Two metric space structures with the same distance coincide. -/\ntheorem âˆ€ {Î± : Type u_1} {m m' : MetricSpace Î±}, PseudoMetricSpace.toDist = PseudoMetricSpace.toDist â†’ m = m' :=\n\n/-- Given an embedding of a topological space into a metrizable space, the source space is also\nmetrizable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : TopologicalSpace.MetrizableSpace Y] {f : X â†’ Y}, Embedding f â†’ TopologicalSpace.MetrizableSpace X :=\n\n/-- In a space with second countable topology, measurable implies ae strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} {x : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasurableSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.AEStronglyMeasurable f Î¼ :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s :=\n\n/-- Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable. -/\ntheorem", "choices": ["TopologicalSpace.MetrizableSpace (Î  (i : Finâ‚“ 2), â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) ", "TopologicalSpace.MetrizableSpace (â„ Ã— â„) "]}
{"docString": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly.", "prompts": "[{\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„• â†’ Î±},\\n  Monotone f â†’ âˆ€ (n : â„•) {x : Î±}, f n < x â†’ x < f (n + 1) â†’ âˆ€ (a : â„•), f a â‰  x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `â„•` to a preorder such that `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}\\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\\n  {I' : ModelWithCorners ğ•œ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M â†’ M'} {x : M} {n : â„•},\\n  ContMDiffAt I I' (â†‘n) f x â†” âˆ€á¶  (x' : M) in nhds x, ContMDiffAt I I' (â†‘n) f x'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„¤ â†’ Î±},\\n  Monotone f â†’ âˆ€ (n : â„¤) {x : Î±}, f n < x â†’ x < f (n + 1) â†’ âˆ€ (a : â„¤), f a â‰  x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `â„¤` to a preorder and `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„• â†’ Î±},\\n  Antitone f â†’ âˆ€ (n : â„•) {x : Î±}, f (n + 1) < x â†’ x < f n â†’ âˆ€ (a : â„•), f a â‰  x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an antitone function from `â„•` to a preorder such that `x` lies between `f (n + 1)` and\\n`f n`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„¤ â†’ Î±},\\n  Antitone f â†’ âˆ€ (n : â„¤) {x : Î±}, f (n + 1) < x â†’ x < f n â†’ âˆ€ (a : â„¤), f a â‰  x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an antitone function from `â„¤` to a preorder and `x` lies between `f (n + 1)` and\\n`f n`, then `x` doesn't lie in the range of `f`. \"}]\n", "prompt_cons": "/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- If `f` is a monotone function from `â„•` to a preorder such that `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„• â†’ Î±},\n  Monotone f â†’ âˆ€ (n : â„•) {x : Î±}, f n < x â†’ x < f (n + 1) â†’ âˆ€ (a : â„•), f a â‰  x :=\n\n/-- Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners ğ•œ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M â†’ M'} {x : M} {n : â„•},\n  ContMDiffAt I I' (â†‘n) f x â†” âˆ€á¶  (x' : M) in nhds x, ContMDiffAt I I' (â†‘n) f x' :=\n\n/-- If `f` is a monotone function from `â„¤` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„¤ â†’ Î±},\n  Monotone f â†’ âˆ€ (n : â„¤) {x : Î±}, f n < x â†’ x < f (n + 1) â†’ âˆ€ (a : â„¤), f a â‰  x :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- If `f` is an antitone function from `â„•` to a preorder such that `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„• â†’ Î±},\n  Antitone f â†’ âˆ€ (n : â„•) {x : Î±}, f (n + 1) < x â†’ x < f n â†’ âˆ€ (a : â„•), f a â‰  x :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- If `f` is an antitone function from `â„¤` to a preorder and `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„¤ â†’ Î±},\n  Antitone f â†’ âˆ€ (n : â„¤) {x : Î±}, f (n + 1) < x â†’ x < f n â†’ âˆ€ (a : â„¤), f a â‰  x :=\n\n/-- Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly. -/\ntheorem", "choices": ["Â¬(âˆƒ f : â„ â†’ â„,\n    âˆ€ (Îµ : â„),\n      0 < Îµ â†’\n        âˆƒ (N : â„•),\n          âˆ€ (x : â„) (n : â„•),\n            N â‰¤ n â†’ x âˆˆ Set.Icc 0 1 â†’ abs (f n x - f x) < Îµ) ", "NotUniformlyConvergentFn : Â¬âˆ€ (Îµ : â„), 0 < Îµ â†’ âˆƒ (N : â„•), âˆ€ (n : â„•), N â‰¤ n â†’ âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ abs (x^n - 0) < Îµ ", "âˆ€ (n : â„•) (x : â„), x âˆˆ Icc (0 : â„) 1 â†’ âˆƒ (l : â„•), âˆ€ k â‰¥ l, âˆ€ m â‰¥ l, abs (x ^ k - x ^ m) > 1 / 2 ", "âˆ€ (n : â„•) (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’\n  âˆ€ (d : â„), 0 < d â†’ âˆƒ (N : â„•), âˆ€ (n : â„•), N â‰¤ n â†’ âˆƒ (x : â„), 0 â‰¤ x âˆ§ x â‰¤ 1 âˆ§ abs (x ^ n - x ^ (n + 1)) â‰¥ d ", "Â¬âˆƒ (f : â„ â†’ â„),\n  Filter.Eventually (fun x => Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (f x))) (Filter.principal (Set.Icc 0 1)) âˆ§\n    Filter.TendstoUniformly (fun n => fun x => x ^ n) f Filter.atTop (Filter.principal (Set.Icc 0 1)) ", "non_uniform_convergence_of_pow_functions : Â¬(UniformConvergent fun n => fun x => x ^ n) ", "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Field â„] [inst_3 : NormedSpace â„ Î±],\n  Â¬UniformlyConvergent fun n => fun x => x ^ n ", "non_uniform_convergence_of_pow : Â¬ UniformConvergent fun n : â„• => fun x : â„ => x ^ n ", "âˆ€ {Î± : Type u} [inst : NormedField Î±] [inst_1 : CompleteSpace Î±] (n : â„•),\n  Â¬UniformlyConvergent fun n x => x ^ n ", "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] [inst_1 : CompleteSpace Î±] {f : â„• â†’ â„ â†’ Î±},\n  (fun n x => x ^ n) = f â†’\n    Â¬UniformlyConvergent (fun n x => f n x) "]}
{"docString": "Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\\nhomotopic to `ContinuousMap.pi fâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f : Con.Quotient c â†’* P),\\n  Con.lift c (MonoidHom.comp f (Con.mk' c)) (_ : âˆ€ (x y : M), â†‘c x y â†’ â†‘f â†‘x = â†‘f â†‘y) = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a homomorphism `f` from the quotient of a monoid by a congruence relation, `f` equals the\\nhomomorphism on the quotient induced by `f` composed with the natural map from the monoid to\\nthe quotient. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (self : Î± â‰ƒâ‚œ Î²),\\n  Continuous self.invFun\",\n  \"isProp\": true,\n  \"docString\": \"The inverse map of a homeomorphism is a continuous function. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ Set.MapsTo f (closure s) (closure t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. \"}]\n", "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\nhomotopic to `ContinuousMap.pi fâ‚`. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚) :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Given a homomorphism `f` from the quotient of a monoid by a congruence relation, `f` equals the\nhomomorphism on the quotient induced by `f` composed with the natural map from the monoid to\nthe quotient. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f : Con.Quotient c â†’* P),\n  Con.lift c (MonoidHom.comp f (Con.mk' c)) (_ : âˆ€ (x y : M), â†‘c x y â†’ â†‘f â†‘x = â†‘f â†‘y) = f :=\n\n/-- The inverse map of a homeomorphism is a continuous function. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (self : Î± â‰ƒâ‚œ Î²),\n  Continuous self.invFun :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c) :=\n\n/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ Set.MapsTo f (closure s) (closure t) :=\n\n/-- Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map. -/\ntheorem", "choices": ["forall {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Function.LeftInverse g f â†’ QuotientMap f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ (f âˆ˜ g = id) â†’ QuotientMap f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ (f âˆ˜ g = id) â†’ QuotientMap f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ (f âˆ˜ g = id) â†’ QuotientMap f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î² â†’ Î±} {p : Î± â†’ Î²},\n  Continuous p â†’ Continuous f â†’ (p âˆ˜ f = id) â†’ QuotientMap p ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {p : Î± â†’ Î²} {f : Î² â†’ Î±},\n  Continuous p â†’ Continuous f â†’ Function.LeftInverse (p âˆ˜ f) id â†’ QuotientMap p ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ (f âˆ˜ g = id) â†’ QuotientMap f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Function.LeftInverse g f â†’ QuotientMap f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {p : Î± â†’ Î²} {f : Î² â†’ Î±},\n  Continuous p â†’ Continuous f â†’ (Function.comp p f = id) â†’ QuotientMap p ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Continuous f â†’ Continuous g â†’ (âˆ€ (y : Î²), f (g y) = y) â†’ QuotientMap f "]}
{"docString": "Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\\n  [inst_3 : ContinuousConstVAdd Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective â†‘f â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\\nopen. \"},\n {\"theorem\": \"âˆ€ {X Y : Profinite} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of profinite spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace E] {f : E â†’ F} {f' : E â†’ E â‰ƒL[ğ•œ] F},\\n  (âˆ€ (x : E), HasStrictFDerivAt f (â†‘(f' x)) x) â†’ IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has an invertible strict derivative at all points, then it is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.  \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"}]\n", "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\n  [inst_3 : ContinuousConstVAdd Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f :=\n\n/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective â†‘f â†’ IsOpenMap â†‘f :=\n\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem âˆ€ {X Y : Profinite} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f :=\n\n/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace E] {f : E â†’ F} {f' : E â†’ E â‰ƒL[ğ•œ] F},\n  (âˆ€ (x : E), HasStrictFDerivAt f (â†‘(f' x)) x) â†’ IsOpenMap f :=\n\n/-- If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²}\n  {A : Set Î±} {B : Set Î²}, IsOpenMap f â†’ IsOpen A â†’ f '' A = B â†’ IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsOpenMap f â†’ IsOpen A â†’ IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsOpenMap f â†’ IsOpen A â†’ IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ âˆ€ (A : Set Î±) (H : IsOpen A), IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  IsOpenMap f â†’ IsOpen A â†’ IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±}\n  {B : Set Î²}, IsOpenMap f â†’ IsOpen A â†’ f '' A = B â†’ IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {f : Î± â†’ Î²}\n  {A : Set Î±} (h_open : IsOpenMap f) (hA : IsOpen A),\n  IsOpenMap (Set.restrict f A) ", "forall {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} (hf : IsOpenMap f) {A : Set Î±} (hA : IsOpen A),\n  IsOpenMap (Set.restrict f A) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ âˆ€ (A : Set Î±) (hA : IsOpen A), IsOpenMap (f âˆ˜ (Set.restrict f A)) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±} {B : Set Î²},\n  IsOpenMap f â†’ IsOpen A â†’ f '' A = B â†’ IsOpenMap (Set.restrict f A) "]}
{"docString": "Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\\n    Pairwise (Disjoint on s) â†’\\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsClopen (s i)) â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\\n    Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsOpen (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint cover by non-empty open subsets has at most one\\nelement. \"}]\n", "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\n    Pairwise (Disjoint on s) â†’\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹ :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsClopen (s i)) â†’ Subsingleton Î¹ :=\n\n/-- In a preconnected space, any disjoint cover by non-empty open subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\n    Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsOpen (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹ :=\n\n/-- Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected. -/\ntheorem", "choices": ["âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î± : Type u_1} {A : Set X} (s : Î± â†’ Set X),\n  Connected A â†’\n    (âˆ€ (i : Î±), Connected (s i)) â†’\n      (âˆ€ (i : Î±), Set.Nonempty (A âˆ© s i)) â†’ Connected (A âˆª â‹ƒ (i : Î±), s i) ", "âˆ€ {Î± : Type u} {Î¹ : Type v} [inst : TopologicalSpace Î±] {A : Set Î±} {s : Î¹ â†’ Set Î±},\n  IsConnected A â†’ (âˆ€ (i : Î¹), IsConnected (s i)) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© s i)) â†’ IsConnected (A âˆª â‹ƒ (i : Î¹), s i) ", "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} [inst : TopologicalSpace Î±] {A : Set Î±} (C : Î¹ â†’ Set Î±),\n  IsConnected A â†’\n    (âˆ€ (i : Î¹), IsConnected (C i)) â†’\n      (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© C i)) â†’ IsConnected (A âˆª â‹ƒ (i : Î¹), C i) ", "âˆ€ {Î± : Type u} {X : Type v} [TopologicalSpace X] [ConnectedSpace X] {Î¹ : Type w} {A : Set X} {B : Î¹ â†’ Set X},\n  Connected A â†’\n    (âˆ€ (i : Î¹), Connected (B i)) â†’\n      (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© B i)) â†’ Connected (A âˆª â‹ƒ (i : Î¹), B i) ", "âˆ€ {Î± : Type u} {Î¹ : Type v} [inst : TopologicalSpace Î±] [ConnectedSpace Î±]\n  {A : Set Î±} {B : Î¹ â†’ Set Î±},\n  IsConnected A â†’\n    (âˆ€ (i : Î¹), IsConnected (B i)) â†’\n      (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© B i)) â†’\n        IsConnected (A âˆª â‹ƒ (i : Î¹), B i) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X} {Î¹ : Type u_2} (AÎ± : Î¹ â†’ Set X),\n  Connected A â†’\n    (âˆ€ (i : Î¹), Connected (AÎ± i)) â†’\n      (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© AÎ± i)) â†’ Connected (A âˆª â‹ƒ (i : Î¹), AÎ± i) ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [ConnectedSpace Î±] {A : Set Î±} {s : Î¹ â†’ Set Î±},\n  IsConnected A â†’\n    (âˆ€ (i : Î¹), IsConnected (s i)) â†’\n      (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© s i)) â†’ IsConnected (A âˆª â‹ƒ (i : Î¹), s i) ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {A : Set Î±} {s : Î¹ â†’ Set Î±},\n  IsConnected A â†’ (âˆ€ (i : Î¹), IsConnected (s i)) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© s i)) â†’ IsConnected (A âˆª â‹ƒ (i : Î¹), s i) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] {A : Set X} {Î¹ : Type v} (B : Î¹ â†’ Set X),\n  IsConnected A â†’\n    (âˆ€ (Î± : Î¹), IsConnected (B Î±)) â†’\n      (âˆ€ (Î± : Î¹), Set.Nonempty (A âˆ© B Î±)) â†’ IsConnected (A âˆª â‹ƒ (Î± : Î¹), B Î±) ", "âˆ€ {Î± : Type u} {Î¹ : Type v} [inst : TopologicalSpace Î±] {A : Set Î±} {B : Î¹ â†’ Set Î±},\n  Connected A â†’\n    (âˆ€ (i : Î¹), Connected (B i)) â†’\n      (âˆ€ (i : Î¹), Set.Nonempty (A âˆ© B i)) â†’ Connected (A âˆª â‹ƒ (i : Î¹), B i) "]}
{"docString": "Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] [inst_5 : Nontrivial ğ•œ] {A B : Set E},\\n  IsExposed ğ•œ A B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nontrivial `ğ•œ`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\\nhalfspace doesn't intersect `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : SeminormedRing ğ•œ] [inst_1 : SMul ğ•œ E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E}, sâ‚ âŠ† sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of bounded sets are bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, s âŠ† t â†’ Metric.Bounded t â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a bounded set are also bounded \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"}]\n", "prompt_cons": "/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x} :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- For nontrivial `ğ•œ`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] [inst_5 : Nontrivial ğ•œ] {A B : Set E},\n  IsExposed ğ•œ A B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x} :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- Subsets of bounded sets are bounded. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : SeminormedRing ğ•œ] [inst_1 : SMul ğ•œ E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E}, sâ‚ âŠ† sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚‚ â†’ Bornology.IsVonNBounded ğ•œ sâ‚ :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, s âŠ† t â†’ Metric.Bounded t â†’ Metric.Bounded s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ C âˆ© A â‰  âˆ… â†’ C âˆ© (HasCompl.compl A) â‰  âˆ… â†’ C âˆ© (Frontier A) â‰  âˆ… ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ C âˆ© A â‰  âˆ… â†’ C âˆ© (HasCompl.compl A) â‰  âˆ… â†’ C âˆ© (Frontier A) â‰  âˆ… ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ (C âˆ© A â‰  âˆ…) â†’ (C âˆ© (HasCompl.compl A) â‰  âˆ…) â†’ (C âˆ© (Frontier A) â‰  âˆ…) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ (C âˆ© A).Nonempty â†’ (C âˆ© (HasCompl.compl A)).Nonempty â†’ (C âˆ© Boundary A).Nonempty ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ (C âˆ© A â‰  âˆ…) â†’ (C âˆ© (Î± \\ A) â‰  âˆ…) â†’ (C âˆ© Boundary A â‰  âˆ…) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’\n  Set.Nonempty (A âˆ© C) â†’ Set.Nonempty ((-A) âˆ© C) â†’ Set.Nonempty (C âˆ© Boundary A) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ (C âˆ© A).Nonempty â†’ (C âˆ© (HasCompl.compl A)).Nonempty â†’ (C âˆ© Frontiers A).Nonempty ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ (C âˆ© A).Nonempty â†’ (C âˆ© (HasCompl.compl A)).Nonempty â†’ (C âˆ© Boundary A).Nonempty ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ Set.Nonempty (C âˆ© A) â†’ Set.Nonempty (C âˆ© (Î± \\ A)) â†’ Set.Nonempty (C âˆ© Boundary A) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A C : Set Î±},\n  IsConnected C â†’ Set.Nonempty (C âˆ© A) â†’ Set.Nonempty (C âˆ© (HasCompl.compl A)) â†’ Set.Nonempty (C âˆ© Frontier A) "]}
{"docString": "Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\\nhomotopic to `ContinuousMap.pi fâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±),\\n  ConnectedComponents.mk â»Â¹' (ConnectedComponents.mk '' U) = â‹ƒ (x : Î±) (_ : x âˆˆ U), connectedComponent x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of the image of a set under the quotient map to `connectedComponents Î±`\\nis the union of the connected components of the elements in it. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"}]\n", "prompt_cons": "/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s :=\n\n/-- If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\nhomotopic to `ContinuousMap.pi fâ‚`. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚) :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- The preimage of the image of a set under the quotient map to `connectedComponents Î±`\nis the union of the connected components of the elements in it. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±),\n  ConnectedComponents.mk â»Â¹' (ConnectedComponents.mk '' U) = â‹ƒ (x : Î±) (_ : x âˆˆ U), connectedComponent x :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î± :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  QuotientMap f â†’ (âˆ€ (y : Î²), IsConnected (f â»Â¹' {y})) â†’ IsConnected Î² â†’ IsConnected Î± ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  QuotientMap f â†’\n  (âˆ€ (y : Î²), IsConnected (f â»Â¹' {y})) â†’\n  IsConnected (Set.Range f) â†’\n  IsConnected Set.univ ", "forall {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  QuotientMap f â†’ ConnectedSpace Î² â†’ (âˆ€ (y : Î²), IsConnected (f â»Â¹' {y})) â†’ ConnectedSpace Î± ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  QuotientMap f â†’ (âˆ€ (y : Î²), IsConnected (f â»Â¹' {y})) â†’ IsConnected Î² â†’ IsConnected Î± ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {p : Î± â†’ Î²},\n  QuotientMap p â†’ (âˆ€ (y : Î²), IsConnected (p â»Â¹' {y})) â†’ IsConnected Î² â†’ IsConnected Î± ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  QuotientMap f â†’ (âˆ€ (y : Î²), IsConnected (f â»Â¹' (singleton y))) â†’ IsConnected Î² â†’ IsConnected Î± ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X â†’ Y},\n  QuotientMap p â†’ (âˆ€ (y : Y), IsConnected (p â»Â¹' {y})) â†’ IsConnected Y â†’ IsConnected X ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  QuotientMap f â†’ (âˆ€ (y : Î²), IsConnected (f â»Â¹' {y})) â†’ IsConnected Î² â†’ IsConnected Î± ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {p : Î± â†’ Î²},\n  QuotientMap p â†’ ConnectedSpace Î² â†’ (âˆ€ (y : Î²), IsConnected (p â»Â¹' {y})) â†’ ConnectedSpace Î± ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X â†’ Y},\n  QuotientMap p â†’ (âˆ€ (y : Y), IsConnected (p â»Â¹' {y})) â†’ IsConnected Y â†’ IsConnected X "]}
{"docString": "Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.)", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] {x : Î±}, Continuous fun f => â†‘f x\",\n  \"isProp\": true,\n  \"docString\": \"When `x` is fixed, `(f : Î± â†’áµ‡ Î²) â†¦ f x` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±} {x y : Î±},\\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) â†’ ContinuousAt f y â†’ Function.IsFixedPt f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\\nthen `y` is a fixed point for `f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsFixedPt f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt (f âˆ˜ g) x â†’ Function.IsFixedPt g x â†’ Function.IsFixedPt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f âˆ˜ g` and `g`, then it is a fixed point of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : DecidableEq Î¹] (i : Î¹),\\n  Continuous fun f => Function.update f.fst i f.snd\",\n  \"isProp\": true,\n  \"docString\": \"`Function.update f i x` is continuous in `(f, x)`. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"}]\n", "prompt_cons": "/-- When `x` is fixed, `(f : Î± â†’áµ‡ Î²) â†¦ f x` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] {x : Î±}, Continuous fun f => â†‘f x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\nthen `y` is a fixed point for `f`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±} {x y : Î±},\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) â†’ ContinuousAt f y â†’ Function.IsFixedPt f y :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x :=\n\n/-- If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. -/\ntheorem âˆ€ {Î± : Type u} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsFixedPt f^[n] x :=\n\n/-- If `x` is a fixed point of `f âˆ˜ g` and `g`, then it is a fixed point of `f`. -/\ntheorem âˆ€ {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt (f âˆ˜ g) x â†’ Function.IsFixedPt g x â†’ Function.IsFixedPt f x :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- `Function.update f i x` is continuous in `(f, x)`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : DecidableEq Î¹] (i : Î¹),\n  Continuous fun f => Function.update f.fst i f.snd :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c :=\n\n/-- Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.) -/\ntheorem", "choices": ["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {f : X â†’ X},\n  Continuous f â†’ âˆƒ x, f x = x ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : ConditionallyCompleteLinearOrder X] [inst_2 : OrderTopology X]\n  {f : X â†’ X}, Continuous f â†’ X = Set.Icc (0 : â„) 1 â†’ âˆƒ x, f x = x ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LinearOrder X] [inst_2 : OrderClosedTopology X]\n  {f : X â†’ X}, Continuous f â†’ X = Set.Icc (0 : X) 1 â†’ âˆƒ x, f x = x ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LinearOrder X] [inst_2 : OrderClosedTopology X] {f : X â†’ X},\n  Continuous f â†’ X = Set.Icc (0 : â„) 1 â†’ âˆƒ x, f x = x ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LinearOrderedAddCommGroup X] [inst_2 : OrderTopology X]\n  {f : X â†’ X}, Continuous f â†’ X = Set.Icc (0 : X) 1 â†’ âˆƒ x, x âˆˆ Set.Icc (0 : X) 1 âˆ§ f x = x ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : ConditionallyCompleteLinearOrder Î±] [inst_2 : OrderTopology Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ HasSubset.Subset (Set.Icc (0 : Î±) 1) (Function.fixedPoints f) â†’ âˆƒ x, x âˆˆ Set.Icc (0 : Î±) 1 âˆ§ Function.IsFixedPt f x ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderClosedTopology Î±],\n  {f : Î± â†’ Î±} (hf : Continuous f) (hâ‚€ : f 0 â‰¤ 0) (hâ‚ : f 1 â‰¥ 1), âˆƒ x, f x = x ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f : X â†’ X},\n  Continuous f â†’ (âˆ€ x : X, 0 â‰¤ x â†’ x â‰¤ 1) â†’ âˆƒ x : X, f x = x ", "âˆ€ {X : Type u} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst_2 : OrderTopology X] {f : X â†’ X},\n  Continuous f â†’ X = Set.Icc (0 : â„) 1 â†’ âˆƒ x, f x = x ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : LinearOrder X] [inst_2 : OrderClosedTopology X] {f : X â†’ X},\n  Continuous f â†’ X = Set.Icc (0 : â„) 1 â†’ âˆƒ x, f x = x "]}
{"docString": "Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological additive group `G` with normal additive subgroup\\n`N`, `0 : G â§¸ N` has a countable neighborhood basis.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"}]\n", "prompt_cons": "/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\ncountable neighborhood basis. -/\ntheorem âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- In a first countable topological additive group `G` with normal additive subgroup\n`N`, `0 : G â§¸ N` has a countable neighborhood basis. -/\ntheorem âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component 1) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (IsConnected.Component (Group.closure {1})) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.componentOfTopGroup G) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G], Subgroup.Normal (ComponentWithGroup G) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G], Subgroup.Normal (TopologicalGroup.component G) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.closure (ConnectedComponent 1)) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G], Subgroup.Normal (Subgroup.component (1 : G)) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Set.Components (Group.topologicalClosure (singleton 1))) "]}
{"docString": "Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact.", "prompts": "[{\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\": \"âˆ€ {X Y : Profinite} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of profinite spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  ClosedEmbedding f â†’ âˆ€ {K : Set Î²}, IsCompact K â†’ IsCompact (f â»Â¹' K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a compact set under a closed embedding is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\": \"âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²]\\n  (f : CocompactMap Î± Î²) â¦ƒs : Set Î²â¦„, IsCompact s â†’ IsCompact (â†‘f â»Â¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact\\ncontinuous map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"}]\n", "prompt_cons": "/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem âˆ€ {X Y : Profinite} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- The preimage of a compact set under a closed embedding is a compact set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  ClosedEmbedding f â†’ âˆ€ {K : Set Î²}, IsCompact K â†’ IsCompact (f â»Â¹' K) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f :=\n\n/-- If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact\ncontinuous map. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²]\n  (f : CocompactMap Î± Î²) â¦ƒs : Set Î²â¦„, IsCompact s â†’ IsCompact (â†‘f â»Â¹' s) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsClosedMap f â†’ Continuous f â†’ Function.Surjective f â†’ (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’ CompactSpace Î² â†’ CompactSpace Î± ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ Function.Surjective f â†’ ClosedEmbedding f â†’ (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’ IsCompact Î² â†’ IsCompact Î± ", "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {f : X â†’ Y}, IsClosedMap f â†’ Continuous f â†’ Function.Surjective f â†’\n  (âˆ€ y : Y, IsCompact (f â»Â¹' {y})) â†’ CompactSpace Y â†’ CompactSpace X ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsClosedMap f â†’ Continuous f â†’ Function.Surjective f â†’ (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’ IsCompact (univ : Set Î²) â†’\n    IsCompact (univ : Set Î±) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ Function.Surjective f â†’ IsClosedMap f â†’ (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’\n  IsCompact (univ : Set Î±) â†’ IsCompact (univ : Set Î²) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  ClosedContinuousSurjectiveCompactFiber f â†’ CompactSpace Î² â†’ CompactSpace Î± ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ ClosedEmbedding f â†’ Function.Surjective f â†’\n  (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’ IsCompact (univ : Set Î²) â†’ IsCompact (univ : Set Î±) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ ClosedEmbedding f â†’ Function.Surjective f â†’\n  (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’ IsCompact (univ : Set Î²) â†’ IsCompact (univ : Set Î±) ", "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X â†’ Y},\n  IsClosedMap p â†’ Continuous p â†’ Function.Surjective p â†’ (âˆ€ (y : Y), IsCompact (p â»Â¹' {y})) â†’\n  IsCompact Y â†’ IsCompact X ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ Function.Surjective f â†’ (âˆ€ y : Î², IsCompact (f â»Â¹' {y})) â†’ IsCompact.Univ Î² â†’ IsCompact.Univ Î± "]}
{"docString": "A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], T1Space (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a `T1Space` space is a `T1Space`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"}]\n", "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- A compact discrete space is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î± :=\n\n/-- The one point compactification of a `T1Space` space is a `T1Space`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], T1Space (OnePoint X) :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompact Î± â†” LimitPointCompact Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompact Î± â†” LimitPointCompact Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±],\n  CountablyCompactSpace Î± â†” LimitPointCompactSpace Î± "]}
{"docString": "Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Isometry â†‘Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The embedding of a metric space in its completion is an isometry. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ UniformInducing f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform inducing map \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : EMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from an emetric space is injective \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†” âˆ€ (x y : Î±), dist (f x) (f y) = dist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"On pseudometric spaces, a map is an isometry if and only if it preserves distances. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {f : Î± â†’ Î²} (h : Embedding f),\\n  Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"An embedding from a topological space to a metric space is an isometry with respect to the\\ninduced metric space structure on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : MetricSpace Î²] {f : Î± â†’ Î²} (h : UniformEmbedding f),\\n  Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform embedding from a uniform space to a metric space is an isometry with respect to the\\ninduced metric space structure on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î³ : Type w} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : EMetricSpace Î³] {f : Î± â†’ Î³},\\n  Isometry f â†’ ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"An isometry from a complete emetric space is a closed embedding \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"}]\n", "prompt_cons": "/-- The embedding of a metric space in its completion is an isometry. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Isometry â†‘Î± :=\n\n/-- An isometry from a metric space is a uniform inducing map -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ UniformInducing f :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ UniformContinuous f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- An isometry from an emetric space is injective -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : EMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ Function.Injective f :=\n\n/-- On pseudometric spaces, a map is an isometry if and only if it preserves distances. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†” âˆ€ (x y : Î±), dist (f x) (f y) = dist x y :=\n\n/-- An embedding from a topological space to a metric space is an isometry with respect to the\ninduced metric space structure on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {f : Î± â†’ Î²} (h : Embedding f),\n  Isometry f :=\n\n/-- A uniform embedding from a uniform space to a metric space is an isometry with respect to the\ninduced metric space structure on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : MetricSpace Î²] {f : Î± â†’ Î²} (h : UniformEmbedding f),\n  Isometry f :=\n\n/-- An isometry from a complete emetric space is a closed embedding -/\ntheorem âˆ€ {Î± : Type u} {Î³ : Type w} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : EMetricSpace Î³] {f : Î± â†’ Î³},\n  Isometry f â†’ ClosedEmbedding f :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism. -/\ntheorem", "choices": ["âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompactSpace X] {f : X â†’ X},\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism f ", "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompactSpace X] {f : X â†’ X},\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism f ", "forall {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±] {f : Î± â†’ Î±},\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism f Î± Î± ", "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompactSpace X] {f : X â†’ X},\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism X X ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompactSpace X] (f : X â†’ X),\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism X X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X â†’ X},\n  Isometry f âˆ§ CompactSpace X â†’ Function.Bijective f âˆ§ Homeomorphism X X ", "forall {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±] {f : Î± â†’ Î±},\n  Isometry f â†’ Function.Bijective f âˆ§ IsHomeomorphism f ", "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompactSpace X] {f : X â†’ X},\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism X X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X â†’ X} (h : Isometry f),\n  CompactSpace X â†’ Function.Bijective f âˆ§ Homeomorphism f ", "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : CompactSpace Î±] {f : Î± â†’ Î±},\n  Isometry f â†’ Function.Bijective f âˆ§ Homeomorphism f Î± Î± "]}
{"docString": "Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)}, TendstoLocallyUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’ Filter.Tendsto F p (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Locally uniform convergence implies convergence in the compact-open topology. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  Â¬Continuous â†‘CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\\n  (s : Set Î²),\\n  IsCompact s â†’\\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\\n      IsClosed A â†’\\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\\n  Disjoint (nhds x) (Filter.cocompact Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"}]\n", "prompt_cons": "/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ :=\n\n/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)}, TendstoLocallyUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’ Filter.Tendsto F p (nhds f) :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  Â¬Continuous â†‘CofiniteTopology.of.symm :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\n  (s : Set Î²),\n  IsCompact s â†’\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\n      IsClosed A â†’\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A :=\n\n/-- In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\n  Disjoint (nhds x) (Filter.cocompact Î±) :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : (i : Î¹) â†’ ChartedSpace â„ (Ï€ i)]\n  [inst_2 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_3 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  Â¬LocallyCompactSpace (UniformSpace.toTopologicalSpace ((i : Î¹) â†’ Ï€ i)) ", "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)]\n  [inst_2 : âˆ€ (i : Î¹), UnitIntervalSpace (Ï€ i)] [inst_3 : âˆ€ (i : Î¹), UniformSpace (Ï€ i)]\n  [inst_4 : âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology (Ï€ i)],\n  Â¬LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Infinite Î±] [inst_2 : UniformSpace Î±] [inst_3 : CompleteSpace Î±]\n  [inst_4 : Discrete_topology Î±], Â¬LocallyCompactSpace (Î± â†’ â„) ", "âˆ€ {Î¹ : Type u_1} [inst : TopologicalSpace â„] [inst_1 : LocallyCompactSpace â„] [inst_2 : CompactSpace â„],\n  Â¬LocallyCompactSpace ((i : Î¹) â†’ â„) ", "forall {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)]\n  [inst_2 : (i : Î¹) â†’ UniformSpace (Ï€ i)] [inst_3 : âˆ€ (i : Î¹), UniformSpace.Completion (Ï€ i)] [inst_4 : âˆ€ (i : Î¹), CompleteSpace (Ï€ i)]\n  [inst_5 : âˆ€ (i : Î¹), SeparatedSpace (Ï€ i)],\n  Â¬LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) ", "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)]\n  [inst_2 : (i : Î¹) â†’ UniformSpace (Ï€ i)] [inst_3 : âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology (Ï€ i)],\n  Â¬LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) ", "âˆ€ {Î² : Type u_1} [inst : UniformSpace Î²] [inst_1 : CompactSpace Î²] [inst_2 : T2Space Î²],\n  Â¬LocallyCompactSpace (â„• â†’â‚€ Î²) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompactSpace Î±] [inst_3 : T2Space Î±],\n  Â¬LocallyCompactSpace (ProductSpace Î± â„•) ", "not_locally_compact_of_uniform_space [0 1]Ï‰ : Â¬LocallyCompactSpace (Set.Icc (0 : â„) 1)Ï‰ ", "forall {Î¹ : Type u_1} [inst : TopologicalSpace Î¹] [inst_1 : Nonempty Î¹] [inst_2 : Infinite Î¹] [inst_3 : CompactSpace Î¹]\n  [inst_4 : T2Space Î¹] [inst_5 : TopologicalSpace.SecondCountableTopology Î¹],\n  Â¬LocallyCompactSpace (Î¹ â†’ â„) "]}
{"docString": "Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²},\\n  Dense s â†’ Dense t â†’ Dense (s Ã—Ë¢ t)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two dense sets is a dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : Finite Î¹]\\n  [inst_2 : âˆ€ (i : Î¹), DiscreteTopology (Ï€ i)], DiscreteTopology ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"A finite product of discrete spaces is discrete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"}]\n", "prompt_cons": "/-- There exists a countable dense set. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- The product of two dense sets is a dense set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²},\n  Dense s â†’ Dense t â†’ Dense (s Ã—Ë¢ t) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- A finite product of discrete spaces is discrete. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : Finite Î¹]\n  [inst_2 : âˆ€ (i : Î¹), DiscreteTopology (Ï€ i)], DiscreteTopology ((i : Î¹) â†’ Ï€ i) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ s, Set.Countable s âˆ§ Dense s ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ D : Set ((i : Î¹) â†’ X i), Set.Countable D âˆ§ Dense D ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ D : Set ((i : Î¹) â†’ X i), Set.Countable D âˆ§ Dense D ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : Countable Î¹]\n  [inst_2 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)], TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ s, Set.Countable s âˆ§ Dense s ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ s, Set.Countable s âˆ§ Dense s ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [t : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_1 : Countable Î¹],\n  âˆƒ s, Set.Countable s âˆ§ Dense s ", "theorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ s : Set ((i : Î¹) â†’ X i), Set.Countable s âˆ§ Dense s ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ D : Set ((i : Î¹) â†’ X i), Set.Countable D âˆ§ Dense D ", "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  âˆƒ s, Set.Countable s âˆ§ Dense s "]}
{"docString": "Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T25Space Î±] â¦ƒx y : Î±â¦„,\\n  x â‰  y â†’ Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a Tâ‚‚.â‚… space, their filters of closed neighborhoods are\\ndisjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\\n  IsClosed s â†’ Â¬a âˆˆ s â†’ Disjoint (nhdsSet s) (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\\nneighborhoods.  \"}]\n", "prompt_cons": "/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- Given two distinct points in a Tâ‚‚.â‚… space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T25Space Î±] â¦ƒx y : Î±â¦„,\n  x â‰  y â†’ Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\nneighborhoods. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\n  IsClosed s â†’ Â¬a âˆˆ s â†’ Disjoint (nhdsSet s) (nhds a) :=\n\n/-- Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint. -/\ntheorem", "choices": ["âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ Uâ‚,\n    Uâ‚ âˆˆ nhds x âˆ§\n      âˆƒ Vâ‚,\n        Vâ‚ âˆˆ nhds y âˆ§\n          IsClosed Uâ‚ âˆ§ IsClosed Vâ‚ âˆ§ Disjoint Uâ‚ Vâ‚ ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds y âˆ§ Closure Uâ‚ âˆ© Closure Vâ‚ = âˆ… ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ x âˆˆ U âˆ§ y âˆˆ V âˆ§ Disjoint (closure U) (closure V) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : RegularSpace Î±] {x y : Î±},\n  x â‰  y â†’ âˆƒ u v, u âˆˆ nhds x âˆ§ v âˆˆ nhds y âˆ§ IsClosed (closure u) âˆ§ IsClosed (closure v) âˆ§ Disjoint (closure u) (closure v) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint (closure u) (closure v) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ x âˆˆ U âˆ§ y âˆˆ V âˆ§ Disjoint (closure U) (closure V) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ x âˆˆ U âˆ§ y âˆˆ V âˆ§ Disjoint (closure U) (closure V) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ U V, x âˆˆ U âˆ§ y âˆˆ V âˆ§ IsOpen U âˆ§ IsOpen V âˆ§ IsClosed Uá¶œ âˆ§ IsClosed Vá¶œ âˆ§ Disjoint U V ", "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x â‰  y â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ x âˆˆ U âˆ§ y âˆˆ V âˆ§ Disjoint (Closure U) (Closure V) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : RegularSpace Î±] {x y : Î±},\n  x â‰  y â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ x âˆˆ U âˆ§ y âˆˆ V âˆ§ Disjoint (closure U) (closure V) "]}
{"docString": "Show that every order topology is regular.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : LinearOrder Î²] [t : TopologicalSpace Î²]\\n  [inst_2 : OrderTopology Î²] {f : Î± â†’ Î²},\\n  StrictMono f â†’ Set.OrdConnected (Set.range f) â†’ TopologicalSpace.induced f t = Preorder.topology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced by a strictly monotone function with order-connected range is the preorder\\ntopology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  Inducing f â†’ tÎ± = TopologicalSpace.induced f tÎ²\",\n  \"isProp\": true,\n  \"docString\": \"The topology on the domain is equal to the induced topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LinearOrder Î±] [inst_1 : LinearOrder Î²] [inst_2 : Encodable Î±]\\n  [inst_3 : DenselyOrdered Î±] [inst_4 : NoMinOrder Î±] [inst_5 : NoMaxOrder Î±] [inst_6 : Nonempty Î±]\\n  [inst_7 : Encodable Î²] [inst_8 : DenselyOrdered Î²] [inst_9 : NoMinOrder Î²] [inst_10 : NoMaxOrder Î²]\\n  [inst_11 : Nonempty Î²], Nonempty (Î± â‰ƒo Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two countable dense, nonempty linear orders without endpoints are order isomorphic. \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is Tâ‚…. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : LowerTopology Î±], T0Space Î±\",\n  \"isProp\": true,\n  \"docString\": \"The lower topology on a partial order is Tâ‚€. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\\n  {n k â„“ Î¼ : â„•},\\n  SimpleGraph.IsSRGWith G n k â„“ Î¼ â†’ SimpleGraph.IsSRGWith Gá¶œ n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a strongly regular graph is strongly regular. \"}]\n", "prompt_cons": "/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- The topology induced by a strictly monotone function with order-connected range is the preorder\ntopology. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : LinearOrder Î²] [t : TopologicalSpace Î²]\n  [inst_2 : OrderTopology Î²] {f : Î± â†’ Î²},\n  StrictMono f â†’ Set.OrdConnected (Set.range f) â†’ TopologicalSpace.induced f t = Preorder.topology Î± :=\n\n/-- The topology on the domain is equal to the induced topology. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Inducing f â†’ tÎ± = TopologicalSpace.induced f tÎ² :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LinearOrder Î±] [inst_1 : LinearOrder Î²] [inst_2 : Encodable Î±]\n  [inst_3 : DenselyOrdered Î±] [inst_4 : NoMinOrder Î±] [inst_5 : NoMaxOrder Î±] [inst_6 : Nonempty Î±]\n  [inst_7 : Encodable Î²] [inst_8 : DenselyOrdered Î²] [inst_9 : NoMinOrder Î²] [inst_10 : NoMaxOrder Î²]\n  [inst_11 : Nonempty Î²], Nonempty (Î± â‰ƒo Î²) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚…. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€ :=\n\n/-- The lower topology on a partial order is Tâ‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : LowerTopology Î±], T0Space Î± :=\n\n/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\n  {n k â„“ Î¼ : â„•},\n  SimpleGraph.IsSRGWith G n k â„“ Î¼ â†’ SimpleGraph.IsSRGWith Gá¶œ n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“)) :=\n\n/-- Show that every order topology is regular. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : OrderTopology Î±], RegularSpace Î± ", "forall {X : Type u_1} [inst : Preorder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "âˆ€ {Î± : Type u_1} [Inst : PartialOrder Î±] [Inst_1 : TopologicalSpace Î±] [Inst : OrderTopology Î±], RegularSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : OrderTopology Î±], RegularSpace Î± ", "âˆ€ {X : Type u_1} [inst : PartialOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PartialOrder Î±] [inst_2 : OrderTopology Î±], RegularSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±], RegularSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±], RegularSpace Î± ", "âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X "]}
{"docString": "Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty s â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ Set.Nonempty t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {x y : TopologicalSpace.NonemptyCompacts Î±}, dist x y = Metric.hausdorffDist â†‘x â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance on `NonemptyCompacts Î±` is the Hausdorff distance, by construction \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : âˆ€ (j : J), Nonempty â†‘(F.obj j)]\\n  [inst_3 : âˆ€ (j : J), CompactSpace â†‘(F.obj j)] [inst_4 : âˆ€ (j : J), T2Space â†‘(F.obj j)],\\n  Nonempty â†‘(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"}]\n", "prompt_cons": "/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\n  Set.Nonempty s â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ Set.Nonempty t :=\n\n/-- The distance on `NonemptyCompacts Î±` is the Hausdorff distance, by construction -/\ntheorem âˆ€ {Î± : Type u} [inst : MetricSpace Î±] {x y : TopologicalSpace.NonemptyCompacts Î±}, dist x y = Metric.hausdorffDist â†‘x â†‘y :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : âˆ€ (j : J), Nonempty â†‘(F.obj j)]\n  [inst_3 : âˆ€ (j : J), CompactSpace â†‘(F.obj j)] [inst_4 : âˆ€ (j : J), T2Space â†‘(F.obj j)],\n  Nonempty â†‘(TopCat.limitCone F).pt :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s } :=\n\n/-- Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] [inst_1 : âˆ€ a, TopologicalSpace (Î± a)] [inst_2 : âˆ€ a, Nonempty (Î± a)]\n  (f : Î± â†’ Î²) (h : T2Space (Pi.TopologicalSpace Î±)) (a : Î±), T2Space (TopologicalSpace Î± a) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)]\n  [inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)] [inst_2 : T2Space ((i : Î¹) â†’ Î± i)] (i : Î¹), T2Space (Î± i) ", "âˆ€ {Î± : Type u_1} {Î² : Î± â†’ Type u_2} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)]\n  [inst_1 : (a : Î±) â†’ Nonempty (Î² a)] {x : Î±},\n  T2Space (Î  (a : Î±), Î² a) â†’ T2Space (Î² x) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)]\n  [inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)] [inst_2 : T2Space (Î  (i : Î¹), Î± i)] (i : Î¹),\n  T2Space (Î± i) ", "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type u_1} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] [inst_1 : âˆ€ (a : Î±), Nonempty (Î² a)]\n  [inst_2 : T2Space (Î  (a : Î±), Î² a)] (a : Î±), T2Space (Î² a) ", "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] [inst_1 : âˆ€ (Î± : Î±), Nonempty (Î² Î±)]\n  [inst_2 : T2Space (Î  (a : Î±), Î² a)] (i : Î±), T2Space (Î² i) ", "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] [inst_1 : âˆ€ (a : Î±), Nonempty (Î² a)] {h : Î±},\n  T2Space (âˆ (a : Î±), Î² a) â†’ T2Space (Î² h) ", "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} [inst : (x : Î±) â†’ TopologicalSpace (Î² x)] [inst_1 : âˆ€ (x : Î±), Nonempty (Î² x)]\n  [inst_2 : T2Space (Î  (a : Î±), Î² a)], (x : Î±) â†’ T2Space (Î² x) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace (Î± i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)]\n  [inst_2 : T2Space (Î  (i : Î¹), Î± i)] (i : Î¹), T2Space (Î± i) ", "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {X : Î¹ â†’ Type u} [inst_1 : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_2 : (i : Î¹) â†’ Nonempty (X i)] [inst_3 : T2Space (Pi.TopologicalSpace X)],\n  (i : Î¹) â†’ T2Space (X i) "]}
{"docString": "Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them\\nare nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {f : Filter Î±} {g : Filter Î²} {h : Filter Î³}\\n  {k : Filter Î´},\\n  Filter.map (fun p => ((p.fst.fst, p.snd.fst), p.fst.snd, p.snd.snd)) ((f Ã—Ë¢ g) Ã—Ë¢ h Ã—Ë¢ k) = (f Ã—Ë¢ h) Ã—Ë¢ g Ã—Ë¢ k\",\n  \"isProp\": true,\n  \"docString\": \"A useful lemma when dealing with uniformities. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Multiset Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Multiset Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Mul Î±] [inst_2 : ContinuousMul Î±], ContinuousMul Î±áµáµ’áµ–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„},\\n  0 â‰¤ M â†’ (âˆ€ (x : E), â€–xâ€– â‰  0 â†’ â€–â†‘f xâ€– â‰¤ M * â€–xâ€–) â†’ â€–fâ€– â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MeasureTheory.SigmaFinite Î¼]\\n  (P : Î± â†’ Prop),\\n  (âˆ€ (s : Set Î±), MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ âˆ€áµ (x : Î±) âˆ‚MeasureTheory.Measure.restrict Î¼ s, P x) â†’\\n    âˆ€áµ (x : Î±) âˆ‚Î¼, P x\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for almost all `x` w.r.t. a Ïƒ-finite measure, it is sufficient to show that\\nthis holds almost everywhere in sets where the measure has finite value. \"}]\n", "prompt_cons": "/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s } :=\n\n/-- If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0 :=\n\n/-- A useful lemma when dealing with uniformities. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {f : Filter Î±} {g : Filter Î²} {h : Filter Î³}\n  {k : Filter Î´},\n  Filter.map (fun p => ((p.fst.fst, p.snd.fst), p.fst.snd, p.snd.snd)) ((f Ã—Ë¢ g) Ã—Ë¢ h Ã—Ë¢ k) = (f Ã—Ë¢ h) Ã—Ë¢ g Ã—Ë¢ k :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- If `Î±` is countable, then so is `Multiset Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Multiset Î±) :=\n\n/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Mul Î±] [inst_2 : ContinuousMul Î±], ContinuousMul Î±áµáµ’áµ– :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„},\n  0 â‰¤ M â†’ (âˆ€ (x : E), â€–xâ€– â‰  0 â†’ â€–â†‘f xâ€– â‰¤ M * â€–xâ€–) â†’ â€–fâ€– â‰¤ M :=\n\n/-- To prove something for almost all `x` w.r.t. a Ïƒ-finite measure, it is sufficient to show that\nthis holds almost everywhere in sets where the measure has finite value. -/\ntheorem âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MeasureTheory.SigmaFinite Î¼]\n  (P : Î± â†’ Prop),\n  (âˆ€ (s : Set Î±), MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ âˆ€áµ (x : Î±) âˆ‚MeasureTheory.Measure.restrict Î¼ s, P x) â†’\n    âˆ€áµ (x : Î±) âˆ‚Î¼, P x :=\n\n/-- Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [_inst_1 : (i : Î¹) â†’ TopologicalSpace (Î± i)]\n  [_inst_2 : TopologicalSpace.NormalSpace (Î  (i : Î¹), Î± i)] (I : Nonempty Î¹),\n  âˆ€ (i : Î¹), TopologicalSpace.NormalSpace (Î± i) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace (Î± i)]\n  [inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)], T2Space (Î  (i : Î¹), Î± i) â†’ âˆ€ (i : Î¹), T2Space (Î± i) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace $ Î± i] [inst_1 : âˆ€ (i : Î¹), Nonempty $ Î± i]\n  [inst_2 : NormalSpace $ Î  i, Î± i] (i : Î¹), NormalSpace $ Î± i ", "âˆ€ {Î¹ : Type u_1} (Î± : Î¹ â†’ Type u_2) [_inst_1 : âˆ€ i, TopologicalSpace (Î± i)] [_inst_2 : âˆ€ i, Nonempty (Î± i)]\n  [_inst_3 : T2Space (Î  (i : Î¹), Î± i)] [_inst_4 : NormalSpace (Î  (i : Î¹), Î± i)], âˆ€ i, NormalSpace (Î± i) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)]\n  [inst_2 : NormalSpace (Î  (i : Î¹), Î± i)] (i : Î¹), NormalSpace (Î± i) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : (i : Î¹) â†’ Nonempty (Î± i)]\n  [inst_2 : T2Space (Î  (i : Î¹), Î± i)], (âˆ€ i, T2Space (Î± i)) ", "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î¹] [inst_2 : NormalSpace (Î¹ â†’ Î±)]\n  [inst_3 : Nonempty Î±] [inst_4 : âˆ€ i, Nonempty (X i)] {X : Î¹ â†’ Set Î±},\n  NormalSpace (X i) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : NormalSpace (Î± Ã— Î²)]\n  [inst_3 : Nonempty Î±] [inst_4 : Nonempty Î²], NormalSpace Î± ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : âˆ€ i, Nonempty (Î± i)],\n  TopologicalSpace.Normal ((i : Î¹) â†’ Î± i) â†’ âˆ€ i, TopologicalSpace.Normal (Î± i) ", "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : âˆ€i, Nonempty (Î± i)],\n  Normal ((i : Î¹) â†’ Î± i) â†’ âˆ€ (i : Î¹), Normal (Î± i) "]}
{"docString": "Show that every locally compact Hausdorff space is completely regular.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\": \"CompleteSpace GromovHausdorff.GHSpace\",\n  \"isProp\": true,\n  \"docString\": \"The Gromov-Hausdorff space is complete. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"}]\n", "prompt_cons": "/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼) :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î± :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H :=\n\n/-- The Gromov-Hausdorff space is complete. -/\ntheorem CompleteSpace GromovHausdorff.GHSpace :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- Show that every locally compact Hausdorff space is completely regular. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  CompletelyRegularSpace Î± "]}
{"docString": "Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners â„ E H â†’\\n    âˆ€ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Ïƒ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Urysohn's metrization theorem* (Tychonoff's version): a Tâ‚ƒ topological space with second\\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\\nsame topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"}]\n", "prompt_cons": "/-- A Ïƒ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners â„ E H â†’\n    âˆ€ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± Ã— Î²) :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- *Urysohn's metrization theorem* (Tychonoff's version): a Tâ‚ƒ topological space with second\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\nsame topology. -/\ntheorem âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  TopologicalSpace.MetrizableSpace X :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V) :=\n\n/-- Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable. -/\ntheorem", "choices": ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  {X_1 X_2 : Set X} [sub_inst_1 : TopologicalSpace X_1] [sub_inst_2 : TopologicalSpace X_2]\n  (hX : X = X_1 âˆª X_2) (hX_1 : IsClosed X_1) (hX_2 : IsClosed X_2)\n  [sub_inst_3 : TopologicalSpace.MetrizableSpace X_1] [sub_inst_4 : TopologicalSpace.MetrizableSpace X_2],\n  TopologicalSpace.MetrizableSpace X ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  âˆ€ (Xâ‚ Xâ‚‚ : Set Î±) [inst_3 : TopologicalSpace.MetrizableSpace (â†¥Xâ‚)] [inst_4 : TopologicalSpace.MetrizableSpace (â†¥Xâ‚‚)],\n  IsClosed Xâ‚ â†’ IsClosed Xâ‚‚ â†’ Î± = Xâ‚ âˆª Xâ‚‚ â†’ TopologicalSpace.MetrizableSpace Î± ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {Xâ‚ Xâ‚‚ : Set X} [inst_3 : TopologicalSpace.MetrizableSpace (â†¥Xâ‚)] [inst_4 : TopologicalSpace.MetrizableSpace (â†¥Xâ‚‚)],\n  IsClosed Xâ‚ â†’ IsClosed Xâ‚‚ â†’ X = Xâ‚ âˆª Xâ‚‚ â†’ TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X],\n  âˆ€ (Xâ‚ Xâ‚‚ : Set X) [inst_3 : TopologicalSpace.Subtype Xâ‚] [inst_4 : TopologicalSpace.MetrizableSpace Xâ‚]\n    [inst_5 : TopologicalSpace.Subtype Xâ‚‚] [inst_6 : TopologicalSpace.MetrizableSpace Xâ‚‚],\n  IsClosed Xâ‚ â†’ IsClosed Xâ‚‚ â†’ X = Xâ‚ âˆª Xâ‚‚ â†’ TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {Xâ‚ Xâ‚‚ : Set X} [inst_3 : TopologicalSpace.SubspaceTopology Xâ‚] [inst_4 : TopologicalSpace.SubspaceTopology Xâ‚‚]\n  [inst_5 : TopologicalSpace.MetrizableSpace Xâ‚] [inst_6 : TopologicalSpace.MetrizableSpace Xâ‚‚],\n  X = Xâ‚ âˆª Xâ‚‚ â†’ IsClosed Xâ‚ â†’ IsClosed Xâ‚‚ â†’ TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X],\n  âˆ€ {X1 X2 : Type u_1} [inst_3 : TopologicalSpace X1] [inst_4 : TopologicalSpace X2] [inst_5 : TopologicalSpace.MetrizableSpace X1]\n    [inst_6 : TopologicalSpace.MetrizableSpace X2],\n  (âˆ€ x : X, x âˆˆ X1 âˆ¨ x âˆˆ X2) â†’\n  (âˆ€ x : X1, IsClosed (singleton x : Set X)) â†’\n  (âˆ€ x : X2, IsClosed (singleton x : Set X)) â†’\n  TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n    {X_1 X_2 : Set X} [inst_3 : TopologicalSpace.MetrizableSpace (â†¥X_1)] [inst_4 : TopologicalSpace.MetrizableSpace (â†¥X_2)],\n  IsClosed X_1 â†’ IsClosed X_2 â†’ X = X_1 âˆª X_2 â†’ TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  (Xâ‚ Xâ‚‚ : Set X) [inst_3 : TopologicalSpace.MetrizableSpace (â†¥Xâ‚)] [inst_4 : TopologicalSpace.MetrizableSpace (â†¥Xâ‚‚)],\n  IsClosed Xâ‚ â†’ IsClosed Xâ‚‚ â†’ X = Xâ‚ âˆª Xâ‚‚ â†’ TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X],\n  âˆ€ {Xâ‚ Xâ‚‚ : Set X} [inst_3 : TopologicalSpace.SubsetTopologicalSpace Xâ‚] [inst_4 : TopologicalSpace.SubsetTopologicalSpace Xâ‚‚],\n    (âˆ€ {x : X} (hx : x âˆˆ Xâ‚), TopologicalSpace.MetrizableSpace (â†¥(Xâ‚ âˆ© Xâ‚‚)) â†’\n      x âˆˆ Xâ‚‚) â†’\n    TopologicalSpace.MetrizableSpace (â†¥Xâ‚) â†’ TopologicalSpace.MetrizableSpace (â†¥Xâ‚‚) â†’ TopologicalSpace.MetrizableSpace X ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  (Xâ‚ Xâ‚‚ : Set X) [sub_instâ‚ : TopologicalSpace (Subtype Xâ‚)] [sub_instâ‚‚ : TopologicalSpace (Subtype Xâ‚‚)]\n  [sub_instâ‚ƒ : T2Space (Subtype Xâ‚)] [sub_instâ‚„ : T2Space (Subtype Xâ‚‚)] [sub_instâ‚… : CompactSpace (Subtype Xâ‚)]\n  [sub_instâ‚† : CompactSpace (Subtype Xâ‚‚)] [sub_instâ‚‡ : TopologicalSpace.MetrizableSpace (Subtype Xâ‚)]\n  [sub_instâ‚ˆ : TopologicalSpace.MetrizableSpace (Subtype Xâ‚‚)], TopologicalSpace.MetrizableSpace X "]}
{"docString": "Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] {Î¹ : Type u_1} [inst_1 : PseudoMetricSpace Î²] (b : â„ â†’ â„),\\n  Filter.Tendsto b (nhds 0) (nhds 0) â†’\\n    âˆ€ (F : Î¹ â†’ Î² â†’ Î±), (âˆ€ (x y : Î²) (i : Î¹), dist (F i x) (F i y) â‰¤ b (dist x y)) â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : CompleteSpace Î²],\\n  CompleteSpace (BoundedContinuousFunction Î± Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Bounded continuous functions taking values in a complete space form a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] {Î¹ : Type u_1} [inst_1 : PseudoMetricSpace Î²]\\n  {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†”\\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î´, Î´ > 0 âˆ§ âˆ€ (x y : Î²), dist x y < Î´ â†’ âˆ€ (i : Î¹), dist (F i x) (F i y) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of uniform equicontinuity for families of functions between\\n(pseudo) metric spaces. \"}]\n", "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] {Î¹ : Type u_1} [inst_1 : PseudoMetricSpace Î²] (b : â„ â†’ â„),\n  Filter.Tendsto b (nhds 0) (nhds 0) â†’\n    âˆ€ (F : Î¹ â†’ Î² â†’ Î±), (âˆ€ (x y : Î²) (i : Î¹), dist (F i x) (F i y) â‰¤ b (dist x y)) â†’ UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- Bounded continuous functions taking values in a complete space form a complete space. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : CompleteSpace Î²],\n  CompleteSpace (BoundedContinuousFunction Î± Î²) :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ UniformContinuous f :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Characterization of uniform equicontinuity for families of functions between\n(pseudo) metric spaces. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] {Î¹ : Type u_1} [inst_1 : PseudoMetricSpace Î²]\n  {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†”\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î´, Î´ > 0 âˆ§ âˆ€ (x y : Î²), dist x y < Î´ â†’ âˆ€ (i : Î¹), dist (F i x) (F i y) < Îµ :=\n\n/-- Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y]\n  {A : Set X} {f : A â†’ Y},\n  UniformContinuous (Set.restrict f A) â†’\n    âˆƒ! (g : Closure A â†’ Y),\n      (Continuous g) âˆ§\n        (UniformContinuous (Set.restrict g (Closure A))) âˆ§\n          (âˆ€ (x : X) (hx : x âˆˆ A), g âŸ¨x, subset_closure hxâŸ© = f x) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {A : Set X} [inst_2 : IsClosed A]\n  [inst_3 : CompleteSpace Y] {f : A â†’ Y},\n  UniformContinuous f â†’\n    (ExistsUnique fun (g : X â†’ Y) =>\n      Continuous g âˆ§\n        (âˆ€ (x : X) (H : x âˆˆ A), g x = f âŸ¨x, HâŸ©) âˆ§ UniformContinuous g) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : CompleteSpace Y] {A : Set X} {f : A â†’ Y},\n  UniformContinuous f â†’\n    âˆƒ! (g : Closure A â†’ Y),\n      Continuous g âˆ§ âˆ€ (x : Closure A) (hx : â†‘x âˆˆ A), â†‘g x = f âŸ¨â†‘x, hxâŸ© âˆ§ UniformContinuous g ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y] {A : Set X}\n  {f : X â†’ Y},\n  UniformContinuous f â†’ Set.Nonempty A â†’ UniqueExtension A f Y ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : CompleteSpace Y] [inst_2 : MetricSpace Y]\n  {A : Set X} {f : A â†’ Y},\n  UniformContinuousOn f A â†’\n    âˆƒ g : Closure A â†’ Y,\n      Continuous g âˆ§ UniformContinuous g âˆ§ âˆ€ (x : X), x âˆˆ A â†’ g (Subtype.mk x (_ : HasMem.Mem x (Closure A))) = f x ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {A : Set X} [inst_2 : CompleteSpace Y],\n  IsClosed A â†’\n    (âˆ€ (f : X â†’ Y) (hf : UniformContinuous (Set.restrict f A)), âˆƒ! g, Continuous g âˆ§ Set.restrict g A = Set.restrict f A) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst_X : MetricSpace X] [inst_Y : MetricSpace Y] [inst_1 : CompleteSpace Y]\n  (A : Set X) (f : A â†’ Y),\n  UniformContinuousOn f A â†’\n    âˆƒ! g, ContinuousOn g (Closure A) âˆ§ âˆ€ (a : A), g (Subtype.mk a _) = f a ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y] {A : Set X} {f : â†¥A â†’ Y},\n  UniformlyContinuous f â†’\n    (âˆƒ! (g : X â†’ Y),\n      Continuous g âˆ§\n        âˆ€ (x : â†¥A), g â†‘x = f x âˆ§\n          âˆ€ (x : X) (y : X), dist x y < UniformContinuityTolerance f â†’ dist (g x) (g y) < UniformContinuityThreshold f) ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y] {A : Set X}\n  (f : A â†’ Y),\n  UniformContinuous (Function.restrict f A) â†’\n    âˆƒ! g, Continuous g âˆ§ âˆ€ (a : X), a âˆˆ A â†’ g a = f a ", "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y] {A : Set X} {f : A â†’ Y},\n  UniformContinuousOn f A â†’\n    (âˆƒ! g : Closure A â†’ Y, Continuous g âˆ§ âˆ€ (x : A), g âŸ¨x, mem_closure_of_mem_open (is_open_interior A) x.2âŸ© = f x) âˆ§\n      UniformContinuousOn (Exists.some _) (Closure A) "]}
{"docString": "Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).", "prompts": "[{\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 3` is `âˆš3 / 2`. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 6` is `âˆš3 / 2`. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 3` is `1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) ^ 2 = 3 / 4\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the sine of `Ï€ / 3` is `3 / 4` (this is sometimes more convenient than the\\nresult for cosine itself). \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a â‰  0 â†’ discrim a b c = 0 â†’ âˆ€ (x : K), a * x * x + b * x + c = 0 â†” x = -b / (2 * a)\",\n  \"isProp\": true,\n  \"docString\": \"Root of a quadratic when its discriminant equals zero \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a â‰  0 â†’\\n    âˆ€ {s : K},\\n      discrim a b c = s * s â†’ âˆ€ (x : K), a * x * x + b * x + c = 0 â†” x = (-b + s) / (2 * a) âˆ¨ x = (-b - s) / (2 * a)\",\n  \"isProp\": true,\n  \"docString\": \"Roots of a quadratic equation. \"}]\n", "prompt_cons": "/-- The sine of `Ï€ / 3` is `âˆš3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- The cosine of `Ï€ / 6` is `âˆš3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- The cosine of `Ï€ / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The square of the sine of `Ï€ / 3` is `3 / 4` (this is sometimes more convenient than the\nresult for cosine itself). -/\ntheorem Real.sin (Real.pi / 3) ^ 2 = 3 / 4 :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Root of a quadratic when its discriminant equals zero -/\ntheorem âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a â‰  0 â†’ discrim a b c = 0 â†’ âˆ€ (x : K), a * x * x + b * x + c = 0 â†” x = -b / (2 * a) :=\n\n/-- Roots of a quadratic equation. -/\ntheorem âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a â‰  0 â†’\n    âˆ€ {s : K},\n      discrim a b c = s * s â†’ âˆ€ (x : K), a * x * x + b * x + c = 0 â†” x = (-b + s) / (2 * a) âˆ¨ x = (-b - s) / (2 * a) :=\n\n/-- Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1). -/\ntheorem", "choices": ["Complex.exp ((2 * Complex.pi * Complex.i) / 3) ^ 3 = 1 ", "(Complex.mk (-1) (Real.sqrt 3)) / 2 ^ 3 = 1 ", "(Complex.mk (-1) (Real.sqrt 3)) / 2 ^ 3 = 1 ", "(Complex.mk (-1) (Real.sqrt 3) / 2) ^ 3 = 1 ", "(Complex.of_real (-1) + Complex.i * Complex.of_real (Real.sqrt 3)) / Complex.of_real 2 ^ 3 = 1 ", "(-1 + Complex.i * Real.sqrt 3) / 2 ^ 3 = 1 ", "Complex.ofReal (-1 + Real.sqrt 3 * I) / 2 ^ (3 : â„•) = 1 ", "(-1 + Complex.I * Real.sqrt 3 / 2) ^ 3 = 1 ", "Complex.mk (-1 / 2) (Real.sqrt 3 / 2) ^ 3 = 1 ", "Complex.of_real (-1 + Real.sqrt 3 * Complex.I) / 2 ^ 3 = 1 "]}
{"docString": "Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  â†‘(quadraticChar F) a = 0 â†” a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The value of the quadratic character on `a` is zero iff `a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `0 : R` equals 0. \"},\n {\"theorem\":\n  \"âˆ€ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\\n  Matrix.Nondegenerate M â†’ âˆ€ {v : m â†’ R}, (âˆ€ (w : m â†’ R), Matrix.dotProduct v (Matrix.mulVec M w) = 0) â†’ v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `M` is nondegenerate and `w â¬ M â¬ v = 0` for all `w`, then `v = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, â†‘v x = âŠ¤ â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, 0 = a * b â†” a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them\\nequals zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_4} (self : AlternatingMap R M N Î¹) (v : Î¹ â†’ M) (i j : Î¹),\\n  v i = v j â†’ i â‰  j â†’ MultilinearMap.toFun (â†‘self) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map is alternating: if `v` has two equal coordinates, then `f v = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±},\\n  Set.EqOn f 0 s â†’ âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i âˆˆ s`\\nequals `0`.\"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’ âˆ€ {a : F}, a â‰  0 â†’ (IsSquare a â†” a ^ (Fintype.card F / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. \"}]\n", "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0 :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  â†‘(quadraticChar F) a = 0 â†” a = 0 :=\n\n/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0 :=\n\n/-- If `M` is nondegenerate and `w â¬ M â¬ v = 0` for all `w`, then `v = 0`. -/\ntheorem âˆ€ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\n  Matrix.Nondegenerate M â†’ âˆ€ {v : m â†’ R}, (âˆ€ (w : m â†’ R), Matrix.dotProduct v (Matrix.mulVec M w) = 0) â†’ v = 0 :=\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, â†‘v x = âŠ¤ â†” x = 0 :=\n\n/-- If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, 0 = a * b â†” a = 0 âˆ¨ b = 0 :=\n\n/-- The map is alternating: if `v` has two equal coordinates, then `f v = 0`. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_4} (self : AlternatingMap R M N Î¹) (v : Î¹ â†’ M) (i j : Î¹),\n  v i = v j â†’ i â‰  j â†’ MultilinearMap.toFun (â†‘self) v = 0 :=\n\n/-- If a function `f` equals `0` on a set `s`, then the product of `f i` over `i âˆˆ s`\nequals `0`. -/\ntheorem âˆ€ {Î± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±},\n  Set.EqOn f 0 s â†’ âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i = 0 :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’ âˆ€ {a : F}, a â‰  0 â†’ (IsSquare a â†” a ^ (Fintype.card F / 2) = 1) :=\n\n/-- Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$. -/\ntheorem", "choices": ["âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0 ", "âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†” a = 0 âˆ¨ v = 0 ", "âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0 ", "âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†” a = 0 âˆ¨ v = 0 ", "âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†” a = 0 âˆ¨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†” a = 0 âˆ¨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  {a : F} {v : V}, a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0 "]}
{"docString": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under subtraction \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"}]\n", "prompt_cons": "/-- A non-unital subring is closed under multiplication. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- A subsemiring is closed under multiplication. -/\ntheorem âˆ€ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- A non-unital subring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- A non-unital subring is closed under subtraction -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- A subfield is closed under multiplication. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$. -/\ntheorem", "choices": ["/-- A non-unital subring is closed under multiplication. -/\ntheorem non_unital_subring_mul_closed {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R} (hx : x âˆˆ s) (hy : y âˆˆ s) : x * y âˆˆ s ", "âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\ntheorem subsemiring_mul_closed {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R} (hx : x âˆˆ s) (hy : y âˆˆ s) : x * y âˆˆ s ", "âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s ", "example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ (c : â„) (x : â„ Ã— â„), x âˆˆ U â†’ (c â€¢ x) âˆˆ U) âˆ§ Â¬(âˆ€ (x y : â„ Ã— â„), x âˆˆ U â†’ y âˆˆ U â†’ x + y âˆˆ U) ", "âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s ", "non_example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ (a : â„) (x : â„ Ã— â„), x âˆˆ U â†’ (a * x) âˆˆ U) âˆ§ Â¬(âˆ€ (x y : â„ Ã— â„), x âˆˆ U â†’ y âˆˆ U â†’ x + y âˆˆ U) ", "nonempty_closed_under_scalar_mul_not_subspace :\n  âˆƒ (U : Set (â„ Ã— â„)), Set.Nonempty U âˆ§ (âˆ€ (c : â„) (x : â„ Ã— â„), x âˆˆ U â†’ (c â€¢ x) âˆˆ U) âˆ§ Â¬ Subspace â„ U ", "example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ (x : â„ Ã— â„) (c : â„), x âˆˆ U â†’ (c â€¢ x) âˆˆ U) âˆ§ Â¬(âˆ€ (x y : â„ Ã— â„), x âˆˆ U â†’ y âˆˆ U â†’ x + y âˆˆ U) ", "example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ (x : â„) (u : â„ Ã— â„), u âˆˆ U â†’ (x * u) âˆˆ U) âˆ§ Â¬Subspace â„ (â„ Ã— â„) ", "example : âˆƒ U : Set (â„ Ã— â„), (âˆ€ x : â„, âˆ€ y : â„ Ã— â„, y âˆˆ U â†’ (x * y) âˆˆ U) âˆ§ Â¬(âˆ€ x y : â„ Ã— â„, x âˆˆ U â†’ y âˆˆ U â†’ x + y âˆˆ U) "]}
{"docString": "Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 â‰¤ s2 â†” âˆ€ (p : P), p âˆˆ s1 â†’ p âˆˆ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is less than or equal to another if and only if all its points are in the second\\nsubspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  (u : â„™ K V), u âˆˆ Projectivization.Subspace.span S â†” âˆ€ (W : Projectivization.Subspace K V), S âŠ† â†‘W â†’ u âˆˆ W\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point in a projective space is contained in the span of a set of points if and only if the\\npoint is contained in all subspaces of the projective space which contain the set of points. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P) (s1 s2 : AffineSubspace k P), p âˆˆ s1 âŠ“ s2 â†” p âˆˆ s1 âˆ§ p âˆˆ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is in the inf of two affine subspaces if and only if it is in both of them. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V},\\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points in projective space is contained in a subspace, and that subspace is\\ncontained in the span of the set of points, then the span of the set of points is equal to\\nthe subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"}]\n", "prompt_cons": "/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- One subspace is less than or equal to another if and only if all its points are in the second\nsubspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 â‰¤ s2 â†” âˆ€ (p : P), p âˆˆ s1 â†’ p âˆˆ s2 :=\n\n/-- A point in a projective space is contained in the span of a set of points if and only if the\npoint is contained in all subspaces of the projective space which contain the set of points. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  (u : â„™ K V), u âˆˆ Projectivization.Subspace.span S â†” âˆ€ (W : Projectivization.Subspace K V), S âŠ† â†‘W â†’ u âˆˆ W :=\n\n/-- A point is in the inf of two affine subspaces if and only if it is in both of them. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P) (s1 s2 : AffineSubspace k P), p âˆˆ s1 âŠ“ s2 â†” p âˆˆ s1 âˆ§ p âˆˆ s2 :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- If a set of points in projective space is contained in a subspace, and that subspace is\ncontained in the span of the set of points, then the span of the set of points is equal to\nthe subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V},\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other. -/\ntheorem", "choices": ["âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Projectivization.Subspace K V},\n  IsSubspace (â†‘Wâ‚ âˆª â†‘Wâ‚‚) â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Projectivization.Subspace K V},\n  IsSubspace (â†‘Wâ‚ âˆª â†‘Wâ‚‚) â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Submodule K V},\n  IsSubmodule (Wâ‚ âˆª Wâ‚‚) â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (W1 W2 : Projectivization.Subspace K V),\n  IsSubspace (â†‘W1 âˆª â†‘W2) â†” W1 â‰¤ W2 âˆ¨ W2 â‰¤ W1 ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Projectivization.Subspace K V},\n  IsAddSubgroup (â†‘(Wâ‚ âŠ” Wâ‚‚)) â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Projectivization.Subspace K V},\n  IsSubspace (â†‘Wâ‚ âˆª â†‘Wâ‚‚) â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s1 s2 : Projectivization.Subspace K V),\n  IsSubspace K (â†‘(s1 âŠ” s2)) â†” s1 â‰¤ s2 âˆ¨ s2 â‰¤ s1 ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Submodule K V},\n  Submodule.span (â†‘Wâ‚ âˆª â†‘Wâ‚‚) = Wâ‚ âŠ” Wâ‚‚ â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Wâ‚ Wâ‚‚ : Projectivization.Subspace K V},\n  IsSubspace (â†‘Wâ‚ âˆª â†‘Wâ‚‚) â†” Wâ‚ â‰¤ Wâ‚‚ âˆ¨ Wâ‚‚ â‰¤ Wâ‚ ", "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (W1 W2 : Projectivization.Subspace K V),\n  IsSubmodule (â†‘W1 âˆª â†‘W2) â†” W1 â‰¤ W2 âˆ¨ W2 â‰¤ W1 "]}
{"docString": "Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from an orthogonal submodule `V` is the zero map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K { x // x âˆˆ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"}]\n", "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K { x // x âˆˆ s } = FiniteDimensional.finrank K V :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$. -/\ntheorem", "choices": ["âˆ€ (K : Type u) {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W] [inst_3 : Module K V] [inst_4 : Module K W]\n  [inst_5 : FiniteDimensional K V] (T : LinearMap K V W),\n  âˆƒ U : Submodule K V, U âŠ“ T.ker = âŠ¥ âˆ§ T.range = LinearMap.rangeRestrict U ", "âˆ€ {ğ•œ : Type u} {V : Type v} {W : Type w}\n  [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  [inst_4 : AddCommGroup W] [inst_5 : Module ğ•œ W] (T : ğ•œ â†’â‚—[ğ•œ] V â†’ W),\n  âˆƒ U : Submodule ğ•œ V, U âŠ“ T.ker = âŠ¥ âˆ§ T.range = LinearMap.rangeRestrict T U ", "âˆ€ {K : Type u} {V : Type v} {W : Type w} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W]\n  [inst_3 : Module K V] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : ContinuousLinearMap K V W),\n  âˆƒ (U : Submodule K V), (U âŠ“ T.ker = âŠ¥) âˆ§ (T.range = ContinuousLinearMap.mapSubmodule T U) ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : AddCommGroup W] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : V â†’â‚—[K] W),\n  âˆƒ (U : Submodule K V), U âŠ“ T.ker = âŠ¥ âˆ§ T.range = LinearMap.rangeRestrict T U ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : AddCommGroup W] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : V â†’â‚—[K] W),\n  âˆƒ U : Submodule K V, U âŠ“ T.ker = âŠ¥ âˆ§ T.range = LinearMap.codRestrict T U (Î» x, âŸ¨T x, x.2âŸ©) ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : AddCommGroup W]\n  [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : LinearMap K V W),\n  âˆƒ U : Submodule K V, U âŠ“ T.ker = âŠ¥ âˆ§ T.range = LinearMap.rangeRestrict T U ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : AddCommGroup W] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V]\n  (T : LinearMap K V W), âˆƒ U : Submodule K V, U âˆ© T.ker = âŠ¥ âˆ§ LinearMap.range T = LinearMap.comp T (Submodule.subtypeL U).range ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W] [inst_3 : Module K V] [inst_4 : Module K W]\n  [inst_5 : FiniteDimensional K V] (T : LinearMap K V W),\n  âˆƒ U : Submodule K V, U âŠ“ T.ker = âŠ¥ âˆ§ T.range = LinearMap.rangeRestrict T U ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : AddCommGroup W] [inst_5 : Module K W] (T : LinearMap K V W),\n  âˆƒ U : Submodule K V,\n    U âˆ© LinearMap.ker T = âŠ¥ âˆ§\n    LinearMap.range T = LinearMap.map T U ", "âˆ€ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W]\n  [inst_3 : Module K V] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : V â†’â‚—[K] W),\n  âˆƒ (U : Submodule K V), (U âŠ“ T.ker = âŠ¥) âˆ§ (T.range = LinearMap.rangeRestrict T U) "]}
{"docString": "Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under addition. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h + g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under addition. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K { x // x âˆˆ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"}]\n", "prompt_cons": "/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼ :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h + g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddRightInvariant Î¼ :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- Affine subspaces are convex. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—® :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K { x // x âˆˆ s } = FiniteDimensional.finrank K V :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$. -/\ntheorem", "choices": ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : V â†’â‚—[K] V) (U : â„• â†’ Submodule K V) (m : â„•),\n  (âˆ€ (i : â„•), i < m â†’ LinearMap.IsInvariantSubspace T (U i)) â†’\n    LinearMap.IsInvariantSubspace T (â¨† (i : â„•) (_ : i < m), U i) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {T : V â†’â‚—[K] V} (U : â„• â†’ Submodule K V),\n  (âˆ€ (i : â„•), Submodule.map T (U i) â‰¤ U i) â†’\n    Submodule.map T (â¨† (i : â„•), U i) â‰¤ â¨† (i : â„•), U i ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V â†’â‚—[K] V}\n  {m : â„•} (U : Finâ‚“ m â†’ Submodule K V),\n  (âˆ€ (i : Finâ‚“ m), âˆ€ (x : V), x âˆˆ U i â†’ T x âˆˆ U i) â†’\n    (âˆ€ (x : V), x âˆˆ (â¨† (i : Finâ‚“ m), U i) â†’ T x âˆˆ (â¨† (i : Finâ‚“ m), U i)) ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V â†’â‚—[K] V}\n  {m : â„•} (U : Finâ‚“ m â†’ Submodule K V),\n  (âˆ€ (i : Finâ‚“ m), âˆ€ (x : V), x âˆˆ U i â†’ T x âˆˆ U i) â†’\n    âˆ€ (x : V), x âˆˆ â¨† (i : Finâ‚“ m), U i â†’ T x âˆˆ â¨† (i : Finâ‚“ m), U i ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : V â†’â‚—[K] V) (U : Î¹ â†’ Submodule K V) (h : âˆ€ (i : Î¹), Submodule.map T (U i) â‰¤ U i),\n  Submodule.map T (â¨† (i : Î¹), U i) â‰¤ â¨† (i : Î¹), U i ", "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : V â†’â‚—[K] V)\n  {m : â„•} (U : Finâ‚“ m â†’ Submodule K V),\n  (âˆ€ (i : Finâ‚“ m), âˆ€ â¦ƒv : Vâ¦„, v âˆˆ U i â†’ â†‘T v âˆˆ U i) â†’\n    âˆ€ â¦ƒv : Vâ¦„, v âˆˆ (U 0 âŠ” â¨† (i : Finâ‚“ (m - 1)), U (Finâ‚“.succ i)) â†’ â†‘T v âˆˆ (U 0 âŠ” â¨† (i : Finâ‚“ (m - 1)), U (Finâ‚“.succ i)) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V â†’â‚—[K] V}\n  (U : â„• â†’ Submodule K V) (h : âˆ€ (i : â„•), Submodule.map T (U i) â‰¤ U i),\n  Submodule.map T (â¨† (i : â„•), U i) â‰¤ â¨† (i : â„•), U i ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V â†’â‚—[K] V}\n  {m : â„•} (U : Finâ‚“ m â†’ Submodule K V),\n  (âˆ€ (i : Finâ‚“ m), âˆ€ (x : V), x âˆˆ U i â†’ T x âˆˆ U i) â†’ âˆ€ (x : V), x âˆˆ (â¨† (i : Finâ‚“ m), U i) â†’ T x âˆˆ (â¨† (i : Finâ‚“ m), U i) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V â†’â‚—[K] V}\n  (U : Î¹ â†’ Submodule K V),\n  (âˆ€ (i : Î¹), âˆ€ (x : V), x âˆˆ U i â†’ T x âˆˆ U i) â†’\n    âˆ€ (x : V), x âˆˆ (â¨† (i : Î¹), U i) â†’ T x âˆˆ (â¨† (i : Î¹), U i) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {T : V â†’â‚—[K] V} {m : â„•} {U : â„• â†’ Submodule K V},\n  (âˆ€ (i : â„•) (x : V), (i â‰¤ m â†’ x âˆˆ U i) â†’ T x âˆˆ U i) â†’\n    âˆ€ (x : V), (x âˆˆ âˆ‘ (i : â„•) (h : i â‰¤ m), U i) â†’ T x âˆˆ âˆ‘ (i : â„•) (h : i â‰¤ m), U i "]}
{"docString": "Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\\n  (âˆ€ (x : V), inner (â†‘S x) x = inner (â†‘T x) x) â†” S = T\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\\nfor all `x`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a Tâ‚€ space are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {Î¼ : R} {k : â„•}, Module.End.HasGeneralizedEigenvalue f Î¼ k â†’ Module.End.HasEigenvalue f Î¼\",\n  \"isProp\": true,\n  \"docString\": \"All generalized eigenvalues are eigenvalues. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  (b : Basis Î¹ R M) {Râ‚ : Type u_2} [inst_3 : Semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Ïƒ' : Râ‚ â†’+* R} [inst_4 : RingHomInvPair Ïƒ Ïƒ']\\n  [inst_5 : RingHomInvPair Ïƒ' Ïƒ] {Mâ‚ : Type u_4} [inst_6 : AddCommMonoid Mâ‚] [inst_7 : Module Râ‚ Mâ‚]\\n  {fâ‚ fâ‚‚ : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚}, (âˆ€ (i : Î¹), â†‘fâ‚ (â†‘b i) = â†‘fâ‚‚ (â†‘b i)) â†’ fâ‚ = fâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear equivs are equal if they are equal on basis vectors. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K) {k : â„•},\\n  FiniteDimensional.finrank K V â‰¤ k â†’\\n    â†‘(Module.End.generalizedEigenspace f Î¼) k = â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {Î¼ : R} {k : â„•}, 0 < k â†’ Module.End.HasEigenvalue f Î¼ â†’ Module.End.HasGeneralizedEigenvalue f Î¼ k\",\n  \"isProp\": true,\n  \"docString\": \"All eigenvalues are generalized eigenvalues. \"}]\n", "prompt_cons": "/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- Two linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\nfor all `x`. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\n  (âˆ€ (x : V), inner (â†‘S x) x = inner (â†‘T x) x) â†” S = T :=\n\n/-- Two inseparable points in a Tâ‚€ space are equal. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y :=\n\n/-- All generalized eigenvalues are eigenvalues. -/\ntheorem âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {Î¼ : R} {k : â„•}, Module.End.HasGeneralizedEigenvalue f Î¼ k â†’ Module.End.HasEigenvalue f Î¼ :=\n\n/-- Two linear equivs are equal if they are equal on basis vectors. -/\ntheorem âˆ€ {Î¹ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Î¹ R M) {Râ‚ : Type u_2} [inst_3 : Semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Ïƒ' : Râ‚ â†’+* R} [inst_4 : RingHomInvPair Ïƒ Ïƒ']\n  [inst_5 : RingHomInvPair Ïƒ' Ïƒ] {Mâ‚ : Type u_4} [inst_6 : AddCommMonoid Mâ‚] [inst_7 : Module Râ‚ Mâ‚]\n  {fâ‚ fâ‚‚ : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚}, (âˆ€ (i : Î¹), â†‘fâ‚ (â†‘b i) = â†‘fâ‚‚ (â†‘b i)) â†’ fâ‚ = fâ‚‚ :=\n\n/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K) {k : â„•},\n  FiniteDimensional.finrank K V â‰¤ k â†’\n    â†‘(Module.End.generalizedEigenspace f Î¼) k = â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V) :=\n\n/-- All eigenvalues are generalized eigenvalues. -/\ntheorem âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {Î¼ : R} {k : â„•}, 0 < k â†’ Module.End.HasEigenvalue f Î¼ â†’ Module.End.HasGeneralizedEigenvalue f Î¼ k :=\n\n/-- Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues. -/\ntheorem", "choices": ["âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (S T : Module.End ğ•œ V) (Î¼ : ğ•œ),\n  Module.End.HasEigenvalue S T Î¼ â†” Module.End.HasEigenvalue T S Î¼ ", "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {S T : Module.End ğ•œ V}\n  (Î¼ : ğ•œ), Module.End.HasEigenvalue (S.comp T) Î¼ â†” Module.End.HasEigenvalue (T.comp S) Î¼ ", "âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {S T : Module.End ğ•œ V},\n  Module.End.eigenvalues (S * T) = Module.End.eigenvalues (T * S) ", "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\n  Module.End.eigenvalues (S.comp T) = Module.End.eigenvalues (T.comp S) ", "âˆ€ {K : Type u} [inst : Field K] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {f g : Module.End K V},\n  (âˆ€ (Î¼ : K), Module.End.HasEigenvalue (f * g) Î¼ â†” Module.End.HasEigenvalue (g * f) Î¼) ", "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S T : Module.End K V},\n  Module.End.eigenvalues (S * T) = Module.End.eigenvalues (T * S) ", "forall {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (S T : Module.End K V) (Î¼ : K), Module.End.HasEigenvalue (S.comp T) Î¼ â†” Module.End.HasEigenvalue (T.comp S) Î¼ ", "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S T : Module.End K V},\n  (âˆ€ (Î¼ : K), Module.End.HasEigenvalue (S * T) Î¼ â†” Module.End.HasEigenvalue (T * S) Î¼) ", "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S T : Module.End K V},\n  (âˆ€ (Î¼ : K), Module.End.HasEigenvalue (S * T) Î¼ â†” Module.End.HasEigenvalue (T * S) Î¼) ", "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S T : Module.End K V} {Î¼ : K},\n  Module.End.HasEigenvalue (S.comp T) Î¼ â†” Module.End.HasEigenvalue (T.comp S) Î¼ "]}
{"docString": "Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 â€¢ x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (a b : M),\\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b)\",\n  \"isProp\": true,\n  \"docString\": \"The symmetric product of vectors is a scalar \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"}]\n", "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 â€¢ x = x :=\n\n/-- The symmetric product of vectors is a scalar -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (a b : M),\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b) :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator. -/\ntheorem", "choices": ["âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ W : Submodule K V, Module.rank K W = Module.rank K V - 1 â†’ Submodule.map T W = W) â†’ (âˆƒ c : K, T = c â€¢ 1) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (W : Submodule K V), Module.rank K W = Module.rank K V - 1 â†’ W â‰¤ LinearMap.range T) â†’\n  (âˆƒ c, T = c â€¢ LinearMap.id) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : LinearMap K V V)\n  (h : âˆ€ W : Submodule K V, Submodule.dim K W = Submodule.dim K V - 1 â†’ Submodule.map T W = W),\n  âˆƒ c, T = c â€¢ LinearMap.id ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : Module.End K V),\n  (âˆ€ (W : Submodule K V), Module.rank K W = Module.rank K V - 1 â†’ Submodule.map T W = W) â†’\n  (âˆƒ (a : K), T = a â€¢ LinearMap.id) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ W : Submodule K V, Module.rank K W = Module.rank K V - 1 â†’ Submodule.IsInvariant T W) â†’ âˆƒ a, T = a â€¢ LinearMap.id ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (hT : âˆ€ (U : Submodule K V), Module.rank K U = Module.rank K V - 1 â†’ âˆ€ (x : V), x âˆˆ U â†’ T x âˆˆ U),\n  âˆƒ (a : K), T = a â€¢ linear_map.id ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ W : Submodule K V, Module.rank K W = Module.rank K V - 1 â†’ T.isInvariantSubspace W) â†’\n  âˆƒ a, âˆ€ (v : V), T v = a â€¢ v ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (W : Submodule K V), Module.rank K W = Module.rank K V - 1 â†’ Module.End.range_restrict T W = W) â†’\n  âˆƒ (c : K), T = c â€¢ 1 ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ W : Submodule K V, Module.rank K W = Module.rank K V - 1 â†’ Module.End.range_restrict T W = W) â†’\n  âˆƒ a : K, T = a â€¢ 1 ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (W : Submodule K V), Module.rank K W = Module.rank K V - 1 â†’ Submodule.IsInvariant T W) â†’\n  âˆƒ (c : K), T = c â€¢ LinearMap.id "]}
{"docString": "Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]\\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚],\\n  (M â‰ƒâ‚—[R] Mâ‚‚) â†’ FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"}]\n", "prompt_cons": "/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚],\n  (M â‰ƒâ‚—[R] Mâ‚‚) â†’ FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚ :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension. -/\ntheorem", "choices": ["âˆ€ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : LinearMap â„ V V), (âˆ€ Î» : â„, Â¬Module.End.eigenvalue T Î») â†’ âˆ€ (W : Submodule â„ V),\n  Submodule.map T W = W â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ W }) ", "âˆ€ {V : Type v} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : Module.End â„ V) (W : Submodule â„ V),\n  (âˆ€ (x : â„), Â¬Module.End.HasEigenvalue T x) â†’ (W â‰¤ Module.End.eigenspace T 1) â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ W }) ", "âˆ€ {V : Type v} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : Module.End â„ V),\n  (âˆ€ x, T.has_eigenvalue x â†’ False) â†’ âˆ€ (S : Submodule â„ V), (Submodule.map T S = S) â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ S }) ", "âˆ€ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : Module.End â„ V) (hT : âˆ€ v : V, T.has_eigenvalue v â†’ False)\n  (W : Submodule â„ V) (hW : âˆ€ w, w âˆˆ W â†’ T w âˆˆ W), Even (FiniteDimensional.finrank â„ { x // x âˆˆ W }) ", "forall {R : Type u} {V : Type v} [inst : Ring R] [inst_1 : CharZero R] [inst_2 : AddCommGroup V] [inst_3 : Module R V]\n  [inst_4 : FiniteDimensional R V] (T : Module.End R V) (hT : âˆ€ Î», Â¬ Module.End.HasEigenvalue T Î»),\n  âˆ€ (W : Submodule R V), Submodule.map T W â‰¤ W â†’ IsEven (FiniteDimensional.finrank R {x // x âˆˆ W}) ", "âˆ€ {V : Type v} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : Module.End â„ V),\n  (âˆ€ x, Â¬Module.End.HasEigenvalue T x) â†’ âˆ€ (U : Submodule â„ V), Module.End.IsInvariantSubmodule T U â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ U }) ", "âˆ€ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : LinearMap â„ V V),\n  (âˆ€ x : V, x â‰  0 â†’ Â¬ T.is_eigenvalue (T x)) â†’\n  âˆ€ (S : Submodule â„ V), LinearMap.IsInvariantSubspace T S â†’\n  FiniteDimensional.finrank â„ { x // x âˆˆ S } % 2 = 0 ", "âˆ€ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : Module.End â„ V),\n  (âˆ€ x : V, x â‰  0 â†’ Â¬ T.has_eigenvalue (Module.End.eigenvalues T x)) â†’\n  âˆ€ (W : Submodule â„ V), Submodule.IsInvariant T W â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ W }) ", "âˆ€ {V : Type v} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : Module.End â„ V),\n  (âˆ€ x : â„, Â¬Module.End.HasEigenvalue T x) â†’\n  âˆ€ (W : Submodule â„ V), Submodule.IsInvariant T W â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ W }) ", "âˆ€ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module â„ V] (T : End V) (h : âˆ€ x : â„, Â¬Module.End.HasEigenvalue T x)\n  (W : Submodule â„ V), Submodule.map T W = W â†’ Even (FiniteDimensional.finrank â„ { x // x âˆˆ W }) "]}
{"docString": "Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] (a b : Î±), a â‰¤ a * b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a â‰¤ a * b` \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : AddCommMonoid M] (a b : â„•) (f : â„• â†’ â„• â†’ M),\\n  (Finset.sum (Finset.Ico a b) fun i => Finset.sum (Finset.Ico i b) fun j => f i j) =\\n    Finset.sum (Finset.Ico a b) fun j => Finset.sum (Finset.Ico a (j + 1)) fun i => f i j\",\n  \"isProp\": true,\n  \"docString\":\n  \"The two ways of summing over `(i,j)` in the range `a<=i<=j<b` are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] (a b : Î±), a â‰¤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a â‰¤ a + b` \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner x y * inner x y â‰¤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchyâ€“Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Î± : Type u_1} [inst : LinearOrderedRing Î±] {s : Finset Î¹} {f : Î¹ â†’ Î±},\\n  (Finset.sum s fun i => f i) ^ 2 â‰¤ â†‘(Finset.card s) * Finset.sum s fun i => f i ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\\nof the sum is less than the size of the set times the sum of the squares. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c\",\n  \"isProp\": true,\n  \"docString\": \"For `a â‰¤ b`, there is a `c` so `b = a * c`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_3} (x : E) {v : Î¹ â†’ E}, Orthonormal ğ•œ v â†’ âˆ‘' (i : Î¹), â€–inner (v i) xâ€– ^ 2 â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality. \"}]\n", "prompt_cons": "/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- For any `a` and `b`, `a â‰¤ a * b` -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] (a b : Î±), a â‰¤ a * b :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- The two ways of summing over `(i,j)` in the range `a<=i<=j<b` are equal. -/\ntheorem âˆ€ {M : Type u_1} [inst : AddCommMonoid M] (a b : â„•) (f : â„• â†’ â„• â†’ M),\n  (Finset.sum (Finset.Ico a b) fun i => Finset.sum (Finset.Ico i b) fun j => f i j) =\n    Finset.sum (Finset.Ico a b) fun j => Finset.sum (Finset.Ico a (j + 1)) fun i => f i j :=\n\n/-- For any `a` and `b`, `a â‰¤ a + b` -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] (a b : Î±), a â‰¤ a + b :=\n\n/-- Cauchyâ€“Schwarz inequality for real inner products. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner x y * inner x y â‰¤ inner x x * inner y y :=\n\n/-- Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\nof the sum is less than the size of the set times the sum of the squares. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Î± : Type u_1} [inst : LinearOrderedRing Î±] {s : Finset Î¹} {f : Î¹ â†’ Î±},\n  (Finset.sum s fun i => f i) ^ 2 â‰¤ â†‘(Finset.card s) * Finset.sum s fun i => f i ^ 2 :=\n\n/-- For `a â‰¤ b`, there is a `c` so `b = a * c`. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c :=\n\n/-- Bessel's inequality. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_3} (x : E) {v : Î¹ â†’ E}, Orthonormal ğ•œ v â†’ âˆ‘' (i : Î¹), â€–inner (v i) xâ€– ^ 2 â‰¤ â€–xâ€– ^ 2 :=\n\n/-- Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$. -/\ntheorem", "choices": ["forall {n : â„•} {a b : â„• â†’ â„},\n  (âˆ‘ (j : â„•) in Finset.range n, a j * b j) ^ 2 â‰¤ (âˆ‘ (j : â„•) in Finset.range n, (j + 1) * a j ^ 2) * (âˆ‘ (j : â„•) in Finset.range n, b j ^ 2 / (j + 1)) ", "âˆ€ {n : â„•} {a b : â„• â†’ â„},\n  (Finset.sum (Finset.range n) fun i => a i * b i) ^ 2 â‰¤\n    (Finset.sum (Finset.range n) fun i => (i + 1) * a i ^ 2) *\n      (Finset.sum (Finset.range n) fun i => b i ^ 2 / (i + 1)) ", "âˆ€ {n : â„•} {a b : â„• â†’ â„},\n  (âˆ‘ (j : â„•) in Finset.range n, a j * b j) ^ 2 â‰¤\n  (âˆ‘ (j : â„•) in Finset.range n, (j + 1) * a j ^ 2) *\n  (âˆ‘ (j : â„•) in Finset.range n, (b j ^ 2) / (j + 1)) ", "âˆ€ {n : â„•} {a b : Finâ‚“ (n + 1) â†’ â„},\n  (Finset.sum Finset.univ fun i => a i * b i) ^ 2 â‰¤\n    (Finset.sum Finset.univ fun i => (i + 1) * (a i ^ 2)) *\n      (Finset.sum Finset.univ fun i => (b i ^ 2) / (i + 1)) ", "âˆ€ {n : â„•} {a b : Finâ‚“ n â†’ â„},\n  (Finset.sum Finset.univ fun j => a j * b j) ^ 2 â‰¤\n    (Finset.sum Finset.univ fun j => (j + 1) * a j ^ 2) *\n      (Finset.sum Finset.univ fun j => b j ^ 2 / (j + 1)) ", "âˆ€ {n : â„•} {a b : Finâ‚“ n â†’ â„},\n  (Finset.sum Finset.univ fun j => a j * b j) ^ 2 â‰¤\n    (Finset.sum Finset.univ fun j => (j + 1) * (a j ^ 2)) *\n      (Finset.sum Finset.univ fun j => b j ^ 2 / (j + 1)) ", "âˆ€ {n : â„•} (a b : â„• â†’ â„),\n  (Finset.sum (Finset.range (n + 1)) (Î» j => a j * b j)) ^ 2 â‰¤\n    (Finset.sum (Finset.range (n + 1)) (Î» j => j * a j ^ 2)) *\n    (Finset.sum (Finset.range (n + 1)) (Î» j => b j ^ 2 / j)) ", "âˆ€ {n : â„•} {a b : Finâ‚“ (n + 1) â†’ â„},\n  (Finset.sum Finset.univ fun j => a j * b j) ^ 2 â‰¤\n    (Finset.sum Finset.univ fun j => (j + 1) * (a j ^ 2)) *\n      (Finset.sum Finset.univ fun j => (b j ^ 2) / (j + 1)) ", "âˆ€ {n : â„•} {a b : Finâ‚“ n â†’ â„},\n  (âˆ‘ (j : Finâ‚“ n), a j * b j) ^ 2 â‰¤ \n    (âˆ‘ (j : Finâ‚“ n), â†‘(j + 1) * a j ^ 2) * (âˆ‘ (j : Finâ‚“ n), b j ^ 2 / â†‘(j + 1)) ", "âˆ€ {n : â„•} {a b : â„• â†’ â„},\n  (Finset.sum (Finset.range (n + 1)) (Î» j => a j * b j)) ^ 2 â‰¤\n    (Finset.sum (Finset.range (n + 1)) (Î» j => (j + 1) * a j ^ 2)) *\n    (Finset.sum (Finset.range (n + 1)) (Î» j => b j ^ 2 / (j + 1))) "]}
{"docString": "Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {s : Set E},\\n  Orthonormal ğ•œ Subtype.val â†’\\n    âˆƒ w _hw, Orthonormal ğ•œ Subtype.val âˆ§ âˆ€ (u : Set E), u âŠ‡ w â†’ Orthonormal ğ•œ Subtype.val â†’ u = w\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\\ncontaining it. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner (x + y) (x - y) = 0 â†” â€–xâ€– = â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum and difference of two vectors are orthogonal if and only\\nif they have the same norm. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_3} {v : Î¹ â†’ E}, Orthonormal ğ•œ v â†’ LinearIndependent ğ•œ v\",\n  \"isProp\": true,\n  \"docString\": \"An orthonormal set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedSpace â„ E] [inst_4 : LinearMap.CompatibleSMul E E ğ•œ â„],\\n  StrictConvex ğ•œ (Metric.closedBall 0 1) â†’ StrictConvexSpace ğ•œ E\",\n  \"isProp\": true,\n  \"docString\":\n  \"A real normed vector space is strictly convex provided that the unit ball is strictly convex. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\\n  x â‰  0 â†’ y â‰  0 â†’ (â€–x + yâ€– = â€–xâ€– + â€–yâ€– â†” InnerProductGeometry.angle x y = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the sum of two non-zero vectors equals the sum of their norms\\nif and only the angle between the two vectors is 0. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] {x : E},\\n  x â‰  0 â†’ â€–(â†‘â€–xâ€–)â»Â¹ â€¢ xâ€– = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lemma to normalize a vector in a normed space `E` over either `â„‚` or `â„` to unit length. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} [inst_3 : Fintype Î¹] {v : Î¹ â†’ E},\\n  Orthonormal ğ•œ v â†’ âˆ€ (l : Î¹ â†’ ğ•œ) (i : Î¹), inner (v i) (Finset.sum Finset.univ fun i => l i â€¢ v i) = l i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of a linear combination of a set of orthonormal vectors with one of those\\nvectors picks out the coefficient of that vector. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E] {n : â„•}\\n  [_i : Fact (FiniteDimensional.finrank â„ E = n)] (o : Orientation â„ E (Fin n)) {v : Fin n â†’ E},\\n  (Pairwise fun i j => inner (v i) (v j) = 0) â†’ |â†‘(Orientation.volumeForm o) v| = Finset.prod Finset.univ fun i => â€–v iâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\\nsign, the product of the norms of the vectors `v i`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\\n  x â‰  0 â†’ y â‰  0 â†’ (inner x y = â€–xâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two non-zero vectors equals the product of their norms\\nif and only if the angle between the two vectors is 0. \"}]\n", "prompt_cons": "/-- Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\ncontaining it. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {s : Set E},\n  Orthonormal ğ•œ Subtype.val â†’\n    âˆƒ w _hw, Orthonormal ğ•œ Subtype.val âˆ§ âˆ€ (u : Set E), u âŠ‡ w â†’ Orthonormal ğ•œ Subtype.val â†’ u = w :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- The sum and difference of two vectors are orthogonal if and only\nif they have the same norm. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner (x + y) (x - y) = 0 â†” â€–xâ€– = â€–yâ€– :=\n\n/-- An orthonormal set is linearly independent. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_3} {v : Î¹ â†’ E}, Orthonormal ğ•œ v â†’ LinearIndependent ğ•œ v :=\n\n/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem âˆ€ (ğ•œ : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedSpace â„ E] [inst_4 : LinearMap.CompatibleSMul E E ğ•œ â„],\n  StrictConvex ğ•œ (Metric.closedBall 0 1) â†’ StrictConvexSpace ğ•œ E :=\n\n/-- The norm of the sum of two non-zero vectors equals the sum of their norms\nif and only the angle between the two vectors is 0. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\n  x â‰  0 â†’ y â‰  0 â†’ (â€–x + yâ€– = â€–xâ€– + â€–yâ€– â†” InnerProductGeometry.angle x y = 0) :=\n\n/-- Lemma to normalize a vector in a normed space `E` over either `â„‚` or `â„` to unit length. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] {x : E},\n  x â‰  0 â†’ â€–(â†‘â€–xâ€–)â»Â¹ â€¢ xâ€– = 1 :=\n\n/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} [inst_3 : Fintype Î¹] {v : Î¹ â†’ E},\n  Orthonormal ğ•œ v â†’ âˆ€ (l : Î¹ â†’ ğ•œ) (i : Î¹), inner (v i) (Finset.sum Finset.univ fun i => l i â€¢ v i) = l i :=\n\n/-- Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\nsign, the product of the norms of the vectors `v i`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E] {n : â„•}\n  [_i : Fact (FiniteDimensional.finrank â„ E = n)] (o : Orientation â„ E (Fin n)) {v : Fin n â†’ E},\n  (Pairwise fun i j => inner (v i) (v j) = 0) â†’ |â†‘(Orientation.volumeForm o) v| = Finset.prod Finset.univ fun i => â€–v iâ€– :=\n\n/-- The inner product of two non-zero vectors equals the product of their norms\nif and only if the angle between the two vectors is 0. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\n  x â‰  0 â†’ y â‰  0 â†’ (inner x y = â€–xâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = 0) :=\n\n/-- Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$. -/\ntheorem", "choices": ["âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {m : â„•} {e : Fin m â†’ V}, Orthonormal ğ•œ e â†’ âˆ€ (v : V),\n  (âˆ¥vâˆ¥ ^ 2 = Finset.sum Finset.univ (Î» i, âˆ¥âŒ©v, e iâŒªâˆ¥ ^ 2) â†” v âˆˆ Submodule.span ğ•œ (Set.range e)) ", "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_3} [_i : Fintype Î¹] {v : E} {e : Î¹ â†’ E},\n  Orthonormal ğ•œ e â†’\n    (â€–vâ€–^2 = Finset.sum Finset.univ fun i => âˆ¥inner (v) (e i)âˆ¥^2 â†” v âˆˆ Submodule.span ğ•œ (Set.Range e)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {m : â„•} {e : Fin m â†’ V}, Orthonormal ğ•œ e â†’ âˆ€ (v : V),\n  (â€–vâ€–^2 = Finset.sum Finset.univ (Î» i, abs (inner v (e i))^2) â†” v âˆˆ submodule.span ğ•œ (set.range e)) ", "âˆ€ {ğ•œ : Type u_2} {V : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {m : â„•} {e : Finâ‚“ m â†’ V},\n  Orthonormal ğ•œ e â†’\n  âˆ€ (v : V), â€–vâ€– ^ 2 = (Finset.sum Finset.univ fun i => âˆ¥inner v (e i)âˆ¥^2) â†” v âˆˆ Submodule.span ğ•œ (Set.range e) ", "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_3} (v : E) (e : Î¹ â†’ E), Orthonormal ğ•œ e â†’ (â€–vâ€–^2 = Finset.sum Finset.univ (Î» i, âˆ¥inner v (e i)âˆ¥^2) â†” v âˆˆ Submodule.span ğ•œ (Set.Range e)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {m : â„•} {e : Fin m â†’ V},\n  Orthonormal ğ•œ e â†’ âˆ€ (v : V),\n  (âˆ¥vâˆ¥^2 = Finset.sum Finset.univ (Î» i, abs (inner v (e i)) ^ 2) â†” v âˆˆ Submodule.span ğ•œ (Set.range e)) ", "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {m : â„•} {v : E} {es : List E},\n  (Orthonormal ğ•œ (Î» i => List.nthLe es i.val i.property) âˆ§ List.length es = m) â†’\n    (â€–vâ€– ^ 2 = Finset.sum (Finset.range m) (Î» i => (inner v (List.nthLe es i i.property)) * (inner v (List.nthLe es i i.property)).conj) â†”\n    v âˆˆ Submodule.span ğ•œ (Set.Range (Î» i => List.nthLe es i.val i.property))) ", "âˆ€ {ğ•œ : Type u_2} {V : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {m : â„•} {es : Finâ‚“ m â†’ V}, Orthonormal ğ•œ es â†’ âˆ€ (v : V),\n  (â€–vâ€– ^ 2 = Finset.sum Finset.univ (Î» i, âˆ¥inner (es i) vâˆ¥^2) â†” v âˆˆ Submodule.span ğ•œ (Set.Range es)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [_inst_1 : IsROrC ğ•œ] [inst_2 : NormedAddCommGroup V] [inst_3 : InnerProductSpace ğ•œ V] {m : â„•}\n  (v : V) (e : Finâ‚“ m â†’ V), Orthonormal ğ•œ e â†’\n  (â€–vâ€– ^ 2 = âˆ‘ i, âˆ¥inner v (e i)âˆ¥ ^ 2 â†” v âˆˆ Submodule.span ğ•œ (Set.Range e)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {m : â„•} {l : List V}, Orthonormal ğ•œ (List.nth l) â†’ âˆ€ (v : V),\n  â€–vâ€–^2 = List.sum (List.map (Î» i, abs (inner v (List.nthLe l i (lt_of_lt_of_le i.property (List.length_le_of_sublist i.val))))^2) (List.range m)) â†”\n  v âˆˆ Submodule.span ğ•œ (List.toSet l) "]}
{"docString": "Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), Â¬s1 â‰¤ s2 â†” âˆƒ p, p âˆˆ s1 âˆ§ Â¬p âˆˆ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is not less than or equal to another if and only if it has a point not in the\\nsecond subspace. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F)\\n  [inst_6 : RingHomIsometric Ïƒâ‚â‚‚], â€–fâ€– = 0 â†” f = 0\",\n  \"isProp\": true,\n  \"docString\": \"An operator is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : Fintype Î¹] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : (i : Î¹) â†’ NormedAddCommGroup (E i)] [inst_3 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)] [inst_4 : NormedAddCommGroup G]\\n  [inst_5 : NormedSpace ğ•œ G] (f g : ContinuousMultilinearMap ğ•œ E G), â€–f + gâ€– â‰¤ â€–fâ€– + â€–gâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The operator norm satisfies the triangle inequality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M),\\n  â†‘(AddSubgroup.topologicalClosure S) â‰  Set.univ â†’ â€–AddSubgroup.normedMk Sâ€– = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The operator norm of the projection is `1` if the subspace is not dense. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î¼ : ğ•œ),\\n  Module.End.eigenspace\\n      (LinearMap.restrict T\\n        (_ : âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®))\\n      Î¼ =\\n    âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space has no eigenvalues. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\\n  [inst : T2Space Î±], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible Tâ‚‚ space. \"},\n {\"theorem\":\n  \"âˆ€ {Vâ‚ : Type u_1} {Vâ‚‚ : Type u_2} [inst : NormedAddCommGroup Vâ‚] [inst_1 : NormedAddCommGroup Vâ‚‚]\\n  {f : NormedAddGroupHom Vâ‚ Vâ‚‚}, â€–fâ€– = 0 â†” f = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For normed groups, an operator is zero iff its norm vanishes. \"}]\n", "prompt_cons": "/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), Â¬s1 â‰¤ s2 â†” âˆƒ p, p âˆˆ s1 âˆ§ Â¬p âˆˆ s2 :=\n\n/-- An operator is zero iff its norm vanishes. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F)\n  [inst_6 : RingHomIsometric Ïƒâ‚â‚‚], â€–fâ€– = 0 â†” f = 0 :=\n\n/-- The operator norm satisfies the triangle inequality. -/\ntheorem âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : Fintype Î¹] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : (i : Î¹) â†’ NormedAddCommGroup (E i)] [inst_3 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace ğ•œ G] (f g : ContinuousMultilinearMap ğ•œ E G), â€–f + gâ€– â‰¤ â€–fâ€– + â€–gâ€– :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The operator norm of the projection is `1` if the subspace is not dense. -/\ntheorem âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M),\n  â†‘(AddSubgroup.topologicalClosure S) â‰  Set.univ â†’ â€–AddSubgroup.normedMk Sâ€– = 1 :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î¼ : ğ•œ),\n  Module.End.eigenspace\n      (LinearMap.restrict T\n        (_ : âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®))\n      Î¼ =\n    âŠ¥ :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- There does not exist a nontrivial preirreducible Tâ‚‚ space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\n  [inst : T2Space Î±], False :=\n\n/-- For normed groups, an operator is zero iff its norm vanishes. -/\ntheorem âˆ€ {Vâ‚ : Type u_1} {Vâ‚‚ : Type u_2} [inst : NormedAddCommGroup Vâ‚] [inst_1 : NormedAddCommGroup Vâ‚‚]\n  {f : NormedAddGroupHom Vâ‚ Vâ‚‚}, â€–fâ€– = 0 â†” f = 0 :=\n\n/-- Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$. -/\ntheorem", "choices": ["âˆ€ {ğ•œ : Type u_2} {V : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  (h_dim : 2 â‰¤ FiniteDimensional.findim ğ•œ V), Â¬Submodule.normalMapSubmodule ğ•œ V âŠ† ContinuousLinearMap.submodule ğ•œ V ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] (h_dim : FiniteDimensional.finrank ğ•œ V â‰¥ 2),\n  Â¬(Submodule ğ•œ (Module.End ğ•œ V) {A : Module.End ğ•œ V | LinearMap.IsNormal A}) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] (h_dim : FiniteDimensional.finrank ğ•œ V â‰¥ 2),\n  Â¬Submodule ğ•œ (V â†’â‚—[ğ•œ] V) (SetOf (Î» T, LinearMap.IsNormal T)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] (h : FiniteDimensional.finrank ğ•œ V â‰¥ 2),\n  Â¬(âˆ€ (x y : End ğ•œ V), x.IsNormal â†’ y.IsNormal â†’ (x + y).IsNormal) ", "âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] (h : FiniteDimensional.finrank ğ•œ V â‰¥ 2),\n  Â¬IsSubmodule (SetOf (LinearMap.IsAdjointPair ğ•œ V)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  (h : FiniteDimensional.finrank ğ•œ V â‰¥ 2), Â¬((AffineSubspace.mk' (0 : V â†’â‚—[ğ•œ] V) LinearMap.IsNormal.toSet).carrier â‰¤ (AffineSubspace.mk' (0 : V â†’â‚—[ğ•œ] V) Set.Univ).carrier) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V], FiniteDimensional.finrank ğ•œ V â‰¥ 2 â†’\n  Â¬Submodule.mk_set (SetOf (LinearMap.IsNormalOperator : (V â†’â‚—[ğ•œ] V) â†’ Prop)) _ ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  (h_dim : FiniteDimensional.finrank ğ•œ V â‰¥ 2), Â¬IsSubspace ğ•œ (SetOf (LinearMap.IsNormalOperator ğ•œ V)) ", "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V], FiniteDimensional.finrank ğ•œ V â‰¥ 2 â†’ Â¬IsSubspace ğ•œ (SetOf (LinearMap.IsNormal)) ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [i : FiniteDimensional K V],\n  2 â‰¤ FiniteDimensional.findim K V â†’\n  Â¬AffineSubspace (SetOf (LinearMap.IsNormal : (V â†’â‚—[K] V) â†’ Prop)) "]}
{"docString": "Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a\",\n  \"isProp\": true,\n  \"docString\": \"The spectrum of a selfadjoint is real \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î¼ : ğ•œ),\\n  Module.End.eigenspace\\n      (LinearMap.restrict T\\n        (_ : âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®))\\n      Î¼ =\\n    âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space has no eigenvalues. \"}]\n", "prompt_cons": "/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® :=\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î¼ : ğ•œ),\n  Module.End.eigenspace\n      (LinearMap.restrict T\n        (_ : âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®))\n      Î¼ =\n    âŠ¥ :=\n\n/-- Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real. -/\ntheorem", "choices": ["âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsNormal T â†’\n    (LinearMap.IsSymmetric T â†” âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼) ", "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†”\n    âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ IsROrC.re Î¼ = Î¼ ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsNormal T â†’\n    (LinearMap.IsSymmetric T â†” âˆ€ (Î¼ : ğ•œ), Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼) ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†” (âˆ€ Î¼, Module.End.HasEigenvalue T Î¼ â†’ Î¼ = â†‘(starRingEnd ğ•œ) Î¼) ", "âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T),\n  (âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼) â†”\n    (âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ IsROrC.im Î¼ = 0) ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†”\n    (âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼) ", "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†” (âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼) ", "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’â‚—[ğ•œ] E}, LinearMap.IsNormal A â†’\n  (LinearMap.IsSymmetric A â†” âˆ€ Î¼, Module.End.HasEigenvalue A Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼) ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†” âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ IsROrC.re Î¼ = Î¼ ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  (LinearMap.IsSymmetric T â†” (âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼)) "]}
{"docString": "Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)", "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`âŸªT v, vâŸ«_â„‚` is real for all v.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the tensor product of a scalar linear map and of an element of a normed space\\nis the product of the norms. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x - yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\\nroots. \"}]\n", "prompt_cons": "/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im :=\n\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€– :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\nroots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x - yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.) -/\ntheorem", "choices": ["âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ âˆƒ (S : V â†’â‚—[â„‚] V), S * S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ âˆƒ S : V â†’â‚—[â„‚] V, S * S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ âˆƒ (S : V â†’â‚—[â„‚] V), LinearMap.comp S S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ âˆƒ (S : V â†’â‚—[â„‚] V), S * S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ âˆƒ S : V â†’â‚—[â„‚] V, (S * S) = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ âˆƒ S : V â†’â‚—[â„‚] V, S * S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ âˆƒ (S : V â†’â‚—[â„‚] V), LinearMap.comp S S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  (âˆ€ (u v : V), inner (â†‘T u) v = inner u (â†‘T v)) â†’ âˆƒ S : V â†’â‚—[â„‚] V, âˆ€ (v : V), â†‘S (â†‘S v) = â†‘T v ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsSymmetric T â†’ âˆƒ S : V â†’â‚—[â„‚] V, S * S = T ", "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ âˆƒ (S : V â†’â‚—[â„‚] V), S * S = T "]}
{"docString": "Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\\n    1 â‰¤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\": \"Â¬Summable fun n => 1 / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"}]\n", "prompt_cons": "/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\n    1 â‰¤ b :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem Â¬Summable fun n => 1 / â†‘n :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer. -/\ntheorem", "choices": ["âˆ€ (n : â„•), n â‰¥ 2 â†’ Â¬(âˆƒ k : â„•, (Finset.sum (Finset.range n) (Î» i => 1 / (i + 2))) = â†‘k) ", "âˆ€ (n : â„•), n > 1 â†’ Â¬(âˆƒ k : â„•, (Finset.sum (Finset.range n) (Î» i => 1 / (i + 2))) = â†‘k) ", "âˆ€ (n : â„•), n > 0 â†’ Â¬âˆƒ k : â„•, (âˆ‘ i in Finset.range n, 1 / (i + 2) : â„š) = k ", "âˆ€ (n : â„•), Â¬IsInteger (Finset.sum (Finset.range (n + 1)) (Î» (k : â„•), 1 / (k + 2))) ", "âˆ€ (n : â„•), Â¬(âˆƒ k : â„•, (Finset.sum (Finset.range n) fun i => 1 / (i + 2)) = â†‘k) ", "âˆ€ n : â„•, n > 1 â†’ Â¬â„¤ (Finset.sum (Finset.range n) (Î» i, 1 / (i + 2))) ", "âˆ€ (n : â„•), Â¬(âˆƒ (k : â„•), (Finset.sum (Finset.range (n + 1)) fun i => 1 / (i + 2)) = â†‘k) ", "âˆ€ {n : â„•}, n > 0 â†’ Â¬âˆƒ k : â„•, (Finset.sum (Finset.range n) fun i => 1 / (i + 2)) = â†‘k ", "âˆ€ (n : â„•), n > 0 â†’ Â¬âˆƒ (k : â„•), (Finset.sum (Finset.range n) (Î» (i : â„•), 1 / (â†‘i + 1))) = â†‘k ", "âˆ€ (n : â„•), Â¬is_integer (Finset.sum (Finset.range (n + 1)) (Î» i => 1 / (i + 2) : â„)) "]}
{"docString": "If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, orderOf (QuaternionGroup.a 1) = 2 * n\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a 1` has order `2 * n`.\\n\"}]\n", "prompt_cons": "/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0 :=\n\n/-- If `0 < n`, then `a 1` has order `2 * n`. -/\ntheorem âˆ€ {n : â„•}, orderOf (QuaternionGroup.a 1) = 2 * n :=\n\n/-- If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even. -/\ntheorem", "choices": ["âˆ€ {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = if Int.even a then 2 else 1 ", "âˆ€ {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = if a % 2 = 0 then 2 else 1 ", "forall {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) âˆ¨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "forall {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = if a % 2 = 0 then 2 else 1 ", " âˆ€ {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) âˆ¨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2 âˆ§ a % 2 = 0) ", "âˆ€ {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) âˆ¨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "âˆ€ {a : â„¤} {n m : â„•}, a â‰  0 â†’ n > m â†’ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) âˆ¨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2 âˆ§ a % 2 = 0) ", "âˆ€ {a : â„¤} {n m : â„•}, a â‰  0 â†’ n > m â†’ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) âˆ¨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "forall {a : â„¤} {n m : â„•}, a â‰  0 â†’ n > m â†’ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 âˆ¨ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) âˆ§ (a % 2 = 0 â†” Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "âˆ€ {a : â„¤} {m n : â„•}, a â‰  0 â†’ n > m â†’ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = if a % 2 = 0 then 1 else 2 "]}
{"docString": "Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, 512 â‰¤ n â†’ n * (2 * n) ^ Nat.sqrt (2 * n) * 4 ^ (2 * n / 3) â‰¤ 4 ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inequality which contradicts Bertrand's postulate, for large enough `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\\n    1 â‰¤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n", "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- The inequality which contradicts Bertrand's postulate, for large enough `n`. -/\ntheorem âˆ€ {n : â„•}, 512 â‰¤ n â†’ n * (2 * n) ^ Nat.sqrt (2 * n) * 4 ^ (2 * n / 3) â‰¤ 4 ^ n :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\n    1 â‰¤ b :=\n\n/-- The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges. -/\ntheorem", "choices": ["/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem sum_exp_pow_eq_sum_pow_factorial {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem sum_exp_pow_eq (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp â„• ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => k^p / Nat.factorial p ", "theorem SummablePrimeSqFree : Â¬ Summable (Î» (n : â„•), if Nat.squareFree n âˆ§ 1 < n then (n : â„)â»Â¹ else 0) ", "âˆ€ {Î± : Type u_1} [inst : OrderedAddCommGroup Î±] {L : Filter â„•} [inst_1 : Filter.IsCountablyGenerated L],\n  Â¬Filter.Tendsto (fun n => âˆ‘ (ab : â„• Ã— â„•) in\n    Finset.filter (fun (ab : â„• Ã— â„•) => ab.fst * ab.snd = n âˆ§ Nat.Coprime (ab.fst) (ab.snd) âˆ§\n      0 < ab.fst âˆ§ 0 < ab.snd) (Finset.product (Finset.ico 1 n) (Finset.ico 1 n)),\n    (â†‘(Nat.divisorsAntidiagonal n) â€¢ Finset.singleton (1, 1)).sum (fun ab => (ab.fst * ab.snd)â»Â¹)) L atTop ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem exp_sum_range_pow {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem sum_exp_series_eq (n : â„•) :\n  (Finset.sum (Finset.range n) (Î» k, exp_series k)) =\n    PowerSeries.mk (Î» p, Finset.sum (Finset.range n) (Î» k, k ^ p / p!.algebra_map â„š A)) ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem exp_pow_sum_eq {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem sum_exp_pow_eq_sum_range_pow_div_fact {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem exp_sum_eq {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ ", "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem exp_taylor_sum {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ "]}
{"docString": "Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers.", "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\": \"âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"}]\n", "prompt_cons": "/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1 :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1 :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0 :=\n\n/-- Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers. -/\ntheorem", "choices": ["âˆ€ (x y : â„¤), 3 * x ^ 2 + 2 â‰  y ^ 2 ", "âˆ€ (x y : â„¤), 3 * x ^ 2 + 2 â‰  y ^ 2 ", "âˆ€ {x y : â„¤}, 3 * x * x + 2 â‰  y * y ", "âˆ€ (x y : â„¤), 3 * x * x + 2 â‰  y * y ", "âˆ€ (x y : â„¤), 3 * x^2 + 2 â‰  y^2 ", "âˆ€ (x y : â„¤), 3 * x * x + 2 â‰  y * y ", "no_sol_3x2_plus_2_eq_y2 : âˆ€ (x y : â„¤), 3 * x * x + 2 â‰  y * y ", "Â¬âˆƒ (x y : â„¤), 3 * x * x + 2 = y * y ", "âˆ€ (x y : â„¤), 3 * x ^ 2 + 2 â‰  y ^ 2 ", "âˆ€ (x y : â„¤), 3 * x * x + 2 â‰  y * y "]}
{"docString": "If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$.", "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `Ï‡â‚„ n = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, Squarefree n â†’ (IsSquare (-1) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q âˆ£ n â†’ q % 4 â‰  3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"}]\n", "prompt_cons": "/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- If `n % 4 = 1`, then `Ï‡â‚„ n = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = 1 :=\n\n/-- If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. -/\ntheorem âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1 :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. -/\ntheorem âˆ€ {n : â„•}, Squarefree n â†’ (IsSquare (-1) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q âˆ£ n â†’ q % 4 â‰  3) :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$. -/\ntheorem", "choices": ["forall {n : â„•}, n â‰  1 â†’ (Â¬Nat.Prime n â†’ â†‘(Nat.factorial (n - 1)) = 0 â†” n â‰  4) ", "forall {n : â„•}, n â‰  1 â†’ Â¬Nat.Prime n â†’ n â‰  4 â†’ â†‘(Nat.factorial (n - 1)) = 0 ", "forall {n : â„•}, n â‰  1 â†’ (Â¬Nat.Prime n â†’ (Nat.factorial (n - 1)) % n = 0 âˆ¨ n = 4) ", "âˆ€ {n : â„•}, n â‰  4 â†’ (Â¬Nat.Prime n â†’ â†‘(Nat.factorial (n - 1)) = 0) ", "forall {n : â„•}, n â‰  4 â†’ (Â¬ Nat.Prime n â†’ â†‘(Nat.factorial (n - 1)) = 0) ", "âˆ€ {n : â„•}, n â‰  1 â†’ Â¬Nat.Prime n â†’ n â‰  4 â†’ â†‘(Nat.factorial (n - 1)) = 0 ", "âˆ€ {n : â„•}, n â‰  1 â†’ Â¬Nat.Prime n â†’ n â‰  4 â†’ â†‘(Nat.factorial (n - 1)) = 0 ", "âˆ€ {n : â„•}, Â¬Nat.Prime n â†’ n â‰  4 â†’ â†‘(Nat.factorial (n - 1)) = 0 ", "forall {n : â„•}, n â‰  1 â†’ Â¬Nat.Prime n â†’ n â‰  4 â†’ â†‘(Nat.factorial (n - 1)) = 0 ", "âˆ€ {n : â„•}, Â¬Nat.Prime n â†’ n â‰  4 â†’ (â†‘(Nat.factorial (n - 1)) = 0) "]}
{"docString": "Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"}]\n", "prompt_cons": "/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$. -/\ntheorem", "choices": ["âˆ€ {a t p : â„•} [pp : Fact (Nat.Prime p)], p = 4 * t + 1 â†’ IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a) p ", "âˆ€ {a : ZMod p} {p : â„•} [inst : Fact (Nat.Prime p)], p = 4 * (p / 4) + 1 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a) p) ", "forall {a : â„•} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a % p) p) ", "âˆ€ {a t : â„•} {p : â„•} [inst : Fact (Nat.Prime p)], p = 4 * t + 1 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a % p) p) ", "âˆ€ {a : â„•} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (is_primitive_root a p â†” is_primitive_root (-a % p) p) ", "âˆ€ {a : â„•} {p : â„•} [pp : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a % p) p) ", "âˆ€ {a : â„•} {p : â„•} (hp : Fact (Nat.Prime p)), p = 4 * (p / 4) + 1 â†’ is_primitive_root a p â†” is_primitive_root (-a % p) p ", "âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’\n  (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a) p) ", "âˆ€ {a : â„•} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a % p) p) ", "âˆ€ {a : â„•} {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a % p) p) "]}
{"docString": "If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {n p k : â„•}, n â‰  0 â†’ Nat.factorization n = Finsupp.single p k â†’ n = p ^ k\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the factorization of `n` contains just one number `p` then `n` is a power of `p` \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {n : â„•} [inst_1 : IsDomain R],\\n  0 < n â†’ âˆ€ {Î¼ : R}, IsPrimitiveRoot Î¼ n â†’ Polynomial.IsRoot (Polynomial.cyclotomic n R) Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `n`-th primitive root of unity is a root of `cyclotomic n R`.\"}]\n", "prompt_cons": "/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem âˆ€ {n p k : â„•}, n â‰  0 â†’ Nat.factorization n = Finsupp.single p k â†’ n = p ^ k :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- Any `n`-th primitive root of unity is a root of `cyclotomic n R`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {n : â„•} [inst_1 : IsDomain R],\n  0 < n â†’ âˆ€ {Î¼ : R}, IsPrimitiveRoot Î¼ n â†’ Polynomial.IsRoot (Polynomial.cyclotomic n R) Î¼ :=\n\n/-- If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$. -/\ntheorem", "choices": ["âˆ€ {p n : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot (3 : ZMod p) p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot (3 : ZMod p) p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ FermatPrime p â†’ IsPrimitiveRoot (3 : ZMod p) p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p ", "âˆ€ {n p : â„•}, Nat.Prime p â†’ p = 2 ^ n + 1 â†’ IsPrimitiveRoot 3 p "]}
{"docString": "Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"}]\n", "prompt_cons": "/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1 :=\n\n/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$. -/\ntheorem", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•}, Â¬ (p - 1) âˆ£ k â†’\n  (Finset.sum (Finset.range p) fun i => (i : ZMod p) ^ k) = 0 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•},\n  Â¬(p - 1) âˆ£ k â†’ (Finset.sum (Finset.range p) (Î» i, i ^ k)) â‰¡ 0 [MOD p] ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•},\n  (p - 1 âˆ£ k â†’ (Finset.sum (Finset.range p) (Î» i, (i : ZMod p) ^ k) = -1)) âˆ§\n  (Â¬(p - 1 âˆ£ k) â†’ (Finset.sum (Finset.range p) (Î» i, (i : ZMod p) ^ k) = 0)) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•},\n  Â¬(p - 1) âˆ£ k â†’ (Finset.sum (Finset.range p) fun x => x ^ k) â‰¡ 0 [ZMOD p] ", "forall {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•},\n  Â¬(p - 1) âˆ£ k â†’ (Finset.sum (Finset.range p) fun i => i ^ k) â‰¡ 0 [MOD p] ", "âˆ€ {p k : â„•} [inst : Fact (Nat.Prime p)], Â¬(p - 1) âˆ£ k â†’\n  (Finset.sum (Finset.range p) fun i => i ^ k) â‰¡ 0 [MOD p]\nâˆ§ (p - 1) âˆ£ k â†’\n  (Finset.sum (Finset.range p) fun i => i ^ k) â‰¡ -1 [MOD p] ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•}, Â¬(p - 1) âˆ£ k â†’ (Finset.sum (Finset.range p) fun x => x ^ k) â‰¡ 0 [MOD p] ", "forall {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•}, Â¬(p - 1) âˆ£ k â†’ (Finset.sum (Finset.range p) fun i => i ^ k) â‰¡ 0 [MOD p] ", "forall {p k : â„•} [inst : Fact (Nat.Prime p)], Â¬ (p - 1) âˆ£ k â†’ ((Finset.sum (Finset.range p) (Î» i, i ^ k)) : ZMod p) = 0 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {k : â„•}, Â¬(p - 1) âˆ£ k â†’ (Finset.sum (Finset.range p) fun i => i ^ k) â‰¡ 0 [MOD p] "]}
{"docString": "Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"}]\n", "prompt_cons": "/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The square of the symbol is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1) :=\n\n/-- Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$. -/\ntheorem", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (ExistsSolution (Î» x, x^4 â‰¡ 2 [ZMOD p]) â†” Exists (Î» A, Exists (Î» B, p = A^2 + 64 * B^2))) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsSolution x ^ 4 â‰¡ 2(p) â†” âˆƒ A B, p = A ^ 2 + 64 * B ^ 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsSquare (2 * â†‘p) â†” âˆƒ A B, p = A ^ 2 + 64 * B ^ 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (HasSolution (Î» x, x^4 â‰¡ 2) â†” Exists (Î» A, Exists (Î» B, p = A^2 + 64 * B^2))) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (IsSolX4Eq2TimesP p â†” âˆƒ A B, p = A ^ 2 + 64 * B ^ 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (HasSolution (Î» x, x ^ 4 â‰¡ 2 [MOD p]) â†” âˆƒ A B : â„•, p = A^2 + 64 * B^2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (ExistsSolX4Eq2 (ZMod p) â†” ExistsSolA2Plus64B2 p) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (Exists (Î» x : ZMod p, x ^ 4 = 2) â†” Exists (Î» A B : â„•, p = A ^ 2 + 64 * B ^ 2)) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (Exists (fun x => x^4 â‰¡ 2 (mod p)) â†” âˆƒ A B, p = A^2 + 64 * B^2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ (Exists (fun x => x ^ 4 â‰¡ 2 [MOD p]) â†” Exists (fun A => Exists (fun B => p = A ^ 2 + 64 * B ^ 2))) "]}
{"docString": "Show that $\\sin (\\pi / 12)$ is an algebraic number.", "prompts": "[{\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 6` is `1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 3` is `âˆš3 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (z : â„‚),\\n  Filter.Tendsto (fun n => â†‘Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (â†‘Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 6` is `âˆš3 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\\n  Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†” EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sine of the angle between three points is 1 if and only if the angle is Ï€ / 2. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\\n  Real.sin (InnerProductGeometry.angle x y) = 1 â†” InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sine of the angle between two vectors is 1 if and only if the angle is Ï€ / 2. \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 3` is `1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (r : â„), HasSum (fun n => (-1) ^ n * r ^ (2 * n + 1) / â†‘(Nat.factorial (2 * n + 1))) (Real.sin r)\",\n  \"isProp\": true,\n  \"docString\": \"The power series expansion of `Real.sin`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] [inst_3 : Nontrivial R]\\n  {x : A}, IsIntegral R x â†’ IsAlgebraic R x\",\n  \"isProp\": true,\n  \"docString\": \"An integral element of an algebra is algebraic.\"}]\n", "prompt_cons": "/-- The sine of `Ï€ / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem âˆ€ (x : â„),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- The sine of `Ï€ / 3` is `âˆš3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem âˆ€ (z : â„‚),\n  Filter.Tendsto (fun n => â†‘Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (â†‘Real.pi * z))) :=\n\n/-- The cosine of `Ï€ / 6` is `âˆš3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- The sine of the angle between three points is 1 if and only if the angle is Ï€ / 2. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\n  Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†” EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ = Real.pi / 2 :=\n\n/-- The sine of the angle between two vectors is 1 if and only if the angle is Ï€ / 2. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\n  Real.sin (InnerProductGeometry.angle x y) = 1 â†” InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- The cosine of `Ï€ / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- The power series expansion of `Real.sin`. -/\ntheorem âˆ€ (r : â„), HasSum (fun n => (-1) ^ n * r ^ (2 * n + 1) / â†‘(Nat.factorial (2 * n + 1))) (Real.sin r) :=\n\n/-- An integral element of an algebra is algebraic. -/\ntheorem âˆ€ (R : Type u) {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] [inst_3 : Nontrivial R]\n  {x : A}, IsIntegral R x â†’ IsAlgebraic R x :=\n\n/-- Show that $\\sin (\\pi / 12)$ is an algebraic number. -/\ntheorem", "choices": ["IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "Real.sin (Real.pi / 12).is_algebraic ", "IsAlgebraic â„ (Real.sin (Real.pi / 12)) ", "IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "sin_pi_over_12_is_algebraic : IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "IsAlgebraic â„š (Real.sin (Real.pi / 12)) ", "IsAlgebraic â„š (Real.sin (Real.pi / 12)) "]}
{"docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"}]\n", "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\nfor some value `v`. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant. -/\ntheorem", "choices": ["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_3} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F} {s : Set E},\n  DifferentiableOn â„‚ f s â†’ IsOpen s â†’ (âˆ€ x âˆˆ s, Complex.im (f x) = 0) â†’ âˆ€ x y âˆˆ s, f x = f y ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {g : E â†’ F} {U : Set E},\n  AnalyticOn â„‚ g U â†’\n    IsOpen U â†’ ContinuousOn g U â†’ (âˆ€ z : E, z âˆˆ U â†’ Complex.im (g z) = 0) â†’ âˆ€ (a b : E), a âˆˆ U â†’ b âˆˆ U â†’ g a = g b ", "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (âˆ€ (x : E), x âˆˆ U â†’ (f x).im = 0) â†’ âˆ€ (x y : E), x âˆˆ U â†’ y âˆˆ U â†’ f x = f y ", "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ (âˆ€ (x : M), x âˆˆ U â†’ (f x).im = 0) â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (âˆ€ (z : E), z âˆˆ U â†’ (f z).im = (f (arbitrary E)).im) â†’ âˆ€ (z w : E), z âˆˆ U â†’ w âˆˆ U â†’ f z = f w ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (âˆ€ (x : E), x âˆˆ U â†’ Im (f x) = 0) â†’ âˆ€ (x y : E), x âˆˆ U â†’ y âˆˆ U â†’ f x = f y ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    IsOpen U â†’ ContinuousOn f U â†’ (âˆ€ (x : E), x âˆˆ U â†’ âˆ€ (y : E), y âˆˆ U â†’ f x = f x) â†’ âˆ€ (a b : E), f a = f b ", "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (âˆ€ (z : E), z âˆˆ U â†’ (f z).im = 0) â†’ âˆ€ (z w : E), z âˆˆ U â†’ w âˆˆ U â†’ f z = f w ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {Î© : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f Î© â†’\n    IsOpen Î© â†’ (âˆƒ (c : â„), âˆ€ (z : E), z âˆˆ Î© â†’ Complex.im (f z) = c) â†’ âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ", "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f U â†’\n    (forall x âˆˆ U, (f x).im = 0) â†’ âˆ€ (x y : E), x âˆˆ U â†’ y âˆˆ U â†’ f x = f y "]}
{"docString": "Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\": \"Â¬Summable fun n => 1 / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„• â†’ â„},\\n  (âˆ€ (n : â„•), 0 â‰¤ f n) â†’ (âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) â†’ ((Summable fun k => 2 ^ k * f (2 ^ k)) â†” Summable f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cauchy condensation test for series of nonnegative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the order of a formal power series is finite,\\nthen the coefficient indexed by the order is nonzero.\"},\n {\"theorem\":\n  \"âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernelâ‚` is convergent. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p q : FormalMultilinearSeries ğ•œ E F),\\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) â‰¤ FormalMultilinearSeries.radius (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The radius of the sum of two formal series is at least the minimum of their two radii. \"}]\n", "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem Â¬Summable fun n => 1 / â†‘n :=\n\n/-- Cauchy condensation test for series of nonnegative real numbers. -/\ntheorem âˆ€ {f : â„• â†’ â„},\n  (âˆ€ (n : â„•), 0 â‰¤ f n) â†’ (âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) â†’ ((Summable fun k => 2 ^ k * f (2 ^ k)) â†” Summable f) :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤ :=\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0 :=\n\n/-- The sum defining `zetaKernelâ‚` is convergent. -/\ntheorem âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2) :=\n\n/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p q : FormalMultilinearSeries ğ•œ E F),\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) â‰¤ FormalMultilinearSeries.radius (p + q) :=\n\n/-- Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle. -/\ntheorem", "choices": ["âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ],\n  Â¬(FormalMultilinearSeries.sum (FormalMultilinearSeries.mk (Î» n, â†‘n * (1 : ğ•œ)) _)) (Complex.exp 1) = âˆ‘' (n : â„•), â†‘n ", "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] [inst_1 : IsAlgClosed ğ•œ] [inst_2 : CharZero ğ•œ], âˆ€ (z : ğ•œ), âˆ¥zâˆ¥ = 1 â†’ Â¬HasSum (Î» n => n * z ^ n) 0 ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {R : â„} [inst_1 : Fact (0 < R)] {r : ğ•œ},\n  HasMem.Mem r (Metric.Sphere 0 R) â†’ Â¬HasSum (fun n => â†‘n * r ^ n) (FormalMultilinearSeries.sum (FormalMultilinearSeries.id ğ•œ R)) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {R : Type u_2} [inst_1 : Semiring R] [inst_2 : Algebra ğ•œ R],\n  Â¬HasSum (fun n => n â€¢ (algebraMap ğ•œ R) ^ n) 1 ", "Â¬(âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {R : Type u_2} [inst_1 : Semiring R] {R' : Type u_3} [inst_2 : Semiring R'] {p : ğ•œ â†’â‚€ R}\n  {q : ğ•œ â†’â‚€ R'}, HasSum (fun n => â†‘(n + 1) * (PowerSeries.coeff ğ•œ n p * PowerSeries.coeff ğ•œ n q)) 1) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : IsROrC ğ•œ],\n  Â¬(FormalMultilinearSeries.radius (fun n => n â€¢ ContinuousMultilinearMap.projâ‚“ ğ•œ n) â‰¤ 1) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : IsROrC ğ•œ],\n  (FormalMultilinearSeries.radius (fun n => n â€¢ (ContinuousMultilinearMap.piFieldEquiv ğ•œ (Finâ‚“ n) ğ•œ).symm)) < 1 ", "âˆ€ {ğ•œ : Type u_1} {R : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : Semiring R] [inst_2 : Algebra ğ•œ R],\n  Â¬AbsoluteConvergenceOn (PowerSeries.mk fun n => â†‘n â€¢ 1) (Metric.Sphere 0 1) ", "âˆ€ (z : â„‚), Complex.abs z = 1 â†’ Â¬HasSum (Î» n, â†‘n * z ^ n) ", "Â¬âˆƒ (x : â„‚), âˆ¥xâˆ¥ = 1 âˆ§ HasSum (Î» n, â†‘n * x ^ n) "]}
{"docString": "Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernelâ‚` is convergent. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"}]\n", "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- The sum defining `zetaKernelâ‚` is convergent. -/\ntheorem âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2) :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$. -/\ntheorem", "choices": ["âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ}, HasSum (Î» n, z ^ n / (n + 1)) (if z = 1 then âŠ¤ else (1 - z)â»Â¹) â†’\n  âˆ€ {z : ğ•œ}, (Complex.abs z = 1 âˆ§ z â‰  1) â†’ Summable (Î» n => z ^ n / (n + 1)) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ], âˆ€ (z : ğ•œ), Complex.abs z = 1 â†’ z â‰  1 â†’\n  Summable (Î» n => (z ^ n) / (n + 1)) ", "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ}, Complex.abs z = 1 â†’ z â‰  1 â†’ Summable (Î» n, z ^ n / â†‘n) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ},\n  Complex.abs (z - 1) < 1 â†’ Summable fun n => z ^ n / â†‘n ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ}, HasNorm z â†’ z â‰  1 â†’\n  Summable fun n => z ^ n / â†‘(Nat.succ n) ", "âˆ€ {ğ•œ : Type u_1} [_inst_1 : IsROrC ğ•œ] (z : ğ•œ), Complex.abs z = 1 â†’ z â‰  1 â†’ Summable (Î» n => z ^ n / (n + 1 : ğ•œ)) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] (z : ğ•œ),\n  (Complex.abs z = 1 âˆ§ z â‰  1) â†’ Summable (Î» n => z^n / n) ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : CompleteSpace ğ•œ] (z : ğ•œ), Complex.abs z = 1 â†’ z â‰  1 â†’ Summable (Î» n, z ^ n / â†‘n) ", "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  ContinuousOn (PowerSeries.sum (PowerSeries.mk (Î» n, if n = 0 then 0 else (1 / â†‘n) * algebraMap â„š A))) (Metric.sphere 0 1)á¶œ ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {z : ğ•œ}, Complex.abs z = 1 â†’ z â‰  1 â†’ Summable fun n => z ^ n / â†‘n "]}
{"docString": "Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 < x â†’ Real.sin x < x\",\n  \"isProp\": true,\n  \"docString\": \"For 0 < x, we have sin x < x. \"},\n {\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 6` is `1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\": \"Real.Gamma (1 / 2) = Real.sqrt Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The special-value formula `Î“(1/2) = âˆšÏ€`, which is equivalent to the Gaussian integral. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 3` is `âˆš3 / 2`. \"}]\n", "prompt_cons": "/-- Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I :=\n\n/-- For 0 < x, we have sin x < x. -/\ntheorem âˆ€ {x : â„}, 0 < x â†’ Real.sin x < x :=\n\n/-- The sine of `Ï€ / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem âˆ€ (x : â„),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- The special-value formula `Î“(1/2) = âˆšÏ€`, which is equivalent to the Gaussian integral. -/\ntheorem Real.Gamma (1 / 2) = Real.sqrt Real.pi :=\n\n/-- The sine of `Ï€ / 3` is `âˆš3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$. -/\ntheorem", "choices": ["âˆ€ (a b : â„),\n  âˆ« (x : â„) in a..b, (Real.sin x) / x = Real.pi / 2 ", "âˆ« (x : â„) in 0..âˆ, Real.sin x / x = Real.pi / 2 ", "âˆ€ (a : â„), (âˆ« (x : â„) in 0..a, Real.sin x / x) = Real.pi / 2 ", "âˆ€ (a : â„), 0 < a â†’ âˆ« (x : â„) in 0..a, Real.sin x / x = Real.pi / 2 ", "Real.has_integral (fun x => Real.sin x / x) (Filter.at_top, 0) (Real.pi / 2) ", "Real.integral_sin_div_tendsto_pi_div_two :\n  Filter.Tendsto (Î» n, âˆ« (x : â„) in 0..n, Real.sin x / x) Filter.atTop (nhds (Real.pi / 2)) ", "Real.integral_sin_div_tendsto_nhds_0 ", "âˆ€ (a : â„), a > 0 â†’ (âˆ« (x : â„) in 0..a, Real.sin x / x = Real.pi / 2) ", "âˆ€ (a : â„) (hf : Filter.Tendsto (Î» (b : â„), âˆ« (x : â„) in a..b, Real.sin x / x) Filter.atTop (nhds (Real.pi / 2))),\n  âˆ« (x : â„) in a..(Real.pi / 2), Real.sin x / x = Real.pi / 2 ", "âˆ€ {a : â„}, 0 â‰¤ a â†’ (âˆ« (x : â„) in a..(âˆ), Real.sin x / x) = Real.pi / 2 "]}
{"docString": "Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {f : ğ•œ â†’ E} {zâ‚€ : ğ•œ},\\n  AnalyticAt ğ•œ f zâ‚€ â†’ (âˆ€á¶  (z : ğ•œ) in nhds zâ‚€, f z = 0) âˆ¨ âˆ€á¶  (z : ğ•œ) in nhdsWithin zâ‚€ {zâ‚€}á¶œ, f z â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *principle of isolated zeros* for an analytic function, local version: if a function is\\nanalytic at `zâ‚€`, then either it is identically zero in a neighborhood of `zâ‚€`, or it does not\\nvanish in a punctured neighborhood of `zâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\\n  {f : E â†’ F} {p : FormalMultilinearSeries ğ•œ E F} {x y : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ y âˆˆ EMetric.ball x r â†’ AnalyticAt ğ•œ f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\\nit is analytic at every point of this ball. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {h : â¦ƒR : Type u_1â¦„ â†’ [inst : CommRing R] â†’ WittVector p R â†’ WittVector p R â†’ WittVector p R}\\n  {f g : â¦ƒR : Type u_1â¦„ â†’ [inst : CommRing R] â†’ WittVector p R â†’ WittVector p R} [hh : WittVector.IsPolyâ‚‚ p h]\\n  [hf : WittVector.IsPoly p f] [hg : WittVector.IsPoly p g], WittVector.IsPolyâ‚‚ p fun R _Rcr x y => h (f x) (g y)\",\n  \"isProp\": true,\n  \"docString\": \"The composition of polynomial functions is polynomial. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], WittVector.IsPoly p fun x x_1 x_2 => 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function that is constantly zero on Witt vectors is a polynomial function. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOn ğ•œ f s â†’ âˆ€ {n : â„•âˆ}, ContDiffOn ğ•œ n f s\",\n  \"isProp\": true,\n  \"docString\": \"An analytic function is infinitely differentiable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. \"}]\n", "prompt_cons": "/-- The *principle of isolated zeros* for an analytic function, local version: if a function is\nanalytic at `zâ‚€`, then either it is identically zero in a neighborhood of `zâ‚€`, or it does not\nvanish in a punctured neighborhood of `zâ‚€`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {f : ğ•œ â†’ E} {zâ‚€ : ğ•œ},\n  AnalyticAt ğ•œ f zâ‚€ â†’ (âˆ€á¶  (z : ğ•œ) in nhds zâ‚€, f z = 0) âˆ¨ âˆ€á¶  (z : ğ•œ) in nhdsWithin zâ‚€ {zâ‚€}á¶œ, f z â‰  0 :=\n\n/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\n  {f : E â†’ F} {p : FormalMultilinearSeries ğ•œ E F} {x y : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ y âˆˆ EMetric.ball x r â†’ AnalyticAt ğ•œ f y :=\n\n/-- The composition of polynomial functions is polynomial. -/\ntheorem âˆ€ {p : â„•} {h : â¦ƒR : Type u_1â¦„ â†’ [inst : CommRing R] â†’ WittVector p R â†’ WittVector p R â†’ WittVector p R}\n  {f g : â¦ƒR : Type u_1â¦„ â†’ [inst : CommRing R] â†’ WittVector p R â†’ WittVector p R} [hh : WittVector.IsPolyâ‚‚ p h]\n  [hf : WittVector.IsPoly p f] [hg : WittVector.IsPoly p g], WittVector.IsPolyâ‚‚ p fun R _Rcr x y => h (f x) (g y) :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q :=\n\n/-- A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€) :=\n\n/-- The function that is constantly zero on Witt vectors is a polynomial function. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], WittVector.IsPoly p fun x x_1 x_2 => 0 :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- An analytic function is infinitely differentiable. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOn ğ•œ f s â†’ âˆ€ {n : â„•âˆ}, ContDiffOn ğ•œ n f s :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z :=\n\n/-- Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial. -/\ntheorem", "choices": ["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  Analytic â„‚ f â†’ (âˆ€ (zâ‚€ : â„‚), âˆƒ n, âˆ€ (p : FormalMultilinearSeries â„‚ â„‚ E), HasFPowerSeriesAt f p zâ‚€ â†’ p n = 0) â†’\n  âˆƒ (q : Polynomial E), âˆ€ (z : â„‚), f z = Polynomial.eval z q ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Analytic ğ•œ f â†’ (âˆ€ zâ‚€, âˆƒ n, (FormalMultilinearSeries.coeff (FormalMultilinearSeries.ofAnalyticAt f zâ‚€) n) = 0) â†’ IsPoly f ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {f : ğ•œ â†’ E},\n  Analytic ğ•œ f â†’ (âˆ€ (zâ‚€ : ğ•œ), âˆƒ n, (FormalMultilinearSeries.radius (pfunctor.map f)) n = 0) â†’ IsPoly ğ•œ f ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  AnalyticAt â„‚ f z0 â†’ (âˆƒ n : â„•, (FormalMultilinearSeries ğ•œ E F).coeff n = 0) â†’ IsPolynomial f ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  (âˆ€ (z : â„‚), AnalyticAt â„‚ f z) â†’ (âˆ€ (zâ‚€ : â„‚), âˆƒ n, (FormalMultilinearSeries.coeff ğ•œ n (AnalyticAt.radiusSeries ğ•œ f zâ‚€)) = 0) â†’ IsPoly â„‚ f ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Analytic â„‚ f â†’ (âˆ€ (zâ‚€ : â„‚), âˆƒ n : â„•, formal_multilinear_series.coeff ğ•œ n (fPowerSeries â„‚ f zâ‚€) = 0) â†’ IsPolynomial f ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Analytic ğ•œ f â†’ (âˆ€ zâ‚€, âˆƒ n, (FormalMultilinearSeries.coeff (AnalyticAt.expansion f zâ‚€)) n = 0) â†’ PolynomialFun â„‚ f ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Analytic â„‚ f â†’ (âˆ€ (zâ‚€ : â„‚), âˆƒ (n : â„•), (FormalMultilinearSeries.coeff ğ•œ E f n).fun zâ‚€ = 0) â†’ IsPoly â„‚ f ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  (âˆ€ (z : â„‚), AnalyticAt â„‚ f z) â†’ (âˆ€ (zâ‚€ : â„‚), âˆƒ (n : â„•), (FormalMultilinearSeries.coeff (AnalyticAt.nhds_power_series f zâ‚€) n).has_const_part = 0) â†’\n  âˆƒ (p : Polynomial E), âˆ€ (z : â„‚), f z = Polynomial.eval z p ", "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  AnalyticOn â„‚ f Set.Univ â†’ (âˆ€ (zâ‚€ : â„‚), âˆƒ n, (FormalMultilinearSeries.radius (FormalMultilinearSeries.removeZero (FderivMeasurableAux.AnalyticOn FderivMeasurableAux.fderivMeasurableAux.has_fpower_series_on_univ)) n zâ‚€).toNnreal = 0) â†’ âˆƒ p : Polynomial â„‚, AnalyticOn â„‚ (â‡‘p) Set.Univ "]}
{"docString": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, âˆ)`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, a < -1 â†’ âˆ€ {c : â„}, 0 < c â†’ MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `0 < c`, then `(Î» t : â„, t ^ a)` is integrable on `(c, âˆ)` for all `a < -1`. \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iic a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-âˆ, a]. \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iio a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-âˆ, a). \"},\n {\"theorem\":\n  \"âˆ€ (x : â„),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„},\\n  a â‰¤ 0 â†’\\n    âˆ€ {z : â„‚},\\n      |z.im| â‰¤ b â†’\\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"}]\n", "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- `exp (-b * x)` is integrable on `(a, âˆ)`. -/\ntheorem âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. -/\ntheorem âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `0 < c`, then `(Î» t : â„, t ^ a)` is integrable on `(c, âˆ)` for all `a < -1`. -/\ntheorem âˆ€ {a : â„}, a < -1 â†’ âˆ€ {c : â„}, 0 < c â†’ MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c) :=\n\n/-- The cardinality of the interval (-âˆ, a]. -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iic a) = Cardinal.continuum :=\n\n/-- The cardinality of the interval (-âˆ, a). -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iio a) = Cardinal.continuum :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem âˆ€ (x : â„),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem âˆ€ {a b : â„},\n  a â‰¤ 0 â†’\n    âˆ€ {z : â„‚},\n      |z.im| â‰¤ b â†’\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$. -/\ntheorem", "choices": ["âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in â„, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) ", "âˆ€ {a : â„}, a > 0 â†’ âˆ« (x : â„) in â„, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) ", "âˆ€ (a : â„), 0 < a â†’ âˆ« (x : â„) in â„, x * Real.sin x / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) ", "âˆ€ (a : â„), 0 < a â†’ âˆ« (x : â„) in â„, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) ", "âˆ€ {a : â„}, a > 0 â†’ âˆ« (x : â„) in â„, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) ", "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) ", "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in â„, x * Real.sin x / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) ", "âˆ€ {a : â„}, a > 0 â†’ âˆ« (x : â„) in -âˆ..âˆ, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Ï€ * rexp (-a) ", "âˆ€ {a : â„}, 0 < a â†’\n  (integral (MeasureTheory.Measure.dirac â„) fun x => (x * Real.sin x) / (x ^ 2 + a ^ 2)) = Real.pi * rexp (-a) ", "âˆ€ (a : â„), a > 0 â†’ âˆ« (x : â„) in Set.Univ, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) "]}
{"docString": "Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) [inst : IsTrichotomous Î± r] [inst : IsIrrefl Î² s]\\n  (f : Î± â†’ Î²), (âˆ€ {x y : Î±}, r x y â†’ s (f x) (f y)) â†’ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"An increasing function is injective \"},\n {\"theorem\":\n  \"âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EmbeddingLike F Î± Î²] (f : F),\\n  Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"The coercion to functions must produce injective functions. \"},\n {\"theorem\":\n  \"âˆ€ {E : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EquivLike E Î± Î²] (e g : E),\\n  EquivLike.coe e = EquivLike.coe g â†’ EquivLike.inv e = EquivLike.inv g â†’ e = g\",\n  \"isProp\": true,\n  \"docString\": \"The two coercions to functions are jointly injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u_3} {Î² : Sort u_1} {Î³ : Sort u_2} {g : Î² â†’ Î³},\\n  Function.Injective g â†’ Function.Injective ((fun x x_1 => x âˆ˜ x_1) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition by an injective function on the left is itself injective. \"},\n {\"theorem\":\n  \"âˆ€ {c : â„}, 0 < c â†’ c < 1 / 2 â†’ Function.Injective (Cardinal.cantorFunction c)\",\n  \"isProp\": true,\n  \"docString\": \"`cantorFunction c` is injective if `0 < c < 1/2`. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : T2Space Î²] [inst_2 : MeasurableSpace Î²] [inst_3 : BorelSpace Î²] {f : Î³ â†’ Î²},\\n  Continuous f â†’ Function.Injective f â†’ MeasurableSet (Set.range f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\\nspace is Borel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Î± â†’ Sort u_3)} [self : FunLike F Î± Î²],\\n  Function.Injective FunLike.coe\",\n  \"isProp\": true,\n  \"docString\": \"The coercion to functions must be injective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {n : â„•}, 0 < n â†’ Function.Injective â†‘(Polynomial.expand R n)\",\n  \"isProp\": true,\n  \"docString\": \"Expansion is injective. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective â†‘(algebraMap R A) â†’ âˆ€ [inst : CharZero R], CharZero A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R â†’+* A` is injective and `R` has characteristic zero then so does `A`. \"}]\n", "prompt_cons": "/-- An increasing function is injective -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) [inst : IsTrichotomous Î± r] [inst : IsIrrefl Î² s]\n  (f : Î± â†’ Î²), (âˆ€ {x y : Î±}, r x y â†’ s (f x) (f y)) â†’ Function.Injective f :=\n\n/-- The coercion to functions must produce injective functions. -/\ntheorem âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EmbeddingLike F Î± Î²] (f : F),\n  Function.Injective â†‘f :=\n\n/-- The two coercions to functions are jointly injective. -/\ntheorem âˆ€ {E : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EquivLike E Î± Î²] (e g : E),\n  EquivLike.coe e = EquivLike.coe g â†’ EquivLike.inv e = EquivLike.inv g â†’ e = g :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem âˆ€ {Î± : Sort u_3} {Î² : Sort u_1} {Î³ : Sort u_2} {g : Î² â†’ Î³},\n  Function.Injective g â†’ Function.Injective ((fun x x_1 => x âˆ˜ x_1) g) :=\n\n/-- `cantorFunction c` is injective if `0 < c < 1/2`. -/\ntheorem âˆ€ {c : â„}, 0 < c â†’ c < 1 / 2 â†’ Function.Injective (Cardinal.cantorFunction c) :=\n\n/-- The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem âˆ€ {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : T2Space Î²] [inst_2 : MeasurableSpace Î²] [inst_3 : BorelSpace Î²] {f : Î³ â†’ Î²},\n  Continuous f â†’ Function.Injective f â†’ MeasurableSet (Set.range f) :=\n\n/-- The coercion to functions must be injective. -/\ntheorem âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Î± â†’ Sort u_3)} [self : FunLike F Î± Î²],\n  Function.Injective FunLike.coe :=\n\n/-- Expansion is injective. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {n : â„•}, 0 < n â†’ Function.Injective â†‘(Polynomial.expand R n) :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- If the algebra map `R â†’+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective â†‘(algebraMap R A) â†’ âˆ€ [inst : CharZero R], CharZero A :=\n\n/-- Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$. -/\ntheorem", "choices": ["âˆ€ {â„‚ : Type u_1} [inst : ComplexField â„‚] {f : â„‚ â†’ â„‚},\n  Entire f â†’ Function.Injective f â†’ âˆƒ (a b : â„‚), a â‰  0 âˆ§ âˆ€ (z : â„‚), f z = a * z + b ", "âˆ€ {â„‚ : Type u_1} [inst : NormedField â„‚] [inst_1 : CompleteSpace â„‚] {f : â„‚ â†’ â„‚},\n  (Entire f) âˆ§ (Function.Injective f) â†’ âˆƒ (a b : â„‚), (a â‰  0) âˆ§ (f = (Î» z, a * z + b)) ", "âˆ€ {â„‚ : Type u_1} [inst : IsDomain â„‚] [inst_1 : NormedField â„‚] {f : â„‚ â†’ â„‚},\n  Function.Injective f â†’ (âˆ€ x : â„‚, DifferentiableAt â„‚ f x) â†’ âˆƒ a b : â„‚, a â‰  0 âˆ§ f = (Î» x, a * x + b) ", "âˆ€ {â„‚ : Type u_1} [inst : ComplexField â„‚] {f : â„‚ â†’ â„‚},\n  (Entire f) âˆ§ (Function.Injective f) â†’ âˆƒ (a b : â„‚), a â‰  0 âˆ§ (f = (Î» z, a * z + b)) ", "âˆ€ {â„‚ : Type u} [inst : ComplexField â„‚] {f : â„‚ â†’ â„‚},\n  ComplexField.Entire f â†’ Function.Injective f â†’ âˆƒ (a : â„‚) (b : â„‚), a â‰  0 âˆ§ f = fun z => a * z + b ", "âˆ€ {â„‚ : Type u_1} [inst : IsComplex â„‚] [inst_1 : MeasurableSpace â„‚] [inst_2 : MeasurableSpace â„‚] {f : â„‚ â†’ â„‚},\n  Entire f â†’ Function.Injective f â†’ âˆƒ a b : â„‚, a â‰  0 âˆ§ âˆ€ z : â„‚, f z = a * z + b ", "âˆ€ {â„‚ : Type u_1} [inst : TopologicalSpace â„‚] {m : MeasurableSpace â„‚} [inst_1 : TopologicalSpace â„]\n  [inst_2 : T2Space â„] {Î¼ : MeasureTheory.Measure â„‚} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f : â„‚ â†’ â„},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] (fun z => a * z + b) â†’ Continuous f â†’ Function.Injective f â†’ a â‰  0 â†’ f = (fun z => a * z + b)\n  where a b : â„‚ ", "âˆ€ {â„‚ : Type u_1} [inst : IsDomain â„‚] [inst_1 : Algebra â„‚ â„‚] (f : â„‚ â†’ â„‚),\n  DifferentiableAt â„‚ f â†’ Function.Injective f â†’ âˆƒ (a b : â„‚), a â‰  0 âˆ§ f = (Î» (z : â„‚), a * z + b) ", "âˆ€ {â„‚ : Type u_1} [inst : IsAlgClosed â„‚] [inst_1 : CharZero â„‚], (âˆ€ (f : â„‚ â†’ â„‚),\n  DifferentiableAt â„‚ f Set.Univ â†’ (âˆ€ (n : â„•), DifferentiableAt â„‚ (deriv^n f) Set.Univ) â†’\n  Function.Injective f â†’ âˆƒ (a b : â„‚), a â‰  0 âˆ§ f = (fun z => a * z + b)) ", "âˆ€ {â„‚ : Type u_1} [inst : NormedField â„‚] [inst_1 : IsROrC â„‚] {f : â„‚ â†’ â„‚},\n  (Entire f) âˆ§ (Function.Injective f) â†’ âˆƒ (a b : â„‚), a â‰  0 âˆ§ f = (fun z => a * z + b) "]}
{"docString": "Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\\n  0 â‰¤ R â†’\\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\\n      Set.Countable s â†’\\n        ContinuousOn f (Metric.closedBall c R) â†’\\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p q : â„},\\n  Real.IsConjugateExponent p q â†’\\n    âˆ€ {f g : Î± â†’ ENNReal},\\n      AEMeasurable f â†’\\n        âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  âŠ¤ â†’\\n          âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  âŠ¤ â†’\\n            âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  0 â†’\\n              âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  0 â†’\\n                âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)\",\n  \"isProp\": true,\n  \"docString\": \"HÃ¶lder's inequality in case of finite non-zero integrals \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball c R) â†’\\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) â†’ f c = c â†’ 0 < R â†’ â†‘Complex.abs (deriv f c) â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk of positive radius to itself and the\\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\\nthis disk is at most `1`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚} {Îµ r : â„},\\n  DiffContOnCl â„‚ f (Metric.ball zâ‚€ r) â†’\\n    0 < r â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.sphere zâ‚€ r â†’ Îµ â‰¤ â€–f z - f zâ‚€â€–) â†’\\n        (âˆƒá¶  (z : â„‚) in nhds zâ‚€, f z â‰  f zâ‚€) â†’ Metric.ball (f zâ‚€) (Îµ / 2) âŠ† f '' Metric.closedBall zâ‚€ r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the modulus of a holomorphic function `f` is bounded below by `Îµ` on a circle, then its range\\ncontains a disk of radius `Îµ / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"}]\n", "prompt_cons": "/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\n  0 â‰¤ R â†’\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\n      Set.Countable s â†’\n        ContinuousOn f (Metric.closedBall c R) â†’\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0 :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- HÃ¶lder's inequality in case of finite non-zero integrals -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p q : â„},\n  Real.IsConjugateExponent p q â†’\n    âˆ€ {f g : Î± â†’ ENNReal},\n      AEMeasurable f â†’\n        âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  âŠ¤ â†’\n          âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  âŠ¤ â†’\n            âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  0 â†’\n              âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  0 â†’\n                âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q) :=\n\n/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f)) :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk of positive radius to itself and the\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\nthis disk is at most `1`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball c R) â†’\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) â†’ f c = c â†’ 0 < R â†’ â†‘Complex.abs (deriv f c) â‰¤ 1 :=\n\n/-- If the modulus of a holomorphic function `f` is bounded below by `Îµ` on a circle, then its range\ncontains a disk of radius `Îµ / 2`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚} {Îµ r : â„},\n  DiffContOnCl â„‚ f (Metric.ball zâ‚€ r) â†’\n    0 < r â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.sphere zâ‚€ r â†’ Îµ â‰¤ â€–f z - f zâ‚€â€–) â†’\n        (âˆƒá¶  (z : â„‚) in nhds zâ‚€, f z â‰  f zâ‚€) â†’ Metric.ball (f zâ‚€) (Îµ / 2) âŠ† f '' Metric.closedBall zâ‚€ r :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$. -/\ntheorem", "choices": ["âˆ€ {f : â„‚ â†’ â„‚} {d : â„•} {z : â„• â†’ â„‚},\n  (âˆ€ (n : â„•), Complex.abs (z n) < 1) â†’\n    IsHolomorphic f (Metric.closedBall 0 1) â†’\n      BoundedContinuous (restrict f (Metric.closedBall 0 1)) â†’\n        f â‰  0 â†’\n          (âˆ€ (n : â„•), f (z n) = 0) â†’\n            Summable (fun n => 1 - Complex.abs (z n)) ", "âˆ€ {f : â„‚ â†’ â„‚},\n  DiffContOnCl â„‚ f (Metric.ball 0 1) â†’\n    (âˆ€ (z : â„‚), z âˆˆ Metric.ball 0 1 â†’ f z â‰  0) â†’\n      (âˆ€ (n : â„•) (z : â„‚), â†‘Complex.abs z < 1 â†’ f z = 0 â†’ âˆ‘ i in Finset.range n, (1 - â†‘Complex.abs z) < âŠ¤) ", "âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : NontriviallyNormedField ğ•œ] [inst_2 : NormedAddCommGroup E]\n  [inst_3 : NormedSpace ğ•œ E] {f : Î± â†’ E} {p : FormalMultilinearSeries ğ•œ Î± E} {z : â„• â†’ Î±} {R : â„},\n  RieszCriterion f p â†’\n    Set.PairwiseOn (Set.Range z) (Î» (i j : Î±), 1 - â€–iâ€– < â€–f i - f jâ€–) â†’\n      ('i : â„•), 1 - â€–z 'iâ€– < â€–f (z 'i)â€– â†’ Summable (Î» (n : â„•), 1 - â€–z nâ€–) ", "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NormedField ğ•œ] [inst_1 : IsROrC ğ•œ] [inst_2 : NormedGroup E] [inst_3 : NormedSpace ğ•œ E] {f : E â†’ ğ•œ},\n  DifferentiableOn ğ•œ f (Metric.ball 0 1) â†’\n    Bounded (Set.Range f) â†’\n      Â¬(âˆ€ (x : E), x âˆˆ Metric.ball 0 1 â†’ f x = 0) â†’\n        âˆƒ (s : â„• â†’ E), (âˆ€ (n : â„•), s n âˆˆ Metric.ball 0 1 âˆ§ f (s n) = 0) âˆ§ (summable fun n => 1 - Complex.abs (s n)) ", "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [IsROrC ğ•œ] {f : ğ•œ â†’ ğ•œ},\n  DiffContOnCl ğ•œ f (Metric.ball 0 1) â†’\n    Bounded ğ•œ f (Metric.ball 0 1) â†’\n      f â‰  0 â†’\n        (âˆ€ (n : â„•), âˆƒ (z : ğ•œ), â†‘Complex.abs z < 1 âˆ§ f z = 0) â†’\n          Summable (Î» (n : â„•), 1 - â†‘Complex.abs (Classical.some (_ : âˆƒ (z : ğ•œ), â†‘Complex.abs z < 1 âˆ§ f z = 0))) ", "âˆ€ {f : â„‚ â†’ â„‚} {zs : â„• â†’ â„‚},\n  DiffContOnCl â„‚ f (Metric.ball 0 1) â†’\n    Bounded (range f) â†’\n      f â‰  Zero.zero â†’\n        (âˆ€ (n : â„•), â†‘Complex.abs (zs n) < 1 âˆ§ f (zs n) = 0) â†’\n          Summable (Î» (n : â„•), 1 - â†‘Complex.abs (zs n)) ", "âˆ€ {f : â„‚ â†’ â„‚} {z : â„• â†’ â„‚},\n  DiffContOnCl â„‚ f (Metric.ball 0 1) â†’\n    (âˆ€ (n : â„•), f (z n) = 0) â†’\n      (âˆ€ (n : â„•), â†‘Complex.abs (z n) < 1) â†’\n        (âˆƒá¶  (w : â„‚) in nhds 0, f w â‰  0) â†’\n          Summable (Î» (n : â„•), 1 - â†‘Complex.abs (z n)) ", "âˆ€ {f : â„‚ â†’ â„‚} {z : â„• â†’ â„‚},\n  DifferentiableOn â„‚ f (Metric.ball 0 1) â†’\n    (âˆ€ (n : â„•), HasComplexDerivative f (z n) âˆ§ â†‘Complex.abs (z n) < 1) â†’\n      BoundedContinuousFunction f (Metric.closedBall 0 1) â†’\n        f â‰  0 â†’\n          HasSum (fun n => 1 - â†‘Complex.abs (z n)) ", "âˆ€ {f : â„‚ â†’ â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin 0 (Metric.ball 0 1), DifferentiableAt â„‚ f z) â†’\n    Bounded (Set.Range f) â†’\n      f â‰  0 â†’\n        âˆ€ (z : â„‚), HasMem.Mem z (f â»Â¹' {0}) â†’ â†‘Complex.abs z < 1 â†’\n          HasSum (fun n => 1 - â†‘Complex.abs (Set.InvOn f (f â»Â¹' {0}) n)) âŠ¤ ", "âˆ€ {f : â„‚ â†’ â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ 0 < R â†’\n        âˆ€ {z : â„‚}, â†‘Complex.abs z < R â†’ z â‰  0 â†’ âˆƒá¶  (n : â„•) in Filter.atTop, (1 - â†‘Complex.abs (z n)) < âŠ¤ â†’\n          Summable (Î» n, 1 - â†‘Complex.abs (z n)) "]}
{"docString": "Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\\n  ConvexOn â„ (Set.Ioi 0) f â†’\\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ 2 â‰¤ n â†’ 0 < x â†’ f â†‘n + x * Real.log (â†‘n - 1) â‰¤ f (â†‘n + x)\",\n  \"isProp\": true,\n  \"docString\": \"Linear lower bound for `f (x + n)` on unit interval \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {n : â„•âˆ}, ContDiff ğ•œ n f â†’ 1 â‰¤ n â†’ Differentiable ğ•œ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `n â‰¥ 1`, then it is differentiable. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {x : E} {n : â„•âˆ}, ContDiffAt ğ•œ n f x â†’ 1 â‰¤ n â†’ DifferentiableAt ğ•œ f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `n â‰¥ 1` at a point, then it is differentiable there. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : Preorder Î±] {f : Fin (n + 1) â†’ Î±},\\n  Monotone f â†” âˆ€ (i : Fin n), f (Fin.castSucc i) â‰¤ f (Fin.succ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` on `Fin (n + 1)` is monotone if and only if `f i â‰¤ f (i + 1)` for all `i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•âˆ} {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {F' : Type u_2} [inst_1 : NormedAddCommGroup F'] [inst_2 : NormedSpace ğ•‚ F']\\n  {f : ğ•‚ â†’ F'} {x : ğ•‚}, ContDiff ğ•‚ n f â†’ 1 â‰¤ n â†’ HasStrictDerivAt f (deriv f x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. \"}]\n", "prompt_cons": "/-- If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n] :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x :=\n\n/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\n  ConvexOn â„ (Set.Ioi 0) f â†’\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ 2 â‰¤ n â†’ 0 < x â†’ f â†‘n + x * Real.log (â†‘n - 1) â‰¤ f (â†‘n + x) :=\n\n/-- If a function is `C^n` with `n â‰¥ 1`, then it is differentiable. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {n : â„•âˆ}, ContDiff ğ•œ n f â†’ 1 â‰¤ n â†’ Differentiable ğ•œ f :=\n\n/-- If a function is `C^n` with `n â‰¥ 1` at a point, then it is differentiable there. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {x : E} {n : â„•âˆ}, ContDiffAt ğ•œ n f x â†’ 1 â‰¤ n â†’ DifferentiableAt ğ•œ f x :=\n\n/-- A function `f` on `Fin (n + 1)` is monotone if and only if `f i â‰¤ f (i + 1)` for all `i`. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : Preorder Î±] {f : Fin (n + 1) â†’ Î±},\n  Monotone f â†” âˆ€ (i : Fin n), f (Fin.castSucc i) â‰¤ f (Fin.succ i) :=\n\n/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼ :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f :=\n\n/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- If a function is `C^n` with `1 â‰¤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem âˆ€ {n : â„•âˆ} {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {F' : Type u_2} [inst_1 : NormedAddCommGroup F'] [inst_2 : NormedSpace ğ•‚ F']\n  {f : ğ•‚ â†’ F'} {x : ğ•‚}, ContDiff ğ•‚ n f â†’ 1 â‰¤ n â†’ HasStrictDerivAt f (deriv f x) x :=\n\n/-- Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$. -/\ntheorem", "choices": ["âˆ€ {f : â„ â†’ â„} [inst : InfiniteContDiff â„ f], f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ x : â„, 0 â‰¤ f x) â†’ âˆƒ n : â„•, âˆƒ x : â„, 0 < n âˆ§ f^[n] x < 0 ", "âˆ€ {f : â„ â†’ â„} [inst : ContDiff â„ ğ”¼ f], f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ (x : â„), 0 â‰¤ f x) â†’\n  âˆƒ (n : â„•), âˆƒ (x : â„), 0 < n âˆ§ f^[n] x < 0 ", "âˆ€ {ğ•‚ : Type u} [inst : IsROrC ğ•‚] {F' : Type u_2} [inst_1 : NormedAddCommGroup F'] [inst_2 : NormedSpace ğ•‚ F']\n  {f : ğ•‚ â†’ F'}, ContDiff ğ•‚ âŠ¤ f â†’ f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ x, 0 â‰¤ f x) â†’ âˆƒ (n : â„•) (x : ğ•‚), 0 < n âˆ§ f^[n] x < 0 ", "âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Continuous â„ f â†’ f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ (x : â„), 0 â‰¤ f x) â†’\nâˆƒ (n : â„•) (x : â„), 0 < n âˆ§ deriv^[n] f x < 0 ", "âˆ€ {f : â„ â†’ â„}, Continuous f â†’ f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ (x : â„), 0 â‰¤ f x) â†’ âˆƒ (n : â„•) (x : â„), n > 0 âˆ§ f^[n] x < 0 ", "âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ {n : â„•}, Differentiable^n â„ f) â†’ f 0 = 0 â†’ f 1 = 1 â†’ âˆ€ (x : â„), 0 â‰¤ f x â†’ (âˆƒ (n : â„•) (y : â„), f^[n] y < 0) ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), 0 â‰¤ f x) â†’ f 0 = 0 â†’ f 1 = 1 â†’\n  (âˆ€ (x : â„), Differentiable â„ f) â†’\n  âˆƒ (n : â„•) (x : â„), 0 < n âˆ§ f^[n] x < 0 ", "âˆ€ {f : â„ â†’ â„} [inst : âˆ€ x, ContDiff ğ•œ â„•âˆ f x] {x : â„},\n  f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ x, 0 â‰¤ f x) â†’ âˆƒ (n : â„•) (x : â„), n > 0 âˆ§ f^[n] x < 0 ", "âˆ€ {f : â„ â†’ â„} [inst : ContDiff â„ ğ”¸ f], f 0 = 0 â†’ f 1 = 1 â†’ (âˆ€ x, 0 â‰¤ f x) â†’ âˆƒ (n : â„•) (x : â„), n > 0 âˆ§ f^[n] x < 0 ", "âˆ€ {f : â„ â†’ â„} [inst : Smooth â„ f] (hfâ‚€ : f 0 = 0) (hfâ‚ : f 1 = 1) (hfâ‚‚ : âˆ€ (x : â„), 0 â‰¤ f x),\n  âˆƒ (n : â„•) (x : â„), n > 0 âˆ§ f^[n] x < 0 "]}
{"docString": "Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic.", "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, orderOf (QuaternionGroup.a 1) = 2 * n\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a 1` has order `2 * n`.\\n\"},\n {\"theorem\": \"âˆ€ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialNumerators (GeneralizedContinuedFraction.of v)) n = some a â†’\\n    a = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that the partial numerators `aáµ¢` are equal to one. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] (a : R) {n : â„•}, n â‰  0 â†’ Polynomial.Monic (Polynomial.X ^ n - â†‘Polynomial.C a)\",\n  \"isProp\": true,\n  \"docString\": \"`X ^ n - a` is monic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {a : R} [inst : Monoid R] {n : â„•}, 0 < n â†’ (IsRightRegular (a ^ n) â†” IsRightRegular a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` is right-regular if and only if a positive power of `a` is right-regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"âˆ€ (n a : â„•) (p : â„• â†’ Prop) [inst : DecidablePred p],\\n  Function.Periodic p a â†’ Finset.card (Finset.filter p (Finset.Ico n (n + a))) = Nat.count p a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An interval of length `a` filtered over a periodic predicate of period `a` has cardinality\\nequal to the number naturals below `a` for which `p a` is true. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {a : R} [inst : Monoid R] {n : â„•}, 0 < n â†’ (IsRegular (a ^ n) â†” IsRegular a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` is regular if and only if a positive power of `a` is regular. \"}]\n", "prompt_cons": "/-- If `0 < n`, then `a 1` has order `2 * n`. -/\ntheorem âˆ€ {n : â„•}, orderOf (QuaternionGroup.a 1) = 2 * n :=\n\n/-- `a ^ 0 = 1` -/\ntheorem âˆ€ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x :=\n\n/-- Shows that the partial numerators `aáµ¢` are equal to one. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialNumerators (GeneralizedContinuedFraction.of v)) n = some a â†’\n    a = 1 :=\n\n/-- `X ^ n - a` is monic. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (a : R) {n : â„•}, n â‰  0 â†’ Polynomial.Monic (Polynomial.X ^ n - â†‘Polynomial.C a) :=\n\n/-- An element `a` is right-regular if and only if a positive power of `a` is right-regular. -/\ntheorem âˆ€ {R : Type u_1} {a : R} [inst : Monoid R] {n : â„•}, 0 < n â†’ (IsRightRegular (a ^ n) â†” IsRightRegular a) :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f) :=\n\n/-- An interval of length `a` filtered over a periodic predicate of period `a` has cardinality\nequal to the number naturals below `a` for which `p a` is true. -/\ntheorem âˆ€ (n a : â„•) (p : â„• â†’ Prop) [inst : DecidablePred p],\n  Function.Periodic p a â†’ Finset.card (Finset.filter p (Finset.Ico n (n + a))) = Nat.count p a :=\n\n/-- An element `a` is regular if and only if a positive power of `a` is regular. -/\ntheorem âˆ€ {R : Type u_1} {a : R} [inst : Monoid R] {n : â„•}, 0 < n â†’ (IsRegular (a ^ n) â†” IsRegular a) :=\n\n/-- Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic. -/\ntheorem", "choices": ["âˆ€ {a : â„} {n : â„•}, n â‰  0 â†’ (Seqâ‚“â‚“.nth (Recurrence.sequence (Î» x y z, 2 * x * y - z) 1 a a) n = 0 â†’ Function.Periodic (Seqâ‚“â‚“.nth (Recurrence.sequence (Î» x y z, 2 * x * y - z) 1 a a)) n) ", "âˆ€ {a : â„} {n : â„•}, n > 0 â†’ Seqâ‚“â‚“.nth (Chebyshev.Ï a) n = 0 â†’ Function.Periodic (Seqâ‚“â‚“.nth (Chebyshev.Ï a)) n ", "forall {a : â„} (n : â„•), n > 0 â†’ (Stream'.iterate (Î» x, 2 * x.snd * x.fst - x.snd) (1, a, a)).nth n = 0 â†’ Function.Periodic (Stream'.nth (Stream'.iterate (Î» x, 2 * x.snd * x.fst - x.snd) (1, a, a))) n ", "âˆ€ {a : â„} {n : â„•}, n â‰  0 â†’\n  sequencePeriodic (Î» n, Chebyshev1.chebyshev1PolyEval a n) 0 â†’ sequencePeriodic (Î» n, Chebyshev1.chebyshev1PolyEval a n) n ", "let a : â„ in\nlet x : â„• â†’ â„ ", "âˆ€ {a : â„} {n : â„•}, n â‰  0 â†’ (0 < n â†’ âˆƒ (m : â„•), 0 < m âˆ§ Function.Periodic (fun (k : â„•) => Chebyshev.chebyshevâ‚_iterate a (k + n)) m) ", "âˆ€ {a : â„} (n : â„•), 0 < n â†’ (Function.IsPeriodicPt (fun x : â„ => 2 * x) n a â†” a = 0) ", "âˆ€ {a : â„} {n : â„•}, n > 0 â†’ (Stream'.Seq.get? (Stream'.iterate (fun x => 2 * x.1 * x.2 - x.1) (1, a, a)) n = 0) â†’ Function.Periodic (Stream'.Seq.get? (Stream'.iterate (fun x => 2 * x.1 * x.2 - x.1) (1, a, a))) n ", "âˆ€ {a : â„} {n : â„•}, n â‰  0 â†’ (Stream'.Seq.get? (Function.Periodic.sequence a) n = 0 â†’ Function.Periodic (Function.Periodic.sequence a) n) ", "theorem chebyshev_recurrence {a : â„} {n : â„•} :\n  (0 < n) â†’\n  let x "]}
{"docString": "Let", "prompts": "[{\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\\n  CategoryTheory.CategoryStruct.comp self.gâ‚ self.fâ‚ = CategoryTheory.CategoryStruct.comp self.gâ‚‚ self.fâ‚‚\",\n  \"isProp\": true,\n  \"docString\": \"The relation itself. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] (s : Finset Î±), BddBelow â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finset is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (o : Part Î±), { Dom := o.Dom, get := fun h => Part.get o h } = o\",\n  \"isProp\": true,\n  \"docString\": \"`Part` eta expansion \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}\\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C â†’ D}\\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C),\\n  (CategoryTheory.MonoidalCategory.leftUnitor (F X)).hom =\\n    CategoryTheory.CategoryStruct.comp\\n      (CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.LaxMonoidal.Îµ (CategoryTheory.CategoryStruct.id (F X)))\\n      (CategoryTheory.CategoryStruct.comp\\n        (CategoryTheory.LaxMonoidal.Î¼ (CategoryTheory.MonoidalCategory.tensorUnit C) X)\\n        (CategoryTheory.map F (CategoryTheory.MonoidalCategory.leftUnitor X).hom))\",\n  \"isProp\": true,\n  \"docString\": \"left unitality \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsProper I], â†‘I â‰  Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is not the whole set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {o p : Part Î±}, (o.Dom â†” p.Dom) â†’ (âˆ€ (hâ‚ : o.Dom) (hâ‚‚ : p.Dom), Part.get o hâ‚ = Part.get p hâ‚‚) â†’ o = p\",\n  \"isProp\": true,\n  \"docString\": \"`Part` extensionality \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (self : ClosureOperator Î±) (x : Î±), x â‰¤ â†‘self.toOrderHom x\",\n  \"isProp\": true,\n  \"docString\": \"An element is less than or equal its closure \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}\\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C â†’ D}\\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] {X Y X' Y' : C} (f : X âŸ¶ Y)\\n  (g : X' âŸ¶ Y'),\\n  CategoryTheory.CategoryStruct.comp\\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.map F f) (CategoryTheory.map F g))\\n      (CategoryTheory.LaxMonoidal.Î¼ Y Y') =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.LaxMonoidal.Î¼ X X')\\n      (CategoryTheory.map F (CategoryTheory.MonoidalCategory.tensorHom f g))\",\n  \"isProp\": true,\n  \"docString\": \"naturality \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} [self : CategoryTheory.IsSplitEpi f],\\n  Nonempty (CategoryTheory.SplitEpi f)\",\n  \"isProp\": true,\n  \"docString\": \"There is a splitting \"}]\n", "prompt_cons": "/-- The relation itself. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.CategoryStruct.comp self.gâ‚ self.fâ‚ = CategoryTheory.CategoryStruct.comp self.gâ‚‚ self.fâ‚‚ :=\n\n/-- A finset is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] (s : Finset Î±), BddBelow â†‘s :=\n\n/-- The ideal is nonempty. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- `Part` eta expansion -/\ntheorem âˆ€ {Î± : Type u_1} (o : Part Î±), { Dom := o.Dom, get := fun h => Part.get o h } = o :=\n\n/-- left unitality -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C â†’ D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C),\n  (CategoryTheory.MonoidalCategory.leftUnitor (F X)).hom =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.LaxMonoidal.Îµ (CategoryTheory.CategoryStruct.id (F X)))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.LaxMonoidal.Î¼ (CategoryTheory.MonoidalCategory.tensorUnit C) X)\n        (CategoryTheory.map F (CategoryTheory.MonoidalCategory.leftUnitor X).hom)) :=\n\n/-- This ideal is not the whole set. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsProper I], â†‘I â‰  Set.univ :=\n\n/-- `Part` extensionality -/\ntheorem âˆ€ {Î± : Type u_1} {o p : Part Î±}, (o.Dom â†” p.Dom) â†’ (âˆ€ (hâ‚ : o.Dom) (hâ‚‚ : p.Dom), Part.get o hâ‚ = Part.get p hâ‚‚) â†’ o = p :=\n\n/-- An element is less than or equal its closure -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (self : ClosureOperator Î±) (x : Î±), x â‰¤ â†‘self.toOrderHom x :=\n\n/-- naturality -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C â†’ D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] {X Y X' Y' : C} (f : X âŸ¶ Y)\n  (g : X' âŸ¶ Y'),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.map F f) (CategoryTheory.map F g))\n      (CategoryTheory.LaxMonoidal.Î¼ Y Y') =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.LaxMonoidal.Î¼ X X')\n      (CategoryTheory.map F (CategoryTheory.MonoidalCategory.tensorHom f g)) :=\n\n/-- There is a splitting -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f) :=\n\n/-- Let -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : HasSup Î±] (a b c : Î±), let x ", "âˆ€ {Î± : Type u} {Î² : Î± â†’ Type v} {Î³ : Type w} (f : Î³ â†’ (Î£ a, Î² a)) (g : Î³ â†’ Î±) (h : âˆ€ (c : Î³), g c = (f c).fst),\n  âˆƒ (k : âˆ€ (a : Î±), Î³ â†’ Î² a),\n    âˆ€ (c : Î³), (g c, k (g c) c) = f c ", "âˆ€ {Î± : Type u_1} (A B C D : Set Î±) (e : A = B) (f : C = D) (g : B = C), A = D ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : PartialOrder Î±] (self : GaloisConnection Î± Î²) {a : Î±} {b : Î²},\n  a â‰¤ â†‘self.lift b â†” b â‰¤ â†‘self.lower a ", "âˆ€ {Î± : Type u} {m : Î± â†’ Î± â†’ Î±} [inst : IsAssociative Î± m] [inst_1 : IsCommutative Î± m] (a b c : Î±),\n  Let d ", "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] (a b : Î±), CategoryTheory.Let a b = (a â‰¤ b) ", "âˆ€ {Î± : Type u} [inst : HasAdd Î±] [inst_1 : One Î±] (n m : â„•), n * m + 1 = (n + 1) * (m + 1) - n - m - 1 ", "âˆ€ {A : Type u} [inst : Add A] [inst_1 : Subsingleton A] (x y : A), x = y ", "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {x : Î±} (h : âˆƒ (x_1 : Î±), p x_1), Exists.some h = x â†’ p x ", "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {a : Î±} {l : List Î±}, List.chain' p (a :: l) â†’ p a âˆ§ List.chain' p l "]}
{"docString": "Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {b : â„•} {l : List â„•}, (âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) â†’ Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b + 2 is less than (b + 2)^n \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, Pell.IsFundamental a â†’ StrictMono fun n => Pell.Solutionâ‚.y (a ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map sending an integer `n` to the `y`-coordinate of `a^n` for a fundamental\\nsolution `a` is stritcly increasing. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} (q : â„•) {p : â„•},\\n  Nat.Prime p â†’\\n    p â‰¤ 2 * q â†’ (n < q â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n) â†’ n < p â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\\ndescending list of primes, each no more than twice the next, such that the list contains a witness\\nfor each number â‰¤ n.\\n\"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem âˆ€ {b : â„•} {l : List â„•}, (âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) â†’ Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- The map sending an integer `n` to the `y`-coordinate of `a^n` for a fundamental\nsolution `a` is stritcly increasing. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, Pell.IsFundamental a â†’ StrictMono fun n => Pell.Solutionâ‚.y (a ^ n) :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\ndescending list of primes, each no more than twice the next, such that the list contains a witness\nfor each number â‰¤ n. -/\ntheorem âˆ€ {n : â„•} (q : â„•) {p : â„•},\n  Nat.Prime p â†’\n    p â‰¤ 2 * q â†’ (n < q â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n) â†’ n < p â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$. -/\ntheorem", "choices": ["âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "âˆƒ! (a n : â„•), a ^ (n + 1) - (a + 1) ^ n = 2001 ", "unique_positive_integers_a_n : âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "unique_solution : âˆƒ a n, a â‰  0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 âˆ§ âˆ€ a' n', a' â‰  0 âˆ§ a' ^ (n' + 1) - (a' + 1) ^ n' = 2001 â†’ a = a' âˆ§ n = n' ", "âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "âˆƒ! (a n : â„•), a > 0 âˆ§ n > 0 âˆ§ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "ExistsUnique fun a => ExistsUnique fun n =>\n  a * a ^ n - (a + 1) ^ n = 2001 âˆ§ 0 < a âˆ§ 0 < n "]}
{"docString": "Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), deriv^[2] f x < 0) â†’ StrictConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `â„`, and `f''` is strictly negative on `â„`,\\nthen `f` is strictly concave on `â„`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly negative, except at at most one point. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `â„`, and `f''` is strictly positive on `â„`,\\nthen `f` is strictly convex on `â„`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly positive, except at at most one point. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonpositive on `â„`,\\nthen `f` is concave on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C < deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C < f'`, then `f` grows faster than\\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  StrictConcaveOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is strictly concave iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"}]\n", "prompt_cons": "/-- If a function `f` is continuous on `â„`, and `f''` is strictly negative on `â„`,\nthen `f` is strictly concave on `â„`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly negative, except at at most one point. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), deriv^[2] f x < 0) â†’ StrictConcaveOn â„ Set.univ f :=\n\n/-- If a function `f` is continuous on `â„`, and `f''` is strictly positive on `â„`,\nthen `f` is strictly convex on `â„`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly positive, except at at most one point. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonpositive on `â„`,\nthen `f` is concave on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C < f'`, then `f` grows faster than\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C < deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x < y â†’ C * (y - x) < f y - f x :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  StrictConcaveOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$. -/\ntheorem", "choices": ["âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  Continuous (deriv^[3] f) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  Continuous (deriv^[3] f) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  Continuous (deriv^[3] f) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[3] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n    Continuous (deriv f) â†’\n      Continuous (deriv^[2] f) â†’\n        Continuous (deriv^[3] f) â†’\n          (âˆ€ (x : â„), 0 < f x) â†’\n            (âˆ€ (x : â„), 0 < deriv f x) â†’\n              (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n                (âˆ€ (x : â„), 0 < deriv^[3] f x) â†’\n                  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n                    âˆ€ (x : â„), deriv f x < 2 * f x ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Differentiable â„ f â†’\n  Differentiable â„ (deriv f) â†’\n  Differentiable â„ (deriv (deriv f)) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Differentiable â„ f â†’\n  Differentiable â„ (deriv f) â†’\n  Differentiable â„ (deriv^[2] f) â†’\n  (âˆ€ (x : â„), 0 < f x âˆ§ 0 < deriv f x âˆ§ 0 < deriv^[2] f x âˆ§ 0 < deriv^[3] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  Continuous (deriv^[3] f) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  âˆ€ (x : â„), deriv f x < 2 * f x ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  (âˆ€ (x : â„), 0 < f x âˆ§ 0 < deriv f x âˆ§ 0 < deriv^[2] f x âˆ§ deriv^[3] f x â‰¤ f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) ", "âˆ€ {f : â„ â†’ â„},\n  Continuous f â†’\n  Continuous (deriv f) â†’\n  Continuous (deriv^[2] f) â†’\n  Continuous (deriv^[3] f) â†’\n  (âˆ€ (x : â„), 0 < f x) â†’\n  (âˆ€ (x : â„), 0 < deriv f x) â†’\n  (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’\n  (âˆ€ (x : â„), deriv^[3] f x <= f x) â†’\n  (âˆ€ (x : â„), deriv f x < 2 * f x) "]}
{"docString": "Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the first and third points are not equal. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first and third points are not\\nequal. \"},\n {\"theorem\": \"âˆ€ (n a b : â„•), n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ List.Ico a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural numbers n, a, and b, one of the following holds:\\n1. n < a\\n2. n â‰¥ b\\n3. n âˆˆ Ico a b\\n\"}]\n", "prompt_cons": "/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c) :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- If the angle between three points is `Ï€`, the first and third points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- For any natural numbers n, a, and b, one of the following holds:\n1. n < a\n2. n â‰¥ b\n3. n âˆˆ Ico a b -/\ntheorem âˆ€ (n a b : â„•), n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ List.Ico a b :=\n\n/-- Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer. -/\ntheorem", "choices": ["âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬is_integer (Real.sqrt (â†‘n ^ 3 + a * â†‘n ^ 2 + b * â†‘n + c)) ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬(Int.sqrt (â†‘n ^ 3 + a * â†‘n ^ 2 + b * â†‘n + c) = â†‘n) ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬(Int.toNat (n ^ 3 + a * n ^ 2 + b * n + c)).sqrt.isSquare ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬(âˆƒ (k : â„•), k ^ 2 = n ^ 3 + a * n ^ 2 + b * n + c) ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬(Int.sqrt ((n ^ 3) + (a * n ^ 2) + (b * n) + c) âˆˆ â„¤) ", "âˆ€ (a b c : â„¤), âˆƒ n : â„•, Â¬ IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬ âˆƒ (m : â„•), Real.sqrt â†‘(n ^ 3 + a * n ^ 2 + b * n + c) = â†‘m ", "âˆ€ (a b c : â„¤), âˆƒ (n : â„•), Â¬Integral (Real.sqrt (â†‘n ^ 3 + a * â†‘n ^ 2 + b * â†‘n + c)) "]}
{"docString": "Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U Z : Set Î±},\\n  IsPreirreducible Z â†’ Set.Nonempty U â†’ IsOpen U â†’ U âŠ† S â†’ S âŠ† Z â†’ IsIrreducible S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `âˆ… â‰  U âŠ† S âŠ† Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] â¦ƒU : Set Î±â¦„,\\n  IsOpen U â†’\\n    âˆ€ (Î¼ : MeasureTheory.Measure Î±) [inst_2 : MeasureTheory.Measure.Regular Î¼],\\n      â†‘â†‘Î¼ U = â¨† (K : Set Î±) (_ : K âŠ† U) (_ : IsCompact K), â†‘â†‘Î¼ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of an open set is the supremum of the measures of compact sets it contains. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"}]\n", "prompt_cons": "/-- If `âˆ… â‰  U âŠ† S âŠ† Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U Z : Set Î±},\n  IsPreirreducible Z â†’ Set.Nonempty U â†’ IsOpen U â†’ U âŠ† S â†’ S âŠ† Z â†’ IsIrreducible S :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\ t) :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- The measure of an open set is the supremum of the measures of compact sets it contains. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] â¦ƒU : Set Î±â¦„,\n  IsOpen U â†’\n    âˆ€ (Î¼ : MeasureTheory.Measure Î±) [inst_2 : MeasureTheory.Measure.Regular Î¼],\n      â†‘â†‘Î¼ U = â¨† (K : Set Î±) (_ : K âŠ† U) (_ : IsCompact K), â†‘â†‘Î¼ K :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s :=\n\n/-- Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” (âˆ€ (x : Î±), x âˆˆ U â†’ Â¬ (âˆ€ (V : Set Î±), V âˆˆ nhds x â†’ Set.Nonempty (V âˆ© Uá¶œ))) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” (âˆ€ x : Î±, x âˆˆ U â†’ (nhds x âŠ“ ğ“Ÿ Uá¶œ) = âŠ¥) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ (nhds x âŠ“ Filter.principal Uá¶œ = âŠ¥) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ Â¬ ClusterPt x (Filter.principal (HasCompl.compl U)) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ (nhds x)á¶œ âˆ© Uá¶œ = âˆ… ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ Â¬ (âˆ€ (V : Set Î±), V âˆˆ nhds x â†’ Set.Nonempty (V âˆ© Uá¶œ)) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ Â¬ (âˆƒ V, IsOpen V âˆ§ x âˆˆ V âˆ§ V âŠ† Uá¶œ) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ U âˆˆ nhds x ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” (âˆ€ x âˆˆ U, Â¬Filter.Liminf (nhds x) (Uá¶œ)) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U : Set Î±},\n  IsOpen U â†” âˆ€ (x : Î±), x âˆˆ U â†’ Â¬ ClusterPt x (Uá¶œ) "]}
{"docString": "Show that every subset of $\\mathbb{N}$ is clopen.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (self : DiscreteQuotient X) (x : X),\\n  IsOpen (setOf (Setoid.Rel self.toSetoid x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every point `x`, the set `{ y | Rel x y }` is a clopen set. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that definability is closed under finite projections. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z : Set Î±}, IsClopen Z â†’ â‹ƒ (x : Î±) (_ : x âˆˆ Z), connectedComponent x = Z\",\n  \"isProp\": true,\n  \"docString\": \"A clopen set is the union of its connected components. \"}]\n", "prompt_cons": "/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- For every point `x`, the set `{ y | Rel x y }` is a clopen set. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (self : DiscreteQuotient X) (x : X),\n  IsOpen (setOf (Setoid.Rel self.toSetoid x)) :=\n\n/-- Shows that definability is closed under finite projections. -/\ntheorem âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s) :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- A clopen set is the union of its connected components. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z : Set Î±}, IsClopen Z â†’ â‹ƒ (x : Î±) (_ : x âˆˆ Z), connectedComponent x = Z :=\n\n/-- Show that every subset of $\\mathbb{N}$ is clopen. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], âˆ€ (s : Set Î±), IsClopen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±] {s : Set Î±}, IsClopen s ", "âˆ€ {N : Type u} [inst : TopologicalSpace N] [inst_1 : Semiring N] (H : âˆ€ (n : N), IsClopen ((fun x => â†‘x) â»Â¹' singleton n)),\n  âˆ€ (s : Set â„•), IsClopen ((fun x => â†‘x) â»Â¹' s) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±] {s : Set Î±}, IsClopen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±] [inst_2 : Nonempty Î±] [inst_3 : Semiring Î±],\n  âˆ€ (s : Set Î±), IsClopen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±] {s : Set Î±}, s âŠ† â„• â†’ IsClopen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±] {s : Set Î±}, IsClopen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±] {s : Set Î±},\n  HasSubset.Subset s (SetOf fun i => true) â†’ IsClopen s ", "âˆ€ {N : Type u} [inst : TopologicalSpace N] [inst_1 : DiscreteTopology N] {s : Set â„•}, IsClopen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  s âŠ† â„• â†’ IsClopen s "]}
{"docString": "Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A B : Finset G},\\n  Finset.Nonempty A â†’ Finset.Nonempty B â†’ âˆƒ a0, a0 âˆˆ A âˆ§ âˆƒ b0, b0 âˆˆ B âˆ§ UniqueAdd A B a0 b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `A B` two nonempty finite sets, there always exist `a0 âˆˆ A, b0 âˆˆ B` such that\\n`UniqueAdd A B a0 b0` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A B : Finset G},\\n  Finset.Nonempty A â†’ Finset.Nonempty B â†’ âˆƒ a0, a0 âˆˆ A âˆ§ âˆƒ b0, b0 âˆˆ B âˆ§ UniqueMul A B a0 b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `A B` two nonempty finite sets, there always exist `a0 âˆˆ A, b0 âˆˆ B` such that\\n`UniqueMul A B a0 b0` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} [inst : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼] â¦ƒK : Set Î±â¦„, IsCompact K â†’ â†‘â†‘Î¼ K < âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact subset has finite measure for a measure which is finite on compacts. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded below \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded \"},\n {\"theorem\":\n  \"âˆ€ (f : StieltjesFunction) {a b : â„} {c d : â„• â†’ â„},\\n  Set.Icc a b âŠ† â‹ƒ (i : â„•), Set.Ioo (c i) (d i) â†’\\n    ENNReal.ofReal (â†‘f b - â†‘f a) â‰¤ âˆ‘' (i : â„•), ENNReal.ofReal (â†‘f (d i) - â†‘f (c i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact interval `[a, b]` is covered by a union of open interval `(c i, d i)`, then\\n`f b - f a â‰¤ âˆ‘ f (d i) - f (c i)`. This is an auxiliary technical statement to prove the same\\nstatement for half-open intervals, the point of the current statement being that one can use\\ncompactness to reduce it to a finite sum, and argue by induction on the size of the covering set. \"}]\n", "prompt_cons": "/-- For `A B` two nonempty finite sets, there always exist `a0 âˆˆ A, b0 âˆˆ B` such that\n`UniqueAdd A B a0 b0` -/\ntheorem âˆ€ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A B : Finset G},\n  Finset.Nonempty A â†’ Finset.Nonempty B â†’ âˆƒ a0, a0 âˆˆ A âˆ§ âˆƒ b0, b0 âˆˆ B âˆ§ UniqueAdd A B a0 b0 :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Set.Nonempty s â†’ Set.Nonempty t â†’ Metric.Bounded s â†’ Metric.Bounded t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ :=\n\n/-- For `A B` two nonempty finite sets, there always exist `a0 âˆˆ A, b0 âˆˆ B` such that\n`UniqueMul A B a0 b0` -/\ntheorem âˆ€ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A B : Finset G},\n  Finset.Nonempty A â†’ Finset.Nonempty B â†’ âˆƒ a0, a0 âˆˆ A âˆ§ âˆƒ b0, b0 âˆˆ B âˆ§ UniqueMul A B a0 b0 :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} [inst : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼] â¦ƒK : Set Î±â¦„, IsCompact K â†’ â†‘â†‘Î¼ K < âŠ¤ :=\n\n/-- A compact set is bounded below -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddBelow s :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- A compact set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ Metric.Bounded s :=\n\n/-- If a compact interval `[a, b]` is covered by a union of open interval `(c i, d i)`, then\n`f b - f a â‰¤ âˆ‘ f (d i) - f (c i)`. This is an auxiliary technical statement to prove the same\nstatement for half-open intervals, the point of the current statement being that one can use\ncompactness to reduce it to a finite sum, and argue by induction on the size of the covering set. -/\ntheorem âˆ€ (f : StieltjesFunction) {a b : â„} {c d : â„• â†’ â„},\n  Set.Icc a b âŠ† â‹ƒ (i : â„•), Set.Ioo (c i) (d i) â†’\n    ENNReal.ofReal (â†‘f b - â†‘f a) â‰¤ âˆ‘' (i : â„•), ENNReal.ofReal (â†‘f (d i) - â†‘f (c i)) :=\n\n/-- Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "forall {Î± : Type u} [inst : MetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n  âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, Metric.dist a0 b0 â‰¤ Metric.dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n  âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n  âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, Metric.dist a0 b0 â‰¤ Metric.dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsCompact B â†’ Set.Nonempty A â†’ Set.Nonempty B â†’ Disjoint A B â†’\n    âˆƒ a0 âˆˆ A, âˆƒ b0 âˆˆ B, âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, dist a0 b0 â‰¤ dist a b "]}
{"docString": "Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `â„•`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s)\",\n  \"isProp\": true,\n  \"docString\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} [hÎ¹ : Nonempty Î¹],\\n  IsCompact s â†’\\n    âˆ€ (U : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ Directed (fun x x_1 => x âŠ† x_1) U â†’ âˆƒ i, s âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open directed cover of a compact set, there exists a single element of the\\ncover which itself includes the set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"}]\n", "prompt_cons": "/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `â„•`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s) :=\n\n/-- For every open directed cover of a compact set, there exists a single element of the\ncover which itself includes the set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} [hÎ¹ : Nonempty Î¹],\n  IsCompact s â†’\n    âˆ€ (U : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ Directed (fun x x_1 => x âŠ† x_1) U â†’ âˆƒ i, s âŠ† U i :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x_1 âŠ† x) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’\n        (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n          Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ† x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  (âˆ€ (i j : Î¹), âˆƒ k, Z k âŠ† Z i âˆ© Z j) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) "]}
{"docString": "Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.", "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\\n  {s : Set E} {x y : E},\\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero FrÃ©chet derivative at every point of a convex set,\\nthen it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"}]\n", "prompt_cons": "/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- If a function has zero FrÃ©chet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\n  {s : Set E} {x y : E},\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y :=\n\n/-- If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n] :=\n\n/-- Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant. -/\ntheorem", "choices": ["âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f y - f x) â‰¤ abs (y - x) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (t x : â„), abs (f t - f x) â‰¤ abs (t - x) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ â¦ƒx y : â„â¦„, abs (f y - f x) â‰¤ abs (y - x)^2) â†’ âˆ€ (z w : â„), f z = f w ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (t x : â„), abs (f t - f x) â‰¤ abs (t - x) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {ğ•œ : Type u_2} [inst : NormedAddCommGroup ğ•œ] [inst_1 : NormedSpace â„ ğ•œ] {f : ğ•œ â†’ ğ•œ},\n  (âˆ€ (t x : ğ•œ), abs (f t - f x) â‰¤ abs (t - x) ^ 2) â†’ (âˆ€ (x y : ğ•œ), f x = f y) ", "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (x y : â„), abs (f y - f x) â‰¤ abs (y - x) ^ 2) â†’\n  âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x y : â„), abs (f y - f x) â‰¤ abs (y - x) ^ 2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (t x : â„), abs (f t - f x) â‰¤ abs (t - x) ^ 2) â†’ âˆƒ c : â„, âˆ€ (x : â„), f x = c ", "âˆ€ {f : â„ â†’ â„}, (âˆ€ (t x : â„), abs (f t - f x) â‰¤ abs (t - x)^2) â†’ âˆ€ (x y : â„), f x = f y ", "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (x y : â„), abs (f y - f x) â‰¤ abs (y - x) ^ 2) â†’\n  âˆ€ (x y : â„), f x = f y "]}
{"docString": "Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$.", "prompts": "[{\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\": \"âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun n => x ^ (n + 1) / (â†‘n + 1)) (-Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\": \"Power series expansion of the logarithm around `1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\": \"Summability of the `p`-series over `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„• â†’ Prop) [inst : DecidablePred p] (n : â„•), Nat.count p n = Fintype.card { k // k < n âˆ§ p k }\",\n  \"isProp\": true,\n  \"docString\":\n  \"`count p n` can be expressed as the cardinality of `{k // k < n âˆ§ p k}`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {x y : â„¤} {n : â„•},\\n  2 âˆ£ x - y â†’\\n    Â¬2 âˆ£ x â†’\\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries ğ•œ E F),\\n  0 < FormalMultilinearSeries.radius p â†’\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"}]\n", "prompt_cons": "/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p :=\n\n/-- Power series expansion of the logarithm around `1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun n => x ^ (n + 1) / (â†‘n + 1)) (-Real.log (1 - x)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Summability of the `p`-series over `â„¤`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- `count p n` can be expressed as the cardinality of `{k // k < n âˆ§ p k}`. -/\ntheorem âˆ€ (p : â„• â†’ Prop) [inst : DecidablePred p] (n : â„•), Nat.count p n = Fintype.card { k // k < n âˆ§ p k } :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem âˆ€ {x y : â„¤} {n : â„•},\n  2 âˆ£ x - y â†’\n    Â¬2 âˆ£ x â†’\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries ğ•œ E F),\n  0 < FormalMultilinearSeries.radius p â†’\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$. -/\ntheorem", "choices": ["âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / â†‘k * (Real.log â†‘k) ^ p) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log (â†‘k))^p)) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / â†‘k * (Real.log â†‘k) ^ p) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / â†‘k * (Real.log â†‘k) ^ p) â†” 1 < p ", "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) â†” 1 < p "]}
{"docString": "A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OpensMeasurableSpace Î±] [inst_3 : MeasurableSpace Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : BorelSpace Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {Î¼ : MeasureTheory.Measure Î±}, ContinuousOn f s â†’ MeasurableSet s â†’ AEMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which is continuous on a set `s` is almost everywhere measurable with respect to\\n`Î¼.restrict s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"}]\n", "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f) :=\n\n/-- A function which is continuous on a set `s` is almost everywhere measurable with respect to\n`Î¼.restrict s`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OpensMeasurableSpace Î±] [inst_3 : MeasurableSpace Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : BorelSpace Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {Î¼ : MeasureTheory.Measure Î±}, ContinuousOn f s â†’ MeasurableSet s â†’ AEMeasurable f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity. -/\ntheorem", "choices": ["forall {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  {f : Î± â†’ Î±} {a b : Î±} {Î¼ : Î± â†’ Î±},\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ ContinuousOn Î¼ (Set.Ioo 0 b) â†’\n  (âˆ€ (s t : Î±), s âˆˆ Set.Icc a b â†’ t âˆˆ Set.Icc a b â†’ abs (f s - f t) â‰¤ Î¼ (abs (s - t))) â†’\n  (âˆ€ (Îµ : Î±), 0 < Îµ â†’ âˆƒ (Î´ : Î±) (H : 0 < Î´), âˆ€ {x y : Î±},\n    x âˆˆ Set.Icc a b â†’ y âˆˆ Set.Icc a b â†’ abs (x - y) < Î´ â†’ abs (f x - f y) < Îµ) âˆ§\n  (âˆ€ (Îµ : Î±), 0 < Îµ â†’ âˆƒ (Î´ : Î±) (H : 0 < Î´), âˆ€ {x y : Î±},\n    x âˆˆ Set.Icc a b â†’ y âˆˆ Set.Icc a b â†’ abs (x - y) < Î´ â†’ abs (f x - f y) < Îµ) â†’\n  ContinuousOn f (Set.Icc a b) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : PseudoMetricSpace Î²] {f : Î± â†’ Î²} {a b : Î±} (hf : ContinuousOn f (Set.Interval a b)),\n  (âˆƒ (Î¼ : Î± â†’ Î±), ContinuousOn Î¼ (Set.Interval 0 (b - a)) âˆ§ StrictMono Î¼ âˆ§\n    Filter.Tendsto Î¼ (ğ“[Set.Ioi 0] 0) (ğ“ 0) âˆ§ âˆ€ (s t : Î±), s âˆˆ Set.Interval a b â†’ t âˆˆ Set.Interval a b â†’ dist (f s) (f t) â‰¤ Î¼ (dist s t)) â†”\n  UniformContinuousOn f (Set.Interval a b) ", "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : Archimedean Î±] {f : Î± â†’ Î±},\n  (âˆƒ (Î¼ : Î± â†’ Î±), StrictMono Î¼ âˆ§ Continuous Î¼ âˆ§ (âˆ€ (s : Î±), 0 < s â†’ 0 < Î¼ s) âˆ§\n    Filter.Tendsto Î¼ (nhds 0) (nhds 0) âˆ§ âˆ€ (s t : Î±), |f s - f t| â‰¤ Î¼ (|s - t|)) â†”\n  UniformContinuous f ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  {f : Î± â†’ Î±} {a b : Î±},\n  a â‰¤ b â†’\n  (âˆ€ (s t : Î±), s âˆˆ Set.Icc a b â†’ t âˆˆ Set.Icc a b â†’ abs (f s - f t) â‰¤ Î¼ (abs (s - t))) â†” UniformContinuous f ", "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] [inst_2 : TopologicalSpace Î±] [inst_3 : OrderTopology Î±]\n  {s : Set Î±} {f : Î± â†’ Î±},\n  IsCompact s â†’ ContinuousOn f s â†’ \n  (âˆƒ (Î¼ : Î± â†’ Î±), StrictMono Î¼ âˆ§ (âˆ€á¶  (y : Î±) in nhds 0, 0 < Î¼ y) âˆ§ âˆ€ (x y : Î±), x âˆˆ s â†’ y âˆˆ s â†’ abs (f x - f y) â‰¤ Î¼ (abs (x - y)))\n  â†”\n  UniformContinuousOn f s ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : LinearOrder Î²] [inst_5 : OrderTopology Î²],\n  UniformContinuous f â†” âˆƒ (Î¼ : Î± â†’ Î±), StrictMono Î¼ âˆ§ Continuous Î¼ âˆ§ âˆ€ (s t : Î±), abs (f s - f t) â‰¤ Î¼ (abs (s - t)) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  (âˆƒ (Î¼ : Î± â†’ Î±), Continuous Î¼ âˆ§ StrictMono Î¼ âˆ§ (âˆ€á¶  (s : Î±) in nhds (0 : Î±), Î¼ s = 0) âˆ§\n    (âˆ€ (s t : Î±), abs (f s - f t) â‰¤ Î¼ (abs (s - t)))) â†” UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : UniformSpace Î²] {f : Î± â†’ Î²} {Î¼ : â„ â†’ â„},\n  Continuous f â†’ (Filter.Tendsto Î¼ (ğ“[Set.Ioi 0] 0) (nhds 0) âˆ§ âˆ€ (s t : Î±), abs (f s - f t) â‰¤ Î¼ (abs (s - t))) â†’\n  UniformContinuous f ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  {f : Î± â†’ Î±} {s t a b : Î±}, a â‰¤ s â†’ s â‰¤ b â†’ a â‰¤ t â†’ t â‰¤ b â†’\n  (âˆƒ (Î¼ : (0, âŠ¤) â†’ (0, âŠ¤)), Continuous Î¼ âˆ§ (âˆ€ s t, |f s - f t| â‰¤ Î¼ (|s - t|))) â†’ UniformContinuous f ", "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  {f : Î± â†’ Î±},\n  (UniformContinuous f) â†” (âˆƒ (Î¼ : â„ â†’ â„), Continuous Î¼ âˆ§ StrictMono Î¼ âˆ§ Filter.Tendsto Î¼ (nhds 0) (nhds 0) âˆ§\n    âˆ€ (s t : Î±), abs (f s - f t) â‰¤ Î¼ (abs (s - t))) "]}
{"docString": "If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [self : DivisionRing K] (a : K), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"For a nonzero `a`, `aâ»Â¹` is a right multiplicative inverse. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹ :=\n\n/-- For a nonzero `a`, `aâ»Â¹` is a right multiplicative inverse. -/\ntheorem âˆ€ {K : Type u} [self : DivisionRing K] (a : K), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1 :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (2 âˆ£ Fintype.card G) â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  2 âˆ£ Fintype.card G â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  2 âˆ£ Fintype.card G â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Even (Fintype.card G) â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ a, a â‰  1 âˆ§ a * a = 1) â†’ 2 âˆ£ Fintype.card G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (Fintype.card G) % 2 = 0 â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ a : G, a â‰  1 âˆ§ a * a = 1 "]}
{"docString": "If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.", "prompts": "[{\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"}]\n", "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), âˆƒ n : â„•, 0 < n âˆ§ a ^ n = 1 "]}
{"docString": "If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"}]\n", "prompt_cons": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c) :=\n\n/-- If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  (âˆ€ i, i âˆˆ [0, 1, 2] â†’ (a * b) ^ i = a ^ i * b ^ i) â†’\n  âˆ€ x y : G, x * y = y * x ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  (âˆ€ i : â„•, i < 3 â†’ a * b * aâ»Â¹ * bâ»Â¹ = (a * b)^i * (a * b)^(-i)) â†’ IsCommutative G ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  (âˆ€ i : â„¤, i âˆˆ [(-1 : â„¤), 0, 1] â†’ (a * b) ^ i = a ^ i * b ^ i) â†’ IsCommutative G ", "forall {G : Type u_1} [inst : Group G] {a b : G} {i : â„¤},\n  a * b * (a * b)^i = a^(i + 1) * b^(i + 1) â†’\n  a * b * (a * b)^(i + 1) = a^(i + 2) * b^(i + 2) â†’\n  a * b * (a * b)^(i + 2) = a^(i + 3) * b^(i + 3) â†’\n  IsCommutative G (*) ", "forall {G : Type u_1} [inst : Group G] {a b : G} {i : â„•},\n  a * b * aâ»Â¹ * bâ»Â¹ = 1 â†’\n  a * (b * a) * bâ»Â¹ = a * b * a * bâ»Â¹ â†’\n  (a * b) ^ (i + 1) = a ^ (i + 1) * b ^ (i + 1) â†’\n  (a * b) ^ (i + 2) = a ^ (i + 2) * b ^ (i + 2) â†’\n  (a * b) ^ (i + 3) = a ^ (i + 3) * b ^ (i + 3) â†’\n  âˆ€ x y : G, x * y = y * x ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  (âˆ€ i, i âˆˆ (â†‘3 : Finset â„•) â†’ (a * b) ^ i = a ^ i * b ^ i) â†’ IsCommutative G Mul ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  (âˆ€ i âˆˆ {0, 1, 2}, (a * b) ^ i = a ^ i * b ^ i) â†’\n  IsCommutative G Mul ", "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem commute_mul {S : Type u_1} [inst : Semigroup S] {a b c : S} (hab : Commute a b) (hac : Commute a c) : Commute a (b * c) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {i : â„¤},\n  a * b * aâ»Â¹ * bâ»Â¹ = 1 â†’ (a * b)^(i + 1) * (a * b)^(i + 2) = a^(i + 1) * b^(i + 1) * a^(i + 2) * b^(i + 2) â†’ G.is_abelian G ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  (âˆ€ i âˆˆ {n : â„¤ | n âˆˆ [0, 1, 2]}, a * b * aâ»Â¹ * bâ»Â¹ = a^i * b^i * (a^i)â»Â¹ * (b^i)â»Â¹) â†’ IsCommutative G Mul "]}
{"docString": "Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\": \"âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"âˆ€ (a : â„¤) (b e : â„•), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"}]\n", "prompt_cons": "/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A) :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (b e : â„•), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (x y : G), (x * y) ^ n = x ^ n * y ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "forall {G : Type u_1} [inst : Group G] {n : â„•} (hn : 1 < n) (a b : G),\n  (âˆ€ a b : G, (a * b) ^ n = a ^ n * b ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (x y : G), (x * y) ^ n = x ^ n * y ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "forall {G : Type u_1} [inst : Group G] {n : â„•},\n  n > 1 â†’ (âˆ€ a b : G, (a * b) ^ n = a ^ n * b ^ n) â†’ âˆ€ a b : G, (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] (n : â„•) (H : âˆ€ (a b : G), (a * b) ^ n = a ^ n * b ^ n) (a b : G),\n  (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (a b : G), (a * b) ^ n = a ^ n * b ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (a b : G), (a * b) ^ n = a ^ n * b ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (x y : G), (x * y) ^ n = x ^ n * y ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (a b : G), (a * b) ^ n = a ^ n * b ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} {n : â„•},\n  1 < n â†’ (âˆ€ (x y : G), (x * y) ^ n = x ^ n * y ^ n) â†’ (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1 "]}
{"docString": "If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number. -/\ntheorem", "choices": ["âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ (H : Subgroup G), H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card G = p â†’ IsCyclic G ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ H : Subgroup G, H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card G = p â†’ IsCyclic G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ K : Subgroup Î±, K = âŠ¥ âˆ¨ K = âŠ¤) â†’ Fintype.card Î± = p â†’ IsCyclic Î± ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ K : Subgroup G, K = âŠ¥ âˆ¨ K = âŠ¤) â†’ Fintype.card G = p â†’ IsCyclic G ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ (H : Subgroup G), H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card G = p â†’ IsCyclic G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ H : Subgroup Î±, H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card Î± = p â†’ IsCyclic Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ H : Subgroup Î±, H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card Î± = p â†’ IsCyclic Î± ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ (H : Subgroup G), H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card G = p â†’ IsCyclic G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ (H : Subgroup Î±), H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card Î± = p â†’ IsCyclic Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  (âˆ€ H : Subgroup Î±, H = âŠ¥ âˆ¨ H = âŠ¤) â†’ Fintype.card Î± = p â†’ IsCyclic Î± "]}
{"docString": "Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\": \"âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\": \"âˆ€ (a : â„¤) (b e : â„•), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (â†‘(CliffordAlgebra.Î¹ Q) a)] [inst_4 : Invertible (â†‘Q a)],\\n  â…Ÿ(â†‘(CliffordAlgebra.Î¹ Q) a) * â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\\n    â†‘(CliffordAlgebra.Î¹ Q) ((â…Ÿ(â†‘Q a) * QuadraticForm.polar (â†‘Q) a b) â€¢ a - b)\",\n  \"isProp\": true,\n  \"docString\": \"$a^{-1}ba$ is a vector. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"}]\n", "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (b e : â„•), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- $a^{-1}ba$ is a vector. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (â†‘(CliffordAlgebra.Î¹ Q) a)] [inst_4 : Invertible (â†‘Q a)],\n  â…Ÿ(â†‘(CliffordAlgebra.Î¹ Q) a) * â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\n    â†‘(CliffordAlgebra.Î¹ Q) ((â…Ÿ(â†‘Q a) * QuadraticForm.polar (â†‘Q) a b) â€¢ a - b) :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), \n  (âˆ€ (K : Subgroup G), Subgroup.Normal K) â†’ âˆ€ (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ âˆ€ (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ âˆ€ (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H â†’ âˆ€ (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, NormalizerCondition G â†’ âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.AllNormal G â†’ âˆ€ (a b : G), âˆƒ j, b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ âˆ€ (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ âˆ€ (a b : G), âˆƒ j, b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  (âˆ€ (K : Subgroup G), Subgroup.Normal K) â†’\n  âˆ€ (a b : G), âˆƒ (j : â„¤), b * a = a ^ j * b "]}
{"docString": "Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p n m : â„•) [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ {H : AddSubgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.IsCharSubgroup H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’\n    âˆ€ {H : AddSubgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.IsCharSubgroup H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’\n    Â¬p âˆ£ m â†’\n    âˆ€ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.charact H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p n m : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ IsCharSubgroup H ", "forall {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.IsChar H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] {p n m : â„•} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ {H : AddSubgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’\n      âˆ€ (Ï† : G â†’* G), AddSubgroup.comap Ï† H = H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.IsChar H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.IsCharSubgroup H ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ n * m = Fintype.card G â†’ Nat.Coprime p m â†’\n    âˆ€ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.char_powers H ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {p n m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m â†’ Nat.Coprime p m â†’\n    âˆ€ {H : AddSubgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ AddSubgroup.Char H "]}
{"docString": "Prove that a group of order 9 must be abelian.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has strong epi-mono factorisations. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"}]\n", "prompt_cons": "/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- An abelian category has strong epi-mono factorisations. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Prove that a group of order 9 must be abelian. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 9), IsCommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 9 â†’ IsAbelian G ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 9 â†’ IsCommutative Î± ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 9 â†’ IsCommutative G ", "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 9 â†’ IsLieAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G] [Fintype G], Fintype.card G = 9 â†’ IsCommutative G ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 9 â†’ IsCommutative Î± ", "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 9 â†’ IsCommutative G ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 9 â†’ IsCommutativeGroup Î± ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 9 â†’ IsCommGroup G "]}
{"docString": "Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] [inst_2 : FiniteDimensional â„ F] {n : â„•}\\n  (Ï† : F â‰ƒâ‚—áµ¢[â„] F),\\n  FiniteDimensional.finrank â„\\n        { x // x âˆˆ (LinearMap.ker (ContinuousLinearMap.id â„ F - â†‘(ContinuousLinearEquiv.mk Ï†.toLinearEquiv)))á—® } â‰¤\\n      n â†’\\n    âˆƒ l, List.length l â‰¤ n âˆ§ Ï† = List.prod (List.map (fun v => reflection (Submodule.span â„ {v})á—®) l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `Ï†` of the orthogonal group of `F` can be factored as a product of reflections, and\\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\\nof `Ï†`. \"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹ :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- An element `Ï†` of the orthogonal group of `F` can be factored as a product of reflections, and\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\nof `Ï†`. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] [inst_2 : FiniteDimensional â„ F] {n : â„•}\n  (Ï† : F â‰ƒâ‚—áµ¢[â„] F),\n  FiniteDimensional.finrank â„\n        { x // x âˆˆ (LinearMap.ker (ContinuousLinearMap.id â„ F - â†‘(ContinuousLinearEquiv.mk Ï†.toLinearEquiv)))á—® } â‰¤\n      n â†’\n    âˆƒ l, List.length l â‰¤ n âˆ§ Ï† = List.prod (List.map (fun v => reflection (Submodule.span â„ {v})á—®) l) :=\n\n/-- Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (Ï† : G â‰ƒ* G),\n  (Fintype.card {x : G | â†‘Ï† x = xâ»Â¹}) > 3 * Fintype.card G / 4 â†’\n    âˆ€ (y : G), â†‘Ï† y = yâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆƒ Ï† : G â‰ƒ* G, âˆ€ x : G, (â†‘Ï† x = xâ»Â¹) âˆˆ Finset.card â†‘(Finset.filter (Î» a, â†‘Ï† a = aâ»Â¹) Finset.univ) > (3 / 4) * Fintype.card G) â†’\n    âˆ€ {y : G}, (Î» a, â†‘Ï† a = aâ»Â¹) y â†’ CommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆƒ Ï† : G â‰ƒ* G, âˆ€ x : G, xâ»Â¹ = â†‘Ï† x â†’ Fintype.card { y // yâ»Â¹ = â†‘Ï† y } > 3 * Fintype.card G / 4) â†’\n  (âˆ€ y : G, yâ»Â¹ = (Groupâ‚“.isConj (Groupâ‚“.invAut G)).toMonoidHom.toFun y) âˆ§ Groupâ‚“.IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (Ï† : G â‰ƒ* G),\n  (Fintype.card {x // Ï† x = xâ»Â¹}) > (3 * Fintype.card G) / 4 â†’\n    âˆ€ (y : G), Ï† y = yâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (varphi : G â‰ƒ* G),\n  (Fintype.card (Set {x : G | â†‘varphi x = xâ»Â¹}) : â„) / (Fintype.card G : â„) > 3 / 4 â†’ âˆ€ y : G, â†‘varphi y = yâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (Ï† : G â‰ƒ* G),\n  (Fintype.card {x // Ï† x = xâ»Â¹}) > (3 * Fintype.card G) / 4 â†’ âˆ€ y : G, Ï† y = yâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (Ï† : G â‰ƒ* G),\n  Fintype.card { x // xâ»Â¹ = â†‘Ï† x } > (3 * Fintype.card G) / 4 â†’\n    âˆ€ (y : G), yâ»Â¹ = â†‘Ï† y ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (Ï• : G â‰ƒ* G),\n  (Fintype.card (â†¥{x : G | coeFn Ï• x = xâ»Â¹})) > (3 * Fintype.card G) / 4 â†’\n    âˆ€ (y : G), coeFn Ï• y = yâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ï† : G â‰ƒ* G},\n  (Fintype.card (Subtype {x // (â†‘Ï† x)â»Â¹ = x})) > 3 * Fintype.card G / 4 â†’ âˆ€ (y : G), (â†‘Ï† y)â»Â¹ = y ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (Ï† : Aut G),\n  Finset.card { x : G | Ï† x = xâ»Â¹ } > (3 * Fintype.card G) / 4 â†’ âˆ€ (y : G), Ï† y = yâ»Â¹ "]}
{"docString": "If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"âˆ€ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Equiv L M N) {n : â„•}\\n  (f : FirstOrder.Language.Functions L n) (x : Fin n â†’ M),\\n  Equiv.toFun self.toEquiv (FirstOrder.Language.Structure.funMap f x) =\\n    FirstOrder.Language.Structure.funMap f (self.toFun âˆ˜ x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The homomorphism commutes with the interpretations of the function symbols \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map one to one. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"}]\n", "prompt_cons": "/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c) :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F) :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€– :=\n\n/-- The homomorphism commutes with the interpretations of the function symbols -/\ntheorem âˆ€ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Equiv L M N) {n : â„•}\n  (f : FirstOrder.Language.Functions L n) (x : Fin n â†’ M),\n  Equiv.toFun self.toEquiv (FirstOrder.Language.Structure.funMap f x) =\n    FirstOrder.Language.Structure.funMap f (self.toFun âˆ˜ x) :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- Ring homomorphisms map one to one. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 1 = 1 :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} {G' : Type u_2} {N : Type u_3} [inst : Group G] [inst_1 : Group G'] [inst_2 : NormalSubgroup N]\n  (Ï† : G â†’* G'), NormalSubgroup (Subgroup.map Ï† N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Set G} [inst : Group G] [inst_1 : Group G'] (Ï• : G â†’ G')\n  (hÏ• : Function.Surjective Ï•) (hN : IsNormalSubgroup N), IsNormalSubgroup (Ï• '' N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Type u_3} [inst : Group G] [inst_1 : Group G'] [inst_2 : NormalSubgroup G N]\n  (Ï• : G â†’* G'), NormalSubgroup G' (Subgroup.map Ï• N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Set G} [inst : Group G] [inst_1 : Group G'] {Ï† : G â†’ G'} (hÏ† : IsGroupHom Ï†)\n  (HN : IsNormalSubgroup N) (hsurj : Function.Surjective Ï†), IsNormalSubgroup (Ï† '' N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {Ï† : G â†’* G'} {N : Subgroup G}\n  (hN : Subgroup.Normal N) (hÏ† : Function.Surjective Ï†.toFun),\n  Subgroup.Normal (Subgroup.map Ï† N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Type u_3} [inst : Group G] [inst_1 : Group G'] [inst_2 : NormalSubgroup G N]\n  {Ïƒ : G â†’* G'} [self : Function.Surjective Ïƒ], NormalSubgroup G' (Ïƒ.range) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Type u_3} [inst : Group G] [inst_1 : Group G'] [inst_2 : Subgroup.Normal N]\n  (Ï† : G â†’* G'), Subgroup.Normal (Subgroup.map Ï† N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Set G} [inst : Group G] [inst_1 : Group G'] (Ï† : G â†’ G') [self : IsGroupHom Ï†],\n  IsNormalSubgroup N â†’ IsNormalSubgroup (Ï† '' N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Type u_3} [inst : Group G] [inst_1 : Group G'] [inst_2 : Group N]\n  (Ï† : G â†’* G') (hÏ† : Function.Surjective Ï†) (hN : IsNormalSubgroup N),\n  IsNormalSubgroup (Subgroup.map Ï† N) ", "âˆ€ {G : Type u_1} {G' : Type u_2} {N : Set G} [inst : Group G] [inst_1 : Group G'] {Ï† : G â†’* G'}\n  [self : IsGroupHom.NormalSubgroup N Ï†], IsNormalSubgroup (Ï† '' N) "]}
{"docString": "Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"}]\n", "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic. -/\ntheorem", "choices": ["âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’\n    âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G] (H : Type u_2) [inst_2 : Group H] [inst_3 : Fintype H],\n      Fintype.card G = p * q â†’\n        Fintype.card H = p * q â†’\n          (âˆ€ x y : G, x â‰  1 â†’ y â‰  1 â†’ x * y â‰  y * x) â†’\n            (âˆ€ x y : H, x â‰  1 â†’ y â‰  1 â†’ x * y â‰  y * x) â†’ Nonempty (G â‰ƒ* H) ", "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’ âˆ€ (G H : Type*) [Group G] [Group H] [Fintype G] [Fintype H],\n  Fintype.card G = p * q â†’ Fintype.card H = p * q â†’ Nonabelian G â†’ Nonabelian H â†’ Isomorphic G H ", "âˆ€ {p q : â„•} {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Fintype Gâ‚] [inst_3 : Fintype Gâ‚‚]\n  [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’ Fintype.card Gâ‚ = p * q â†’ Fintype.card Gâ‚‚ = p * q â†’ Nonabelian Gâ‚ â†’ Nonabelian Gâ‚‚ â†’ Nonempty (Gâ‚ â‰ƒ* Gâ‚‚) ", "âˆ€ {p q : â„•} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H] \n[hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’ Fintype.card G = p * q â†’ Fintype.card H = p * q â†’ Nonabelian G â†’ Nonabelian H â†’ Nonempty (Group.Isom G H) ", "âˆ€ {p q : â„•} {Gâ‚ Gâ‚‚ : Type u} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Fintype Gâ‚]\n  [inst_3 : Fintype Gâ‚‚] [inst_4 : Fact (Nat.Prime p)] [inst_5 : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’\n    Fintype.card Gâ‚ = p * q â†’ Fintype.card Gâ‚‚ = p * q â†’\n      Nonabelian Gâ‚ â†’ Nonabelian Gâ‚‚ â†’ Nonempty (Gâ‚ â‰ƒ* Gâ‚‚) ", "forall {p q : â„•} {G H : Type}\n  [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)]\n  [groupG : Group G] [groupH : Group H]\n  [fintypeG : Fintype G] [fintypeH : Fintype H],\n    p > q -> q âˆ£ p - 1 ->\n    Fintype.card G = p * q -> Fintype.card H = p * q ->\n    Nonabelian G -> Nonabelian H -> Nonempty (G â‰ƒ* H) ", "âˆ€ {p q : â„•} {G H : Type u_1} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H]\n  [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p > q â†’ q âˆ£ p - 1 â†’\n    Nonabelian G â†’ Fintype.card G = p * q â†’ Nonabelian H â†’ Fintype.card H = p * q â†’ Group.Isomorphic G H ", "âˆ€ {p q : â„•} {Gâ‚ Gâ‚‚ : Type} [inst_1 : Group Gâ‚] [inst_2 : Group Gâ‚‚] [inst_3 : Fintype Gâ‚] [inst_4 : Fintype Gâ‚‚]\n  [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’\n    (âˆ€ (x : Gâ‚), orderOf x â‰  p âˆ§ orderOf x â‰  q â†’ orderOf x = 1) â†’\n      (âˆ€ (x : Gâ‚‚), orderOf x â‰  p âˆ§ orderOf x â‰  q â†’ orderOf x = 1) â†’\n        Nonempty (Gâ‚ â‰ƒ* Gâ‚‚) ", "âˆ€ {p q : â„•} [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fact (Nat.Prime q)] (G : Type u_1) (H : Type u_2)\n  [inst_3 : Group G] [inst_4 : Group H] [inst_5 : Fintype G] [inst_6 : Fintype H],\n  p > q â†’ q âˆ£ p - 1 â†’ Fintype.card G = p * q â†’ Fintype.card H = p * q â†’ Nonabelian G â†’ Nonabelian H â†’\n    Group.Isomorphic G H ", "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p > q â†’ q âˆ£ p - 1 â†’\n    âˆ€ (Gâ‚ Gâ‚‚ : Type) [inst_2 : Group Gâ‚] [inst_3 : Fintype Gâ‚] [inst_4 : Group Gâ‚‚] [inst_5 : Fintype Gâ‚‚],\n      Nonabelian Gâ‚ â†’ Fintype.card Gâ‚ = p * q â†’\n        Nonabelian Gâ‚‚ â†’ Fintype.card Gâ‚‚ = p * q â†’\n          Nonempty (Gâ‚ â‰ƒ Gâ‚‚) "]}
{"docString": "Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\": \"âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"}]\n", "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {A : Subgroup G} (b : G) (p : â„•) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A â†’ orderOf b = p â†’ b âˆ‰ A â†’ A âŠ“ Subgroup.zpowers b = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A â†’ Nat.Prime (orderOf b) â†’ b âˆ‰ A â†’ A âŠ“ Subgroup.zpowers b = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] {A : Subgroup G} (b : G) (p : â„•) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A â†’ orderOf b = p â†’ b âˆ‰ A â†’ A âˆ© Subgroup.centralizer (Subgroup.singleton b) = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G) [inst_1 : Fact (Nat.Prime (orderOf b))],\n  A.normal â†’ b âˆ‰ A â†’ Subgroup.map (Subgroup.subtype A) (A âŠ“ Subgroup.closure {b}) = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] {A : Subgroup G} (b : G) (p : â„•) [hA : Subgroup.Normal A] [Fact (Nat.Prime p)],\n  orderOf b = p â†’ b âˆ‰ A â†’ A âˆ© Subgroup.zpowers b = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G) [hp : Fact (Nat.Prime (orderOf b))],\n  Subgroup.Normal A â†’ b âˆ‰ A â†’ Subgroup.comap (QuotientGroup.mk' A) (Subgroup.gpowers b) = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] {A : Subgroup G} (b : G) (p : â„•) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A â†’ b âˆ‰ A â†’ orderOf b = p â†’ A âŠ“ Subgroup.zpowers b = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G) (p : â„•),\n  Subgroup.Normal A â†’ Nat.Prime p â†’ orderOf b = p â†’ b âˆ‰ A â†’ A âˆ© Subgroup.zpowers b = Subgroup.singleton 1 ", "âˆ€ {G : Type u_1} [inst : Group G] (A : Subgroup G) {b : G} (p : â„•) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A â†’ orderOf b = p â†’ b âˆ‰ A â†’ Subgroup.comap (Subgroup.subtype A) (Subgroup.centralizer âŸ¨b, p, hpâŸ©) = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] {A : Subgroup G} (b : G) (p : â„•) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A â†’ orderOf b = p â†’ b âˆ‰ A â†’ A âŠ“ Subgroup.zpowers b = âŠ¥ "]}
{"docString": "If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) âŠ” N = G`. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’ CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) âŠ” N = G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤ :=\n\n/-- `P` respects isomorphisms. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’ CategoryTheory.MorphismProperty.RespectsIso P :=\n\n/-- If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$. -/\ntheorem", "choices": ["âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] {P : Sylow p G}\n  [inst_1 : Subgroup.Normal (â†‘P : Set G)], âˆ€ (Ï• : G â‰ƒ* G), (Ï•.to_equiv '' â†‘P) = â†‘P ", "âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {P : Sylow p G} [inst_2 : Subgroup.Normal (â†‘P)],\n  âˆ€ (Ï† : G â‰ƒ* G), Ï†.to_equiv '' â†‘P = â†‘P ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  (âˆ€ (Ï• : G â‰ƒ* G), Ï•.to_equiv '' â†‘P = â†‘P) ", "âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G) [inst_1 : Subgroup.Normal (â†‘P)],\n  âˆ€ (Ï• : G â‰ƒ* G), Subgroup.map (MulEquiv.toMonoidHom Ï•) â†‘P = â†‘P ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Sylow p G} {Ï• : G â‰ƒ* G},\n  (âˆ€ H : Subgroup G, P â‰¤ H â†’ Ï•.to_equiv '' â†‘P = â†‘P) â†’ Ï•.to_equiv '' â†‘P = â†‘P ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Sylow p G} [inst_1 : Subgroup.Normal (â†‘P)],\n  âˆ€ (Ï• : G â‰ƒ* G), Subgroup.comap (MulEquiv.toMonoidHom Ï•) (â†‘P) = â†‘P ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Sylow p G) [inst_1 : Subgroup.Normal (â†‘P)],\n  âˆ€ (Ï• : G â‰ƒ* G), Subgroup.map (MulEquiv.toMonoidHom Ï•) (â†‘P) = â†‘P ", "âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G) [inst_1 : Subgroup.Normal â†‘P],\n  âˆ€ (Ï• : G â‰ƒ* G), (Ï• âˆ˜* (Subgroup.subtype â†‘P)) âˆ˜* Ï•â»Â¹ = Subgroup.subtype â†‘P ", "forall {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] (P : Sylow p G) [inst_1 : Subgroup.Normal (â†‘P)],\n  âˆ€ (Ï• : G â‰ƒ* G), Subgroup.map (MulEquiv.toMonoidHom Ï•) â†‘P = â†‘P ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] {P : Sylow p G} [inst_1 : Subgroup.Normal â†‘P],\n  âˆ€ (Ï† : G â‰ƒ* G), Ï† âˆ˜* â†‘P = â†‘P "]}
{"docString": "If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f g : Equiv.Perm Î±} {x : Î±} [inst : DecidableEq Î±] [inst_1 : Fintype Î±],\\n  Equiv.Perm.IsCycle f â†’\\n    Equiv.Perm.IsCycle g â†’\\n      (âˆ€ (x : Î±), x âˆˆ Equiv.Perm.support f âˆ© Equiv.Perm.support g â†’ â†‘f x = â†‘g x) â†’\\n        â†‘f x = â†‘g x â†’ x âˆˆ Equiv.Perm.support f â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two cyclic permutations agree on all terms in their intersection,\\nand that intersection is not empty, then the two cyclic permutations must be equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\\n  s =á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s = â†‘â†‘Î¼ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are equal modulo a set of measure zero, then `Î¼ s = Î¼ t`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : PartialOrder Î±] {f : Fin n â†’ Î±} {Ïƒ Ï„ : Equiv.Perm (Fin n)},\\n  Monotone (f âˆ˜ â†‘Ïƒ) â†’ Monotone (f âˆ˜ â†‘Ï„) â†’ f âˆ˜ â†‘Ïƒ = f âˆ˜ â†‘Ï„\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two permutations of a tuple `f` are both monotone, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±], Function.Injective Equiv.Perm.cycleFactorsFinset\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two permutations `f g : perm Î±` have the same cycle factors iff they are the same. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (e p : Equiv.Perm Î±), â†‘(Equiv.permCongr e) p = e * p * eâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `e` is also a permutation, we can write `permCongr`\\ncompletely in terms of the group structure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u_2} [inst : DecidableEq Î±] {Î² : Sort u_1} {v : Î± â†’ Î²} {i j : Î±},\\n  v i = v j â†’ âˆ€ (k : Î±), v (â†‘(Equiv.swap i j) k) = v k\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is invariant to a swap if it is equal at both elements \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (g : M â†’â‚—[R] M)\\n  (f : (M â†’â‚—[R] M)Ë£), â†‘(LinearMap.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â†‘(LinearMap.trace R M) g\",\n  \"isProp\": true,\n  \"docString\": \"The trace of an endomorphism is invariant under conjugation \"}]\n", "prompt_cons": "/-- If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. -/\ntheorem âˆ€ {Î± : Type u_1} {f g : Equiv.Perm Î±} {x : Î±} [inst : DecidableEq Î±] [inst_1 : Fintype Î±],\n  Equiv.Perm.IsCycle f â†’\n    Equiv.Perm.IsCycle g â†’\n      (âˆ€ (x : Î±), x âˆˆ Equiv.Perm.support f âˆ© Equiv.Perm.support g â†’ â†‘f x = â†‘g x) â†’\n        â†‘f x = â†‘g x â†’ x âˆˆ Equiv.Perm.support f â†’ f = g :=\n\n/-- If two sets are equal modulo a set of measure zero, then `Î¼ s = Î¼ t`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\n  s =á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s = â†‘â†‘Î¼ t :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A) :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- If two permutations of a tuple `f` are both monotone, then they are equal. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : PartialOrder Î±] {f : Fin n â†’ Î±} {Ïƒ Ï„ : Equiv.Perm (Fin n)},\n  Monotone (f âˆ˜ â†‘Ïƒ) â†’ Monotone (f âˆ˜ â†‘Ï„) â†’ f âˆ˜ â†‘Ïƒ = f âˆ˜ â†‘Ï„ :=\n\n/-- If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g :=\n\n/-- Two permutations `f g : perm Î±` have the same cycle factors iff they are the same. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±], Function.Injective Equiv.Perm.cycleFactorsFinset :=\n\n/-- If `e` is also a permutation, we can write `permCongr`\ncompletely in terms of the group structure. -/\ntheorem âˆ€ {Î± : Type u} (e p : Equiv.Perm Î±), â†‘(Equiv.permCongr e) p = e * p * eâ»Â¹ :=\n\n/-- A function is invariant to a swap if it is equal at both elements -/\ntheorem âˆ€ {Î± : Sort u_2} [inst : DecidableEq Î±] {Î² : Sort u_1} {v : Î± â†’ Î²} {i j : Î±},\n  v i = v j â†’ âˆ€ (k : Î±), v (â†‘(Equiv.swap i j) k) = v k :=\n\n/-- The trace of an endomorphism is invariant under conjugation -/\ntheorem âˆ€ (R : Type u) [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (g : M â†’â‚—[R] M)\n  (f : (M â†’â‚—[R] M)Ë£), â†‘(LinearMap.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â†‘(LinearMap.trace R M) g :=\n\n/-- If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  (âˆ€ (x : Î±), x âˆˆ Equiv.Perm.support Ïƒ âˆ© Equiv.Perm.support Ï„ â†’ x = x) â†’\n    (Ïƒ * Ï„) = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] (Ïƒ Ï„ : Equiv.Perm Î±),\n  Equiv.Perm.Disjoint Ïƒ Ï„ â†’ Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  Disjoint (Equiv.Perm.support Ïƒ) (Equiv.Perm.support Ï„) â†’ Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  Disjoint (Equiv.Perm.support Ïƒ) (Equiv.Perm.support Ï„) â†’ Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±]\n  (Ïƒ Ï„ : Equiv.Perm Î±),\n  (Equiv.Perm.support Ïƒ) âˆ© (Equiv.Perm.support Ï„) = âˆ… â†’\n  Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’\n  Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  Disjoint (Equiv.Perm.support Ïƒ) (Equiv.Perm.support Ï„) â†’\n    Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  (Equiv.Perm.support Ïƒ) âˆ© (Equiv.Perm.support Ï„) = âˆ… â†’ Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  (Ïƒ * Ï„ = Equiv.Perm.refl Î±) â†’ (Equiv.Perm.support Ïƒ âˆ© Equiv.Perm.support Ï„ = âˆ…) â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] (Ïƒ Ï„ : Equiv.Perm Î±),\n  Disjoint (Equiv.Perm.support Ïƒ) (Equiv.Perm.support Ï„) â†’ Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± ", "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {Ïƒ Ï„ : Equiv.Perm Î±},\n  Equiv.Perm.Disjoint Ïƒ Ï„ â†’ Ïƒ * Ï„ = Equiv.Perm.refl Î± â†’ Ïƒ = Equiv.Perm.refl Î± âˆ§ Ï„ = Equiv.Perm.refl Î± "]}
{"docString": "Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T3Space Î“â‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is Tâ‚ƒ. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T â‰¤ S â†’\\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\\n      [inst_5 : Fintype (M â§¸ T)],\\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is Tâ‚…. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C â„¤]\\n  {Tâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism Tâ‚ Tâ‚‚),\\n  CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ƒ ((CategoryTheory.shiftFunctor C 1).map self.homâ‚) =\\n    CategoryTheory.CategoryStruct.comp self.homâ‚ƒ Tâ‚‚.morâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\": \"the third commutative square of a triangle morphism \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"}]\n", "prompt_cons": "/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚ƒ. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T3Space Î“â‚€ :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T â‰¤ S â†’\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\n      [inst_5 : Fintype (M â§¸ T)],\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚…. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€ :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’ Monoid.IsTorsion G â†’ Monoid.IsTorsion H :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- the third commutative square of a triangle morphism -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C â„¤]\n  {Tâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism Tâ‚ Tâ‚‚),\n  CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ƒ ((CategoryTheory.shiftFunctor C 1).map self.homâ‚) =\n    CategoryTheory.CategoryStruct.comp self.homâ‚ƒ Tâ‚‚.morâ‚ƒ :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3. -/\ntheorem", "choices": ["Matrix.twoXTwoMatrixGroupWithDetNotEqualToZeroIsoS3 :\n  Nonempty (Matrix.SpecialLinearGroup (Finâ‚“ 2) (Zmod 2) â‰ƒ* SymmetricGroup (Finâ‚“ 3)) ", "T_isomorphic_to_S3 : âˆƒ (Ï† : GL 2 (Zmod 2) â‰ƒ* SymmetricGroup (Fin 3)),\n                   âˆ€ (A : GL 2 (Zmod 2)), Ï† A = Equiv.Perm.swap (Fin.mk 0 (by norm_num)) (Fin.mk 1 (by norm_num)) âˆ¨\n                                          Ï† A = Equiv.Perm.swap (Fin.mk 0 (by norm_num)) (Fin.mk 2 (by norm_num)) âˆ¨\n                                          Ï† A = Equiv.Perm.swap (Fin.mk 1 (by norm_num)) (Fin.mk 2 (by norm_num)) ", "âˆ€ {F : Type u_1} [inst : Field F] {n : â„•} [inst_1 : CharP F n] [inst_2 : Fintype F], n = 2 â†’\n  Nonempty (Matrix.SpecialLinearGroup (Finâ‚“ 2) F â‰ƒ* SymGroup (Finâ‚“ 3)) ", "âˆ€ (T : Matrix.SpecialLinearGroup (Fin 2) (Zmod 2)), âˆƒ (f : T â‰ƒ* Equiv.Perm (Fin 3)), Function.Bijective f.to_fun ", "âˆ€ (T : Type u_1) [inst : Field T] (h : CharP T 2), Nonempty (T â‰ƒ+* S3) ", "matrixGroupIsomS3 : âˆ€ {K : Type u_1} [_inst_1 : Field K] [charZero : CharZero K] (det_not_zero : K â‰  0),\n  Nonempty (GroupEquiv (Matrix.SpecialLinearGroup (Finâ‚“ 2) K) (Equiv.Perm (Finâ‚“ 3))) ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_2 : Fintype F] (hF : Fintype.card F = 2),\n  Nonempty (Matrix.SpecialLinearGroup (Finâ‚“ 2) F â‰ƒ* SymmetricGroup (Finâ‚“ 3)) ", "GL2_Z2_equiv_S3 : LinearEquiv â‰ƒâ‚—[â„¤] Matrix.SpecialLinearGroup (Fin 2) (Zmod 2) â‰ƒ* Equiv.Perm (Fin 3) ", "âˆ€ {F : Type u_1} [inst : Field F] [hF : CharP F 2],\n  Nonempty (Matrix.SpecialLinearGroup (Finâ‚“ 2) F â‰ƒ* SymmetricGroup (Finâ‚“ 3)) ", "GL2_S3_iso : âˆƒ (f : GLâ‚‚ (Zmod 2) â‰ƒ* Sâ‚ƒ), Function.Bijective â†‘f "]}
{"docString": "If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\": \"âˆ€ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±] {a : Î±}, 0 âˆ£ a â†” a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  â†‘(quadraticChar F) a = 0 â†” a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The value of the quadratic character on `a` is zero iff `a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- `a ^ 0 = 1` -/\ntheorem âˆ€ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±] {a : Î±}, 0 âˆ£ a â†” a = 0 :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c) :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  â†‘(quadraticChar F) a = 0 â†” a = 0 :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (x * a + a * x) a ", "âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "forall {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "forall {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "âˆ€ {R : Type u_1} [inst : CommRing R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a ", "âˆ€ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 â†’ Commute (a * x + x * a) a "]}
{"docString": "If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±] {a : Î±}, 0 âˆ£ a â†” a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` has characteristic `0`, then so does `FractionRing R`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"}]\n", "prompt_cons": "/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±] {a : Î±}, 0 âˆ£ a â†” a = 0 :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- If `R` has characteristic `0`, then so does `FractionRing R`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R) :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- A non-unital subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] (a : R), Ideal (SetOf (Î» x, x * a = 0)) ", "âˆ€ {R : Type u_1} [inst : CommRing R] {a : R}, Ideal L_a ", "âˆ€ {R : Type u_1} [inst : CommRing R] (a : R), Ideal (Submodule.span R {x : R | x * a = 0}) ", "âˆ€ {R : Type u} [inst : CommRing R] (a : R), Ideal R ", "âˆ€ {R : Type u_1} [inst : CommRing R] (a : R), Ideal (SetOf (Î» x : R, x * a = 0)) ", "âˆ€ {R : Type u} [inst : CommRing R] (a : R), Ideal R (Î» x, x * a = 0) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (a : R), Ideal (SetOf fun x => x * a = 0) ", "âˆ€ {R : Type u_1} [inst : CommRing R] {a : R}, Ideal (Set {x : R | x * a = 0}) ", "âˆ€ (R : Type u_1) [inst : CommRing R] (a : R), Ideal R (Î» x, x * a = 0) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R "]}
{"docString": "Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"}]\n", "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$. -/\ntheorem", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’\n  (card (QR p) = (p - 1) / 2) âˆ§ (card (QNR p) = (p - 1) / 2) ", "forall {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (p - 1) / 2 = (card (QRing p) + card (QNonRes p)) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’\n  (card {x âˆˆ Finset.range (p - 1) | IsSquare (x : â„¤)}) = (p - 1) / 2 âˆ§\n  (card {x âˆˆ Finset.range (p - 1) | Â¬IsSquare (x : â„¤)}) = (p - 1) / 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ \n  âˆƒ (qr : finset â„¤) (nqr: finset â„¤),\n    (qr âŠ† {i : â„¤ | 0 < i âˆ§ i < â†‘p}) âˆ§\n    (nqr âŠ† {i : â„¤ | 0 < i âˆ§ i < â†‘p}) âˆ§\n    (âˆ€ a, a âˆˆ qr â†” IsSquare (a % â†‘p)) âˆ§\n    (âˆ€ a, a âˆˆ nqr â†” Â¬IsSquare (a % â†‘p)) âˆ§\n    qr.card = (p - 1) / 2 âˆ§\n    nqr.card = (p - 1) / 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’\n  (card (set_of (IsSquare : â„¤ â†’ Prop)) = (p - 1) / 2) âˆ§\n  (card (set_of (Î» a, Â¬IsSquare a)) = (p - 1) / 2) ", "quadratic_residues_and_nonresidues (p : â„•) [Fact (Nat.Prime p)] : p â‰  2 â†’\n  (Finset.card (Finset.filter IsSquare (Finset.range p)) = (p - 1) / 2) âˆ§\n  (Finset.card (Finset.filter (Î» a, Â¬IsSquare a) (Finset.range p)) = (p - 1) / 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (Finset.card (QuadraticResidues p) = (p - 1) / 2 âˆ§ Finset.card (QuadraticNonresidues p) = (p - 1) / 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (p â‰  2)],\n  (Finset.card (Finset.filter IsSquare (Finset.range (p - 1))) = (p - 1) / 2) âˆ§\n  (Finset.card (Finset.filter (Î» x, Â¬IsSquare x) (Finset.range (p - 1))) = (p - 1) / 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (card (Residue p) = (p - 1) / 2) âˆ§ (card (NonResidue p) = (p - 1) / 2) ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (Finset.card (QR p) = (p - 1) / 2) âˆ§ (Finset.card (QNR p) = (p - 1) / 2) "]}
{"docString": "Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\\n  Polynomial.Monic gâ‚ â†’\\n    Polynomial.Monic gâ‚‚ â†’\\n      IsCoprime gâ‚ gâ‚‚ â†’\\n        âˆƒ q râ‚ râ‚‚,\\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\\ndeg(râ‚‚) < deg(gâ‚‚).\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"}]\n", "prompt_cons": "/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\ndeg(râ‚‚) < deg(gâ‚‚). -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\n  Polynomial.Monic gâ‚ â†’\n    Polynomial.Monic gâ‚‚ â†’\n      IsCoprime gâ‚ gâ‚‚ â†’\n        âˆƒ q râ‚ râ‚‚,\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚ :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic. -/\ntheorem", "choices": ["I cannot prove this specific example in Lean, as it requires a custom instance for the specific field `â„¤_7`. However, I can provide you with a general theorem that can be applied to this example:\n\n/-- Let `F` be a finite field, `p(x)` and `q(x)` be monic irreducible polynomials in `F[x]`, and `E_p` and `E_q` be the fields `F[x]/(p(x))` and `F[x]/(q(x))`. If the degrees of `p(x)` and `q(x)` are equal, then `E_p` and `E_q` are isomorphic. -/\ntheorem finite_field.isomorphic_quotient_polynomials {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p q : Polynomial F}\n  (hp : Polynomial.Monic p) (hq : Polynomial.Monic q) (hpq : Polynomial.degree p = Polynomial.degree q) (hp_irred : Irreducible p) (hq_irred : Irreducible q) :\n  Nonempty (Algebra.Isomorphism (Polynomial.QuotientRing F p) (Polynomial.QuotientRing F q)) ", "Sorry, I cannot prove this theorem as it involves a specific example which requires computations rather than a general statement. My main focus is on translating general theorems into Lean Theorem Prover code.", "I cannot prove this statement directly as a Lean theorem, but I can provide you with Lean code that demonstrates that p(x) and q(x) are irreducible over F, and that the quotient rings F[x]/(p(x)) and F[x]/(q(x)) are isomorphic. Here's how you can do that:\n\n```lean\nimport data.polynomial\nimport data.zmod.basic\nimport field_theory.adjoin\nimport field_theory.algebraic_closure\nimport field_theory.finite\nimport field_theory.is_alg_closed\nimport data.mv_polynomial\nimport linear_algebra.finite_dimensional\nimport ring_theory.adjoin_root\nimport ring_theory.integral_closure\nimport ring_theory.localization\nimport data.real.basic\n\nopen_locale classical\n\n/-- Define F as the field Zmod 7. -/\ndef F ", "I cannot prove this specific example in Lean because Lean does not support reasoning about specific fields like $\\mathbb{Z}_7$. However, I can help you with a general proof of this kind of problems. Please provide a more general statement or a different example that does not involve specific fields.", "Sorry, I cannot write the entire proof for this question as it is beyond the scope of a single translation. However, I can help you write the Lean code for the given data and some individual statements.\n\n```lean\nimport data.polynomial\nimport data.zmod.basic\n\nopen polynomial\n\ndef F ", "Sorry, I cannot generate a theorem statement for the given problem as it involves a specific example and a question about isomorphism between fields. My current capabilities only allow me to generate theorem statements for general cases.", "Sorry, I cannot provide a proof for this specific problem as I can only generate code based on given examples.", "Sorry, I cannot write a theorem for this specific example since Lean does not have a built-in structure for finite fields like ğ”½7. However, you can use the general theorems I provided earlier to prove the irreducibility of p(x) and q(x) in a general finite field and the isomorphism between the corresponding quotient fields.", "Sorry, I cannot provide a proof for this specific example as I am only able to generate code following the examples given previously.", "âˆ€ {F : Type u_1} [inst : Field F] [char_p F 7] {p q : Polynomial F},\n  p = Polynomial.x^3 - 2 â†’\n  q = Polynomial.x^3 + 2 â†’\n  (Irreducible p âˆ§ Irreducible q) âˆ§\n    (âˆƒ (Ï• : FractionRing (Polynomial F / Ideal.span {p}) â‰ƒâ‚[F] FractionRing (Polynomial F / Ideal.span {q})),\n      Ï•.is_iso) "]}
{"docString": "Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\\n  Ideal.IsPrime P â†’\\n    Â¬Polynomial.leadingCoeff f âˆˆ P â†’\\n      (âˆ€ (n : â„•), â†‘n < Polynomial.degree f â†’ Polynomial.coeff f n âˆˆ P) â†’\\n        0 < Polynomial.degree f â†’ Â¬Polynomial.coeff f 0 âˆˆ P ^ 2 â†’ Polynomial.IsPrimitive f â†’ Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\\nirreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\n  Ideal.IsPrime P â†’\n    Â¬Polynomial.leadingCoeff f âˆˆ P â†’\n      (âˆ€ (n : â„•), â†‘n < Polynomial.degree f â†’ Polynomial.coeff f n âˆˆ P) â†’\n        0 < Polynomial.degree f â†’ Â¬Polynomial.coeff f 0 âˆˆ P ^ 2 â†’ Polynomial.IsPrimitive f â†’ Irreducible f :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$. -/\ntheorem", "choices": ["f_irreducible : Irreducible (Polynomial.map (Int.castRingHom â„š) (Polynomial.x ^ 3 + 3 * Polynomial.x + 2)) ", "Polynomial.â„š_irreducible_x_pow_3_add_3x_add_2 : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial â„š) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial â„š) ", "irreducible_fx : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial â„š) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial â„š) ", "f_irreducible : Irreducible (Polynomial.map (Int.castRingHom â„š) (Polynomial.x ^ 3 + 3 * Polynomial.x + 2)) ", "f_irreducible : Irreducible (Polynomial.map (Int.castRingHom â„š) (Polynomial.x ^ 3 + 3 * Polynomial.x + 2)) ", "f_irreducible : Irreducible (Polynomial.x^3 + 3*Polynomial.x + 2 : Polynomial â„š) ", "irreducible_fx : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial â„š) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial â„š) "]}
{"docString": "If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’ âˆ€ {a : F}, a â‰  0 â†’ a ^ (Fintype.card F / 2) = 1 âˆ¨ a ^ (Fintype.card F / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = Â±1`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"âˆ€ {R' : Type v} [inst : CommRing R'] {F : Type u} [inst_1 : Field F] {Ïˆ : AddChar F R'},\\n  AddChar.IsNontrivial Ïˆ â†’ AddChar.IsPrimitive Ïˆ\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `R` is a field `F`, then a nontrivial additive character is primitive \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K]\\n  [inst_3 : FiniteDimensional F K] [inst_4 : CharZero F], IsSeparable F K\",\n  \"isProp\": true,\n  \"docString\": \"A finite field extension in characteristic 0 is separable. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) {p m : â„•} [inst : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\\n  Â¬p âˆ£ m â†’ âˆ€ {k : â„•}, 0 < k â†’ Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is of characteristic `p` and `Â¬p âˆ£ m`, then\\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ Nat.factorization (a * b) = Nat.factorization a + Nat.factorization b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) {p n : â„•} [hp : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\\n  p âˆ£ n â†’ Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is of characteristic `p` and `p âˆ£ n`, then\\n`cyclotomic (n * p) R = (cyclotomic n R) ^ p`. \"}]\n", "prompt_cons": "/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = Â±1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’ âˆ€ {a : F}, a â‰  0 â†’ a ^ (Fintype.card F / 2) = 1 âˆ¨ a ^ (Fintype.card F / 2) = -1 :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1 :=\n\n/-- When `R` is a field `F`, then a nontrivial additive character is primitive -/\ntheorem âˆ€ {R' : Type v} [inst : CommRing R'] {F : Type u} [inst_1 : Field F] {Ïˆ : AddChar F R'},\n  AddChar.IsNontrivial Ïˆ â†’ AddChar.IsPrimitive Ïˆ :=\n\n/-- A finite field extension in characteristic 0 is separable. -/\ntheorem âˆ€ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K]\n  [inst_3 : FiniteDimensional F K] [inst_4 : CharZero F], IsSeparable F K :=\n\n/-- If `R` is of characteristic `p` and `Â¬p âˆ£ m`, then\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. -/\ntheorem âˆ€ (R : Type u_1) {p m : â„•} [inst : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\n  Â¬p âˆ£ m â†’ âˆ€ {k : â„•}, 0 < k â†’ Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1)) :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\ntheorem âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ Nat.factorization (a * b) = Nat.factorization a + Nat.factorization b :=\n\n/-- If `R` is of characteristic `p` and `p âˆ£ n`, then\n`cyclotomic (n * p) R = (cyclotomic n R) ^ p`. -/\ntheorem âˆ€ (R : Type u_1) {p n : â„•} [hp : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\n  p âˆ£ n â†’ Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ p :=\n\n/-- If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$. -/\ntheorem", "choices": ["âˆ€ (F : Type u_1) [inst : Field F] [inst_1 : CharP F p] {a b : F} {m : â„•} (n : â„•),\n  0 < n â†’ m = p ^ n â†’ (a + b) ^ m = a ^ m + b ^ m ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p n : â„•} [inst_2 : CharP F p] {a b : F},\n  Nat.Prime p â†’ 0 < n â†’ (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "âˆ€ {F : Type u_1} [inst : Field F] {p : â„•} [hp : Fact (Nat.Prime p)] [inst_1 : CharP F p] {n m : â„•}, 0 < n â†’ m = p ^ n â†’\n  âˆ€ (a b : F), (a + b) ^ m = a ^ m + b ^ m ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] {p : â„•} (hp : Fact (Nat.Prime p)) {n : â„•} (hn : 0 < n),\n  âˆ€ (a b : F), (a + b) ^ (p^n) = a^(p^n) + b^(p^n) ", "âˆ€ {F : Type u_1} [inst : Field F] {p : â„•} [inst_1 : Fact (Nat.Prime p)] [inst_2 : CharP F p] {a b : F} {n : â„•},\n  0 < n â†’ (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "âˆ€ {F : Type u_1} [inst : Field F] {p m : â„•} [inst_1 : Fact (Nat.Prime p)] [inst_2 : CharP F p],\n  âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (a b : F), (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : CharP F p] {p : â„•} [Fact (Nat.Prime p)] {a b : F} {n : â„•},\n  0 < n â†’ (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "âˆ€ {F : Type u_1} [inst : Field F] {p n : â„•} [inst_1 : Fact (Nat.Prime p)] [inst_2 : CharP F p] (a b : F),\n  0 < n â†’ (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : CharP F p], p â‰  0 â†’ âˆ€ (a b : F) (m : â„•), m = p^n â†’ (a + b) ^ m = a ^ m + b ^ m ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] {p n : â„•} (hp : Fact (Nat.Prime p)) (hn : 0 < n)\n  {a b : F}, (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) "]}
{"docString": "If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} {A : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\\n  Algebra.IsAlgebraic K L â†’ Algebra.IsAlgebraic L A â†’ Algebra.IsAlgebraic K A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If L is an algebraic field extension of K and A is an algebraic algebra over L,\\nthen A is algebraic over K. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\\n  Algebra.IsAlgebraic K A â†’ Algebra.IsAlgebraic L A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A] {x : A},\\n  IsAlgebraic K x â†’ IsAlgebraic L x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x is algebraic over K, then x is algebraic over L when L is an extension of K \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (A : Subalgebra K L),\\n  Algebra.IsAlgebraic K L â†’ IsField { x // x âˆˆ A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an algebraic extension L/K, an intermediate subalgebra is a field. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A],\\n  Algebra.IsAlgebraic R A â†” Subalgebra.IsAlgebraic âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebra is algebraic if and only if it is algebraic as a subalgebra. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_2) [inst : CommRing R] (S : Type u_3) [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_1)\\n  [inst_3 : Field K] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : Algebra R K] [inst_7 : Algebra S K]\\n  [inst_8 : NoZeroSMulDivisors R K] [inst_9 : IsFractionRing S K] [inst_10 : IsScalarTower R S K],\\n  Algebra.IsAlgebraic R S â†” Algebra.IsAlgebraic R K\",\n  \"isProp\": true,\n  \"docString\":\n  \"`S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] (S : Subalgebra R A),\\n  Subalgebra.IsAlgebraic S â†” Algebra.IsAlgebraic R { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subalgebra is algebraic if and only if it is algebraic as an algebra. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"}]\n", "prompt_cons": "/-- If L is an algebraic field extension of K and A is an algebraic algebra over L,\nthen A is algebraic over K. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} {A : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\n  Algebra.IsAlgebraic K L â†’ Algebra.IsAlgebraic L A â†’ Algebra.IsAlgebraic K A :=\n\n/-- If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\n  Algebra.IsAlgebraic K A â†’ Algebra.IsAlgebraic L A :=\n\n/-- If x is algebraic over K, then x is algebraic over L when L is an extension of K -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A] {x : A},\n  IsAlgebraic K x â†’ IsAlgebraic L x :=\n\n/-- In an algebraic extension L/K, an intermediate subalgebra is a field. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (A : Subalgebra K L),\n  Algebra.IsAlgebraic K L â†’ IsField { x // x âˆˆ A } :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1 :=\n\n/-- An algebra is algebraic if and only if it is algebraic as a subalgebra. -/\ntheorem âˆ€ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A],\n  Algebra.IsAlgebraic R A â†” Subalgebra.IsAlgebraic âŠ¤ :=\n\n/-- `S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` -/\ntheorem âˆ€ (R : Type u_2) [inst : CommRing R] (S : Type u_3) [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_1)\n  [inst_3 : Field K] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : Algebra R K] [inst_7 : Algebra S K]\n  [inst_8 : NoZeroSMulDivisors R K] [inst_9 : IsFractionRing S K] [inst_10 : IsScalarTower R S K],\n  Algebra.IsAlgebraic R S â†” Algebra.IsAlgebraic R K :=\n\n/-- A subalgebra is algebraic if and only if it is algebraic as an algebra. -/\ntheorem âˆ€ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] (S : Subalgebra R A),\n  Subalgebra.IsAlgebraic S â†” Algebra.IsAlgebraic R { x // x âˆˆ S } :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1 :=\n\n/-- If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$. -/\ntheorem", "choices": ["âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) â†’ IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) â†’ IsAlgebraic F a ", "âˆ€ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) â†’ IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a^2) â†’ IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) â†’ IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  Algebra.IsAlgebraic F (a ^ 2) â†’ Algebra.IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) â†’ IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) â†’ IsAlgebraic F a ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {x : K},\n  IsAlgebraic F (x * x) â†’ IsAlgebraic F x ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  Algebra.IsAlgebraic F (a ^ 2) â†’ Algebra.IsAlgebraic F a "]}
{"docString": "If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.", "prompts": "[{\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)],\\n  p â‰  2 â†’ âˆ€ (a : â„¤), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = â†‘a})) = legendreSym p a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of square roots of `a` modulo `p` is determined by the Legendre symbol. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\\n  â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p â†’\\n    â†‘Polynomial.C (Polynomial.leadingCoeff p) *\\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - â†‘Polynomial.C a) (Polynomial.roots p)) =\\n      p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial `p` that has as many roots as its degree\\ncan be written `p = p.leadingCoeff * âˆ(X - a)`, for `a` in `p.roots`. \"}]\n", "prompt_cons": "/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)],\n  p â‰  2 â†’ âˆ€ (a : â„¤), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = â†‘a})) = legendreSym p a + 1 :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1) :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1 :=\n\n/-- The square of the symbol is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leadingCoeff * âˆ(X - a)`, for `a` in `p.roots`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p â†’\n    â†‘Polynomial.C (Polynomial.leadingCoeff p) *\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - â†‘Polynomial.C a) (Polynomial.roots p)) =\n      p :=\n\n/-- If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80. -/\ntheorem", "choices": ["âˆ€ {C : Type u_1} [inst : Field C] {a : C}, â†‘(2 ^ (1 / 2)) * a ^ 3 + â†‘(5 ^ (1 / 2)) * a ^ 2 + (â†‘(7 ^ (1 / 2)) * a + â†‘(11 ^ (1 / 2))) = 0 â†’ IsAlgebraic â„š a âˆ§ Algebraic.degree â„š a â‰¤ 80 ", "âˆ€ {C : Type u} [inst : Field C] [inst_1 : Algebra â„š C] {a : C},\n  a ^ 5 + â†‘(algebraMap â„š C (Real.sqrt 2)) * a ^ 3 + â†‘(algebraMap â„š C (Real.sqrt 5)) * a ^ 2 + â†‘(algebraMap â„š C (Real.sqrt 7)) * a + â†‘(algebraMap â„š C (Real.sqrt 11)) = 0 â†’\n    IsAlgebraic â„š a âˆ§ (minpoly â„š a).natDegree â‰¤ 80 ", "âˆ€ {C : Type u_1} [inst : CommRing C] {a : C},\n  a ^ 5 + â†‘(algebraMap â„š C (Rat.sqrt 2)) * a ^ 3 + â†‘(algebraMap â„š C (Rat.sqrt 5)) * a ^ 2 +\n      â†‘(algebraMap â„š C (Rat.sqrt 7)) * a + â†‘(algebraMap â„š C (Rat.sqrt 11)) = 0 â†’\n    âˆƒ {F : Type u_1} [inst_1 : CommRing F] [inst_2 : Algebra â„š F], IsIntegral F a âˆ§ FiniteDimensional.finrank â„š F â‰¤ 80 ", "âˆ€ {C : Type u} [inst : CommRing C] {a : C},\n  a ^ 5 + âˆš2 * a ^ 3 + âˆš5 * a ^ 2 + âˆš7 * a + âˆš11 = 0 â†’\n    IsAlgebraic â„š a âˆ§ Algebraic.degree â„š a â‰¤ 80 ", "âˆ€ {C : Type u} [inst : Field C] {a : C},\n  a ^ 5 + a ^ 3 * âˆš(2 : â„) + a ^ 2 * âˆš(5 : â„) + a * âˆš(7 : â„) + âˆš(11 : â„) = 0 â†’\n    AlgebraicDegree (ğš¯ a) (Rational a) â‰¤ 80 ", "âˆ€ (C : Type u) [inst : CommRing C] [inst_1 : Algebra â„š C] (a : C),\n  a ^ 5 + Algebra.adjoinRoot â„š âˆš2 * a ^ 3 + Algebra.adjoinRoot â„š âˆš5 * a ^ 2 + Algebra.adjoinRoot â„š âˆš7 * a + Algebra.adjoinRoot â„š âˆš11 = 0 â†’\n    âˆƒ (p : Polynomial â„š), p â‰  0 âˆ§ Polynomial.evalâ‚‚ (Algebra.map â„š C) a p = 0 âˆ§ Polynomial.natDegree p â‰¤ 80 ", "âˆ€ {C : Type u} [inst : Field C] (a : C),\n  a ^ 5 + (2 ^ (1 / 2) * a ^ 3) + (5 ^ (1 / 2) * a ^ 2) + (7 ^ (1 / 2) * a) + 11 ^ (1 / 2) = 0 â†’\n    IsAlgebraic (Rational â„š) a âˆ§ algebraicDegree (Rational â„š) a â‰¤ 80 ", "âˆ€ {C : Type u} [inst : Field C] (a : C),\n  a ^ 5 + (2 ^ (1 / 2)) * a ^ 3 + (5 ^ (1 / 2)) * a ^ 2 + (7 ^ (1 / 2)) * a + (11 ^ (1 / 2)) = 0 â†’\n    âˆƒ (n : â„•) (f : Polynomial â„š), n â‰¤ 80 âˆ§\n      Polynomial.degree f = n âˆ§ f â‰  0 âˆ§ Polynomial.aeval a f = 0 ", "âˆ€ {C : Type u} [inst : Field C] (a : C),\n  a ^ 5 + âˆš(2) * a ^ 3 + âˆš(5) * a ^ 2 + âˆš(7) * a + âˆš(11) = 0 â†’\n    IsAlgebraic â„š a âˆ§ Algebraic.degree â„š a â‰¤ 80 ", "âˆ€ (C : Type u) [inst : CommRing C] (a : C),\n  a ^ 5 + (âˆš(2 : â„š)) * a ^ 3 + (âˆš(5 : â„š)) * a ^ 2 + (âˆš(7 : â„š)) * a + (âˆš(11 : â„š)) = 0 â†’\n    IsAlgebraic â„š a âˆ§ AlgebraicDegree â„š a â‰¤ 80 "]}
{"docString": "If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (p : â„•) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R â‰  0 â†’ (IsUnit â†‘p â†” Â¬p âˆ£ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m = 1 â†” Â¬â†‘p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ p` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\\n  p â‰  0 â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x â†’ Polynomial.Monic a â†’ DvdNotUnit a (minpoly A x) â†’ â†‘(Polynomial.aeval x) a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"}]\n", "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (p : â„•) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R â‰  0 â†’ (IsUnit â†‘p â†” Â¬p âˆ£ ringChar R) :=\n\n/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m = 1 â†” Â¬â†‘p âˆ£ m :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ p` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\n  p â‰  0 â†’ Nat.Prime p :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x â†’ Polynomial.Monic a â†’ DvdNotUnit a (minpoly A x) â†’ â†‘(Polynomial.aeval x) a â‰  0 :=\n\n/-- If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct. -/\ntheorem", "choices": ["forall {F : Type u} [inst : Field F] {p : â„•} [hp : Fact (Nat.Prime p)] [char_p_F : CharP F p] {n m : â„•},\n  m = p^n â†’ (Polynomial.x ^ m - Polynomial.x).roots.nodup ", "âˆ€ {F : Type u_1} [inst : Field F] {m : â„•} (hpos : 0 < m) [hcp : CharP F] (p : â„•) [inst_1 : Fact (Nat.Prime p)],\n  hcp p â†’ m = p ^ (Nat.findGreatest (Î» n, p ^ n â‰¤ m) m) â†’ Polynomial.Separable (Polynomial.x ^ m - Polynomial.x) ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] {p : â„•} [inst_2 : Fact (Nat.Prime p)] {n : â„•},\n  ringChar F â‰  0 â†’\n    âˆ€ {m : â„•}, m = p ^ n â†’ Polynomial.nodupRoots (Polynomial.x ^ m - Polynomial.x) ", "forall {R : Type u} [inst : CommRing R] [inst_1 : CharZero R] {p : â„•} [Fact (Nat.Prime p)] {n : â„•}, \n  ringChar R â‰  0 â†’\n  âˆ€ (hroots : âˆ€ (x : R), HasMem.Mem x (Finset.image (fun m => Polynomial.Roots.coeffs_nth_roots (p ^ n) m) (Finset.range p))\n  â†” Polynomial.x ^ (p ^ n) - Polynomial.x = 0),\n  Finset.card (Finset.image (fun m => Polynomial.Roots.coeffs_nth_roots (p ^ n) m) (Finset.range p)) = p ", "âˆ€ {F : Type u} [inst : Field F] {p : â„•} [inst_1 : Fact (Nat.Prime p)] [inst_2 : CharP F p] {m : â„•},\n  m = p ^ Nat.find âŸ¨m, _âŸ© â†’ âˆ€ aâ‚ aâ‚‚ : F, Polynomial.eval aâ‚ (Polynomial.x ^ m - Polynomial.x) = 0 â†’\n                                Polynomial.eval aâ‚‚ (Polynomial.x ^ m - Polynomial.x) = 0 â†’ aâ‚ = aâ‚‚ ", "/-- If `F` is of characteristic `p` and `m = p ^ n`, the roots of `x^m - x` are distinct. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] {p m : â„•} [hF : CharP F p] [hp : Fact (Nat.Prime p)]\n         [hpm : m = p ^ n] {n : â„•},\n  Polynomial.pairwise_coprime_X_sub (Polynomial.roots (Polynomial.x ^ m - Polynomial.x)) ", "âˆ€ {F : Type u} [inst : Field F] {p : â„•} [hp : Fact (Nat.Prime p)] [hF : CharP F p] {n : â„•},\n  âˆ€ (m : â„•) (hm : m = p ^ n), Polynomial.nodupRoots (Polynomial.x ^ m - Polynomial.x) ", "forall {F : Type u} [inst : Field F] {p : â„•} [hp : Fact (Nat.Prime p)] [char_p : CharP F p],\n  p â‰  0 â†’ âˆ€ (n : â„•), Polynomial.Separable (Polynomial.x ^ (p^n) - Polynomial.x) ", "âˆ€ {F : Type u} [inst : Field F] [inst_1 : CharP F] {p : â„•} [inst_2 : Fact (Nat.Prime p)] {n m : â„•},\n  m = p ^ n â†’ âˆ€ (xâ‚ xâ‚‚ : F), xâ‚ ^ m = xâ‚ âˆ§ xâ‚‚ ^ m = xâ‚‚ â†’ xâ‚ = xâ‚‚ ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : CharP R] {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)],\n  ringChar R â‰  0 â†’ CharP R p â†’ m = p ^ Nat.findGreatest (Î» n, p ^ n âˆ£ m) 0 â†’\n    Polynomial.HasDistinctRoots (Polynomial.x ^ m - Polynomial.x) "]}
{"docString": "Prove that the products $a b$ and $b a$ are conjugate elements in a group.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => âˆƒ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation â€œthere exists an element that semiconjugates `a` to `b`â€ on a semigroup\\nis transitive. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S], Transitive fun a b => âˆƒ c, AddSemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation â€œthere exists an element that semiconjugates `a` to `b`â€ on an additive\\nsemigroup is transitive.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z â†’ SemiconjBy b x y â†’ SemiconjBy (a * b) x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\\nsemiconjugates `x` to `z`. \"}]\n", "prompt_cons": "/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- The relation â€œthere exists an element that semiconjugates `a` to `b`â€ on a semigroup\nis transitive. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => âˆƒ c, SemiconjBy c a b :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b :=\n\n/-- The relation â€œthere exists an element that semiconjugates `a` to `b`â€ on an additive\nsemigroup is transitive. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S], Transitive fun a b => âˆƒ c, AddSemiconjBy c a b :=\n\n/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z â†’ SemiconjBy b x y â†’ SemiconjBy (a * b) x z :=\n\n/-- Prove that the products $a b$ and $b a$ are conjugate elements in a group. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ c, SemiconjBy c (a * b) (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ c, Conjugate (a * b) (b * a) ", "/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem prod_comm_of_comm {S : Type u_1} [inst : Semigroup S] {a b c : S} (hac : Commute a c) (hbc : Commute b c) : Commute (a * b) c ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ c, SemiconjBy c (a * b) (b * a) ", "forall {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ g, SemiconjBy g (a * b) (b * a) ", "forall {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ c, SemiconjBy c (a * b) (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ c, SemiconjBy c (a * b) (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ c, SemiconjBy c (a * b) (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, âˆƒ x, SemiconjBy x (a * b) (b * a) ", "forall {G : Type u_1} [inst : Group G] {a b : G}, IsConj (a * b) (b * a) "]}
{"docString": "Prove that the center of the product of two groups is the product of their centers.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalNonAssocSemiring Î±] (self : CentroidHom Î±) (a b : Î±),\\n  ZeroHom.toFun (â†‘self.toAddMonoidHom) (a * b) = ZeroHom.toFun (â†‘self.toAddMonoidHom) a * b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of centroid homomorphims with right multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} [inst : NonUnitalNonAssocSemiring Î±] [self : CentroidHomClass F Î±] (f : F)\\n  (a b : Î±), â†‘f (a * b) = a * â†‘f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of centroid homomorphims with left multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R], SMulCommClass R { x // x âˆˆ Subring.center R } R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The center of a semiring acts commutatively on that semiring. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"}]\n", "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M :=\n\n/-- Commutativity of centroid homomorphims with right multiplication. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NonUnitalNonAssocSemiring Î±] (self : CentroidHom Î±) (a b : Î±),\n  ZeroHom.toFun (â†‘self.toAddMonoidHom) (a * b) = ZeroHom.toFun (â†‘self.toAddMonoidHom) a * b :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- Commutativity of centroid homomorphims with left multiplication. -/\ntheorem âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} [inst : NonUnitalNonAssocSemiring Î±] [self : CentroidHomClass F Î±] (f : F)\n  (a b : Î±), â†‘f (a * b) = a * â†‘f b :=\n\n/-- The center of a semiring acts commutatively on that semiring. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R], SMulCommClass R { x // x âˆˆ Subring.center R } R :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G) :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- Prove that the center of the product of two groups is the product of their centers. -/\ntheorem", "choices": ["forall {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\nSubgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G Ã— H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) "]}
{"docString": "Prove that every homomorphism of fields is injective.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R â†’\\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra Râ‚ A] [inst_4 : Algebra Râ‚ B] (f : A â†’â‚[Râ‚] B), Function.Injective â†‘(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : { x // x âˆˆ LinearMap.ker f } â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’\\n    LinearMap.ker f = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective â†‘f â†’ Ideal.IsMaximal (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a field is a maximal ideal. \"}]\n", "prompt_cons": "/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R â†’\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem âˆ€ {Râ‚ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra Râ‚ A] [inst_4 : Algebra Râ‚ B] (f : A â†’â‚[Râ‚] B), Function.Injective â†‘(Ideal.kerLiftAlg f) :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0) :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- A monomorphism is injective. -/\ntheorem âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\n  (âˆ€ (u v : { x // x âˆˆ LinearMap.ker f } â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’\n    LinearMap.ker f = âŠ¥ :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\n  Function.Surjective â†‘f â†’ Ideal.IsMaximal (RingHom.ker f) :=\n\n/-- Prove that every homomorphism of fields is injective. -/\ntheorem", "choices": ["âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] {Ï† : K â†’+* L},\n  Function.Injective â†‘Ï† ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] (f : F â†’+* K), Function.Injective â†‘f ", "âˆ€ {Fâ‚ : Type u_1} {Fâ‚‚ : Type u_2} [inst : Field Fâ‚] [inst_1 : Field Fâ‚‚] {f : Fâ‚ â†’+* Fâ‚‚}, Function.Injective â†‘f ", "âˆ€ {Fâ‚ : Type u_1} {Fâ‚‚ : Type u_2} [inst : Field Fâ‚] [inst_1 : Field Fâ‚‚] {Ïƒ : Fâ‚ â†’+* Fâ‚‚},\n  Function.Injective â†‘Ïƒ ", "âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] {f : K â†’+* L}, Function.Injective â†‘f ", "âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] {f : K â†’+* L},\n  Function.Injective â†‘f ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] {f : F â†’+* K}, Function.Injective â†‘f ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] {f : F â†’+* K},\n  Function.Injective â†‘f ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] {f : F â†’+* K},\n  Function.Injective â†‘f ", "âˆ€ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] {f : F â†’+* K},\n  Function.Injective â†‘f "]}
{"docString": "Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces.", "prompts": "[{\"theorem\":\n  \"âˆ€ (ğ•œ : Type u) [inst : NontriviallyNormedField ğ•œ] (E : Type v) [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ] [inst : FiniteDimensional ğ•œ E], ProperSpace E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any finite-dimensional vector space over a proper field is proper.\\nWe do not register this as an instance to avoid an instance loop when trying to prove the\\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\\nexplicitly when needed. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\\n    âˆ€ (f : V'' â†’â‚—[R] V),\\n      Function.Injective â†‘f â†’\\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\\n * the function `f' : V'' â†’ V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), Â¬s1 â‰¤ s2 â†” âˆƒ p, p âˆˆ s1 âˆ§ Â¬p âˆˆ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is not less than or equal to another if and only if it has a point not in the\\nsecond subspace. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite (Function.mulSupport fun v => IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\\n`v^(val_v(I))` is not the unit ideal. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"}]\n", "prompt_cons": "/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem âˆ€ (ğ•œ : Type u) [inst : NontriviallyNormedField ğ•œ] (E : Type v) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ] [inst : FiniteDimensional ğ•œ E], ProperSpace E :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\n * the function `f' : V'' â†’ V'` doesn't need to be injective -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\n    âˆ€ (f : V'' â†’â‚—[R] V),\n      Function.Injective â†‘f â†’\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), Â¬s1 â‰¤ s2 â†” âˆƒ p, p âˆˆ s1 âˆ§ Â¬p âˆˆ s2 :=\n\n/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\n`v^(val_v(I))` is not the unit ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite (Function.mulSupport fun v => IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I) :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces. -/\ntheorem", "choices": ["âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  [inst_3 : Infinite F], Â¬âˆƒ (Î¹ : Type u_1) (s : Î¹ â†’ Submodule F V) [inst_4 : Finite Î¹],\n    V = â‹ƒ (i : Î¹), â†‘(s i) ", "âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ], Infinite ğ•œ â†’\n  âˆ€ {Î¹ : Type u_1} [inst_4 : Finite Î¹] (s : Î¹ â†’ Submodule ğ•œ E), (âˆ€ i, s i < âŠ¤) â†’ Â¬(â‹ƒ i, â†‘(s i) : Set E) = Set.Univ ", "âˆ€ {F : Type u} {V : Type v} [inst : NontriviallyNormedField F] [inst_1 : AddCommGroup V] [inst_2 : Module F V],\n  Infinite F â†’\n    âˆ€ {Î¹ : Type u_1} [inst_3 : Fintype Î¹], (âˆƒ (f : Î¹ â†’ Submodule F V), âˆ€ (i : Î¹), f i < âŠ¤) â†’ Â¬âŠ¤ â‰¤ supr f ", "âˆ€ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  Â¬âˆƒ (s : Finset (Submodule F V)), Submodule.span F âŠ¤ = Set.Unionâ‚“ (coe '' â†‘s) ", "âˆ€ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  Â¬Submodule.IsSubfieldUnionFinsupp F V ", "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  Â¬Set.Finite (Set.Range (Î» (x : Subspace F V), â†‘x)) â†’ (âˆ€ (s : Set (Subspace F V)), Set.Finite s â†’ Â¬(â‹ƒâ‚€ s = âŠ¤)) ", "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  âˆ€ (s : Set (Submodule F V)), Set.Finite s â†’ (âˆƒ (x : V), Â¬x âˆˆ Set.Unionâ‚“ fun H => coe H) â†’\n    âˆ€ (x : V), Â¬x âˆˆ Set.Unionâ‚“ fun (H : Submodule F V) (h : H âˆˆ s) => coe H ", "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inf : Infinite F],\n  Â¬âˆƒ (Î¹ : Type) (t : Fintype Î¹), âˆ€ (x : V), âˆƒ (i : Î¹), x âˆˆ Submodule.span F {t i} ", "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : Infinite K] [inst_2 : AddCommGroup V] [inst_3 : Module K V],\n  Â¬Exists (fun (s : Set (Finset (Submodule K V))) => Set.Finite s âˆ§ V = â‹ƒâ‚€ s) ", "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  Â¬âˆƒ (n : â„•) (s : Finâ‚“ n â†’ Submodule F V), V = â‹ƒ (i : Finâ‚“ n), â†‘(s i) "]}
{"docString": "Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\\n  p â‰  p' â†’ Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`- and `q`-primary components are disjoint for `p â‰  q`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\\n  p â‰  p' â†’ Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\": \"The `p`- and `q`-primary components are disjoint for `p â‰  q`.\"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p â‰  q`. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\n  p â‰  p' â†’ Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p â‰  q`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\n  p â‰  p' â†’ Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p') :=\n\n/-- Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬ IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬ IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬ IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬ IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ Not (IsSimpleGroup G) ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ Â¬IsSimpleGroup Î± "]}
{"docString": "Prove that no group of order 224 is simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Prove that no group of order 224 is simple. -/\ntheorem", "choices": ["no_group_of_order_224_is_simple : âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 224 â†’ Â¬IsSimpleGroup Î± ", "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 224 â†’ Â¬IsSimpleGroup G ", "theorem no_group_of_order_224_is_simple :\n  âˆ€ {G : Type u_1} [_inst_1 : Fintype G] [_inst_2 : Group G], Fintype.card G = 224 â†’ Â¬IsSimpleGroup G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 224 â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 224 â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 224 â†’ Â¬IsSimpleGroup G ", "/-- A finite group of prime order is simple. -/\ntheorem prime_order_is_simple {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 224 â†’ Â¬IsSimpleGroup G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 224 â†’ Â¬IsSimpleGroup Î± ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 224 â†’ Â¬IsSimpleGroup Î± "]}
{"docString": "An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P â†’ IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] {x : R}, â€–xâ€– < 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a normed ring, the powers of an element x with `â€–xâ€– < 1` tend to zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Polynomial R),\\n  IsUnit P â†” IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\\nnilpotent, except its constant term which is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G â§¸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚ : Type u_1} {Gâ‚‚ : Type u_2} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Group.IsNilpotent Gâ‚]\\n  [inst_3 : Group.IsNilpotent Gâ‚‚], Group.IsNilpotent (Gâ‚ Ã— Gâ‚‚)\",\n  \"isProp\": true,\n  \"docString\": \"Products of nilpotent groups are nilpotent \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup of a nilpotent group is nilpotent \"}]\n", "prompt_cons": "/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P â†’ IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i) :=\n\n/-- In a normed ring, the powers of an element x with `â€–xâ€– < 1` tend to zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] {x : R}, â€–xâ€– < 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) :=\n\n/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Polynomial R),\n  IsUnit P â†” IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i) :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G â§¸ H) :=\n\n/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤ :=\n\n/-- Products of nilpotent groups are nilpotent -/\ntheorem âˆ€ {Gâ‚ : Type u_1} {Gâ‚‚ : Type u_2} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Group.IsNilpotent Gâ‚]\n  [inst_3 : Group.IsNilpotent Gâ‚‚], Group.IsNilpotent (Gâ‚ Ã— Gâ‚‚) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A subgroup of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x âˆˆ H } :=\n\n/-- An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : Semiring R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : Ring R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] (x : R), IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) ", "âˆ€ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x â†’ IsUnit (1 + x) "]}
{"docString": "Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  Â¬IsField A â†’\\n    âˆ€ {I : Ideal A},\\n      I â‰  âŠ¥ â†’\\n        âˆƒ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I âˆ§\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, Â§ 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : Field K] [inst_2 : IsDomain A] [inst_3 : Algebra A K]\\n  [inst_4 : IsFractionRing A K] [h : IsDedekindDomain A] (I : Ideal A), I â‰  âŠ¥ â†’ â†‘I * (â†‘I)â»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Nonzero integral ideals in a Dedekind domain are invertible.\\n\\nWe will use this to show that nonzero fractional ideals are invertible,\\nand finally conclude that fractional ideals in a Dedekind domain form a group with zero.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (p : â„•) [inst_1 : CharP R p] (I : Ideal R),\\n  (âˆ€ (x : â„•), â†‘x âˆˆ I â†’ â†‘x = 0) â†’ CharP (R â§¸ I) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\\ninherits the characteristic of the underlying ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Râ‚ K]\\n  [frac : IsFractionRing Râ‚ K] [inst_3 : IsDomain Râ‚] [inst_4 : IsNoetherianRing Râ‚]\\n  (I : FractionalIdeal (nonZeroDivisors Râ‚) K), IsNoetherian Râ‚ { x // x âˆˆ â†‘I }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every fractional ideal of a noetherian integral domain is noetherian. \"}]\n", "prompt_cons": "/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, Â§ 3.3, Lemma 3]) -/\ntheorem âˆ€ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  Â¬IsField A â†’\n    âˆ€ {I : Ideal A},\n      I â‰  âŠ¥ â†’\n        âˆƒ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I âˆ§\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰  âŠ¥ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0 :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- Nonzero integral ideals in a Dedekind domain are invertible.\n\nWe will use this to show that nonzero fractional ideals are invertible,\nand finally conclude that fractional ideals in a Dedekind domain form a group with zero. -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : Field K] [inst_2 : IsDomain A] [inst_3 : Algebra A K]\n  [inst_4 : IsFractionRing A K] [h : IsDedekindDomain A] (I : Ideal A), I â‰  âŠ¥ â†’ â†‘I * (â†‘I)â»Â¹ = 1 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (p : â„•) [inst_1 : CharP R p] (I : Ideal R),\n  (âˆ€ (x : â„•), â†‘x âˆˆ I â†’ â†‘x = 0) â†’ CharP (R â§¸ I) p :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Râ‚ K]\n  [frac : IsFractionRing Râ‚ K] [inst_3 : IsDomain Râ‚] [inst_4 : IsNoetherianRing Râ‚]\n  (I : FractionalIdeal (nonZeroDivisors Râ‚) K), IsNoetherian Râ‚ { x // x âˆˆ â†‘I } :=\n\n/-- Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer. -/\ntheorem", "choices": ["âˆ€ {I : Ideal â„¤[i]}, I â‰  âŠ¥ â†’ âˆƒ x : â„¤, x â‰  0 âˆ§ â†‘x âˆˆ I ", "âˆ€ {Î± : Type u_1} [inst : CommRing Î±] [inst_1 : IsDomain Î±] [inst_2 : NoZeroDivisors Î±] [inst_3 : IsGaussianRing Î±] [inst_4 : Nontrivial Î±]\n  {I : Ideal Î±}, I â‰  âŠ¥ â†’ âˆƒ x, â†‘x âˆˆ I âˆ§ â†‘x â‰  (0 : Î±) ", "âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I ", "âˆ€ {R : Type u_1} [inst : EuclideanDomain R] [inst_1 : IsGaussValuation R] {I : Ideal R},\n  I â‰  âŠ¥ â†’ âˆƒ x x_1, â†‘x âˆˆ I ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsUniqueFactorizationMonoid R],\n  Â¬IsField R â†’\n    âˆ€ {I : Ideal R},\n      I â‰  âŠ¥ â†’\n        âˆƒ x, x âˆˆ I âˆ§ x â‰  0 ", "âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : IsDomain K] [inst_2 : Algebra â„¤ K] [inst_3 : IsFractionRing â„¤ K] {I : Ideal (â„¤[i])},\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap â„¤ K) x âˆˆ I ", "âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I ", "âˆ€ {Z : Type u_1} [inst : CommRing Z] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Z K]\n  [inst_3 : IsFractionRing Z K] {I : FractionalIdeal (nonZeroDivisors Z) K} [inst_4 : Nontrivial Z],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap Z K) x âˆˆ I ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {I : Ideal R} [inst_2 : Nontrivial R],\n  I â‰  âŠ¥ â†’ âˆƒ x x_1, â†‘x âˆˆ I "]}
{"docString": "Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (âˆ€ (P : Ideal R) (hP : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I â‰¤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\\n    I â‰¤ J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\\nthe localization of `J` at `P`, then `I â‰¤ J`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R}\\n  {p : R} {z : S},\\n  p âˆˆ Ideal.comap (algebraMap R S) (conductor R x) â†’\\n    z âˆˆ Ideal.map (algebraMap R S) I â†’\\n      â†‘(algebraMap R S) p * z âˆˆ\\n        â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) ''\\n          â†‘(Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\\nthen `p * (I * S) âŠ† I * R<x>` for any `p` in `C âˆ© R` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I â†’\\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\\n  Function.Injective\\n    â†‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n        (_ :\\n          P â‰¤\\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be an ideal in `R[x]`.  The map\\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\\nis injective.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R) (s : Set R),\\n  â†‘(Ideal.Quotient.mk I) â»Â¹' (â†‘(Ideal.Quotient.mk I) '' s) = â‹ƒ (x : { x // x âˆˆ I }), (fun y => â†‘x + y) '' s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `I` is an ideal of a commutative ring `R`, if `q : R â†’ R/I` is the quotient map, and if\\n`s âŠ† R` is a subset, then `qâ»Â¹(q(s)) = â‹ƒáµ¢(i + s)`, the union running over all `i âˆˆ I`. \"}]\n", "prompt_cons": "/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\n    I = J :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I â‰¤ J`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (P : Ideal R) (hP : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I â‰¤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\n    I â‰¤ J :=\n\n/-- A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥ :=\n\n/-- This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\nthen `p * (I * S) âŠ† I * R<x>` for any `p` in `C âˆ© R` -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R}\n  {p : R} {z : S},\n  p âˆˆ Ideal.comap (algebraMap R S) (conductor R x) â†’\n    z âˆˆ Ideal.map (algebraMap R S) I â†’\n      â†‘(algebraMap R S) p * z âˆˆ\n        â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) ''\n          â†‘(Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I) :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I â†’\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\n          P I :=\n\n/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\nis injective. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\n  Function.Injective\n    â†‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n        (_ :\n          P â‰¤\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P))) :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- If `I` is an ideal of a commutative ring `R`, if `q : R â†’ R/I` is the quotient map, and if\n`s âŠ† R` is a subset, then `qâ»Â¹(q(s)) = â‹ƒáµ¢(i + s)`, the union running over all `i âˆˆ I`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R) (s : Set R),\n  â†‘(Ideal.Quotient.mk I) â»Â¹' (â†‘(Ideal.Quotient.mk I) '' s) = â‹ƒ (x : { x // x âˆˆ I }), (fun y => â†‘x + y) '' s :=\n\n/-- Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I âŠ” J = âŠ¤ â†’\n    I * J = I âŠ“ J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R}, I âŠ” J = âŠ¤ â†’ I * J = I âŠ“ J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (I âŠ” J = âŠ¤) â†’ (I * J = I âŠ“ J) ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R}, I âŠ” J = âŠ¤ â†’ I * J = I âŠ“ J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I âŠ” J = âŠ¤ â†’ I * J = I âŠ“ J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R}, I âŠ” J = âŠ¤ â†’ I * J = I âŠ“ J ", "forall {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I âŠ” J = âŠ¤ â†’\n  I * J = I âŠ“ J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I âŠ” J = âŠ¤ â†’\n    I âŠ“ J = I * J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I âŠ” J = âŠ¤ â†’ I * J = I âŠ“ J ", "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I âŠ” J = âŠ¤ â†’ I * J = I âŠ“ J "]}
{"docString": "If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.", "prompts": "[{\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ b â†’ (a âˆ£ b + c â†” a âˆ£ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\\nelement `c` iff `a` divides `c`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ c â†’ (a âˆ£ b + c â†” a âˆ£ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\\n`b` with `c` iff `a` divides `b`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ b â†’ (a âˆ£ b - c â†” a âˆ£ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `b` in a ring, `a` divides the difference of `b` and\\nanother element `c` iff `a` divides `c`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ c â†’ (a âˆ£ b - c â†” a âˆ£ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `c` in a ring, `a` divides the difference of another\\nelement `b` with `c` iff `a` divides `b`. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a b : Î±}, a âˆ£ b + a â†” a âˆ£ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum b + a if and only if a divides b.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a b : Î±}, a âˆ£ a + b â†” a âˆ£ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum a + b if and only if a divides b.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"}]\n", "prompt_cons": "/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0 :=\n\n/-- If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\nelement `c` iff `a` divides `c`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ b â†’ (a âˆ£ b + c â†” a âˆ£ c) :=\n\n/-- If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\n`b` with `c` iff `a` divides `b`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ c â†’ (a âˆ£ b + c â†” a âˆ£ b) :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- If an element `a` divides another element `b` in a ring, `a` divides the difference of `b` and\nanother element `c` iff `a` divides `c`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ b â†’ (a âˆ£ b - c â†” a âˆ£ c) :=\n\n/-- If an element `a` divides another element `c` in a ring, `a` divides the difference of another\nelement `b` with `c` iff `a` divides `b`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NonUnitalRing Î±] {a b c : Î±}, a âˆ£ c â†’ (a âˆ£ b - c â†” a âˆ£ b) :=\n\n/-- An element a divides the sum b + a if and only if a divides b. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a b : Î±}, a âˆ£ b + a â†” a âˆ£ b :=\n\n/-- An element a divides the sum a + b if and only if a divides b. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a b : Î±}, a âˆ£ a + b â†” a âˆ£ b :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$. -/\ntheorem", "choices": ["âˆ€ {a b : â„¤}, a.int_divides b â†’ a âˆ£ b ", "âˆ€ {a b : â„¤}, a âˆ£ b â†’ âˆƒ (c : â„¤), b = a * c ", "âˆ€ {a b : â„¤}, (â„¤[i].norm a âˆ£ â„¤[i].norm b) â†’ (a âˆ£ b) ", "âˆ€ {a b : â„¤}, GaussianInt.gcd a b âˆ£ a â†’ a âˆ£ b ", "âˆ€ {a b : â„¤}, a âˆ£ b â†’ (a : GaussianInt) âˆ£ b â†’ a âˆ£ b ", "âˆ€ {a b : â„¤}, a âˆ£ b â†’ (a âˆ£ b) ", "âˆ€ {a b : â„¤}, (â„¤[i].coe a) âˆ£ (â„¤[i].coe b) â†’ a âˆ£ b ", "âˆ€ {a b : â„¤}, a âˆ£ b â†’ (a âˆ£ b : Prop) ", "forall {a b : â„¤} {k : â„¤}, a * k = b â†’ (a âˆ£ b) ", "âˆ€ {a b : â„¤}, (GaussianInt.of_int a) âˆ£ (GaussianInt.of_int b) â†’ a âˆ£ b "]}
{"docString": "Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$. -/\ntheorem", "choices": ["irreducible_x_pow2_plus_x_plus_1_in_F2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "Irreducible_x_square_x_add_one_f2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "x_pow_two_add_x_add_one_irreducible : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "irreducible_X_pow_add_one_of_char_two : âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†’ Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1) ", "irreducible_X_pow_add_add_one {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] (h : ringChar F = 2) : Irreducible (X ^ 2 + X + 1 : Polynomial F) ", "x_pow_2_plus_x_plus_1_irreducible : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "x_pow_two_plus_x_plus_one_irreducible : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "Irreducible_x_squared_plus_x_plus_one : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "Irreducible_X_pow_two_add_X_add_one : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "x_pow2_plus_x_plus1_irred : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) "]}
{"docString": "Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$. -/\ntheorem", "choices": ["irreducible_x_pow_sub_C {F : Type u_1} [Field F] (x : F) {p : â„•} [CharP F p] (hp : Fact (Nat.Prime p))\n  (n : â„•) (hn : n % p â‰  0) : Irreducible (Polynomial.x ^ 3 - coeFn Polynomial.c 9) ", "irreducible_x_pow_minus_9_in_F_31 : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "irreducible_x_pow_sub_nine : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "x_pow_3_minus_9_irreducible_in_F_31 : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "x_pow_three_minus_nine_irreducible : Irreducible (Polynomial.x ^ 3 - coe 9 : Polynomial (Zmod 31)) ", "x_pow_3_minus_9_irreducible : Irreducible (Polynomial.map (Int.castRingHom (GaloisField 31)) (Polynomial.x ^ 3 - 9)) ", "irreducible_x_pow_sub_9_in_F31 : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "irreducible_pow_minus_const {k : â„•} [Field K] {x : K} (hx : x â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)] (Hfield : DiscreteField (Zmod p)) (hpx : coeFn (RingHom.map (Zmod.castRingHom (Zmod p)) (algebraMap (Zmod 1) (Zmod p))) x â‰  0) (hp_odd : p % 2 = 1) : Irreducible (Polynomial.x ^ 3 - coeFn Polynomial.c (9 : K)) ", "irreducible_x_pow_sub_nine : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "x_pow_3_minus_9_irreducible : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) "]}
{"docString": "Prove that there are infinitely many primes congruent to $-1$ (modulo $4$).", "prompts": "[{\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"}]\n", "prompt_cons": "/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1 :=\n\n/-- Prove that there are infinitely many primes congruent to $-1$ (modulo $4$). -/\ntheorem", "choices": ["âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 4]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ", "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} "]}
{"docString": "Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, v âˆˆ K â†’ â†‘(reflection Ká—®) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `Ká—®` of an element of `K` is its negation. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : IsLeftCancelMulZero Mâ‚€] {a b c : Mâ‚€},\\n  a â‰  0 â†’ a * b = a * c â†’ b = c\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by a nonzero element is left cancellative. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, v âˆˆ Ká—® â†’ â†‘(reflection K) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `K` of an element of `Ká—®` is its negation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : IsRightCancelMulZero Mâ‚€] {a b c : Mâ‚€},\\n  b â‰  0 â†’ a * b = c * b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicatin by a nonzero element is right cancellative. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection Ká—®] {v : E}, v âˆˆ K â†’ â†‘(orthogonalProjection Ká—®) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `Ká—®` of an element of `K` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Algebraically closed fields are infinite since `Xâ¿âºÂ¹ - 1` is separable when `#K = n` \"}]\n", "prompt_cons": "/-- The reflection in `Ká—®` of an element of `K` is its negation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, v âˆˆ K â†’ â†‘(reflection Ká—®) v = -v :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Multiplication by a nonzero element is left cancellative. -/\ntheorem âˆ€ {Mâ‚€ : Type u} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : IsLeftCancelMulZero Mâ‚€] {a b c : Mâ‚€},\n  a â‰  0 â†’ a * b = a * c â†’ b = c :=\n\n/-- The reflection in `K` of an element of `Ká—®` is its negation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, v âˆˆ Ká—® â†’ â†‘(reflection K) v = -v :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- Multiplicatin by a nonzero element is right cancellative. -/\ntheorem âˆ€ {Mâ‚€ : Type u} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : IsRightCancelMulZero Mâ‚€] {a b c : Mâ‚€},\n  b â‰  0 â†’ a * b = c * b â†’ a = c :=\n\n/-- The orthogonal projection onto `Ká—®` of an element of `K` is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection Ká—®] {v : E}, v âˆˆ K â†’ â†‘(orthogonalProjection Ká—®) v = 0 :=\n\n/-- Algebraically closed fields are infinite since `Xâ¿âºÂ¹ - 1` is separable when `#K = n` -/\ntheorem âˆ€ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K :=\n\n/-- Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$. -/\ntheorem", "choices": ["âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [_inst_2 : Invertible (1 : K)], âˆá¶  (x : K) (hx : x â‰  0), x = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : IsFiniteField K],\n  âˆá¶  (x : K) (_ : x â‰  0), x = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : IsFiniteField K], (âˆá¶  (x : K) (_ : x â‰  0), x) = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (-1 : K)], âˆá¶  (x : K), x â‰  0, x = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Nontrivial K], âˆá¶  (x : K) (hx : x â‰  0), x = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [Fintype K] [is_nonempty : Nonempty K], âˆá¶  (x : K), if x = 0 then 1 else x = -1 ", "âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1 : K)], (âˆá¶  (x : K), x) = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst : Fintype K] [inst_1 : Invertible (1 : K)], âˆá¶  (x : K) (_ : x â‰  0), x = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1 - â†‘(Fintype.card K))],\n  âˆá¶  (x : K) (hx : x â‰  0), x = -1 ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1:K)], Fintype.card K âˆ£ (Fintype.card K - 1) â†’\n  âˆá¶  (x : K) (_ : x â‰  0), x = -1 "]}
{"docString": "Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PartialOrder Î±] {f : Î² â†’ Î² â†’ Î±},\\n  (âˆ€ (a b : Î²), f a b â‰¤ f b a) â†’ âˆ€ (a b : Î²), f a b = f b a\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove commutativity of a binary operation `â—‹`, we only to check `a â—‹ b â‰¤ b â—‹ a` for all `a`,\\n`b`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : GeneralizedBooleanAlgebra Î±] (a b : Î±), a âŠ“ b âŠ“ a \\\\ b = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"For any `a`, `b`, `(a âŠ“ b) âŠ“ (a / b) = âŠ¥` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Monoid R] [inst_1 : NonUnitalNonAssocSemiring A]\\n  [inst_2 : DistribMulAction R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B]\\n  [inst_5 : DistribMulAction R B] [inst_6 : Star B] (self : A â†’â‹†â‚™â‚[R] B) (a : A),\\n  MulActionHom.toFun self.toMulActionHom (star a) = star (MulActionHom.toFun self.toMulActionHom a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a non-unital â‹†-algebra homomorphism preserves the `star` operation. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {b : â„•}, jacobiSym a b = -1 â†’ Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"If `J(a | b)` is `-1`, then `a` is not a square modulo `b`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {l m n : â„•} {Î± : Type u_1} [inst : Mul Î±] [inst_1 : AddCommMonoid Î±] (A : Matrix (Fin l) (Fin m) Î±)\\n  (B : Matrix (Fin m) (Fin n) Î±), Matrix.muláµ£ A B = Matrix.mul A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"This can be used to prove\\n```lean\\nexample [AddCommMonoid Î±] [Mul Î±] (aâ‚â‚ aâ‚â‚‚ aâ‚‚â‚ aâ‚‚â‚‚ bâ‚â‚ bâ‚â‚‚ bâ‚‚â‚ bâ‚‚â‚‚ : Î±) :\\n  !![aâ‚â‚, aâ‚â‚‚;\\n     aâ‚‚â‚, aâ‚‚â‚‚] â¬ !![bâ‚â‚, bâ‚â‚‚;\\n                    bâ‚‚â‚, bâ‚‚â‚‚] =\\n  !![aâ‚â‚*bâ‚â‚ + aâ‚â‚‚*bâ‚‚â‚, aâ‚â‚*bâ‚â‚‚ + aâ‚â‚‚*bâ‚‚â‚‚;\\n     aâ‚‚â‚*bâ‚â‚ + aâ‚‚â‚‚*bâ‚‚â‚, aâ‚‚â‚*bâ‚â‚‚ + aâ‚‚â‚‚*bâ‚‚â‚‚] :=\\n(muláµ£_eq _ _).symm\\n```\\n\"}]\n", "prompt_cons": "/-- To prove commutativity of a binary operation `â—‹`, we only to check `a â—‹ b â‰¤ b â—‹ a` for all `a`,\n`b`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PartialOrder Î±] {f : Î² â†’ Î² â†’ Î±},\n  (âˆ€ (a b : Î²), f a b â‰¤ f b a) â†’ âˆ€ (a b : Î²), f a b = f b a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- For any `a`, `b`, `(a âŠ“ b) âŠ“ (a / b) = âŠ¥` -/\ntheorem âˆ€ {Î± : Type u} [self : GeneralizedBooleanAlgebra Î±] (a b : Î±), a âŠ“ b âŠ“ a \\ b = âŠ¥ :=\n\n/-- Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- By definition, a non-unital â‹†-algebra homomorphism preserves the `star` operation. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Monoid R] [inst_1 : NonUnitalNonAssocSemiring A]\n  [inst_2 : DistribMulAction R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B]\n  [inst_5 : DistribMulAction R B] [inst_6 : Star B] (self : A â†’â‹†â‚™â‚[R] B) (a : A),\n  MulActionHom.toFun self.toMulActionHom (star a) = star (MulActionHom.toFun self.toMulActionHom a) :=\n\n/-- If `J(a | b)` is `-1`, then `a` is not a square modulo `b`. -/\ntheorem âˆ€ {a : â„¤} {b : â„•}, jacobiSym a b = -1 â†’ Â¬IsSquare â†‘a :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- This can be used to prove\n```lean\nexample [AddCommMonoid Î±] [Mul Î±] (aâ‚â‚ aâ‚â‚‚ aâ‚‚â‚ aâ‚‚â‚‚ bâ‚â‚ bâ‚â‚‚ bâ‚‚â‚ bâ‚‚â‚‚ : Î±) :\n  !![aâ‚â‚, aâ‚â‚‚;\n     aâ‚‚â‚, aâ‚‚â‚‚] â¬ !![bâ‚â‚, bâ‚â‚‚;\n                    bâ‚‚â‚, bâ‚‚â‚‚] =\n  !![aâ‚â‚*bâ‚â‚ + aâ‚â‚‚*bâ‚‚â‚, aâ‚â‚*bâ‚â‚‚ + aâ‚â‚‚*bâ‚‚â‚‚;\n     aâ‚‚â‚*bâ‚â‚ + aâ‚‚â‚‚*bâ‚‚â‚, aâ‚‚â‚*bâ‚â‚‚ + aâ‚‚â‚‚*bâ‚‚â‚‚] :=\n(muláµ£_eq _ _).symm\n``` -/\ntheorem âˆ€ {l m n : â„•} {Î± : Type u_1} [inst : Mul Î±] [inst_1 : AddCommMonoid Î±] (A : Matrix (Fin l) (Fin m) Î±)\n  (B : Matrix (Fin m) (Fin n) Î±), Matrix.muláµ£ A B = Matrix.mul A B :=\n\n/-- Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative. -/\ntheorem", "choices": ["âˆ€ {a b : â„¤}, a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) ", "âˆ€ {a b : â„¤}, a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) ", "âˆ€ (a b : â„¤), a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) ", "âˆ€ (a b : â„¤), a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) ", "âˆ€ (a b : â„¤), a - b â‰  b - a ", "âˆ€ {a b : â„¤}, a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) ", "âˆ€ (a b : â„¤), a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) ", "âˆ€ (a b : â„¤), a - b â‰  b - a ", "Â¬âˆ€ (a b : â„¤), a - b = b - a ", "âˆ€ (a b : â„¤), a - b â‰  b - a â†’ Â¬(âˆ€ (a b : â„¤), a - b = b - a) "]}
{"docString": "Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : NonUnitalSemiring Î±] (a b c : Î±), a * b * c = a * (b * c)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is associative \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w * y) (x * z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\\n  â†‘f (a * b) = â†‘f a * â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddCommMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"}]\n", "prompt_cons": "/-- Multiplication is associative -/\ntheorem âˆ€ {Î± : Type u} [self : NonUnitalSemiring Î±] (a b c : Î±), a * b * c = a * (b * c) :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y :=\n\n/-- Multiplicative congruence relations preserve multiplication. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w * y) (x * z) :=\n\n/-- Multiplication is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x :=\n\n/-- Ring homomorphisms preserve multiplication. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\n  â†‘f (a * b) = â†‘f a * â†‘f b :=\n\n/-- Multiplication is commutative -/\ntheorem âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddCommMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative. -/\ntheorem", "choices": ["âˆ€ {n : â„•} [self : CommRing (Zmod n)] (a b c : Zmod n), a * b * c = a * (b * c) ", "âˆ€ {n : â„•} [inst : Fact (0 < n)] (a b c : Zmod n), a * b * c = a * (b * c) ", "âˆ€ {n : â„•} (a b c : Zmod n), a * b * c = a * (b * c) ", "âˆ€ {n : â„•} {a b c : Zmod n}, a * b * c = a * (b * c) ", "âˆ€ {n : â„•} [self : CommRing (Zmod n)] (a b c : Zmod n), a * b * c = a * (b * c) ", "âˆ€ {n : â„•} (a b c : Zmod n), (a * b) * c = a * (b * c) ", "âˆ€ {n : â„•} (a b c : Zmod n), a * b * c = a * (b * c) ", "âˆ€ {n : â„•} (a b c : Zmod n), a * b * c = a * (b * c) ", "forall {n : â„•} [self : Nat.AddCommGroup n] (a b c : Zmod n), a * b * c = a * (b * c) ", "forall {n : â„•} (a b c : Zmod n), a * b * c = a * (b * c) "]}
{"docString": "Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) â†’ G) (j : Fin (n + 1)) (k : Fin n),\\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))â»Â¹ *\\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\\n    Fin.contractNth j (fun x x_1 => x * x_1) g k\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `(gâ‚€, gâ‚, ..., gâ‚™)` be a tuple of elements in `Gâ¿âºÂ¹`.\\nThen if `k < j`, this says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚– = gâ‚–`.\\nIf `k = j`, it says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–gâ‚–â‚Šâ‚`.\\nIf `k > j`, it says `(gâ‚€gâ‚...gâ‚–)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–â‚Šâ‚.`\\nUseful for defining group cohomology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [self : DivisionRing K] (a : K), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"For a nonzero `a`, `aâ»Â¹` is a right multiplicative inverse. \"}]\n", "prompt_cons": "/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Let `(gâ‚€, gâ‚, ..., gâ‚™)` be a tuple of elements in `Gâ¿âºÂ¹`.\nThen if `k < j`, this says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚– = gâ‚–`.\nIf `k = j`, it says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–gâ‚–â‚Šâ‚`.\nIf `k > j`, it says `(gâ‚€gâ‚...gâ‚–)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–â‚Šâ‚.`\nUseful for defining group cohomology. -/\ntheorem âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) â†’ G) (j : Fin (n + 1)) (k : Fin n),\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))â»Â¹ *\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\n    Fin.contractNth j (fun x x_1 => x * x_1) g k :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹ :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- For a nonzero `a`, `aâ»Â¹` is a right multiplicative inverse. -/\ntheorem âˆ€ {K : Type u} [self : DivisionRing K] (a : K), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {n : â„•} (a : Finâ‚“ n â†’ G),\n  List.prod (List.map (a âˆ˜ id) (Finâ‚“.range n))â»Â¹ = List.prod (List.reverse (List.map (fun i => (a i)â»Â¹) (Finâ‚“.range n))) ", "âˆ€ {Î± : Type u} [inst : Group Î±] (n : â„•) (a : Vector Î± n),\n  List.prod (Vector.toList a)â»Â¹ = List.prod (List.reverse (List.map (Î» x : Î±, xâ»Â¹) (Vector.toList a))) ", "âˆ€ {Î± : Type u} [self : Group Î±] (l : List Î±),\n  (List.prod l)â»Â¹ = List.prod (List.map (fun a => aâ»Â¹) (List.reverse l)) ", "âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] (a : Fin (n + 1) â†’ G),\n  ((Fin.partialProd a (Fin.last n))â»Â¹ = Fin.partialProd (Î» i, a iâ»Â¹) (Fin.last n)) ", "forall {n : â„•} {G : Type u_1} [inst : Group G] (a : Fin n â†’ G),\n  (Fin.partialProd a n)â»Â¹ = Fin.partialProd (fun i => (a i)â»Â¹) n ", "âˆ€ {G : Type u_1} [inst : Group G] (n : â„•) (a : Fin n â†’ G),\n  (Fin.partialProd a n)â»Â¹ = Fin.partialProd (Î» i, (a i)â»Â¹) (Fin.reverse n) ", "âˆ€ {Î± : Type u} [inst : Group Î±] (l : List Î±),\n  List.prod lâ»Â¹ = List.prod (List.map (Î» (a : Î±), aâ»Â¹) (List.reverse l)) ", "âˆ€ {G : Type u} [inst : Group G] {n : â„•} (a : Vector G n),\n  Vector.prod (Vector.reverse (Vector.map (Î» x, xâ»Â¹) a)) = (Vector.prod a)â»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {n : â„•} (a : Fin n â†’ G),\n  (Fin.partialProd a n)â»Â¹ = Fin.partialProd (Î» i, (a i)â»Â¹) n ", "âˆ€ {G : Type u_1} [inst : Group G] (n : â„•) (a : Fin n â†’ G),\n  (Fin.prod a)â»Â¹ = Fin.prod (fun i => a (Fin.orderIsoNats n).symm i)â»Â¹ "]}
{"docString": "Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x â‰  0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {x : M} (m : â„•) {n : â„•}, x ^ n = 1 â†’ x ^ m = x ^ (m % n)\",\n  \"isProp\": true,\n  \"docString\": \"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (Ï‡ : MulChar R R') {n : â„•},\\n  0 < n â†’ âˆ€ (a : R), â†‘(Ï‡ ^ n) a = â†‘Ï‡ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(Ï‡ ^ n) a = (Ï‡ a) ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 â†’ IsLeftRegular a\",\n  \"isProp\": true,\n  \"docString\": \"An element admitting a left inverse is left-regular. \"}]\n", "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- By definition, if `x` is invertible then `inverse x = xâ»Â¹`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹ :=\n\n/-- If `n * x = 0`, but `n/p * x â‰  0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n :=\n\n/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {x : M} (m : â„•) {n : â„•}, x ^ n = 1 â†’ x ^ m = x ^ (m % n) :=\n\n/-- If `n` is positive, then `(Ï‡ ^ n) a = (Ï‡ a) ^ n`. -/\ntheorem âˆ€ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (Ï‡ : MulChar R R') {n : â„•},\n  0 < n â†’ âˆ€ (a : R), â†‘(Ï‡ ^ n) a = â†‘Ï‡ a ^ n :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- An element admitting a left inverse is left-regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 â†’ IsLeftRegular a :=\n\n/-- Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$. -/\ntheorem", "choices": ["forall {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "forall {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "forall {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ xâ»Â¹ = x ^ (n - 1) "]}
{"docString": "For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x â‰  0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x :=\n\n/-- If `n * x = 0`, but `n/p * x â‰  0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n :=\n\n/-- By definition, if `x` is invertible then `inverse x = xâ»Â¹`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹ :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf xâ»Â¹ "]}
{"docString": "Deduce that $|a b|=|b a|$ for all $a, b \\in G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\": \"âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\": \"âˆ€ (a : â„¤) (b e : â„•), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_3} [inst : CategoryTheory.Category C] {D : Type u_4} [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\\n  CategoryTheory.CoverPreserving (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G\",\n  \"isProp\": true,\n  \"docString\": \"`G` is cover-preserving wrt the induced topology. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. \"}]\n", "prompt_cons": "/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (e b : â„•), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem âˆ€ (a : â„¤) (b e : â„•), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- `G` is cover-preserving wrt the induced topology. -/\ntheorem âˆ€ {C : Type u_3} [inst : CategoryTheory.Category C] {D : Type u_4} [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.CoverPreserving (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb :=\n\n/-- Deduce that $|a b|=|b a|$ for all $a, b \\in G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_6} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "forall {G : Type u} [inst : Group G] (a b : G), abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) "]}
{"docString": "Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"}]\n", "prompt_cons": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian. -/\ntheorem", "choices": ["âˆ€ {A : Type u_1} [inst_1 : AddGroup A] {B : Type u_2} [inst_2 : AddGroup B],\n  (AddGroup.IsAbelian (A Ã— B)) â†” (AddGroup.IsAbelian A) âˆ§ (AddGroup.IsAbelian B) ", "âˆ€ {A B : Type u} [instA : AddGroup A] [instB : AddGroup B],\n  AddCommGroup A â†’ AddCommGroup B â†’ AddCommGroup (A Ã— B) ", "âˆ€ {A : Type u_1} [inst : AddGroup A] {B : Type u_2} [inst_1 : AddGroup B],\n  AddCommGroup (A Ã— B) â†” AddCommGroup A âˆ§ AddCommGroup B ", "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommGroup A] [inst_1 : CommGroup B],\n  CommGroup (A Ã— B) â†” (CommGroup A âˆ§ CommGroup B) ", "For all {A : Type u_1} [inst_A : AddGroup A] {B : Type u_2} [inst_B : AddGroup B],\n  AddGroup (A Ã— B) â†” AddGroup A âˆ§ AddGroup B ", "âˆ€ {A B : Type u} [inst : AddGroup A] [inst_1 : AddGroup B], AddCommGroup A â†’ AddCommGroup B â†’ AddCommGroup (A Ã— B) ", "âˆ€ {A B : Type u_1} [inst : CommGroup A] [inst_1 : CommGroup B], CommGroup (A Ã— B) ", "âˆ€ {A : Type u_1} [inst : AddCommGroup A] {B : Type u_2} [inst_1 : AddCommGroup B],\n  AddCommGroup (A Ã— B) â†” AddCommGroup A âˆ§ AddCommGroup B ", "âˆ€ {A : Type u_1} [inst : AddGroup A] {B : Type u_2} [inst_1 : AddGroup B],\n  AddCommGroup (A Ã— B) â†” AddCommGroup A âˆ§ AddCommGroup B ", "âˆ€ {A B : Type u_1} [instA : CommGroup A] [instB : CommGroup B], CommGroup (A Ã— B) â†” (CommGroup A âˆ§ CommGroup B) "]}
{"docString": "Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {a : Î±} {p : Î± â†’ Prop} {h : Â¬a âˆˆ s},\\n  (âˆ€ (x : Î±), x âˆˆ Finset.cons a s h â†’ p x) â†’ âˆ€ (x : Î±), x âˆˆ s â†’ p x\",\n  \"isProp\": true,\n  \"docString\": \"Useful in proofs by induction. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"}]\n", "prompt_cons": "/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- Useful in proofs by induction. -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {a : Î±} {p : Î± â†’ Prop} {h : Â¬a âˆˆ s},\n  (âˆ€ (x : Î±), x âˆˆ Finset.cons a s h â†’ p x) â†’ âˆ€ (x : Î±), x âˆˆ s â†’ p x :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G :=\n\n/-- Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Infinite Î±] [inst_2 : Fintype (Sym Î±)], False ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] {h : Nonempty (Î± â‰ƒ â„•)}, Group.Infinite (Permutations Î±) ", "âˆ€ {Î± : Type u} (hÎ± : Infinite Î±), Infinite (perm Î±) ", "âˆ€ {Î± : Type u_1} [inst : Infinite Î±] [inst_1 : Fintype (Equiv.Perm Î±)], Infinite (Equiv.Perm Î±) ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] {Ï‰ : â„•}, Fintype.card Î± = Ï‰ â†’ Â¬Group.Finite (Sym (Finset.range Ï‰)) ", "âˆ€ {Î± : Type u} [inst : Group Î±] (hÎ± : Infinite Î±) [inst_1 : Fintype Î±], Infinite (Sym.Group Î±) ", "âˆ€ {Î± : Type u} [inst : Group (Permutation Î±)] [h : â„• â†’ Î±],\n  (âˆ€ (x : â„•), h x â‰  h (x + 1)) â†’ Â¬Monoid.FG (Permutation Î±) ", "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Infinite Î±],\n  Infinite (Permutation Î±) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] [inst_1 : Infinite Î±], Infinite (Equiv.perm Î±) ", "âˆ€ {Î± : Type u} [inst : Group (Permutation Î±)] [inst_1 : Infinite Î±], Infinite (Permutation Î±) "]}
{"docString": "Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$. -/\ntheorem", "choices": ["âˆ€ {A : Type u} [inst : Group A] {B : Type v} [inst_1 : Group B],\n  IsGroupHom (Î» (p : A Ã— B), (p.snd, p.fst)) ", "âˆ€ {A : Type u_1} [inst : Group A] {B : Type u_2} [inst_1 : Group B],\n  GroupEquiv.prodComm A B â‰ˆ GroupEquiv.prodComm B A ", "âˆ€ {A : Type u_1} [inst : Group A] {B : Type u_2} [inst_1 : Group B],\n  GroupEquiv (A Ã— B) (B Ã— A) ", "âˆ€ {A B : Type u_1} [inst_A : Group A] [inst_B : Group B],\n  GroupEquiv (A Ã— B) (B Ã— A) ", "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem commute.symm {S : Type u_1} [Mul S] {a b : S} (h : Commute a b) : Commute b a ", "âˆ€ {A : Type u} [inst : Group A] {B : Type v} [inst_1 : Group B],\n  GroupEquiv (A Ã— B) (B Ã— A) ", "forall {A : Type u_1} [instA : Group A] {B : Type u_2} [instB : Group B],\n  Group.IsGroupIso (Prod.swap : A Ã— B â†’ B Ã— A) ", "âˆ€ {A : Type u_1} [inst_A : Group A] {B : Type u_2} [inst_B : Group B],\n  Group.Isomorphic (A Ã— B) (B Ã— A) ", "âˆ€ {A B : Type u_1} [inst : Group A] [inst_1 : Group B],\n  âˆƒ (Ï† : A Ã— B â‰ƒ* B Ã— A), True ", "âˆ€ {A : Type u_1} [inst : Group A] {B : Type u_2} [inst_1 : Group B],\n  Group.Isomorph A Prod B (Î» a b, (b, a)) "]}
{"docString": "Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian.", "prompts": "[{\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun Î± G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : AddGroup G] [inst_1 : UniformSpace G] [inst_2 : UniformAddGroup G],\\n  UniformAddGroup (UniformFun Î± G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform additive group,\\nthen `Î± â†’áµ¤ G` is a uniform additive group as well.\"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4}\\n  [inst_3 : (i : Î¹) â†’ NormedAddCommGroup (G i)] [inst_4 : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)]\\n  {V : (i : Î¹) â†’ G i â†’â‚—áµ¢[ğ•œ] E} (self : IsHilbertSum ğ•œ G V),\\n  Function.Surjective â†‘(OrthogonalFamily.linearIsometry (_ : OrthogonalFamily ğ•œ G V))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The isometry `lp G 2 â†’ E` induced by the orthogonal family is surjective. \"}]\n", "prompt_cons": "/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun Î± G) :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ f 1 = 1 :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- If `G` is a uniform additive group,\nthen `Î± â†’áµ¤ G` is a uniform additive group as well. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : AddGroup G] [inst_1 : UniformSpace G] [inst_2 : UniformAddGroup G],\n  UniformAddGroup (UniformFun Î± G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- The isometry `lp G 2 â†’ E` induced by the orthogonal family is surjective. -/\ntheorem âˆ€ {Î¹ : Type u_1} {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4}\n  [inst_3 : (i : Î¹) â†’ NormedAddCommGroup (G i)] [inst_4 : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)]\n  {V : (i : Î¹) â†’ G i â†’â‚—áµ¢[ğ•œ] E} (self : IsHilbertSum ğ•œ G V),\n  Function.Surjective â†‘(OrthogonalFamily.linearIsometry (_ : OrthogonalFamily ğ•œ G V)) :=\n\n/-- Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], âˆ€ {Ïƒ : Equiv.Perm G},\n  (âˆ€ g : G, Ïƒ g = g â†” g = 1) â†’ (âˆ€ g : G, Ïƒ (Ïƒ g) = g) â†’ CommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆ€ g : G, âˆƒ Ïƒ : Aut G, Ïƒ.to_fun = Ïƒ.inv_fun âˆ§ (âˆ€ h : G, Ïƒ.to_fun h = h â†” h = 1) âˆ§\n    (âˆ€ h : G, (Ïƒ * Ïƒ).to_fun h = h)) â†’ IsCommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : G â†’* G},\n  (âˆ€ (g : G), â‡‘Ïƒ g = g â†’ g = 1) â†’ (âˆ€ (g : G), â‡‘(Ïƒ * Ïƒ) g = g) â†’ IsCommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : G â‰ƒ* G},\n  (âˆ€ g : G, Ïƒ g = g â†” g = 1) â†’ Ïƒ.to_equiv.trans Ïƒ.to_equiv = Equiv.refl G â†’ IsCommutative G ", "âˆ€ {G : Type u_1} [inst : Fintype G] [inst_1 : Group G] (Ïƒ : Aut G),\n  (âˆ€ g : G, Ïƒ.to_fun g = g â†” g = 1) â†’ Ïƒ.to_fun^2 = id â†’ CommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : Aut G},\n  (âˆ€ (g : G), Ïƒ.to_fun g = g â†” g = 1) â†’ Ïƒ.to_fun âˆ˜ Ïƒ.to_fun = id â†’ CommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : Aut G}, (âˆ€ g : G, g â‰  1 â†’ Ïƒ g â‰  g) â†’ (Ïƒ * Ïƒ) = Aut.id â†’ CommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : G â‰ƒ* G},\n  (âˆ€ (g : G), Ïƒ g = g â†” g = 1) â†’ (Ïƒ * Ïƒ).to_equiv = Equiv.refl G â†’ CommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : G â†’* G},\n  (âˆ€ g : G, Ïƒ g = g â†” g = 1) â†’ Ïƒ * Ïƒ = MonoidHom.id G â†’ IsCommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {Ïƒ : G â‰ƒ* G},\n  (âˆ€ g : G, Ïƒ g = g â†” g = 1) â†’ Ïƒ * Ïƒ = 1 â†’ âˆ€ a b : G, a * b = b * a "]}
{"docString": "Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an additive subgroup gives a singleton then the additive subgroup\\nis the whole additive group.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R), 0 âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"An additive submonoid contains `0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²}, IsAddGroupHom f â†’ f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"}]\n", "prompt_cons": "/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group. -/\ntheorem âˆ€ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- An additive submonoid contains `0`. -/\ntheorem âˆ€ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R), 0 âˆˆ self.carrier :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²}, IsAddGroupHom f â†’ f 0 = 0 :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0 :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$. -/\ntheorem", "choices": ["âˆ€ {H : AddSubgroup â„š}, (âˆ€ x : â„š, x â‰  0 â†’ x âˆˆ H â†’ 1 / x âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ (H : AddSubgroup â„š), (âˆ€ x, x â‰  0 â†’ x âˆˆ H â†’ (1 / x) âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ {H : AddSubgroup â„š}, (âˆ€ x : â„š, x â‰  0 â†’ xâ»Â¹ âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "forall (H : AddSubgroup Q), (âˆ€ x âˆˆ H, x â‰  0 â†’ (1 / x) âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ {H : AddSubgroup â„š}, (âˆ€ x : â„š, x â‰  0 â†’ xâ»Â¹ âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "forall {H : AddSubgroup â„š}, (âˆ€ x â‰  0, x âˆˆ H.carrier â†’ (1 / x) âˆˆ H.carrier) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ {H : AddSubgroup â„š},\n  (âˆ€ x : â„š, x â‰  0 â†’ x âˆˆ H â†’ 1 / x âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ {self : IsGroupHom â„š â„š} (H : AddSubgroup â„š) (hp : âˆ€ (x : â„š), x â‰  0 â†’ x âˆˆ H â†’ (1 / x) âˆˆ H), H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ (H : AddSubgroup â„š), (âˆ€ x âˆˆ H, x â‰  0 â†’ 1 / x âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ ", "âˆ€ {H : AddSubgroup â„š}, (âˆ€ x âˆˆ H, x â‰  0 â†’ 1 / x âˆˆ H) â†’ H = âŠ¥ âˆ¨ H = âŠ¤ "]}
{"docString": "A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"}]\n", "prompt_cons": "/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1 :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0 :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H â‰  âŠ¤ â†’ âˆƒ M, H â‰¤ M âˆ§ IsCoatom M ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H â‰  âŠ¤ â†’ âˆƒ M : Subgroup G, H â‰¤ M âˆ§ âˆ€ (N : Subgroup G), M â‰¤ N â†’ N = M âˆ¨ N = âŠ¤ ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H â‰  âŠ¤ â†’ âˆƒ M, H â‰¤ M âˆ§ IsCoatom M ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H âŠ† G.toSubgroup â†’ H â‰  G.toSubgroup â†’ âˆƒ M, Subgroup.IsMaximal M âˆ§ H â‰¤ M ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H < âŠ¤ â†’ âˆƒ M, H â‰¤ M âˆ§ IsCoatom M ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H â‰  âŠ¤ â†’ âˆƒ M, H â‰¤ M âˆ§ IsCoatom M ", "âˆ€ {G : Type u} [_inst_1 : Group G] [_inst_2 : Fintype G] {H : Subgroup G},\n  H < âŠ¤ â†’ âˆƒ M, H â‰¤ M âˆ§ IsCoatom M ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G),\n  H < âŠ¤ â†’ âˆƒ M, H â‰¤ M âˆ§ M < âŠ¤ âˆ§ âˆ€ (K : Subgroup G), H â‰¤ K â†’ K â‰¤ M â†’ K = H âˆ¨ K = M ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H â‰  âŠ¤ â†’ âˆƒ M : Subgroup G, H â‰¤ M âˆ§ IsCoatom M ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G) (hH : H â‰  âŠ¤),\n  âˆƒ M : Subgroup G, H â‰¤ M âˆ§ IsCoatom M "]}
{"docString": "Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (x : G) {n : â„•},\n  1 â‰¤ n â†’ orderOf x = n â†’\n    âˆ€ (H : Subgroup G), IsCoatom H â†” âˆƒ p [_hp : Fact (Nat.Prime p)], p âˆ£ n âˆ§ Subgroup.zpowers x ^ p = H ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•},\n  0 < n â†’ orderOf x = n â†’ IsCyclic G â†’\n  âˆ€ (H : Subgroup G), IsCoatom H â†” (âˆƒ p [_hp : Fact (Nat.Prime p)], p âˆ£ n âˆ§ H = Subgroup.map (MonoidHom.pow G p) (gpowers x)) ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G} {n : â„•} (hx : IsCyclic G) (hn : Fintype.card G = n) (H : Subgroup G),\n  (âˆƒ p [_hp : Fact (Nat.Prime p)], H = Subgroup.zpowers (x ^ p)) â†” IsCoatom H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•} (hx : IsCyclic G) (hn : Fintype.card G = n) {H : Subgroup G},\n  H.is_maximal â†” âˆƒ p [_hp : Fact (Nat.Prime p)], p âˆ£ n âˆ§ Fintype.card { y // y âˆˆ H } = n / p ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•} (hx : Subgroup.zpowers x = âŠ¤) (hn : 0 < n) (hcard : Fintype.card G = n),\n  âˆ€ {H : Subgroup G}, IsCoatom H â†” (âˆƒ (p : â„•) (hp : Nat.Prime p) (hpx : p âˆ£ n), Subgroup.map (MonoidHom.zpowers x) H = Subgroup.zpowers (x ^ p)) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic G] {x : G} {n : â„•} (hn : orderOf x = n) (H : Subgroup G),\n  n â‰¥ 1 â†’ (IsCoatom H â†” âˆƒ p [inst_2 : Fact (Nat.Prime p)], p âˆ£ n âˆ§ Subgroup.zpowers (x ^ p) = H) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•} {H : Subgroup G},\n  Fintype.card G = n â†’ IsCyclic G â†’ n â‰  0 â†’\n    (âˆƒ p [_hp : Fact (Nat.Prime p)], p âˆ£ n âˆ§ Fintype.card { x // x âˆˆ H } = n / p) â†” IsCoatom H ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•} {H : Subgroup G},\n  Fintype.card G = n â†’ IsCyclic G â†’\n    (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n âˆ§ Fintype.card { y // y âˆˆ H } = n / p) â†” IsCoatom H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•} {H : Subgroup G},\n  1 â‰¤ n â†’ Fintype.card G = n â†’ IsSubgroup.Closure {x} â‰¤ H â†’\n    (IsCoatom H â†” âˆƒ (p : â„•) [hp : Fact (Nat.Prime p)], p âˆ£ n âˆ§ H = Subgroup.mk {g : G | âˆƒ m, g ^ (p * m) = 1} ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : â„•} {H : Subgroup G},\n  0 < n â†’ orderOf x = n â†’ IsCyclic G â†’\n    (âˆƒ K, IsCoatom K âˆ§ H â‰¤ K) â†” (âˆƒ p [_hp : Fact (Nat.Prime p)], p âˆ£ n âˆ§ H = Powers.mk (x ^ p)) "]}
{"docString": "Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"}]\n", "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.Normal K â†’ Subgroup.Normal (H âŠ“ K) ", " âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.Normal K â†’ Subgroup.Normal (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.Normal K â†’ Subgroup.Normal (H âŠ“ K) ", "forall {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Subgroup.Normal H] [inst_2 : Subgroup.Normal K],\n  Subgroup.Normal (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.Normal K â†’ Subgroup.Normal (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Subgroup.Normal H] [inst_2 : Subgroup.Normal K],\n  Subgroup.Normal (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G) [inst_1 : Subgroup.Normal Hâ‚] [inst_2 : Subgroup.Normal Hâ‚‚],\n  Subgroup.Normal (Hâ‚ âŠ“ Hâ‚‚) ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Subgroup.Normal H] [inst_2 : Subgroup.Normal K],\n  Subgroup.Normal (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G) [Subgroup.Normal H] [Subgroup.Normal K],\n  Subgroup.Normal (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.Normal K â†’ Subgroup.Normal (H âŠ“ K) "]}
{"docString": "Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure â†‘K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure â†‘K = K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s) :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ Subgroup.one = Subgroup.inf H K ", "âˆ€ {G : Type u_1} [inst : Group G]\n  (H K : Subgroup G) [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ (H âŠ“ K = âŠ¥) ", "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ H âŠ“ K = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ Subgroup.is_trivial (H âŠ“ K) ", "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ H âŠ“ K = âŠ¥ ", "âˆ€ {G : Type u_2} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ âˆ€ (x : G), x âˆˆ H âˆ© K â†’ x = 1 ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ H âŠ“ K = âŠ¥ ", "forall {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ H âŠ“ K = âŠ¥ ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype { x // x âˆˆ H }] [inst_2 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ H âŠ“ K = âŠ¥ ", "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_2 : Fintype { x // x âˆˆ H }] [inst_3 : Fintype { x // x âˆˆ K }],\n  Nat.coprime (Fintype.card { x // x âˆˆ H }) (Fintype.card { x // x âˆˆ K }) â†’ H âŠ“ K = âŠ¥ "]}
{"docString": "Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  p â‰  2 â†’\\n    â†‘a â‰  0 â†’\\n      legendreSym p a =\\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (â†‘a * â†‘x)) (Finset.Ico 1 (Nat.succ (p / 2))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\\nthan `p/2` such that `(a * x) % p > p / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"}]\n", "prompt_cons": "/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2) :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\nthan `p/2` such that `(a * x) % p > p / 2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  p â‰  2 â†’\n    â†‘a â‰  0 â†’\n      legendreSym p a =\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (â†‘a * â†‘x)) (Finset.Ico 1 (Nat.succ (p / 2)))) :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$. -/\ntheorem", "choices": ["âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "forall {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "fermat_little (p : â„•) [hp : Fact (Nat.Prime p)] (a : â„¤) : a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] ", "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {a : â„¤}, a ^ p â‰¡ a [ZMOD â†‘p] "]}
{"docString": "Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"}]\n", "prompt_cons": "/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H :=\n\n/-- Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$. -/\ntheorem", "choices": ["forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} [Hn : Subgroup.Normal H],\n  Fintype.card (G â§¸ H) = p â†’\n    âˆ€ (K : Subgroup G), K â‰¤ H âˆ¨ (H * K = âŠ¤ âˆ§ Fintype.card (K â§¸ H.subgroup_of K) = p) ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H K : Subgroup G},\n  Subgroup.Normal H â†’ Fintype.card (G â§¸ H) = p â†’ K â‰¤ H âˆ¨ (âˆƒ h : G, H â‹Š[h] K = Subgroup.comap (Subgroup.subtype _) âŠ¤) âˆ§\n    Fintype.card (K â§¸ (K âŠ“ H)) = p ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G} [inst_1 : Subgroup.Normal H] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card (G â§¸ H) = p â†’\n    K â‰¤ H âˆ¨ (âˆƒ h : H Ã— K â‰ƒ G, âˆ€ x âˆˆ K, orderOf (h (1, x)) = orderOf x * p) ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} [inst_2 : Subgroup.Normal H],\n  Subgroup.index H = p â†’\n    âˆ€ (K : Subgroup G), K â‰¤ H âˆ¨ (H * K = âŠ¤ âˆ§ Fintype.card (K â§¸ (H âŠ“ K)) = p) ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H K : Subgroup G},\n  Subgroup.Normal H â†’ Fintype.card (G â§¸ H) = p â†’\n    K â‰¤ H âˆ¨ (Fintype.card (K â§¸ (K âŠ“ H)) = p âˆ§ H âŠ” K = âŠ¤) ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} [inst_2 : Subgroup.Normal H],\n  Fintype.card (G â§¸ H) = p â†’\n    âˆ€ (K : Subgroup G), K â‰¤ H âˆ¨ âˆƒ (h : â„•), Fintype.card (K â§¸ (K âŠ“ H)) = p âˆ§ H * K = âŠ¤ ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} [inst_2 : Subgroup.Normal H],\n  Fintype.card (G â§¸ H) = p â†’\n    âˆ€ (K : Subgroup G), K â‰¤ H âˆ¨ (H * K = âŠ¤ âˆ§ Fintype.card (K â§¸ (K âŠ“ H)) = p) ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Subgroup.Normal H â†’ Nat.card (G â§¸ H) = p â†’\n    âˆ€ {K : Subgroup G},\n      K â‰¤ H âˆ¨ (âˆƒ (J : Subgroup G), Subgroup.IsComplement' H J âˆ§ â‡‘Subgroup.subtype K = â‡‘Subgroup.subtype J) âˆ§\n        Fintype.card (K â§¸ (K âŠ“ H)) = p ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Fintype.card (G â§¸ N) = p â†’\n    âˆ€ (K : Subgroup G), K â‰¤ N âˆ¨ âˆƒ (h : â„•), Fintype.card (K â§¸ (K âŠ“ N)) = p âˆ§ Subgroup.comap (Subgroup.subtype N) K = âŠ¥ ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G}\n  [inst_2 : Subgroup.Normal H] (hH : Fintype.card (G â§¸ H) = p),\n  âˆ€ (K : Subgroup G), K â‰¤ H âˆ¨ (âˆƒ (hG : H âŠ” K = âŠ¤) (hcard : Fintype.card (K â§¸ (K âŠ“ H)) = p), K â‰  H) "]}
{"docString": "Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {a : Î±} {p : Î± â†’ Prop} {h : Â¬a âˆˆ s},\\n  (âˆ€ (x : Î±), x âˆˆ Finset.cons a s h â†’ p x) â†’ âˆ€ (x : Î±), x âˆˆ s â†’ p x\",\n  \"isProp\": true,\n  \"docString\": \"Useful in proofs by induction. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\\n  Nat.card { x // x âˆˆ commutator G } â‰¤ Subgroup.cardCommutatorBound (Nat.card â†‘(commutatorSet G))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\\ncommutators. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"}]\n", "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Useful in proofs by induction. -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {a : Î±} {p : Î± â†’ Prop} {h : Â¬a âˆˆ s},\n  (âˆ€ (x : Î±), x âˆˆ Finset.cons a s h â†’ p x) â†’ âˆ€ (x : Î±), x âˆˆ s â†’ p x :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\ncommutators. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\n  Nat.card { x // x âˆˆ commutator G } â‰¤ Subgroup.cardCommutatorBound (Nat.card â†‘(commutatorSet G)) :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q :=\n\n/-- Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : â„•),\n  n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card { x // x âˆˆ H } = n ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] (n : â„•),\n  n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card (â†¥H) = n ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G], âˆ€ n : â„•, n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card { x // x âˆˆ H } = n ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] (n : â„•),\n  n âˆ£ Fintype.card G â†’ âˆƒ (H : AddSubgroup G), Fintype.card {x // x âˆˆ H} = n ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : â„•),\n  n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card { x // x âˆˆ H} = n ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] (n : â„•), n âˆ£ Fintype.card G â†’ âˆƒ (H : AddSubgroup G), Fintype.card { x // x âˆˆ H } = n ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] (n : â„•), n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card { x // x âˆˆ H } = n ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G],\n  âˆ€ (n : â„•), n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card { x // x âˆˆ H } = n ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : â„•),\n  n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card { x // x âˆˆ H } = n ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : â„•),\n  n âˆ£ Fintype.card G â†’ âˆƒ H : AddSubgroup G, Fintype.card (â†¥H) = n "]}
{"docString": "Prove that quotient groups of a solvable group are solvable.", "prompts": "[{\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\\n  â†‘h (x / y) = â†‘h x / â†‘h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G â§¸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â†‘f â†’\\n    N = MonoidHom.ker f â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ (Monoid.IsTorsion H â†” Monoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\\n  [inst_3 : ContinuousConstVAdd Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"}]\n", "prompt_cons": "/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\n  â†‘h (x / y) = â†‘h x / â†‘h y :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G â§¸ H) :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I) :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  Function.Surjective â†‘f â†’\n    N = MonoidHom.ker f â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ (Monoid.IsTorsion H â†” Monoid.IsTorsion G) :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\n  [inst_3 : ContinuousConstVAdd Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- Prove that quotient groups of a solvable group are solvable. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N] [_h : IsSolvable G],\n  IsSolvable (G â§¸ N) ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N] [h : IsSolvable G],\n  IsSolvable (G â§¸ N) ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N] [_h : IsSolvable G],\n  IsSolvable (G â§¸ N) ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G â§¸ H) ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N] [_h : IsSolvable G],\n  IsSolvable (G â§¸ N) ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N] [_h : IsSolvable G],\n  IsSolvable (G â§¸ N) ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G â§¸ H) ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N] [h : IsSolvable G],\n  IsSolvable (G â§¸ N) ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G â§¸ H) ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G â§¸ H) "]}
{"docString": "Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K â‰¤ H âˆ§ K.normal âˆ§ Fintype.card (G â§¸ K) â‰¤ Subgroup.index H ! ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K.normal âˆ§ K â‰¤ H âˆ§ Fintype.card (G â§¸ K) â‰¤ (Subgroup.index H).factorial ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K â‰¤ H âˆ§ Fintype.card (G â§¸ K) â‰¤ fact (Subgroup.index H) ", "forall {G : Type u_1} [inst : Group G] {H : Subgroup G} [FiniteIndex H],\n  âˆƒ (K : Subgroup G), K.normal âˆ§ K â‰¤ H âˆ§ Fintype.card (G â§¸ K) â‰¤ Subgroup.index H ! ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K â‰¤ H âˆ§ K.normal âˆ§ Fintype.card (G â§¸ K) â‰¤ (Subgroup.index H).factorial ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H],\n  âˆƒ K, K â‰¤ H âˆ§ K.normal âˆ§ nat.factorial (Subgroup.index H) âˆ£ Fintype.card (G â§¸ K) ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ (K : Subgroup G), K â‰¤ H âˆ§ Subgroup.index K â‰¤ Subgroup.index H! ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K â‰¤ H âˆ§ Fintype.card (G â§¸ K) â‰¤ fact (Subgroup.index H) ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K â‰¤ H âˆ§ K.normal âˆ§ Fintype.card (G â§¸ K) â‰¤ Subgroup.index H ! ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.FiniteIndex H],\n  âˆƒ K : Subgroup G, K â‰¤ H âˆ§ K.normal G âˆ§ Fintype.card (G â§¸ K) â‰¤ Subgroup.index H "]}
{"docString": "Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_2} [inst : Group G],\\n  IsPGroup p G â†’\\n    âˆ€ [hp : Fact (Nat.Prime p)] (Î± : Type u_1) [inst_1 : MulAction G Î±] [inst_2 : Fintype Î±]\\n      [inst_3 : Fintype â†‘(MulAction.fixedPoints G Î±)],\\n      Fintype.card Î± â‰¡ Fintype.card â†‘(MulAction.fixedPoints G Î±) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a `p`-group acting on a finite set `Î±`, then the number of fixed points\\nof the action is congruent mod `p` to the cardinality of `Î±` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"}]\n", "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- If `G` is a `p`-group acting on a finite set `Î±`, then the number of fixed points\nof the action is congruent mod `p` to the cardinality of `Î±` -/\ntheorem âˆ€ {p : â„•} {G : Type u_2} [inst : Group G],\n  IsPGroup p G â†’\n    âˆ€ [hp : Fact (Nat.Prime p)] (Î± : Type u_1) [inst_1 : MulAction G Î±] [inst_2 : Fintype Î±]\n      [inst_3 : Fintype â†‘(MulAction.fixedPoints G Î±)],\n      Fintype.card Î± â‰¡ Fintype.card â†‘(MulAction.fixedPoints G Î±) [MOD p] :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u} [inst : Group G] {p Î± : â„•} [hp : Fact (Nat.Prime p)] [inst_1 : Fintype G],\n  Fintype.card G = p ^ Î± â†’\n    âˆ€ {H : Subgroup G}, Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p Î± : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ Î± â†’\n    âˆ€ H : Subgroup G, Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {Î± : â„•},\n  Fintype.card G = p ^ Î± â†’\n    âˆ€ {H : Subgroup G}, Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)] {Î± : â„•},\n  Fintype.card G = p ^ Î± â†’\n    âˆ€ (H : Subgroup G), Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} {Î± : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ Î± â†’\n    âˆ€ {H : Subgroup G}, Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  (âˆƒ n : â„•, Fintype.card G = p ^ n) â†’\n  âˆ€ (H : Subgroup G), Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)] {Î± : â„•} (H : Subgroup G),\n  Fintype.card G = p ^ Î± â†’\n    Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card (G â§¸ H) = p â†’ Subgroup.Normal H "]}
{"docString": "Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `cyclotomic p R = âˆ‘ i in range p, X ^ i`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"}]\n", "prompt_cons": "/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- If `p` is prime, then `cyclotomic p R = âˆ‘ i in range p, X ^ i`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ IsAddCyclic Î± ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ IsAddCyclic G ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ p â‰  q â†’ IsAddCyclic G ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ p â‰  q â†’ IsAddCyclic G ", "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ IsAddCyclic G ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ p â‰  q â†’ IsAddCyclic G ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ IsAddCyclic G ", "âˆ€ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ IsAddCyclic G ", "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q â†’ p â‰  q â†’ IsAddCyclic G ", "âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * q â†’ p â‰  q â†’ IsAddCyclic Î± "]}
{"docString": "Prove that there exists a normal subgroup that is not characteristic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"}]\n", "prompt_cons": "/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1 :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0 :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Prove that there exists a normal subgroup that is not characteristic. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], âˆƒ (H : Subgroup G), Subgroup.Normal H âˆ§ Â¬Subgroup.IsCharacteristic H ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ (N : Subgroup G), Subgroup.Normal N âˆ§ Â¬Subgroup.IsCharSubgroup N ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ (N : Subgroup G), Subgroup.Normal N âˆ§ Â¬Subgroup.IsCharSubgroup N ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G), âˆƒ H : Subgroup G, Subgroup.Normal H âˆ§ Â¬Subgroup.IsChar H ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ H : Subgroup G, Subgroup.Normal H âˆ§ Â¬CharSubgroup G H ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Nontrivial G], âˆƒ H : Subgroup G, Subgroup.Normal H âˆ§ Â¬Subgroup.Characteristic H ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ H : Subgroup G, Subgroup.Normal H âˆ§ Â¬Subgroup.Characteristic H ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ (H : Subgroup G), Subgroup.Normal H âˆ§ Â¬Subgroup.Characteristic H ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ (H : Subgroup G), Subgroup.Normal H âˆ§ Â¬Subgroup.Characteristic H ", "âˆ€ {G : Type u_1} [inst : Group G], âˆƒ (N : Subgroup G), Subgroup.Normal N âˆ§ Â¬Subgroup.IsChar N "]}
{"docString": "Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$. -/\ntheorem", "choices": ["âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.Characteristic H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharSubgroup H K â†’ Subgroup.Normal K â†’ H â‰¤ K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharacteristic K H â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  H â‰¤ K â†’ Subgroup.Characteristic H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.Characteristic H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsChar H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsChar H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  H â‰¤ K â†’ Subgroup.Characteristic H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.char H K â†’ Subgroup.Normal K â†’ Subgroup.Normal H ", "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  H â‰¤ K â†’ Subgroup.IsCharacteristic K H â†’ Subgroup.Normal K â†’ Subgroup.Normal H "]}
{"docString": "Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"}]\n", "prompt_cons": "/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p (H : Subgroup G), Nat.Prime p âˆ§ Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p [Fact (Nat.Prime p)] (P : Sylow p G), Subgroup.normal P ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p [inst_2 : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, Subgroup.normal P ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p (P : Sylow p G), Subgroup.normal P ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p [Fact (Nat.Prime p)], Subgroup.IsNormal (MulAction.fixedPoints (Sylow p G)) G ", "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ âˆƒ P : Sylow p G, Subgroup.normal P ", "âˆ€ {G : Type u} [Group G] [Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p {hp : Fact (Nat.Prime p)}, âˆƒ H : Subgroup G, H.normal âˆ§ Fintype.card { x // x âˆˆ H } = p ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p (Hp : Fact (Nat.Prime p)), âˆƒ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ (Nat.factorization (Fintype.card G) p) âˆ§ Subgroup.normal H ", "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 â†’ âˆƒ (p : â„•) (P : Sylow p G), Subgroup.normal P ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ âˆƒ P : Sylow p G, Subgroup.normal P "]}
{"docString": "Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"}]\n", "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem", "choices": ["âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ p [Fact (Nat.Prime p)], âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ", "âˆƒ p (hp : Fact (Nat.Prime p)), âˆƒ (P : Sylow p (Units.IntMod 351)), is_normal_subgroup (set.range (â‡‘P)) ", "group_of_order_351_has_normal_sylow :\n  âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 â†’ âˆƒ p (H : Subgroup G),\n    Fact (Nat.Prime p) âˆ§ Nat.Coprime (Fintype.card { x // x âˆˆ H }) (Subgroup.index H) âˆ§ Subgroup.normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ p [hp : Fact (Nat.Prime p)], âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ p, (Nat.Prime p âˆ§ p âˆ£ Fintype.card G) âˆ§ âˆƒ P : Subgroup G, IsPGroup p { x // x âˆˆ P } âˆ§ Subgroup.normal P ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ p [hp : Fact (Nat.Prime p)] (P : Sylow p G), Subgroup.Normal â†‘P ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ p (H : Subgroup G) [inst_2 : Fact (Nat.Prime p)], Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ (p : â„•) (H : Subgroup G) [_inst_2 : Fact (Nat.Prime p)], IsPGroup p { x // x âˆˆ H } âˆ§ Subgroup.normal H ", "sylow_normal_351 : âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 â†’ âˆƒ (p : â„•) (H : Subgroup G), Nat.Prime p âˆ§ Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.normal H ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 â†’ âˆƒ (p : â„•) (P : Subgroup G), Fact (Nat.Prime p) âˆ§ Fintype.card { x // x âˆˆ P } = p âˆ§ Subgroup.normal P "]}
{"docString": "Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\\n      Nonempty\\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\\n  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n", "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\n      Nonempty\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\n  âŠ¤ :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (P5 : Sylow 5 G), Subgroup.Normal â†‘P5) âˆ§ (âˆƒ (P7 : Sylow 7 G), Subgroup.Normal â†‘P7) ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (P5 : Sylow 5 G), Subgroup.Normal â†‘P5) âˆ§ (âˆƒ (P7 : Sylow 7 G), Subgroup.Normal â†‘P7) ", "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G] (h_card : Fintype.card G = 105),\n  (âˆƒ (P5 : Sylow 5 G), Subgroup.Normal â†‘P5) âˆ§ (âˆƒ (P7 : Sylow 7 G), Subgroup.Normal â†‘P7) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    ((âˆƒ (N : Sylow 5 G), Subgroup.Normal â†‘N) âˆ§ (âˆƒ (N : Sylow 7 G), Subgroup.Normal â†‘N)) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 105 â†’\n    (âˆƒ (N5 : Sylow 5 G), Subgroup.Normal â†‘N5) âˆ§ (âˆƒ (N7 : Sylow 7 G), Subgroup.Normal â†‘N7) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (N5 : Sylow 5 G), Subgroup.Normal â†‘N5 âˆ§ âˆƒ (N7 : Sylow 7 G), Subgroup.Normal â†‘N7) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 105),\n  (Exists (Î» (H : Subgroup G), Subgroup.Normal H âˆ§ Fintype.card { x // x âˆˆ â†‘H } = 5)) âˆ§\n  (Exists (Î» (H : Subgroup G), Subgroup.Normal H âˆ§ Fintype.card { x // x âˆˆ â†‘H } = 7)) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (N5 : Sylow 5 G), Subgroup.Normal â†‘N5) âˆ§ (âˆƒ (N7 : Sylow 7 G), Subgroup.Normal â†‘N7) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 105 â†’\n  (âˆƒ (H : Sylow 5 G), Subgroup.Normal â†‘H) âˆ§ (âˆƒ (K : Sylow 7 G), Subgroup.Normal â†‘K) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆƒ (N5 : Sylow 5 G), Subgroup.Normal â†‘N5) âˆ§ (âˆƒ (N7 : Sylow 7 G), Subgroup.Normal â†‘N7) "]}
{"docString": "Prove that if $|G|=6545$ then $G$ is not simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±), Set.Nontrivial (f '' s) â†’ Set.Nontrivial s\",\n  \"isProp\": true,\n  \"docString\": \"If the image of a set is nontrivial, the set is nontrivial. \"}]\n", "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±), Set.Nontrivial (f '' s) â†’ Set.Nontrivial s :=\n\n/-- Prove that if $|G|=6545$ then $G$ is not simple. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] (hG : Fintype.card G = 6545), Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] (hCard : Fintype.card G = 6545), Â¬ IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G],\n  Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 â†’ Â¬IsSimpleGroup G "]}
{"docString": "Prove that if $|G|=2907$ then $G$ is not simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"}]\n", "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x â‰  1 :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- Prove that if $|G|=2907$ then $G$ is not simple. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (hN : Fintype.card G = 2907),\n  Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G], Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 2907 â†’ Â¬IsSimpleGroup G ", "Â¬IsSimpleGroup {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 2907) ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] (hG : Fintype.card G = 2907), Â¬IsSimpleGroup G "]}
{"docString": "Prove that if $|G|=462$ then $G$ is not simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"}]\n", "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g :=\n\n/-- Prove that if $|G|=462$ then $G$ is not simple. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "IsNotSimpleGroupOfOrder462 : âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [Fintype G] [DecidableEq G],\n  Fintype.card G = 462 â†’ Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] [hS : Fintype.card G = 462], Â¬IsSimpleGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 â†’ Â¬IsSimpleGroup.mk G "]}
{"docString": "Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$. -/\ntheorem", "choices": ["âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} (hP : IsSylow P) (H : Subgroup G),\n  IsSylow (P âŠ“ H) âˆ§ âˆ€ {Q : Subgroup { x // x âˆˆ H }}, IsSylow Q â†’ Q = comap (Subgroup.subtype H) (P âŠ“ H) ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] (P : Subgroup G) [P_norm : P.normal]\n  (H : Subgroup G), IsPGroup p { x // x âˆˆ H } â†’ âˆƒ! Q, P âŠ“ H = Q ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsPGroup p { x // x âˆˆ P } â†’ P.normal â†’\n    (âˆ€ Q : Subgroup H, IsPGroup p { x // x âˆˆ Q } â†’ P âŠ“ H = Q) ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsPGroup p { x // x âˆˆ P } â†’ P.normal â†’ âˆƒ! Q : Sylow p { x // x âˆˆ H }, P âŠ“ H = â†‘Q ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} [IsPGroup p { x // x âˆˆ P }] [Subgroup.Normal P],\n  âˆ€ {H : Subgroup G}, âˆƒ! Q : Sylow p { x // x âˆˆ H }, P âŠ“ H = â†‘Q ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] {P : Subgroup G} {H : Subgroup G},\n  IsNormal P â†’ Sylow p P â†’ âˆ€ Q : Subgroup H, Sylow p Q â†’ Q = Subgroup.comap H.subtype (P âŠ“ H) ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsPGroup p { x // x âˆˆ P } â†’ P.normal â†’\n    âˆ€ Q : Subgroup { x // x âˆˆ H }, IsPGroup p { x // x âˆˆ Q } â†’ Subgroup.comap H.subtype Q = P âŠ“ H ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsNormal P â†’ IsPGroup p { x // x âˆˆ P } â†’\n  Sylow p G â†’ âˆ€ {H : Subgroup G}, âˆƒ! (K : Subgroup H), Sylow p {x // x âˆˆ H} ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fact (Nat.Prime p)] {P : Subgroup G}\n  (hP : IsNormal P âˆ§ IsPGroup p { x // x âˆˆ P }),\n  âˆ€ H : Subgroup G, âˆƒ! Q : Sylow p { x // x âˆˆ H }, P âŠ“ H = Subgroup.map (Subgroup.subtype P) Q ", "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsPGroup p { x // x âˆˆ P } â†’ Subgroup.normal P â†’\n    âˆ€ Q : Subgroup H, IsPGroup p { x // x âˆˆ Q } â†’ Subgroup.comap (Subgroup.subtype H) Q = P âŠ“ H "]}
{"docString": "Prove that if $u$ is a unit in $R$ then so is $-u$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {n : â„•} (u : RË£),\\n  IsUnit â†‘n â†’ Polynomial.Separable (Polynomial.X ^ n - â†‘Polynomial.C â†‘u)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (u : RË£), â†‘u < 0 â†’ âˆ€ (v : Module.Ray R M), u â€¢ v = -v\",\n  \"isProp\": true,\n  \"docString\": \"Scaling by a negative unit is negation. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : AddMonoid M] {a : AddUnits M} {x y : M}, AddSemiconjBy (â†‘a) x y â†’ AddSemiconjBy (â†‘(-a)) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\\n`x`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\\n  {L : CategoryTheory.Functor C D} {R : CategoryTheory.Functor D C} (h : L âŠ£ R) {X : D}\\n  [inst_2 : CategoryTheory.IsIso (CategoryTheory.NatTrans.app h.counit X)],\\n  CategoryTheory.inv (R.map (CategoryTheory.NatTrans.app h.counit X)) = CategoryTheory.NatTrans.app h.unit (R.obj X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the counit of an adjunction is an isomorphism, then its inverse on the image of R is given\\nby R whiskered with the unit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : NonAssocRing Î±] [inst_2 : ContinuousMul Î±], ContinuousNeg Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\\nis just multiplication with `-1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : AddMonoid M] {a : M} {x y : AddUnits M}, AddSemiconjBy a â†‘x â†‘y â†’ AddSemiconjBy a â†‘(-x) â†‘(-y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\\nsemiconjugates `-x` to `-y`.\"}]\n", "prompt_cons": "/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b :=\n\n/-- If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {n : â„•} (u : RË£),\n  IsUnit â†‘n â†’ Polynomial.Separable (Polynomial.X ^ n - â†‘Polynomial.C â†‘u) :=\n\n/-- Scaling by a negative unit is negation. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (u : RË£), â†‘u < 0 â†’ âˆ€ (v : Module.Ray R M), u â€¢ v = -v :=\n\n/-- If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`. -/\ntheorem âˆ€ {M : Type u_1} [inst : AddMonoid M] {a : AddUnits M} {x y : M}, AddSemiconjBy (â†‘a) x y â†’ AddSemiconjBy (â†‘(-a)) y x :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If the counit of an adjunction is an isomorphism, then its inverse on the image of R is given\nby R whiskered with the unit. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\n  {L : CategoryTheory.Functor C D} {R : CategoryTheory.Functor D C} (h : L âŠ£ R) {X : D}\n  [inst_2 : CategoryTheory.IsIso (CategoryTheory.NatTrans.app h.counit X)],\n  CategoryTheory.inv (R.map (CategoryTheory.NatTrans.app h.counit X)) = CategoryTheory.NatTrans.app h.unit (R.obj X) :=\n\n/-- If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\nis just multiplication with `-1`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : NonAssocRing Î±] [inst_2 : ContinuousMul Î±], ContinuousNeg Î± :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P :=\n\n/-- If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`. -/\ntheorem âˆ€ {M : Type u_1} [inst : AddMonoid M] {a : M} {x y : AddUnits M}, AddSemiconjBy a â†‘x â†‘y â†’ AddSemiconjBy a â†‘(-x) â†‘(-y) :=\n\n/-- Prove that if $u$ is a unit in $R$ then so is $-u$. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] {u : RË£}, IsUnit (-â†‘u) ", "âˆ€ {R : Type u} [inst : Ring R] (u : RË£), IsUnit (-â†‘u) ", "âˆ€ {R : Type u} [inst : Ring R] (u : RË£), IsUnit (-u) ", "âˆ€ {R : Type u} [inst : CommRing R] (u : RË£), IsUnit (-u) ", "âˆ€ {R : Type u} [inst : CommRing R] (u : RË£), IsUnit (-â†‘u) ", "âˆ€ {R : Type u} [inst : Ring R] (u : RË£), IsUnit (- â†‘u) ", "âˆ€ {R : Type u} [inst : CommRing R] (u : RË£), IsUnit (-â†‘u) ", "âˆ€ {R : Type u} [inst : CommRing R] (u : RË£), IsUnit (-â†‘u) ", "âˆ€ {R : Type u} [inst : MonoidWithZero R] (u : RË£), IsUnit (-â†‘u) ", "âˆ€ {R : Type u} [inst : CommRing R] (u : RË£), IsUnit (-u) "]}
{"docString": "Prove that any subring of a field which contains the identity is an integral domain.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K],\\n  â¨… (v : PrimeSpectrum R),\\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\\n        (_ : Ideal.primeCompl v.asIdeal â‰¤ nonZeroDivisors R) =\\n    âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is equal to the intersection of its localizations at all its prime ideals\\nviewed as subalgebras of its field of fractions. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite â†‘S] [inst_6 : IsCyclotomicExtension S A B],\\n  Algebra.IsIntegral A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite cyclotomic extension of an integral noetherian domain is integral \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\": \"A subring of a domain is a domain. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Râ‚ K]\\n  [frac : IsFractionRing Râ‚ K] [inst_3 : IsDomain Râ‚] [inst_4 : IsNoetherianRing Râ‚]\\n  (I : FractionalIdeal (nonZeroDivisors Râ‚) K), IsNoetherian Râ‚ { x // x âˆˆ â†‘I }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every fractional ideal of a noetherian integral domain is noetherian. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K],\\n  â¨… (v : MaximalSpectrum R),\\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\\n        (_ : Ideal.primeCompl v.asIdeal â‰¤ nonZeroDivisors R) =\\n    âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is equal to the intersection of its localizations at all its maximal ideals\\nviewed as subalgebras of its field of fractions. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring is closed under multiplication. \"}]\n", "prompt_cons": "/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- An integral domain is equal to the intersection of its localizations at all its prime ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  â¨… (v : PrimeSpectrum R),\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal â‰¤ nonZeroDivisors R) =\n    âŠ¥ :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem âˆ€ (S : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite â†‘S] [inst_6 : IsCyclotomicExtension S A B],\n  Algebra.IsIntegral A B :=\n\n/-- A subring of a domain is a domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x âˆˆ s } :=\n\n/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Râ‚ K]\n  [frac : IsFractionRing Râ‚ K] [inst_3 : IsDomain Râ‚] [inst_4 : IsNoetherianRing Râ‚]\n  (I : FractionalIdeal (nonZeroDivisors Râ‚) K), IsNoetherian Râ‚ { x // x âˆˆ â†‘I } :=\n\n/-- An integral domain is equal to the intersection of its localizations at all its maximal ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  â¨… (v : MaximalSpectrum R),\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal â‰¤ nonZeroDivisors R) =\n    âŠ¥ :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- A subring is closed under multiplication. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- Prove that any subring of a field which contains the identity is an integral domain. -/\ntheorem", "choices": ["âˆ€ {F : Type u} [inst : Field F] (s : Subring F), One.one âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "âˆ€ {K : Type u} [inst : Field K] (s : Subring K), 1 âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "âˆ€ {K : Type u} [inst : Field K] (s : Subring K), (1 : K) âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "âˆ€ {R : Type u} {K : Type v} [inst : Field K] [inst_1 : Ring R] [inst_2 : Algebra R K], IsDomain R â†’ IsDomain K ", "âˆ€ {K : Type u_1} [inst : Field K] (s : Subring K), 1 âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "forall {K : Type u} [inst : Field K] (s : Subring K), (1 : K) âˆˆ s â†’ IsDomain {x // x âˆˆ s} ", "âˆ€ {K : Type u} [inst : Field K] (s : Subring K), One.one âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "âˆ€ {K : Type u_1} [inst : Field K] (s : Subring K), (1 : K) âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "âˆ€ {K : Type u} [inst : Field K] (s : Subring K), 1 âˆˆ s â†’ IsDomain { x // x âˆˆ s } ", "âˆ€ {K : Type u} [inst : Field K] (s : Subring K), s.has_one â†’ IsDomain { x // x âˆˆ s } "]}
{"docString": "Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\\n  P â‰  âŠ¥ â†’\\n    (âˆ€ (x : R), â†‘Polynomial.C x âˆˆ P â†’ x = 0) â†’\\n      âˆƒ p, p âˆˆ P âˆ§ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"This technical lemma asserts the existence of a polynomial `p` in an ideal `P âŠ‚ R[x]`\\nthat is non-zero in the quotient `R / (P âˆ© R) [x]`.  The assumptions are equivalent to\\n`P â‰  0` and `P âˆ© R = (0)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ (Polynomial.coeff (minpoly A x) 0 = 0 â†” x = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} (n : â„•) (Ï† : MvPolynomial Ïƒ â„¤),\\n  â†‘MvPolynomial.C â†‘n âˆ£ Ï† â†” â†‘(MvPolynomial.map (Int.castRingHom (ZMod n))) Ï† = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial over the integers is divisible by `n : â„•`\\nif and only if it is zero over `ZMod n`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†” b * a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has no zero divisors, then for elements `a, b : Î±`, `a * b` equals zero iff so is\\n`b * a`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x â†’ Polynomial.Monic a â†’ DvdNotUnit a (minpoly A x) â†’ â†‘(Polynomial.aeval x) a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CancelCommMonoidWithZero R] {x y a p : R} {n : â„•},\\n  Prime p â†’ x * y = a * p ^ n â†’ âˆƒ i j b c, i + j = n âˆ§ a = b * c âˆ§ x = b * p ^ i âˆ§ y = c * p ^ j\",\n  \"isProp\": true,\n  \"docString\":\n  \"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written\\nas the product of a power of `p` and a divisor of `a`. \"}]\n", "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- This technical lemma asserts the existence of a polynomial `p` in an ideal `P âŠ‚ R[x]`\nthat is non-zero in the quotient `R / (P âˆ© R) [x]`.  The assumptions are equivalent to\n`P â‰  0` and `P âˆ© R = (0)`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\n  P â‰  âŠ¥ â†’\n    (âˆ€ (x : R), â†‘Polynomial.C x âˆˆ P â†’ x = 0) â†’\n      âˆƒ p, p âˆˆ P âˆ§ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p â‰  0 :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ (Polynomial.coeff (minpoly A x) 0 = 0 â†” x = 0) :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- A polynomial over the integers is divisible by `n : â„•`\nif and only if it is zero over `ZMod n`. -/\ntheorem âˆ€ {Ïƒ : Type u_1} (n : â„•) (Ï† : MvPolynomial Ïƒ â„¤),\n  â†‘MvPolynomial.C â†‘n âˆ£ Ï† â†” â†‘(MvPolynomial.map (Int.castRingHom (ZMod n))) Ï† = 0 :=\n\n/-- If `Î±` has no zero divisors, then for elements `a, b : Î±`, `a * b` equals zero iff so is\n`b * a`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†” b * a = 0 :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x â†’ Polynomial.Monic a â†’ DvdNotUnit a (minpoly A x) â†’ â†‘(Polynomial.aeval x) a â‰  0 :=\n\n/-- If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written\nas the product of a power of `p` and a divisor of `a`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CancelCommMonoidWithZero R] {x y a p : R} {n : â„•},\n  Prime p â†’ x * y = a * p ^ n â†’ âˆƒ i j b c, i + j = n âˆ§ a = b * c âˆ§ x = b * p ^ i âˆ§ y = c * p ^ j :=\n\n/-- Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  (âˆƒ (b : R), b â‰  0 âˆ§ p * Polynomial.C b = 0) â†” p * q = 0 â†’ q = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  (âˆƒ q : Polynomial R, q â‰  0 âˆ§ p * q = 0) â†” (âˆƒ b : R, b â‰  0 âˆ§ âˆ€ n : â„•, b * Polynomial.coeff p n = 0) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  (âˆƒ (a : R), a â‰  0 âˆ§ a â€¢ p = 0) â†” p * Polynomial.C 0 â‰  0 â†’ Exists (fun {q : Polynomial R} => p * q = 0) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  (âˆƒ (b : R), b â‰  0 âˆ§ âˆ€ (a : R), a * b = 0 â†’ a = 0) â†’ (p â‰  0 âˆ§ p * p = 0 â†” âˆƒ (b : R), b â‰  0 âˆ§ âˆ€ (a : R), a * b = 0 â†’ a = 0) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  p * p â‰  0 â†” âˆƒ (b : R), b â‰  0 âˆ§ b â€¢ p = 0 ", "âˆ€ {R : Type u_1} [inst : Ring R] (p : Polynomial R),\n  (âˆƒ q : Polynomial R, q â‰  0 âˆ§ p * q = 0) â†” (âˆƒ b : R, b â‰  0 âˆ§ âˆ€ n, Polynomial.coeff p n * b = 0) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], let p : Polynomial R ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  p * Polynomial.X = 0 â†” âˆƒ (b : R), b â‰  0 âˆ§ p = Polynomial.C b * Polynomial.X ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  (âˆƒ (b : R) (hp : b â‰  0) (h : b * p = 0), b â‰  0) â†” p * b = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  p * p â‰  0 â†’ (âˆƒ (b : R), b â‰  0 âˆ§ p * â†‘Polynomial.C b = 0) â†’ p = 0 "]}
{"docString": "Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R â†’+* S),\\n  Function.Surjective â†‘f â†’ IsLocalRingHom f â†’ Function.Surjective â†‘(Units.map â†‘f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : R â†’+* S` is a surjective local ring hom, then the induced units map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (â†‘f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subsemiring generated by a set equals\\nthe subsemiring generated by the image of the set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S) (s : Set R),\\n  Subring.map f (Subring.closure s) = Subring.closure (â†‘f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subring generated by a set equals\\nthe subring generated by the image of the set. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\\n  {Râ‚˜ : Type u_3} {Sâ‚˜ : Type u_4} [inst_3 : CommRing Râ‚˜] [inst_4 : CommRing Sâ‚˜] [inst_5 : Algebra R Râ‚˜]\\n  [inst_6 : IsLocalization M Râ‚˜] [inst_7 : Algebra S Sâ‚˜] [inst_8 : IsLocalization (Algebra.algebraMapSubmonoid S M) Sâ‚˜],\\n  Algebra.IsIntegral R S â†’\\n    RingHom.IsIntegral\\n      (IsLocalization.map Sâ‚˜ (algebraMap R S)\\n        (_ : M â‰¤ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R â†’ S` is an integral extension, `M` is a submonoid of `R`,\\n`Râ‚˜` is the localization of `R` at `M`,\\nand `Sâ‚˜` is the localization of `S` at the image of `M` under the extension map,\\nthen the induced map `Râ‚˜ â†’ Sâ‚˜` is also an integral extension \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R â†’+* S} {s : Set R},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"theorem\":\n  \"âˆ€ (K : Subfield â„‚) {Ïˆ : { x // x âˆˆ K } â†’+* â„‚},\\n  UniformContinuous â†‘Ïˆ â†’ Ïˆ.toFun = â†‘(Subfield.subtype K) âˆ¨ Ïˆ.toFun = â†‘(starRingEnd â„‚) âˆ˜ â†‘(Subfield.subtype K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `K` a subfield of `â„‚` and let `Ïˆ : K â†’+* â„‚` a ring homomorphism. Assume that `Ïˆ` is uniform\\ncontinuous, then `Ïˆ` is either the inclusion map or the composition of the inclusion map with the\\ncomplex conjugation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R â†’+* S} {s : Set R},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K â†’+* L) (s : Set K),\\n  Subfield.map f (Subfield.closure s) = Subfield.closure (â†‘f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subfield generated by a set equals\\nthe subfield generated by the image of the set. \"}]\n", "prompt_cons": "/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- If `f : R â†’+* S` is a surjective local ring hom, then the induced units map is surjective. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R â†’+* S),\n  Function.Surjective â†‘f â†’ IsLocalRingHom f â†’ Function.Surjective â†‘(Units.map â†‘f) :=\n\n/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (â†‘f '' s) :=\n\n/-- The image under a ring homomorphism of the subring generated by a set equals\nthe subring generated by the image of the set. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S) (s : Set R),\n  Subring.map f (Subring.closure s) = Subring.closure (â†‘f '' s) :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€– :=\n\n/-- If `R â†’ S` is an integral extension, `M` is a submonoid of `R`,\n`Râ‚˜` is the localization of `R` at `M`,\nand `Sâ‚˜` is the localization of `S` at the image of `M` under the extension map,\nthen the induced map `Râ‚˜ â†’ Sâ‚˜` is also an integral extension -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  {Râ‚˜ : Type u_3} {Sâ‚˜ : Type u_4} [inst_3 : CommRing Râ‚˜] [inst_4 : CommRing Sâ‚˜] [inst_5 : Algebra R Râ‚˜]\n  [inst_6 : IsLocalization M Râ‚˜] [inst_7 : Algebra S Sâ‚˜] [inst_8 : IsLocalization (Algebra.algebraMapSubmonoid S M) Sâ‚˜],\n  Algebra.IsIntegral R S â†’\n    RingHom.IsIntegral\n      (IsLocalization.map Sâ‚˜ (algebraMap R S)\n        (_ : M â‰¤ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M))) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R â†’+* S} {s : Set R},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subsemiring.closure s) :=\n\n/-- Let `K` a subfield of `â„‚` and let `Ïˆ : K â†’+* â„‚` a ring homomorphism. Assume that `Ïˆ` is uniform\ncontinuous, then `Ïˆ` is either the inclusion map or the composition of the inclusion map with the\ncomplex conjugation. -/\ntheorem âˆ€ (K : Subfield â„‚) {Ïˆ : { x // x âˆˆ K } â†’+* â„‚},\n  UniformContinuous â†‘Ïˆ â†’ Ïˆ.toFun = â†‘(Subfield.subtype K) âˆ¨ Ïˆ.toFun = â†‘(starRingEnd â„‚) âˆ˜ â†‘(Subfield.subtype K) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R â†’+* S} {s : Set R},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subring.closure s) :=\n\n/-- The image under a ring homomorphism of the subfield generated by a set equals\nthe subfield generated by the image of the set. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K â†’+* L) (s : Set K),\n  Subfield.map f (Subfield.closure s) = Subfield.closure (â†‘f '' s) :=\n\n/-- Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$. -/\ntheorem", "choices": ["âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S) [self : RingHomSurjective Ï•],\n  (Subring.center R).carrier â‰¤ (Subring.center S).carrier ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S),\n  Function.Surjective â†‘Ï• â†’ Set.Image (â‡‘Ï•) (Ring.center R) âŠ† Ring.center S ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S),\n  Function.Surjective â†‘f â†’ Subring.center S â‰¤ Subring.map f (Subring.center R) ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S),\n  Function.Surjective â†‘Ï• â†’ âˆ€ (x : R), x âˆˆ Center R â†’ â†‘Ï• x âˆˆ Center S ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S),\n  Function.Surjective â†‘Ï• â†’ âˆ€ {x : R}, x âˆˆ Ring.center R â†’ â†‘Ï• x âˆˆ Ring.center S ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S),\n  Function.Surjective â†‘Ï• â†’ Subring.center R â‰¤ Subring.comap Ï• (Subring.center S) ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S),\n  Function.Surjective â†‘Ï• â†’ Subring.center R â‰¤ Subring.comap Ï• (Subring.center S) ", "âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {Ïƒ : R â†’+* S}\n  [self : RingHomSurjective Ïƒ], âˆ€ (x : R), HasMem.Mem x (Subring.center R) â†’ HasMem.Mem (Ïƒ x) (Subring.center S) ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (Ï• : R â†’+* S),\n  Function.Surjective â†‘Ï• â†’ (â†‘(Subring.center R)).map Ï• â‰¤ Subring.center S ", "âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {Ï• : R â†’+* S}, Function.Surjective â†‘Ï• â†’\n  âˆ€ (x : R), HasMem.Mem x (Subring.center R) â†’ HasMem.Mem (Ï• x) (Subring.center S) "]}
{"docString": "Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P â†’ IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Polynomial R),\\n  IsUnit P â†” IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\\nnilpotent, except its constant term which is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G â§¸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±] {a : Î±}, 0 âˆ£ a â†” a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"}]\n", "prompt_cons": "/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b :=\n\n/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P â†’ IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i) :=\n\n/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Polynomial R),\n  IsUnit P â†” IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i) :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤ :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G â§¸ H) :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : SemigroupWithZero Î±] {a : Î±}, 0 âˆ£ a â†” a = 0 :=\n\n/-- Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] {a b : R},\n  IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] {a b : R}, IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [nontrivial : Nontrivial R] {a b : R}, IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [ne_zero_one_class : Nontrivial R] {a b : R},\n  IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [Nontrivial R] {a b : R}, IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [_h : Nontrivial R] {a b : R}, IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [nontrivial : Nontrivial R] {a b : R}, IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsNilpotent a â†’ IsUnit (1 - a * b) ", "âˆ€ {R : Type u} [inst : CommRing R] [ne_one_zero : 1 â‰  (0 : R)] {a b : R},\n  IsNilpotent a â†’ IsUnit (1 - a * b) "]}
{"docString": "Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R\",\n  \"isProp\": true,\n  \"docString\": \"A principal ideal domain has unique factorization \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  Â¬IsField A â†’\\n    âˆ€ {I : Ideal A},\\n      I â‰  âŠ¥ â†’\\n        âˆƒ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I âˆ§\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, Â§ 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\\n  Fintype.card (ClassGroup R) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The class number of a principal ideal domain is `1`. \"}]\n", "prompt_cons": "/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- A principal ideal domain has unique factorization -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, Â§ 3.3, Lemma 3]) -/\ntheorem âˆ€ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  Â¬IsField A â†’\n    âˆ€ {I : Ideal A},\n      I â‰  âŠ¥ â†’\n        âˆƒ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I âˆ§\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰  âŠ¥ :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- The class number of a principal ideal domain is `1`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\n  Fintype.card (ClassGroup R) = 1 :=\n\n/-- Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R,\n    a â‰  0 â†’\n      b â‰  0 â†’\n        âˆƒ r s, âˆ€ (z : R), gcd a b âˆ£ z â†” a * r + b * s âˆ£ z) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ i, a i â‰  0) â†’ (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n, a n âˆ£ a N) â†’\n    IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R, a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s, EuclideanDomain.gcd a b = r * a + s * b) â†’\n  (âˆ€ a : â„• â†’ R, (âˆ€ i, a i â‰  0) â†’ (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n, a n = a N * Units.mk0 (a (N + n)) (_ : a (N + n) â‰  0)) â†’\n    IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ (a b : R), a â‰  0 â†’ b â‰  0 â†’ âˆƒ (d : R), (âˆ€ (d' : R), d' âˆ£ a â†’ d' âˆ£ b â†’ d' âˆ£ d) âˆ§ âˆƒ (r s : R), a * r + b * s = d) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ (i : â„•), a (i + 1) âˆ£ a i) â†’ âˆƒ (N : â„•), âˆ€ (n : â„•), n â‰¥ N â†’ âˆƒ (c : R), a n = a N * c âˆ§ IsUnit c) â†’\n    IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ (a b : R), a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s d, r * a + s * b = d âˆ§ d âˆ£ a âˆ§ d âˆ£ b âˆ§ âˆ€ (d' : R), d' âˆ£ a â†’ d' âˆ£ b â†’ d' âˆ£ d) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ (i : â„•), a i â‰  0 â†’ a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ (n : â„•), n â‰¥ N â†’ âˆƒ u : R, a n = u * a N) â†’\n  IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R, a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s d, r * a + s * b = d âˆ§ is_gcd a b d) â†’\n    (âˆ€ (a : â„• â†’ R), (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n, n â‰¥ N â†’ âˆƒ u, is_unit u âˆ§ a n = u * a N) â†’\n      IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R, a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s gcd_ab : R, gcd_ab âˆ£ a âˆ§ gcd_ab âˆ£ b âˆ§ gcd_ab = r * a + s * b) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n â‰¥ N, âˆƒ u, a n = u * a N) â†’\n    IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ (a b : R), a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s, EuclideanDomain.gcd a b = r * a + s * b) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n â‰¥ N, IsUnit (a n / a N)) â†’\n    IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R, a â‰  0 â†’ b â‰  0 â†’ âˆƒ x y, gcd a b = x * a + y * b) â†’\n    (âˆ€ (a : â„• â†’ R), (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n â‰¥ N, âˆƒ u : RË£, a n = â†‘u * a N) â†’\n      IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R, a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s, EuclideanDomain.gcd a b = r * a + s * b) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n, a n âˆ£ a N) â†’\n    IsPrincipalIdealRing R ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (âˆ€ a b : R, a â‰  0 â†’ b â‰  0 â†’ âˆƒ r s, IsGcd a b (r * a + s * b)) â†’\n  (âˆ€ (a : â„• â†’ R), (âˆ€ i, a (i + 1) âˆ£ a i) â†’ âˆƒ N, âˆ€ n, a n âˆ£ a N) â†’\n  IsPrincipalIdealRing R "]}
{"docString": "Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$.", "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {n : â„•} [inst_1 : IsDomain R],\\n  0 < n â†’ âˆ€ {Î¼ : R}, IsPrimitiveRoot Î¼ n â†’ Polynomial.IsRoot (Polynomial.cyclotomic n R) Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `n`-th primitive root of unity is a root of `cyclotomic n R`.\"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"}]\n", "prompt_cons": "/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- Any `n`-th primitive root of unity is a root of `cyclotomic n R`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {n : â„•} [inst_1 : IsDomain R],\n  0 < n â†’ âˆ€ {Î¼ : R}, IsPrimitiveRoot Î¼ n â†’ Polynomial.IsRoot (Polynomial.cyclotomic n R) Î¼ :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, SquareFree n â†’ n > 3 â†’\n  Irreducible (2 : â„¤[sqrt (-n)]) âˆ§ Irreducible (â„¤[sqrt (-n)].sqrt) âˆ§ Irreducible (1 + â„¤[sqrt (-n)].sqrt) ", "âˆ€ {n : â„•}, Nat.Prime n â†’ Squarefree n â†’ n > 3 â†’\n  (Irreducible (2 : â„¤âˆš-n) âˆ§ Irreducible (rootOfUnity n) âˆ§ Irreducible (1 + rootOfUnity n)) ", "irreducible_2_sqrt_minus_n_and_1_plus_sqrt_minus_n :\n  âˆ€ {n : â„•}, Nat.squarefree n â†’ 3 < n â†’\n    Irreducible (2 : â„¤[sqrt (-n)]) âˆ§\n    Irreducible ((1 : â„¤[sqrt (-n)]) + sqrt (-n)) âˆ§\n    Irreducible (sqrt (-n) : â„¤[sqrt (-n)]) ", "âˆ€ {n : â„•}, Nat.Prime n â†’ n > 3 â†’ IsSquareFree n â†’\n  Irreducible (2 : â„¤âˆš-n) âˆ§ Irreducible ((1 : â„¤âˆš-n) + sqrt (-n)) âˆ§ Irreducible (sqrt (-n)) ", "âˆ€ {n : â„•} (h : Nat.Squarefree n) (h1 : 3 < n),\n  Irreducible (2 : â„¤âˆš(-n)) âˆ§\n  Irreducible (â„¤âˆš(-n).sqrt) âˆ§\n  Irreducible (1 + â„¤âˆš(-n).sqrt) ", "âˆ€ {n : â„•},\n  Nat.Squarefree n â†’\n    3 < n â†’\n      âˆ€ (x y : â„¤âˆš-â†‘n),\n        (x * y = 2 â†’ Irreducible x âˆ§ Irreducible y) âˆ§\n        (x * y = sqrt (-â†‘n) â†’ Irreducible x âˆ§ Irreducible y) âˆ§\n        (x * y = 1 + sqrt (-â†‘n) â†’ Irreducible x âˆ§ Irreducible y) ", "âˆ€ {n : â„•}, Nat.squarefree n â†’ n > 3 â†’\n  Irreducible (2 : â„¤âˆš-â†‘n) âˆ§ Irreducible (â„¤âˆš-â†‘n) âˆ§ Irreducible (1 + â„¤âˆš-â†‘n) ", "âˆ€ {n : â„•}, Nat.SquareFree n â†’ 3 < n â†’\n  (Irreducible (2 : Zsqrt (-n)) âˆ§ Irreducible (Zsqrt.ofInt (Zsqrt (-n)) 0) âˆ§ Irreducible (1 + Zsqrt.ofInt (Zsqrt (-n)) 0)) ", "âˆ€ {n : â„•} [H : Fact (Nat.Prime n) âˆ§ NotSquare n âˆ§ 3 < n],\n  Irreducible (2 : â„¤âˆš-n) âˆ§ Irreducible (â„¤âˆš-n.ofInt n) âˆ§ Irreducible (1 + â„¤âˆš-n.ofInt n) ", "âˆ€ {n : â„•} [inst : Fact (Nat.Squarefree n)] [inst_1 : Fact (n > 3)],\n  Irreducible (2 : â„¤âˆš-â†‘n) âˆ§ Irreducible (â„¤âˆš-â†‘n) âˆ§ Irreducible (1 + â„¤âˆš-â†‘n) "]}
{"docString": "Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.", "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"}]\n", "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements. -/\ntheorem", "choices": ["âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span ({â†‘q} : Set â„¤[i])) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span ({â†‘q} : Set â„¤[i])) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (Zmod q)[X] / Polynomial.x ^ 2 + Polynomial.x + 1 âˆ§ Fintype.card ((Zmod q)[X] / (Polynomial.x ^ 2 + Polynomial.x + 1)) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {â†‘q}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {â†‘q}) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {â†‘q}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {â†‘q}) = q ^ 2 ", "âˆ€ {q : â„•} [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’\n  IsField (Z[X] â§¸ (Ideal.span ([C (Int.ofNat q)]))) âˆ§ Fintype.card (Z[X] â§¸ (Ideal.span ([C (Int.ofNat q)]))) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {â†‘q}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {â†‘q}) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {â†‘q}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {â†‘q}) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {Iâ€¢(q)}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {Iâ€¢(q)}) = q ^ 2 ", "âˆ€ {q : â„•} [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {[q]}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {[q]}) = q ^ 2 ", "âˆ€ (q : â„•) [inst : Fact (Nat.Prime q)], q % 4 = 3 â†’ IsField (â„¤[i] â§¸ Ideal.span {â†‘q}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {â†‘q}) = q ^ 2 "]}
{"docString": "Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals.", "prompts": "[{\"theorem\":\n  \"âˆ€ (R : Type wâ‚) [inst : CommRing R] (Î¹ : Type u_2) [inst_1 : Finite Î¹], Algebra.FinitePresentation R (MvPolynomial Î¹ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of polynomials in finitely many variables is finitely presented. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S â‰¤ nonZeroDivisors R â†’\\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R â†’+* S),\\n  Function.Surjective â†‘f â†’ IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"}]\n", "prompt_cons": "/-- The ring of polynomials in finitely many variables is finitely presented. -/\ntheorem âˆ€ (R : Type wâ‚) [inst : CommRing R] (Î¹ : Type u_2) [inst_1 : Finite Î¹], Algebra.FinitePresentation R (MvPolynomial Î¹ R) :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S â‰¤ nonZeroDivisors R â†’\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem âˆ€ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R â†’+* S),\n  Function.Surjective â†‘f â†’ IsPrincipalIdealRing S :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I) :=\n\n/-- Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_2} [inst : â„• â†’ Unique Î¹] (I : Î¹ â†’ Ideal (MvPolynomial â„• â„¤))\n  (hI : âˆ€ i, I i = Ideal.span ({MvPolynomial.x (2 * i) * MvPolynomial.x (2 * i + 1)})),\n  Set.Infinite {P : Ideal (MvPolynomial â„• â„¤) | Ideal.IsPrime P âˆ§ âˆ€ i, I i â‰¤ P} ", "âˆ€ {R : Type u_1} [inst : CommRing R] (Î¹ : Type u_2) [g : â„• â†’ Î¹] [inst_1 : Infinite Î¹],\n  (âˆ€ i j, i â‰  j â†” g i â‰  g j) â†’\n    Set.Infinite {P : Ideal (MvPolynomial Î¹ R) | Ideal.IsMinimal P âˆ§ âˆ€ k, MvPolynomial.x (g (2 * k)) * MvPolynomial.x (g (2 * k + 1)) âˆˆ P} ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : â„• â†’ R}, \n  (âˆ€ n, x (2 * n) * x (2 * n + 1) âˆˆ {I | Ideal.IsPrime I}) â†’ \n  Set.Infinite {I | Ideal.IsPrime I} ", "âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : IsIntegralDomain R] (Î¹ : Type u_2) [inst_2 : Infinite Î¹] (f : Î¹ â†’ Ideal R),\n  (âˆ€ i, f i â‰  0 âˆ§ Ideal.IsPrime (f i)) â†’ (âˆ€ i j, i â‰  j â†’ f i â‰  f j) â†’ Set.Infinite {p : Ideal R | Ideal.IsMinimal p} ", "âˆ€ {R : Type u_1} [inst : CommRing R] (x : â„• â†’ R),\n  (âˆ€ n, x (2 * n) * x (2 * n + 1) = 0) â†’ Set.Infinite {p : Ideal R | Ideal.IsMinPrime p} ", "âˆ€ {R : Type u_1} [inst : CommRing R], (âˆƒ P : â„• â†’ Ideal R,\n  (âˆ€ n, Ideal.IsPrime (P n)) âˆ§ (âˆ€ n m, n â‰  m â†’ P n <> P m)) â†’\n    Â¬âˆ€ J : Ideal R, Ideal.IsPrime J â†’ âˆƒ n, J = P n ", "âˆ€ {R : Type u_1} [inst : CommRing R] (Î¹ : Type u_2) [inst_1 : Infinite Î¹] (f : Î¹ â†’â‚€ R),\n  (âˆƒ g : Î¹ â†’â‚€ R, âˆ€ i j, f i * g j = 0) â†’ Set.Infinite {P : Ideal (Î¹ â†’â‚€ R) | Ideal.IsPrime P âˆ§ âˆ€ i j, f i * g j âˆˆ P} ", "âˆ€ {R : Type u_1} [inst : CommRing R], R = â„¤ â†’ âˆƒ Î¹ : Type* [inst_1 : Infinite Î¹], âˆƒ f : Î¹ â†’ Ideal R,\n  (âˆ€ i, Ideal.IsMinPrime (f i)) âˆ§ âˆ€ i j, i â‰  j â†’ f i â‰  f j ", "âˆ€ (R : Type wâ‚) [inst : CommRing R], âˆƒ P : â„• â†’ Ideal (Polynomial R),\n  (âˆ€ n, Ideal.IsPrime (P n)) âˆ§ âˆ€ n m, n â‰  m â†’ P n â‰  P m ", "âˆ€ {Î± : Type u} [inst : CommRing Î±], âˆƒ s : â„• â†’ Ideal Î±, (âˆ€ n, Ideal.IsMinimal (s n)) âˆ§ âˆ€ i j, i â‰  j â†’ Disjoint (s i) (s j) "]}
{"docString": "Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem", "choices": ["x_pow_four_minus_4_x_pow_three_plus_6_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 - 4 * Polynomial.x + 1) ", "x_pow_four_sub_four_x_pow_three_plus_six_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_minus_four_x_pow_three_plus_six_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_minus_four_x_pow_three_plus_six_irr : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_minus_4x_pow_three_plus_6_irred : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "irreducible_x_pow_4_sub_4_pow_3_add_6 : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_sub_four_x_pow_three_plus_six_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_sub_four_x_pow_three_plus_six_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_4_minus_4x_pow_3_plus_6_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_minus_four_x_pow_three_plus_six_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) "]}
{"docString": "Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C :=\n\n/-- Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem", "choices": ["irreducible_x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_four_plus_four_x_pow_three_plus_six_x_pow_two_plus_two_x_plus_one : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_four_plus_four_x_pow_three_plus_six_x_pow_two_plus_two_x_plus_one : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_4_4x_pow_3_6x_pow_2_2x_1 : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1 : Polynomial â„¤) ", "polynomial_irreducible : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "x_pow_four_plus_4x_pow_three_plus_6x_pow_two_plus_2x_plus_1_irreducible : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1 : Polynomial â„¤) ", "irreducible_x_pow_four_plus_four_x_pow_three_plus_six_x_pow_two_plus_two_x_plus_one : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one :\n  Irreducible (Polynomial.x^4 + 4*Polynomial.x^3 + 6*Polynomial.x^2 + 2*Polynomial.x + 1) ", "irreducible_x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one :\n  Irreducible (1 + (2 * X + (6 * X ^ 2 + (4 * X ^ 3 + X ^ 4)))) ", "irreducible_poly : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1 : Polynomial â„¤) "]}
{"docString": "Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D.", "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Algebra â„¤ R] [inst_2 : IsDomain R] [Fact (IsUFD R)],\n  Irreducible (Polynomial.x ^ 2 - (1 + 1).sqrt) ", "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : Algebra â„¤ A] [inst_3 : UFD A],\n  Irreducible (Polynomial.x ^ 2 - coe (rootTwoSq A)) ", "âˆ€ {A : Type u_1} [inst : CommRing A] [Algebra A â„š] [IsDomain A] [IsUFD A] [IntegralClosure A (Ring.Ext â„š (Int.sqrtTwo.Extension â„š))],\n  Irreducible (Polynomial.x ^ 2 - AlgebraMap A â„š (Ring.Ext â„š (Int.sqrtTwo.Extension â„š)).mk (Int.sqrtTwo.AuxRat.sqrtTwo)) ", "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : Algebra â„š A] [IsUFD A],\n  Irreducible ((Polynomial.map (algebraMap â„š A)) (Polynomial.x ^ 2 - C (Rational.sqrt 2))) ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Algebra â„š K] [inst_2 : IsDomain K],\n  (âˆƒ x : K, x * x = AlgebraMap (â„¤) K (Int.sqrt 2)) â†’ Irreducible (Polynomial.x ^ 2 - AlgebraMap (â„¤) K (Int.sqrt 2)) ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Algebra (â„¤.sqrtTwoRatHom.range) R],\n  Irreducible (Polynomial.map (AlgebraMap (â„¤.sqrtTwoRatHom.range) R) (Polynomial.x ^ 2 - (sqrt 2))) ", "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : Algebra â„ A] [inst_3 : IsUFD A],\n  Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap â„ A) (real.sqrt 2)) ", "âˆ€ {R : Type u_1} [inst : UFD R] [inst_1 : Algebra â„¤ R] [inst_2 : IsDomain R],\n  (âˆ€ {x : â„¤}, coe x â‰  (1 + real.sqrt 2) * coe x) â†’\n    Irreducible (Polynomial.X ^ 2 - coe âŒŠ(real.sqrt 2) * (2 ^ 31)âŒ‹ / 2 ^ 31) ", "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : Algebra A â„] [inst_3 : Algebra A â„š],\n  (Irreducible (Polynomial.x ^ 2 - EmbeddingOfMinpoly A â„ (real.sqrt 2))) ", "âˆ€ {K : Type u_1} [inst : UFD K] [inst_1 : Algebra â„š K] [inst_2 : IsDomain K], Algebra.adjoin â„š (â†‘(âˆš2 : â„)) = K â†’\n  Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap â„š K) (â†‘(âˆš2 : â„))) "]}
{"docString": "Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional ğ•œ E] [inst_14 : FiniteDimensional ğ•œ F],\\n  Nonempty (E â‰ƒL[ğ•œ] F) â†” FiniteDimensional.finrank ğ•œ E = FiniteDimensional.finrank ğ•œ F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional ğ•œ E] [inst_14 : FiniteDimensional ğ•œ F],\\n  FiniteDimensional.finrank ğ•œ E = FiniteDimensional.finrank ğ•œ F â†’ Nonempty (E â‰ƒL[ğ•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : ContinuousSMul â„ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module â„ F]\\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul â„ F] [inst_8 : T2Space F] {G : Type u_1}\\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous â†‘f â†’ âˆ€ (c : â„) (x : E), â†‘f (c â€¢ x) = c â€¢ â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous additive map between two vector spaces over `â„` is `â„`-linear. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K] {n : â„•}, FiniteDimensional.finrank K (Fin n â†’ K) = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The vector space of functions on `Fin n` has finrank equal to `n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"}]\n", "prompt_cons": "/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional ğ•œ E] [inst_14 : FiniteDimensional ğ•œ F],\n  Nonempty (E â‰ƒL[ğ•œ] F) â†” FiniteDimensional.finrank ğ•œ E = FiniteDimensional.finrank ğ•œ F :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if they have the same (finite) dimension. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional ğ•œ E] [inst_14 : FiniteDimensional ğ•œ F],\n  FiniteDimensional.finrank ğ•œ E = FiniteDimensional.finrank ğ•œ F â†’ Nonempty (E â‰ƒL[ğ•œ] F) :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- A continuous additive map between two vector spaces over `â„` is `â„`-linear. -/\ntheorem âˆ€ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul â„ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module â„ F]\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul â„ F] [inst_8 : T2Space F] {G : Type u_1}\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous â†‘f â†’ âˆ€ (c : â„) (x : E), â†‘f (c â€¢ x) = c â€¢ â†‘f x :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0) :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The vector space of functions on `Fin n` has finrank equal to `n`. -/\ntheorem âˆ€ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K] {n : â„•}, FiniteDimensional.finrank K (Fin n â†’ K) = n :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ğ•œ : Type u_2) [inst : IsROrC ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$. -/\ntheorem", "choices": ["âˆ€ (n : â„•), Nonempty ((Fin n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "âˆ€ (n : â„•), Nonempty (((â„š ^ n) â†’â‚—[â„š] â„) â‰ƒâ‚—[â„š] (â„š â†’â‚—[â„š] â„)) ", "âˆ€ (n : â„•), Nonempty ((Fin n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "âˆ€ (n : â„•), Nonempty ((Fin n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "âˆ€ {n : â„•} (hn : 0 < n), FiniteDimensional.finrank â„š (Fin n â†’ â„) = 1 ", "âˆ€ (n : â„•), Nonempty ((Fin n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "âˆ€ (n : â„•), Nonempty ((Finâ‚“ n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "âˆ€ {n : â„•}, Nonempty ((Fin n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "forall {n : â„•} (hn : n > 0), Nonempty ((Fin n â†’ â„) â‰ƒâ‚—[â„š] â„) ", "âˆ€ (n : â„•), Nonempty ((Finâ‚“ n â†’ â„) â‰ƒâ‚—[â„š] â„) "]}
