{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["If every proper closed subset of a topological space is compact, then the space itself is compact.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian."],
 "elaborated-prompts":
 [{"theorem":
   "âˆ€ {p : â„•}, Nat.Prime p â†’ p â‰¡ 1 [MOD 4] â†’ âˆƒ x y, p = x ^ 2 + y ^ 2",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["âˆ€ {p : â„•}, Nat.Prime p â†’ p â‰¡ 1 [MOD 4] â†’ âˆƒ x y, p = x ^ 2 + y ^ 2",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ p % 4 = 1 â†’ âˆƒ a b, p = a ^ 2 + b ^ 2"],
    ["âˆ€ {p : â„•}, Nat.Prime p â†’ p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, p = a ^ 2 + b ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {p : â„•} [inst: Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ p â‰¡ 1 [MOD 4] â†’ âˆƒ x y, p = x ^ 2 + y ^ 2",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, p = a ^ 2 + b ^ 2",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ p % 4 = 1 â†’ âˆƒ a b, p = a ^ 2 + b ^ 2",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, p = a ^ 2 + b ^ 2",
    "âˆ€ {p : â„•} [Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p",
    "âˆ€ (p : â„•) [Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p"]},
  {"theorem":
   "âˆ€ {a b x y z w p q r s : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’\n    b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ u v t s, a * b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["âˆ€ {a b x y z w p q r s : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’\n    b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ u v t s, a * b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2",
     "âˆ€ (a b c d w x y z : â„•),\n  âˆƒ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "âˆ€ {a b x y z w u v s t : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 â†’ âˆƒ r q p n, a * b = r ^ 2 + q ^ 2 + p ^ 2 + n ^ 2"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), âˆƒ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] {a b c d w x y z : R},\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) =\n    (a * w - b * x - c * y - d * z) ^ 2 + (a * x + b * w + c * z - d * y) ^ 2 + (a * y - b * z + c * w + d * x) ^ 2 +\n      (a * z + b * y - c * x + d * w) ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} [inst : CommRing R] {a b c d w x y z : R},\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) =\n    (a * w - b * x - c * y - d * z) ^ 2 +\n      (a * x + b * w + c * z - d * y) ^ 2 +\n      (a * y - b * z + c * w + d * x) ^ 2 +\n      (a * z + b * y - c * x + d * w) ^ 2",
    "âˆ€ {a b x y z w p q r s : â„•}, \na = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ \nb = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 â†’ \nâˆƒ u v t s, a * b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2",
    "âˆ€ (a b c d w x y z : â„•),\n  âˆƒ p q r s, (a^2 + b^2 + c^2 + d^2) * (w^2 + x^2 + y^2 + z^2) = p^2 + q^2 + r^2  + s^2",
    "âˆ€ {a b x y z w u v s t : â„•}, \n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ \n  b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 â†’ \n  âˆƒ r q p n, a * b = r ^ 2 + q ^ 2 + p ^ 2 + n ^ 2",
    "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  âˆƒ w x y z : R, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2",
    "âˆ€ {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ : â„•}, \n  a = xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 â†’ \n  b = yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 â†’ \n  âˆƒ zâ‚ zâ‚‚ zâ‚ƒ zâ‚„, a * b = zâ‚ ^ 2 + zâ‚‚ ^ 2 + zâ‚ƒ ^ 2 + zâ‚„ ^ 2",
    "âˆ€ {a b x y z w p q r s : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ u v x y, a * b = u ^ 2 + v ^ 2 + x ^ 2 + y ^ 2",
    "âˆ€ {a b x y z w u v r s : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ p q t u, a * b = p ^ 2 + q ^ 2 + t ^ 2 + u ^ 2",
    "âˆ€ {R : Type u_1} [inst : CommRing R] (m n : â„•),\n  âˆƒ a b c d, m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 â†’\n  âˆƒ e f g h, n = e ^ 2 + f ^ 2 + g ^ 2 + h ^ 2 â†’\n  âˆƒ p q r s, m * n = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "âˆ€ {a b u v w x y z : â„•}, \na = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2 â†’ \nb = y ^ 2 + z ^ 2 + w ^ 2 + x ^ 2 â†’ \nâˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]},
  {"theorem":
   "âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a b : Î±), a * b = b * a",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a b : Î±), a * b = b * a",
     "âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a b : Î±), a * b = b * a"],
    ["âˆ€ {G : Type u_3} [self : BooleanRing G] (a b : G), a * b = b * a"],
    ["âˆ€ {Î± : Type u_1} [inst : BooleanRing Î±] (a b : Î±), a * b = b * a"],
    ["{Î± : Type u} â†’ [inst : Semiring Î±] â†’ (âˆ€ (a : Î±), a * a = a) â†’ AddCommGroup Î±"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} [inst : BooleanRing Î±] (a b : Î±), a * b = b * a",
    "âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a b : Î±), a * b = b * a",
    "âˆ€ {Î± : Type u} [inst : Semiring Î±] (h : âˆ€ (a : Î±), a * a = a), AddCommGroup Î±",
    "âˆ€ {G : Type u_3} [self : BooleanRing G] (a b : G), a * b = b * a",
    "âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a b : Î±), a * b = b * a",
    "âˆ€ {Î± : Type u_1} [BooleanRing Î±], IsCommutative Î± Mul.mul",
    "âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a b : Î±), a * b = b * a"]},
  {"theorem": "Set.Infinite {p | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p âˆ§ Nat.Prime (p + 2)}"],
    ["Set.Infinite {p | Nat.Prime p.1 âˆ§ Nat.Prime p.2 âˆ§ p.2 - p.1 = 2}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• Ã— â„• | Nat.Prime p.1 âˆ§ Nat.Prime p.2 âˆ§ p.2 - p.1 = 2}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}",
    "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Prime (p + 2)}"]},
  {"theorem":
   "âˆ€ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["âˆ€ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
     "âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
     "âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Finite D], IsField D"],
    ["âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K"],
    ["âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D",
    "âˆ€ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
    "âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst : Finite D], IsField D",
    "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R",
    "âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], Field D",
    "âˆ€ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], Field D",
    "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "âˆ€ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"]},
  {"theorem":
   "âˆ€ {X Y : Type u}, Nonempty (X â†ª Y) â†’ Nonempty (Y â†ª X) â†’ Nonempty (X â‰ƒ Y)",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["âˆ€ {X Y : Type u}, Nonempty (X â†ª Y) â†’ Nonempty (Y â†ª X) â†’ Nonempty (X â‰ƒ Y)"],
    ["âˆ€ {Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)"],
    ["âˆ€ {Î± Î² : Type u} (f : Î± â†’ Î²) (g : Î² â†’ Î±), Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)"],
    ["âˆ€ {Î± : Type u_12} {Î² : Type u_13} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)"],
    ["âˆ€ {Î± : Type u_12} {Î² : Type u_13},\n  (âˆƒ f, Function.Injective f) â†’ (âˆƒ g, Function.Injective g) â†’ âˆƒ f g, Function.Bijective f âˆ§ Function.Bijective g"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)",
    "âˆ€ {Î± Î² : Type u} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)",
    "âˆ€ {Î± Î² : Type*} (f : Î± â†’ Î²) (g : Î² â†’ Î±), Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)",
    "âˆ€ {Î± Î² : Type*} (h1 : âˆƒ (f : Î± â†’ Î²), function.injective f) (h2 : âˆƒ (g : Î² â†’ Î±), function.injective g),\n  âˆƒ (f : Î± â†’ Î²) (g : Î² â†’ Î±), function.bijective f âˆ§ function.bijective g",
    "âˆ€ {X Y : Type u} (hâ‚ : Nonempty (X â†ª Y)) (hâ‚‚ : Nonempty (Y â†ª X)), Nonempty (X â‰ƒ Y)",
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (eâ‚ : Nonempty (Î± â†ª Î²)) (eâ‚‚ : Nonempty (Î² â†ª Î±)), Nonempty (Î± â‰ƒ Î²)",
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)",
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2}, Nonempty (Î± â†ª Î²) â†’ Nonempty (Î² â†ª Î±) â†’ Nonempty (Î± â‰ƒ Î²)",
    "âˆ€ {X Y : Type u} (f : X â†’ Y) (g : Y â†’ X),\n  Function.Injective f â†’ Function.Injective g â†’\n  âˆƒ (h : X â‰ƒ Y), True",
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Function.Injective f â†’ Function.Injective g â†’ âˆƒ (h : Î± â‰ƒ Î²), True"]},
  {"theorem":
   "âˆ€ {V : Type u} {G : SimpleGraph V} [inst : Fintype V] [inst : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! u, G.Adj u v âˆ§ G.Adj u w) â†’ âˆƒ v, âˆ€ (w : V), w â‰  v â†’ G.Adj v w",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "groups":
   [["âˆ€ {V : Type u} {G : SimpleGraph V} [inst : Fintype V] [inst : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! u, G.Adj u v âˆ§ G.Adj u w) â†’ âˆƒ v, âˆ€ (w : V), w â‰  v â†’ G.Adj v w"],
    ["âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), âˆƒ! x, G.Adj v x âˆ§ G.Adj w x) â†’ âˆƒ v, âˆ€ (w : V), w â‰  v â†’ G.Adj v w"],
    ["âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V],\n  (âˆ€ (v w : V), âˆƒ! x, G.Adj x v âˆ§ G.Adj x w) â†’ âˆƒ x, âˆ€ (v : V), v â‰  x â†’ G.Adj x v"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), âˆƒ! (x : V), G.Adj v x âˆ§ G.Adj w x) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ G.Adj v w",
    "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V], \n  (âˆ€ (v w : V), âˆƒ! x, SimpleGraph.Adj G x v âˆ§ SimpleGraph.Adj G x w) â†’ âˆƒ x, âˆ€ v â‰  x, SimpleGraph.Adj G x v",
    "âˆ€ {V : Type u} {G : SimpleGraph V} [Fintype V] [DecidableRel G.Adj],\n (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! u, SimpleGraph.Adj G u v âˆ§ SimpleGraph.Adj G u w) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (s : Set Î±), Set.Nonempty s â†’ âˆƒ a, âˆ€ b âˆˆ s, r b a âˆ¨ b = a) â†’\n    (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "groups":
   [["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (s : Set Î±), Set.Nonempty s â†’ âˆƒ a, âˆ€ b âˆˆ s, r b a âˆ¨ b = a) â†’\n    (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m"],
    ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsPartialOrder Î± r] {S : Set Î±},\n  Set.Nonempty S â†’ (âˆ€ (c : Set Î±), IsChain r c â†’ c âŠ† S â†’ âˆƒ ub âˆˆ S, âˆ€ a âˆˆ c, r a ub) â†’ âˆƒ m âˆˆ S, âˆ€ a âˆˆ S, r m a â†’ r a m"],
    ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : IsRefl Î± r] [inst : IsTrans Î± r],\n  (âˆ€ (s : Set Î±), IsChain r s â†’ âˆƒ ub, âˆ€ a âˆˆ s, r a ub) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m"],
    ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (s : Set Î±), âˆƒ a, âˆ€ b âˆˆ s, r b a) â†’\n    (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m"],
    ["âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {S : Set Î±},\n  Set.Nonempty S â†’ (âˆ€ c âŠ† S, IsChain LE.le c â†’ âˆƒ ub âˆˆ S, âˆ€ a âˆˆ c, a â‰¤ ub) â†’ âˆƒ m âˆˆ S, âˆ€ a âˆˆ S, m â‰¤ a â†’ a = m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsPartialOrder Î± r] {S : Set Î±}, \n  Set.Nonempty S â†’ (âˆ€ (c : Set Î±), IsChain r c â†’ c âŠ† S â†’ âˆƒ ub âˆˆ S, âˆ€ a âˆˆ c, r a ub) â†’ \n    âˆƒ m âˆˆ S, âˆ€ a âˆˆ S, r m a â†’ r a m",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [IsRefl Î± r] [IsTrans Î± r],\n  (âˆ€ (s : Set Î±), IsChain r s â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ s â†’ r a ub)\n    â†’ (âˆƒ m : Î±, âˆ€ (a : Î±), r m a â†’ r a m)",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (s : Set Î±), âˆƒ a, âˆ€ b âˆˆ s, r b a) â†’ \n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’\n  âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m",
    "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {S : Set Î±},\n  Set.Nonempty S â†’ (âˆ€ c âŠ† S, IsChain LE.le c â†’ âˆƒ ub âˆˆ S, âˆ€ a âˆˆ c, a â‰¤ ub) â†’ âˆƒ m âˆˆ S, âˆ€ a âˆˆ S, m â‰¤ a â†’ a = m",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (s : Set Î±), Set.Nonempty s â†’ âˆƒ (a : Î±), âˆ€ (b : Î±), b âˆˆ s â†’ r b a âˆ¨ b = a) â†’ \n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ (ub : Î±), âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, \n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’ âˆƒ m, âˆ€ a, r m a â†’ r a m",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [_inst_1 : PartialOrder Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’\n  Nonempty Î± â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±}, \n  Set.Nonempty s â†’ \n  (âˆ€c, IsChain r c â†’ c âŠ† s â†’ âˆƒ ub âˆˆ s, âˆ€ a âˆˆ c, r a ub) â†’ \n  âˆƒ m âˆˆ s, âˆ€a âˆˆ s, r m a â†’ r a m"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [UniformSpace Î±] [UniformSpace Î²] [UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] \n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] \n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [UniformSpace Î±] [UniformSpace Î²] [UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
     "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [UniformSpace Î±] [UniformSpace Î²] [UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] \n  {g : Î² â†’ Î³} {f : Î± â†’ Î²}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] \n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)",
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [UniformSpace Î±] [UniformSpace Î²] [UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)"]},
  {"theorem":
   "âˆ€ {X : Type u_2} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ âˆ€ x âˆˆ t, f x = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["âˆ€ {X : Type u_2} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ âˆ€ x âˆˆ t, f x = 1"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X),\n      IsClosed s â†’\n        IsClosed t â†’\n          Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ (x : X), f x âˆˆ Set.Icc 0 1 âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ âˆ€ x âˆˆ t, f x = 1"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ x âˆˆ t â†’ f x = 1"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ âˆ€ x âˆˆ t, f x = 1"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X), Disjoint s t â†’ IsClosed s â†’ IsClosed t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ (x : X), f x = 0 âˆ¨ f x = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {X : Type u} [inst : TopologicalSpace X], NormalSpace X â†”\n  âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ x, f x âˆˆ Set.Icc (0 : â„) 1 âˆ§\n    (âˆ€ x âˆˆ s, f x = 0) âˆ§ âˆ€ x âˆˆ t, f x = 1",
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], NormalSpace X â†” âˆ€ (s t : Set X),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ (x : X), x âˆˆ s â†’ f x = 0 âˆ§ x âˆˆ t â†’ f x = 1",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X], NormalSpace X â†”\n  âˆ€ s t : Set X, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1)",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n  âˆ€ (s t : Set X), Disjoint s t â†’ IsClosed s â†’ IsClosed t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ (x : X), f x = 0 âˆ¨ f x = 1",
    "âˆ€ {X : Type u_2} [TopologicalSpace X], NormalSpace X â†” âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ (x : X), x âˆˆ s â†’ f x = 0 âˆ§ âˆ€ (x : X), x âˆˆ t â†’ f x = 1",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ s t : Set Î±, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ âˆ€ x, (x âˆˆ s â†’ f x = 0) âˆ§ (x âˆˆ t â†’ f x = 1)"]},
  {"theorem":
   "âˆ€ {f : â„ â†’ â„},\n  (âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n > 0, âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["âˆ€ {f : â„ â†’ â„},\n  (âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n > 0, âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x",
     "âˆ€ {f : â„ â†’ â„},\n  (âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n > 0, âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x",
     "âˆ€ {f : â„ â†’ â„},\n  (âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x"],
    ["âˆ€ {f : â„ â†’ â„} {x : â„}, Function.IsPeriodicPt f 3 x â†’ âˆ€ n > 0, âˆƒ y, Function.IsPeriodicPt f n y"],
    ["âˆ€ {f : â„ â†’ â„}, Function.IsPeriodicPt f 3 0.5 â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {f : â„ â†’ â„}, (âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n > 0, âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f n x",
    "âˆ€ {f : â„ â†’ â„}, (âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n : â„•, n > 0 â†’ âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f n x",
    "âˆ€ {f : â„ â†’ â„},\n  (âˆƒ x âˆˆ Set.Icc (0 : â„) (1 : â„), Function.IsPeriodicPt f 3 x) â†’\n    âˆ€ n, 0 < n â†’ âˆƒ x âˆˆ Set.Icc (0 : â„) (1 : â„), Function.IsPeriodicPt f n x",
    "âˆ€ {f : â„ â†’ â„}, Function.IsPeriodicPt f 3 0.5 â†’ âˆ€ n : â„•, 0 < n â†’ âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x",
    "âˆ€ {f : â„ â†’ â„} {x : â„}, Function.IsPeriodicPt f 3 x â†’ \n  (âˆ€ (n : â„•), n > 0 â†’ âˆƒ y, Function.IsPeriodicPt f n y)",
    "âˆ€ {f : â„ â†’ â„},\n  (âˆƒ x âˆˆ Set.Icc (0 : â„) (1 : â„), Function.IsPeriodicPt f 3 x) â†’\n  âˆ€ n : â„•, 0 < n â†’ âˆƒ x âˆˆ Set.Icc (0 : â„) (1 : â„), Function.IsPeriodicPt f n x",
    "âˆ€ {f : â„ â†’ â„}, (âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, n > 0 â†’ âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f n x",
    "âˆ€ {f : â„ â†’ â„}, (0 â‰¤ f âˆ§ f â‰¤ 1) â†’ âˆƒ (x : â„), Function.IsPeriodicPt f 3 x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ (y : â„), Function.IsPeriodicPt f n y",
    "âˆ€ {f : â„ â†’ â„}, (âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, âˆƒ x, Function.IsPeriodicPt f n x"]},
  {"theorem":
   "{C : Type u} â†’\n  [category : CategoryTheory.Category.{?u.19312857, u} C] â†’\n    [has_terminal : CategoryTheory.Limits.HasTerminal C] â†’ Unique (CategoryTheory.Limits.IsTerminal (âŠ¤_ C))",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "groups":
   [["{C : Type u} â†’\n  [category : CategoryTheory.Category.{?u.19312857, u} C] â†’\n    [has_terminal : CategoryTheory.Limits.HasTerminal C] â†’ Unique (CategoryTheory.Limits.IsTerminal (âŠ¤_ C))"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {C : Type u} [category : CategoryTheory.Category C] [has_terminal : CategoryTheory.Limits.HasTerminal C],\n  unique (CategoryTheory.Limits.IsTerminal (âŠ¤_ C))"]},
  {"theorem": "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), HasCompl.compl (s âˆª t) = HasCompl.compl s âˆ© HasCompl.compl t",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), HasCompl.compl (s âˆª t) = HasCompl.compl s âˆ© HasCompl.compl t",
    "âˆ€ {Î± : Type u} (A B : Set Î±), (A âˆª B)á¶œ = Aá¶œ âˆ© Bá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ"]},
  {"theorem": "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
     "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
     "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
     "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
     "âˆ€ {n m p : â„•}, 0 < n â†’ 0 < m â†’ Â¬n ^ 3 + m ^ 3 = p ^ 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
    "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
    "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
    "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a^3 + b^3 â‰  c^3",
    "âˆ€ {n m p : â„•}, 0 < n â†’ 0 < m â†’ Â¬(n^3 + m^3 = p^3)",
    "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ Â¬(x ^ 3 + y ^ 3 = z ^ 3)",
    "âˆ€ {a b c : â„•}, 0 < a â†’ 0 < b â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
    "âˆ€ {n m l : â„•}, n > 0 â†’ m > 0 â†’ n ^ 3 + m ^ 3 â‰  l ^ 3",
    "âˆ€ {a b c : â„•}, 0 < a â†’ 0 < b â†’ a ^ 3 + b ^ 3 â‰  c ^ 3",
    "âˆ€ {a b c : â„•}, a > 0 â†’ b > 0 â†’ a ^ 3 + b ^ 3 â‰  c ^ 3"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (g : G), orderOf g = 2) â†’ âˆ€ (a b : G), Commute a b",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), x * y = y * x"],
    ["âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (g : G), g ^ 2 = 1) â†’ âˆ€ (x y : G), x * y = y * x",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (g : G), g ^ 2 = 1) â†’ âˆ€ (a b : G), a * b = b * a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
    "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ g : G, orderOf g = 2) â†’ âˆ€ a b : G, Commute a b",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ g : G, g ^ 2 = 1) â†’ âˆ€ x y : G, x * y = y * x",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ g : G, g^2 = 1) â†’ âˆ€ a b : G, a * b = b * a",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), x * y = y * x",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (a b : G), a * b = b * a",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x * x = 1) â†’ âˆ€ x y : G, x * y = y * x",
    "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ g : G, g * g = 1) â†’ (âˆ€ g h : G, g * h = h * g)"]},
  {"theorem": "âˆ€ (n : â„•), Even (n * (n + 1))",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups":
   [["âˆ€ (n : â„•), Even (n * (n + 1))",
     "âˆ€ (n : â„•), Even (n * (n + 1))",
     "âˆ€ (n : â„•), Even (n * (n + 1))",
     "âˆ€ (n : â„•), Even (n * (n + 1))",
     "âˆ€ (n : â„•), Even (n * (n + 1))"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))",
    "âˆ€ (n : â„•), Even (n * (n + 1))"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
     "âˆ€ (G : Type u_1) [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] [hN : IsFreeGroup G], Monoid.IsTorsionFree G"],
    ["âˆ€ (Î± : Type u_1) [inst : Semigroup Î±], Monoid.IsTorsionFree (FreeGroup Î±)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
    "âˆ€ (Î± : Type u_1) [inst : Semigroup Î±], Monoid.IsTorsionFree (FreeGroup Î±)",
    "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
    "âˆ€ (G : Type u_1) [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] [hN : IsFreeGroup G], Monoid.IsTorsionFree G",
    "âˆ€ {A : Type u_1} [inst : Group A], IsFreeGroup A â†’ Monoid.IsTorsionFree A"]},
  {"theorem": "âˆ€ n > 1, âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["âˆ€ n > 1, âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ n > 1, âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ n > 1, âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ (n : â„•), 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), n > 1 â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ (n : â„•), 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ (n : â„•), 1 < n â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G â†’ Subsingleton G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Subsingleton G"]},
  {"theorem":
   "âˆ€ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["âˆ€ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
     "âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
     "âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Finite D], IsField D"],
    ["âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K"],
    ["âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D",
    "âˆ€ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
    "âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst : Finite D], IsField D",
    "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R",
    "âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], Field D",
    "âˆ€ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], Field D",
    "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "âˆ€ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"],
    ["âˆ€ {X : Type u} [fintype : Fintype X] [inst : TopologicalSpace X], CompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [fintype : Fintype X] [inst : TopologicalSpace X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
     "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
     "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"],
    ["âˆ€ {Î± : Type u} {F : Type v} [inst : AddCommGroup F] [inst_1 : Group F] (f : F â†’* F),\n  (âˆƒ S, Subgroup.closure S = âŠ¤ âˆ§ Set.Finite S) â†’ Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"],
    ["âˆ€ {Î¹ : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype Î¹] (f : FreeGroup Î¹ â†’* G),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
    "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
    "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
    "âˆ€ {Î¹ : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype Î¹] (f : FreeGroup Î¹ â†’* G),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
    "âˆ€ {Î± : Type u} {F : Type v} [inst : AddCommGroup F] [inst_1 : Group F] (f : F â†’* F),\n  (âˆƒ (S : Set F), Subgroup.closure S = âŠ¤ âˆ§ Set.Finite S) â†’ Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"]},
  {"theorem":
   "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + q = n",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + q = n",
     "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + q = n"],
    ["âˆ€ n > 2, n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q"],
    ["âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q"],
    ["âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ a b, Nat.Prime a âˆ§ Nat.Prime b âˆ§ a + b = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ n : â„•, 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ a + b = n",
    "âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
    "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + q = n",
    "âˆ€ (n : â„•), n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
    "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + q = n",
    "âˆ€ {n : â„•}, n â‰  0 â†’ Even n â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
    "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ a + b = n",
    "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
    "âˆ€ {n : â„•}, 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q"]},
  {"theorem":
   "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M),\n  (Polynomial.aeval f) (LinearMap.charpoly f) = 0",
   "some-correct": null,
   "prompt": "Every matrix satisfies its own characteristic polynomial.",
   "groups":
   [["âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M),\n  (Polynomial.aeval f) (LinearMap.charpoly f) = 0"],
    ["âˆ€ {ğ•œ : Type u_1} {n : Type u_2} [inst : Field ğ•œ] [inst_1 : DecidableEq n] [inst_2 : Fintype n] {M : Matrix n n ğ•œ},\n  Polynomial.evalâ‚‚ (Matrix.scalar n) M (Matrix.charpoly M) = 0"],
    ["âˆ€ {R : Type u_1} {n : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : DecidableEq n]\n  [inst_3 : Fintype n] (M : Matrix n n R), Polynomial.evalâ‚‚ (Matrix.scalar n) M (Matrix.charpoly M) = 0"],
    ["âˆ€ {M : Type u_1} [inst : CommRing M] [inst_1 : IsDomain M] {n : Type u_2} [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (A : Matrix n n M), (Polynomial.aeval A) (Matrix.charpoly A) = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {ğ•œ : Type u_1} {n : Type u_2} [inst : Field ğ•œ] [inst_1 : DecidableEq n] [inst_2 : Fintype n] {M : Matrix n n ğ•œ},\n  Polynomial.evalâ‚‚ (Matrix.scalar n) M (Matrix.charpoly M) = 0",
    "âˆ€ {R : Type u_1} {n : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (M : Matrix n n R), ((Matrix.charpoly M).evalâ‚‚ (Matrix.scalar n) M) = 0",
    "âˆ€ {M : Type u_1} [inst : CommRing M] [inst_1 : IsDomain M] {n : Type u_2} [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (A : Matrix n n M), Polynomial.aeval A (Matrix.charpoly A) = 0",
    "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M), Polynomial.aeval f (LinearMap.charpoly f) = 0"]},
  {"theorem": "âˆ€ {r : â„}, Irrational r â†’ r â‰  0 â†’ Irrational (Real.sqrt r)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "groups":
   [["âˆ€ {r : â„}, Irrational r â†’ r â‰  0 â†’ Irrational (Real.sqrt r)",
     "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x)",
     "âˆ€ {x : â„}, Irrational x â†’ x â‰  0 â†’ Irrational (Real.sqrt x)",
     "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x)"],
    ["âˆ€ {r : â„}, Irrational r â†’ 0 < r â†’ Irrational (Real.sqrt r)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {r : â„}, Irrational r â†’ r â‰  0 â†’ Irrational (Real.sqrt r)",
    "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x)",
    "âˆ€ {x : â„}, Irrational x â†’ x â‰  0 â†’ Irrational (Real.sqrt x)",
    "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x)",
    "âˆ€ {r : â„}, Irrational r â†’ 0 < r â†’ Irrational (Real.sqrt r)",
    "âˆ€ (r : â„), Irrational r â†’ Irrational (Real.sqrt r)",
    "âˆ€ {x : â„}, Irrational x â†’ x â‰¥ 0 â†’ Irrational (Real.sqrt x)",
    "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x)",
    "âˆ€ {x : â„}, Irrational x â†’ x â‰  0 â†’ Irrational (Real.sqrt x)",
    "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r)"]},
  {"theorem": "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups":
   [["âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
     "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
     "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
     "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
     "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„•}, Even (n^2) â†’ Even n",
    "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„¤}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n",
    "âˆ€ {n : â„¤}, Even (n ^ 2) â†” Even n",
    "âˆ€ {n : â„•}, Even (n ^ 2) â†’ Even n"]},
  {"theorem":
   "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
     "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R] (P : Ideal R),\n  Ideal.IsPrime P â†’ Ideal.IsMaximal P"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
    "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R]\n(P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
    "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
    "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsClosed {p | p.1 = p.2}",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsClosed {p | p.1 = p.2}",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsClosed {p | p.1 = p.2}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed {p : X Ã— X | p.fst = p.snd}",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed {p : X Ã— X | p.fst = p.snd}"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
     "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsOpen t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsOpen s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±}, (âˆ€x âˆˆ s, âˆƒu, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±}, \n(âˆ€x âˆˆ s, âˆƒu, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, \n  (âˆ€x âˆˆ s, âˆƒt, IsOpen t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€x âˆˆ s, âˆƒu, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [TopologicalSpace Î±] {s : Set Î±}, \n(âˆ€x âˆˆ s, âˆƒu, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} {s : Set Î±} [TopologicalSpace Î±], \n  (âˆ€x âˆˆ s, âˆƒu, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s",
    "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] (s : Set Î±),\n  (âˆ€x âˆˆ s, âˆƒu, IsOpen u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ IsOpen s"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x â‰  1 â†’ Â¬IsOfFinOrder x"],
    ["âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x"],
    ["âˆ€ {G : Type u_1} [inst : Group G], IsFreeGroup G â†’ âˆ€ (g : â„•), g â‰  1 â†’ Â¬IsOfFinOrder g"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    "âˆ€ {G : Type u_1} [inst : Group G], IsFreeGroup G â†’ âˆ€ g, g â‰  1 â†’ Â¬IsOfFinOrder g",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x â‰  1 â†’ Â¬ IsOfFinOrder x",
    "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬ IsOfFinOrder x",
    "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x"]},
  {"theorem":
   "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R),\n  IsUnit x â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
   "some-correct": null,
   "prompt":
   "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
   "groups":
   [["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R),\n  IsUnit x â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
     "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) {x : R},\n  IsUnit x â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (u : R),\n  IsUnit u â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v u = 0"],
    ["âˆ€ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] {Î“â‚€ : Type u_3} [inst_2 : LinearOrderedCommMonoidWithZero Î“â‚€]\n  {v : Valuation A Î“â‚€} [inst_3 : DiscreteValuationRing A] (u : A), IsUnit u â†” v u = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] \n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), IsUnit x â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
    "âˆ€ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] {Î“â‚€ : Type u_3} [inst_2 : LinearOrderedCommMonoidWithZero Î“â‚€]\n  {v : Valuation A Î“â‚€} [inst_3 : DiscreteValuationRing A], âˆ€ (u : A), IsUnit u â†” v u = 0",
    "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) {x : R}, IsUnit x â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
    "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] \n  (v : IsDedekindDomain.HeightOneSpectrum R) (u : R), IsUnit u â†” IsDedekindDomain.HeightOneSpectrum.intValuationDef v u = 0"]},
  {"theorem":
   "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ x y, N â‰¤ a * x + b * y",
   "some-correct": null,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "groups":
   [["âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ x y, N â‰¤ a * x + b * y",
     "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ x y, N â‰¤ a * x + b * y",
     "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ x y, a * x + b * y â‰¥ N âˆ§ a * x + b * y âˆˆ Set.Ici N"],
    ["âˆ€ {a b N : â„•}, Nat.Coprime a b â†’ N â‰¥ a * b â†’ âˆƒ x y, a * x + b * y = N"],
    ["âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆƒ N, âˆ€ (n : â„•), N â‰¤ n â†’ âˆƒ x y, a * x + b * y = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ x y : â„•, N â‰¤ a * x + b * y",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ N : â„•, âˆƒ x y : â„•, a * x + b * y â‰¥ N âˆ§ a * x + b * y âˆˆ Set.Ici N",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆƒ (N : â„•), âˆ€ (n : â„•), N â‰¤ n â†’ âˆƒ (x y : â„•), a * x + b * y = n",
    "âˆ€ {a b N : â„•}, Nat.Coprime a b â†’ N â‰¥ a * b â†’ âˆƒ (x y : â„•), a * x + b * y = N",
    "âˆ€ a b : â„•, Nat.Coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, a * x + b * y = N âˆ§ N â‰¥ a * b - a - b",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ {N : â„•}, âˆƒ x y : â„•, N â‰¤ a * x + b * y",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆƒ N, âˆ€ n â‰¥ N, âˆƒ i j, i * a + j * b = n",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ {N : â„•}, N â‰¥ a * b - (a + b) â†’ âˆƒ x y, N = a * x + b * y",
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, a * x + b * y = N âˆ§ max a b â‰¤ N"]},
  {"theorem": "(K : Type u_1) â†’ [inst : Field K] â†’ Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["(K : Type u_1) â†’ [inst : Field K] â†’ Ring K",
     "(K : Type u_1) â†’ [inst : Field K] â†’ Ring K"],
    ["{K : Type u} â†’ [inst : Field K] â†’ Ring K"],
    ["{K : Type u_1} â†’ [inst : Field K] â†’ Ring K"],
    ["(K : Type u) â†’ [inst : Field K] â†’ Ring K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (K : Type u_1) [inst : Field K], Ring K",
    "âˆ€ {K : Type u_1} [inst : Field K], Ring K",
    "âˆ€ (K : Type u) [inst : Field K], Ring K",
    "âˆ€ (K : Type u_1) [inst : Field K], Ring K",
    "âˆ€ {K : Type u} [inst : Field K], Ring K",
    "âˆ€ (K : Type u) [inst : Field K], Ring K",
    "âˆ€ {K : Type u} [inst : Field K], Ring K",
    "âˆ€ (F : Type u) [inst : Field F], Ring F",
    "âˆ€ {K : Type u} [inst : Field K], Ring K",
    "âˆ€ (K : Type u) [inst : Field K], Ring K"]},
  {"theorem": "{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£",
     "{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£"],
    ["{R : Type u_1} â†’ [inst : MonoidWithZero R] â†’ Group RË£"],
    ["{R : Type u_1} â†’ [inst : MonoidWithZero R] â†’ Group RË£"],
    ["{R : Type u} â†’ [inst : Ring R] â†’ Group RË£"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} [inst : Ring R], Group RË£",
    "âˆ€ {R : Type u_1} [inst : MonoidWithZero R], Group RË£",
    "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£",
    "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£",
    "âˆ€ {R : Type u_1} [inst : MonoidWithZero R], Group (Units R)",
    "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£",
    "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£",
    "âˆ€ {R : Type u} [inst : Ring R], Group RË£",
    "âˆ€ {R : Type u} [inst : MonoidWithZero R], Group (Units R)"]},
  {"theorem":
   "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "groups":
   [["âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
     "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
     "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
     "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H"],
    ["âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], \n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], \n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  (Monoid.IsTorsionFree (G Ã— H)) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H",
    "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H"]}],
 "elaborated": 37}