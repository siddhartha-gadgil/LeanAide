{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["A finitely-presented group containing a torsion element is finite.",
  "The number of partitions of a finite set is a prime number.",
  "The initial object of a category is isomorphic to its terminal object."],
 "elaborated-prompts":
 [{"theorem": "âˆ€ {R : Type u} [inst : Ring R], IsField R",
   "some-correct": null,
   "prompt": "Every ring is a field.",
   "groups":
   [["âˆ€ {R : Type u} [inst : Ring R], IsField R",
     "âˆ€ (R : Type u) [inst : Ring R], IsField R"],
    ["âˆ€ {R : Type u} [inst : Semiring R], IsField R",
     "âˆ€ {R : Type u} [inst : Semiring R], IsField R"],
    ["âˆ€ {R : Type u} [inst : CommSemiring R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} [inst : Semiring R], IsField R",
    "âˆ€ {R : Type u} [inst : Ring R], IsField R",
    "âˆ€ (R : Type u) [inst : Ring R], IsField R",
    "âˆ€ {R : Type u} [inst : Semiring R], IsField R",
    "âˆ€ {R : Type u} [inst : CommSemiring R], IsField R",
    "âˆ€ (R : Type u_1) [inst : CommRing R], IsField R",
    "âˆ€ {R : Type u} [inst : Semiring R], IsField R",
    "âˆ€ {R : Type u} [inst : Semiring R], Nonempty (IsField R)",
    "âˆ€ {R : Type u} [inst : Semiring R], IsField R",
    "âˆ€ {R : Type u} [inst : Semiring R], IsField R"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "groups":
   [["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    "This theorem is generally not true. A vector space is not necessarily finite-dimensional. In fact, there exist infinite-dimensional vector spaces. Therefore, there is no accurate Lean 4 code for this incorrect theorem. \n\nOne might mistakenly try to assert the theorem in Lean as follows:\n\nâˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V\n\nHowever, this is not a valid theorem in general."]},
  {"theorem": "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [inst_2 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, âˆƒ (_ : Nat.Prime p), Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [inst_2 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, âˆƒ (_ : Nat.Prime p), Fintype.card G = p",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p"],
    ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G â†’ âˆƒ p, âˆƒ (_ : Fact (Nat.Prime p)), Fintype.card G = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G â†’ âˆƒ (p : â„•) (hp : Fact (Nat.Prime p)), Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_2 : Fintype G], IsSimpleGroup G â†’ âˆƒ (p : â„•) (hp : Nat.Prime p), Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"],
    ["âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "âˆ€ {G : Type u} [group G] [fintype G], IsSimpleGroup G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p"],
    ["âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
    "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p"]},
  {"theorem": "âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0",
   "some-correct": null,
   "prompt": "Every set has Lebesgue measure zero.",
   "groups":
   [["âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0",
     "âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], ?m.1117835 = 0"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±}, ?m.1116256 = 0"],
    ["âˆ€ {Î± : Type u} [inst : MeasurableSpace Î±] (s : Set Î±), ?m.1117213 s = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±}, â†‘â†‘Î¼ s = 0",
    "âˆ€ (s : Set â„), MeasureTheory.volume s = 0",
    "âˆ€ {Î± : Type u} [inst : MeasurableSpace Î±] (s : Set Î±), â†‘â†‘MeasureTheory.volume s = 0",
    "âˆ€ (s : Set â„), MeasureTheory.volume s = 0",
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], â†‘â†‘MeasureTheory.volume (Set.Univ : Set Î±) = 0",
    "âˆ€ {Î± : Type u_1} [MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), â†‘â†‘Î¼ s = 0"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : CompactSpace Î±] (s : Set Î±), IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : CompactSpace Î±] (s : Set Î±), IsCompact s",
     "âˆ€ {Î± : Type u_1} [topological_space : TopologicalSpace Î±] [compact_space : CompactSpace Î±] (s : Set Î±), IsCompact s",
     "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [inst_1 : CompactSpace X], IsCompact s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : CompactSpace Î±] (s : Set Î±), IsCompact s",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
    "âˆ€ {Î± : Type u_1} [topological_space : TopologicalSpace Î±] [compact_space : CompactSpace Î±] (s : Set Î±), IsCompact s",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [inst_1 : CompactSpace X], IsCompact s",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
    "âˆ€ {Î± : Type u_1} [topological_space Î±] [compact_space Î±] (s : set Î±), is_compact s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±) [inst_1 : CompactSpace Î±], IsCompact s",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s"]},
  {"theorem":
   "âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [self : BorelSpace Î±] (s : Set Î±),\n  MeasurableSet s âˆ§ Â¬borel Î± â‰¤ inst_1 â†’ ?m.1223460 s = 0",
   "some-correct": null,
   "prompt":
   "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
   "groups":
   [["âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [self : BorelSpace Î±] (s : Set Î±),\n  MeasurableSet s âˆ§ Â¬borel Î± â‰¤ inst_1 â†’ ?m.1223460 s = 0"],
    ["âˆ€ {s : Set â„} [inst : MeasurableSpace â„] [inst_1 : BorelSpace â„] (Î¼ : MeasureTheory.Measure â„),\n  MeasurableSet s â†’ Â¬borel â„ â‰¤ inst â†’ ?m.1220083 Î¼ = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {s : Set â„} [inst : MeasurableSpace â„] [inst_1 : BorelSpace â„] (Î¼ : MeasureTheory.Measure â„),\n  MeasurableSet s â†’ Â¬(borel â„ â‰¤ inst) â†’ â†‘â†‘Î¼ s = 0",
    "âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [self : BorelSpace Î±] (s : Set Î±),\n  MeasurableSet s âˆ§ Â¬(borel Î± â‰¤ inst_1) â†’ â†‘â†‘MeasureTheory.volume s = 0"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
     "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t : Set X, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ x âˆˆ s, âˆƒ t âŠ† s, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t : Set Î±, IsClosed t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X Ã— X$.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)"],
    ["âˆ€ {X : Type u} [t : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X â†” IsOpenMap fun x => (x, x)",
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X â†” IsOpenMap fun (x : X) => (x, x)",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)",
    "âˆ€ {X : Type u} [t : TopologicalSpace X], T2Space X â†” IsOpenMap fun x => (x, x)",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X â†” IsOpenMap fun (x : X) => (x, x)",
    "âˆ€ {X : Type u} [top : TopologicalSpace X],\n  T2Space X â†” IsOpenMap fun (p : X) => (p, p)"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
     "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
     "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1"],
    ["âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, n â‰  0 âˆ§ x ^ n = 1"],
    ["âˆ€ {G : Type u} [inst : Group G] {a : G}, 0 < orderOf a â†’ a ^ orderOf a = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
    "âˆ€ {G : Type u} [group G] {a : G}, 0 < orderOf a â†’ a ^ orderOf a = 1",
    "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ âˆƒ n â‰  0, x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒn, 0 < n âˆ§ x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n â‰  0, x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, n > 0 âˆ§ x ^ n = 1",
    "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n, 0 < n âˆ§ x ^ n = 1"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Injective â‡‘f â†’ Function.Surjective â‡‘f",
   "some-correct": null,
   "prompt":
   "Every injective homomorphism from a finitely generated free group to itself is surjective.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Injective â‡‘f â†’ Function.Surjective â‡‘f",
     "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Injective â‡‘f â†’ Function.Surjective â‡‘f",
     "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±), Function.Injective â‡‘f â†’ Function.Surjective â‡‘f"],
    ["âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] (f : FreeGroup Î¹ â†’* FreeGroup Î¹), Function.Injective â‡‘f â†’ Function.Surjective â‡‘f"],
    ["âˆ€ {Î± : Type u} {G : Type v} [inst : Group G] [inst_1 : Fintype Î±] (f : FreeGroup Î± â†’* G),\n  Function.Injective â‡‘f â†’ Function.Surjective â‡‘f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±),\n  Function.Injective â‡‘f â†’ Function.Surjective â‡‘f",
    "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±),\n  Function.Injective â‡‘f â†’ Function.Surjective â‡‘f",
    "âˆ€ {Î± : Type u} [inst : Fintype Î±] (f : FreeGroup Î± â†’* FreeGroup Î±),\n  Function.Injective (â‡‘f) â†’ Function.Surjective (â‡‘f)",
    "âˆ€ {Î± : Type u} {G : Type v} [inst : Group G] [inst_1 : Fintype Î±] (f : FreeGroup Î± â†’* G),\n  Function.Injective â‡‘f â†’ Function.Surjective â‡‘f",
    "âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] (f : FreeGroup Î¹ â†’* FreeGroup Î¹),\n  Function.Injective â‡‘f â†’ Function.Surjective â‡‘f"]},
  {"theorem": "âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ Finite K",
   "some-correct": null,
   "prompt": "Every division ring is either a field or finite.",
   "groups":
   [["âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ Finite K",
     "âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ Finite K",
     "âˆ€ (K : Type u_1) [inst : DivisionRing K], IsField K âˆ¨ Finite K",
     "âˆ€ (D : Type u_1) [inst : DivisionRing D], IsField D âˆ¨ Finite D"],
    ["âˆ€ {R : Type u} [inst : DivisionRing R], IsField R âˆ¨ Finite R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} [inst : DivisionRing R], IsField R âˆ¨ Finite R",
    "âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ Finite K",
    "âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ Finite K",
    "âˆ€ (K : Type u_1) [inst : DivisionRing K], IsField K âˆ¨ Finite K",
    "Here's a sketch of how you might want to structure this theorem, but note that Lean doesn't currently have a definition for \"finite division ring\" so this might not compile without additional context:\n\nâˆ€ (D : Type u_1) [inst : DivisionRing D], IsField D âˆ¨ Finite D\n"]},
  {"theorem": "âˆ€ n > 1, âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "groups":
   [["âˆ€ n > 1, âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
     "âˆ€ n > 1, âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q"],
    ["âˆ€ (n : â„•), âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
     "âˆ€ (n : â„•), âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q"],
    ["âˆ€ (n : â„•), n = 0 âˆ¨ n = 1 âˆ¨ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
    "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
    "âˆ€ (n : â„•), n = 0 âˆ¨ n = 1 âˆ¨ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
    "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
    "âˆ€ (n : â„•), âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q",
    "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q"]},
  {"theorem": "âˆ€ {n : â„•}, Even n â†’ âˆƒ m, m * m = n",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "groups":
   [["âˆ€ {n : â„•}, Even n â†’ âˆƒ m, m * m = n"],
    ["âˆ€ {n : â„•}, 2 âˆ£ n ^ 2 â†’ âˆƒ m, 2 * m = n âˆ§ (2 * m) ^ 2 = n ^ 2"],
    ["âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2"],
    ["âˆ€ {n : â„•}, Even n â†” âˆƒ m, n = m ^ 2"],
    ["âˆ€ {n : â„•}, Even (n ^ 2) âˆ¨ Odd (n ^ 2)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["This is not a valid theorem because not every even number is a square of a natural number. A correct version could be \"Every perfect square that is even is the square of an even natural number\", which translates to:\n\nâˆ€ {n : â„•}, 2 âˆ£ (n ^ 2) â†’ âˆƒ m, 2 * m = n âˆ§ (2 * m) ^ 2 = n ^ 2",
    "âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2",
    "âˆ€ {n : â„•}, Even n â†” âˆƒ m, n = m ^ 2",
    "This is not a valid theorem as not every even number is the square of a natural number. For example, the number 2 is an even number but is not a square of any natural number. However, if the statement was \"Every square of a natural number is either even or odd\", then the Lean code would be:\n\nâˆ€ {n : â„•}, Even (n ^ 2) âˆ¨ Odd (n ^ 2)",
    "âˆ€ {n : â„•}, Even n â†’ âˆƒ m : â„•, m * m = n",
    "âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H â†’ Subgroup.FiniteIndex H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H â†’ Subgroup.FiniteIndex H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [Subgroup.Normal N], Subgroup.FiniteIndex N",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H â†’ Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [Subgroup.Normal H], Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [hN : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_2 : Subgroup.Normal H], Subgroup.FiniteIndex H"]},
  {"theorem":
   "âˆ€ {n : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] {ğ•œ : Type u_4} [inst_2 : Field ğ•œ] [inst_3 : IsAlgClosed ğ•œ]\n  {A : Matrix n n ğ•œ} (Î¼ : ğ•œ), Polynomial.IsRoot (Matrix.charpoly A) Î¼",
   "some-correct": null,
   "prompt": "The characteristic polynomial of every matrix has real roots.",
   "groups":
   [["âˆ€ {n : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] {ğ•œ : Type u_4} [inst_2 : Field ğ•œ] [inst_3 : IsAlgClosed ğ•œ]\n  {A : Matrix n n ğ•œ} (Î¼ : ğ•œ), Polynomial.IsRoot (Matrix.charpoly A) Î¼"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {n : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] {ğ•œ : Type u_4} [inst_2 : Field ğ•œ] [inst_3 : IsAlgClosed ğ•œ]\n  {A : Matrix n n ğ•œ}, âˆ€ Î¼, Polynomial.IsRoot (Matrix.charpoly A) Î¼"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R] (p : Ideal R), Ideal.IsPrime p â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ p â‰¤ M",
   "some-correct": null,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R] (p : Ideal R), Ideal.IsPrime p â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ p â‰¤ M",
     "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [IsLocalRing : LocalRing R] {I : Ideal R},\n  Ideal.IsPrime I â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ I â‰¤ M"],
    ["âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Nontrivial R] (P : Ideal R),\n  Ideal.IsPrime P â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [hR : Ideal.IsJacobson R] (P : Ideal R),\n  Ideal.IsPrime P â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} [inst : CommRing R] [hR : Ideal.IsJacobson R] (P : Ideal R), Ideal.IsPrime P â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M",
    "âˆ€ (R : Type u) [inst : CommRing R] [Nontrivial R] (P : Ideal R), Ideal.IsPrime P â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M",
    "âˆ€ {R : Type u} [inst : CommRing R] (p : Ideal R), Ideal.IsPrime p â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ p â‰¤ M",
    "âˆ€ {R : Type u} [inst : CommRing R] [IsLocalRing : LocalRing R] {I : Ideal R},\n  Ideal.IsPrime I â†’ âˆƒ! M, Ideal.IsMaximal M âˆ§ I â‰¤ M",
    "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P â†’ ExistsUnique fun M => Ideal.IsMaximal M âˆ§ P â‰¤ M"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
     "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f",
     "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
     "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"],
    ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : UniformSpace Î²]\n  [inst_3 : ClosedIciTopology Î²] [inst_4 : Nonempty Î±] {f : Î± â†’ Î²}, UniformContinuous f â†’ BddAbove (Set.range f)",
   "some-correct": null,
   "prompt": "Every uniformly continuous function is bounded above.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : UniformSpace Î²]\n  [inst_3 : ClosedIciTopology Î²] [inst_4 : Nonempty Î±] {f : Î± â†’ Î²}, UniformContinuous f â†’ BddAbove (Set.range f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : UniformSpace Î²] [inst_3 : ClosedIciTopology Î²]\n  [inst_4 : Nonempty Î±] {f : Î± â†’ Î²}, UniformContinuous f â†’ BddAbove (Set.range f)"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ {K : Set X}, IsCompact K â†’ IsClosed K) â†’ CompactSpace X"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ {K : Set X}, IsCompact K â†’ IsClosed K) â†’ CompactSpace X"],
    ["âˆ€ {X : Type u_2} [inst : TopologicalSpace X], (âˆ€ {s : Set X}, IsCompact s â†’ IsClosed s) â†’ CompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (H : âˆ€ {K : Set X}, IsCompact K â†’ IsClosed K), CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X], \n(âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ {K : Set X}, IsCompact K â†’ IsClosed K) â†’ CompactSpace X",
    "âˆ€ {X : Type u_2} [inst : TopologicalSpace X] (self : âˆ€ {s : Set X}, IsCompact s â†’ IsClosed s), CompactSpace X",
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ â¦ƒK : Set Xâ¦„, IsCompact K â†’ IsClosed K) â†’ CompactSpace X",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], \n  (âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s) â†’ CompactSpace Î±",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], (âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s) â†’ CompactSpace Î±",
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (h : âˆ€ {s : Set X}, IsCompact s â†’ IsClosed s), CompactSpace X"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y â†’ IsIdempotentElem (x + y)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y â†’ IsIdempotentElem (x + y)"],
    ["âˆ€ {R : Type u_1} [self : CommRing R] (a b : R),\n  IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) â†’ IsIdempotentElem a âˆ§ IsIdempotentElem b"],
    ["âˆ€ {R : Type u_2} [inst : CommSemiring R] {a b : R},\n  IsIdempotentElem a â†’ IsIdempotentElem b â†’ Commute a b â†’ IsIdempotentElem (a + b)"],
    ["âˆ€ {R : Type u_1} [inst : BooleanRing R] (a b : R), IsIdempotentElem (a + b)"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y â†’ IsIdempotentElem (x + y)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’\n  IsIdempotentElem (a + b) â†’ IsIdempotentElem a âˆ§ IsIdempotentElem b",
    "âˆ€ {R : Type u_2} [inst : CommSemiring R] {a b : R},\n  IsIdempotentElem a â†’ IsIdempotentElem b â†’ Commute a b â†’ IsIdempotentElem (a + b)",
    "âˆ€ {R : Type u_1} [inst : BooleanRing R] (a b : R), IsIdempotentElem (a + b)",
    "âˆ€ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y â†’ IsIdempotentElem (x + y)",
    "âˆ€ {R : Type u} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y â†’ IsIdempotentElem (x + y)",
    "âˆ€ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x â†’ IsIdempotentElem y â†’ \n  x * y = 0 â†’ IsIdempotentElem (x + y)",
    "âˆ€ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y â†’ IsIdempotentElem (x + y)",
    "âˆ€ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a â†’ IsIdempotentElem b â†’ Commute a b â†’ \nIsIdempotentElem (a + b)"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [inst : IsTrans Î± r] [inst_1 : IsAntisymm Î± r],\n  (âˆƒ m, âˆ€ (a : Î±), r a m â†’ r m a) â†’ âˆƒ! m, âˆ€ (a : Î±), r m a â†’ r a m",
   "some-correct": null,
   "prompt":
   "If a poset has a maximal element, then it has a unique minimal element.",
   "groups":
   [["âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [inst : IsTrans Î± r] [inst_1 : IsAntisymm Î± r],\n  (âˆƒ m, âˆ€ (a : Î±), r a m â†’ r m a) â†’ âˆƒ! m, âˆ€ (a : Î±), r m a â†’ r a m"],
    ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, (âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m) â†’ âˆƒ! b, âˆ€ (a : Î±), r a b â†’ r b a"],
    ["âˆ€ {Î± : Type u_1} [self : PartialOrder Î±] {a : Î±}, (âˆƒ m, âˆ€ (b : ?m.38217070), m â‰¤ b â†’ m = b) â†’ âˆƒ! b, âˆ€ a_2 â‰¤ b, a_2 = b"],
    ["âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a : Î±},\n  (âˆƒ b, âˆ€ (x : ?m.38218336), x â‰¤ b) â†’ âˆƒ! a_2, âˆ€ (x : ?m.38218338), a_2 â‰¤ x"],
    ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : IsPartialOrder Î± r],\n  (âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m) â†’ âˆƒ! m, âˆ€ (a : Î±), r a m â†’ r m a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m) â†’ (âˆƒ! b, âˆ€ (a : Î±), r a b â†’ r b a)",
    "âˆ€ {Î± : Type u_1} [self : PartialOrder Î±] {a : Î±},\n  (âˆƒ m, âˆ€ b, m â‰¤ b â†’ m = b) â†’ âˆƒ! b, âˆ€ a, a â‰¤ b â†’ a = b",
    "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a : Î±}, (âˆƒ b, âˆ€ x, x â‰¤ b) â†’ (âˆƒ! a, âˆ€ x, a â‰¤ x)",
    "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [IsPartialOrder Î± r],\n  (âˆƒ m, âˆ€ a, r m a â†’ r a m) â†’ âˆƒ! m, âˆ€ a, r a m â†’ r m a",
    "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [inst : IsTrans Î± r] [inst_1 : IsAntisymm Î± r],\n  (âˆƒ m, âˆ€ a, r a m â†’ r m a) â†’ âˆƒ! m, âˆ€ a, r m a â†’ r a m"]},
  {"theorem": "âˆ€ {Î± : Type u} [inst : AddCommGroup Î±], IsCyclic (AddAut Î±)",
   "some-correct": null,
   "prompt": "The automorphism group of an Abelian group is cyclic.",
   "groups": [["âˆ€ {Î± : Type u} [inst : AddCommGroup Î±], IsCyclic (AddAut Î±)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [inst : AddCommGroup Î±], IsCyclic (AddAut Î±)"]},
  {"theorem":
   "âˆ€ {f : â†‘unitInterval â†’ â†‘unitInterval} {x : â†‘unitInterval} {n : â„•},\n  Function.IsFixedPt f x â†’ 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "groups":
   [["âˆ€ {f : â†‘unitInterval â†’ â†‘unitInterval} {x : â†‘unitInterval} {n : â„•},\n  Function.IsFixedPt f x â†’ 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y"],
    ["âˆ€ {f : â„ â†’ â„} {x : â„},\n  0 â‰¤ x â†’ x â‰¤ 1 â†’ Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ y âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n y"],
    ["âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] {f : Î± â†’ Î±} {x : Î±} {m : â„•} {n : â„•},\n  Function.IsFixedPt f x â†’ 0 < m â†’ Function.IsPeriodicPt f m x"],
    ["âˆ€ {f : â„ â†’ â„} {x : â„}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ y, dist y x < 1 âˆ§ Function.IsPeriodicPt f n y"],
    ["âˆ€ {f : Unit â†’ Unit} {x : Unit}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ x', Function.IsPeriodicPt f n x'"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {f : â„ â†’ â„} {x : â„},\n  0 â‰¤ x â†’ x â‰¤ 1 â†’ Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ y âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n y",
    "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  {f : Î± â†’ Î±} {x : Î±} {m n : â„•},\n  Function.IsFixedPt f x â†’ 0 < m â†’ Function.IsPeriodicPt f m x",
    "âˆ€ {f : â„ â†’ â„} {x : â„},\n  HasSubset.Subset (Set.Icc 0 1) (Set.fixedPoints f) â†’\n  Function.IsFixedPt f x â†’ âˆ€ n : â„•, 0 < n â†’ âˆƒ y, dist y x < 1 âˆ§ Function.IsPeriodicPt f n y",
    "âˆ€ {f : unit â†’ unit} {x : unit}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ x', Function.IsPeriodicPt f n x'",
    "âˆ€ {f : unit_interval â†’ unit_interval} {x : unit_interval} {n : â„•},\n  Function.IsFixedPt f x â†’ 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y",
    "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} {n : â„•},\n  Function.IsFixedPt f x â†’ 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y"]},
  {"theorem": "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "groups":
   [["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ â‰¤ sá¶œ âˆª tá¶œ",
     "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ"],
    ["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆª tá¶œ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆª tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ â‰¤ sá¶œ âˆª tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), HasSubset.Subset ((s âˆª t)á¶œ) (sá¶œ âˆª tá¶œ)",
    "âˆ€ {Î± : Type u} (s t : Set Î±), HasSubset.Subset ((s âˆª t)á¶œ) (sá¶œ âˆª tá¶œ)",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ â‰¤ sá¶œ âˆª tá¶œ",
    "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ â‰¤ sá¶œ âˆª tá¶œ"]},
  {"theorem": "âˆ€ (q : â„š), âˆƒ p, p * p = q",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "groups":
   [["âˆ€ (q : â„š), âˆƒ p, p * p = q",
     "âˆ€ (q : â„š), âˆƒ r, r * r = q",
     "âˆ€ (r : â„š), âˆƒ q, q * q = r",
     "âˆ€ (q : â„š), âˆƒ r, r * r = q âˆ¨ -r * -r = q",
     "âˆ€ (q : â„š), âˆƒ p, p * p = q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (q : â„š), âˆƒ p : â„š, p * p = q",
    "âˆ€ (q : â„š), âˆƒ r : â„š, r * r = q",
    "âˆ€ (r : â„š), âˆƒ (q : â„š), q*q = r",
    "âˆ€ (q : â„š), âˆƒ r : â„š, (r * r = q) âˆ¨ ((-r) * (-r) = q)",
    "âˆ€ (q : â„š), âˆƒ p : â„š, p * p = q",
    "âˆ€ (q : â„š), âˆƒ r : â„š, r*r = q",
    "âˆ€ {a : â„š}, âˆƒ q : â„š, (q * q) = a",
    "âˆ€ {r : â„š}, âˆƒ q : â„š, q * q = r"]},
  {"theorem":
   "{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst_2 : Module R M] â†’ [self : Module.Free R M] â†’ CommRing R",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "groups":
   [["{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst_2 : Module R M] â†’ [self : Module.Free R M] â†’ CommRing R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [self : Module.Free R M], CommRing R"]},
  {"theorem":
   "âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] (U : Submonoid R) [inst_1 : Group â†¥U], IsCommutative R Mul.mul",
   "some-correct": null,
   "prompt":
   "If the set of units of a ring forms a group then the ring is commutative.",
   "groups":
   [["âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] (U : Submonoid R) [inst_1 : Group â†¥U], IsCommutative R Mul.mul"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] (U : Submonoid R) [inst_1 : Group U], IsCommutative R Mul.mul"]},
  {"theorem": "âˆ€ {n : â„•}, n > 10 â†’ âˆƒ m p, m ^ 2 + p = n âˆ§ Nat.Prime p",
   "some-correct": null,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "groups":
   [["âˆ€ {n : â„•}, n > 10 â†’ âˆƒ m p, m ^ 2 + p = n âˆ§ Nat.Prime p",
     "âˆ€ (n : â„•), 10 < n â†’ âˆƒ a b, a ^ 2 + b = n âˆ§ Nat.Prime b",
     "âˆ€ {n : â„•}, 10 < n â†’ âˆƒ a p, a ^ 2 + p = n âˆ§ Nat.Prime p"],
    ["âˆ€ {n : â„•}, n > 10 â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p"],
    ["âˆ€ {n : â„•}, n > 10 â†’ âˆƒ x p, Nat.Prime p âˆ§ n = x ^ 2 + p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {n : â„•}, n > 10 â†’ âˆƒ m p, m ^ 2 + p = n âˆ§ Nat.Prime p",
    "âˆ€ n : â„•, 10 < n â†’ âˆƒ a b : â„•, a^2 + b = n âˆ§ Nat.Prime b",
    "âˆ€ {n : â„•}, n > 10 â†’ âˆƒ (x : â„•) (p : â„•), Nat.Prime p âˆ§ n = x ^ 2 + p",
    "âˆ€ {n : â„•}, 10 < n â†’ âˆƒ (a p : â„•), a ^ 2 + p = n âˆ§ Nat.Prime p",
    "âˆ€ {n : â„•}, n > 10 â†’ âˆƒ (x p : â„•), n = x ^ 2 + p âˆ§ Nat.Prime p",
    "âˆ€ {n : â„•}, n > 10 â†’ âˆƒ a p, n = a ^ 2 + p âˆ§ Nat.Prime p",
    "âˆ€ (n : â„•), n > 10 â†’ âˆƒ (x : â„•), âˆƒ (p : â„•), Nat.Prime p âˆ§ n = x ^ 2 + p",
    "âˆ€ (n : â„•), n > 10 â†’ âˆƒ a b, n = a^2 + b âˆ§ Nat.Prime b",
    "âˆ€ (n : â„•), n > 10 â†’ âˆƒ (p : â„•) (h : Nat.Prime p) (x : â„•), n = x^2 + p",
    "âˆ€ {n : â„•}, n > 10 â†’ âˆƒ p a, Nat.Prime p âˆ§ n = a ^ 2 + p"]},
  {"theorem":
   "âˆ€ {X Y Z : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z] {f : Y â†’ Z}\n  {g : X â†’ Y}, Continuous g â†’ Continuous (f âˆ˜ g) â†’ Continuous f",
   "some-correct": null,
   "prompt":
   "If the composition of two functions is continuous, then each of them is continuous.",
   "groups":
   [["âˆ€ {X Y Z : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z] {f : Y â†’ Z}\n  {g : X â†’ Y}, Continuous g â†’ Continuous (f âˆ˜ g) â†’ Continuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["This theorem is not generally true. The continuity of the composition of two functions does not guarantee the continuity of each function. For example, let f : â„ â†’ â„ be defined by f(x) = x for x â‰  0 and f(0) = 1, and let g : â„ â†’ â„ be defined by g(x) = 0 for all x. Then the composition f âˆ˜ g is continuous, but f is not.\n\nHowever, a correct version of a similar statement could be: if g is continuous and the composition f âˆ˜ g is continuous, then f is continuous. In Lean 4, it might be expressed as follows:\n\nâˆ€ {X Y Z : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]\n  {f : Y â†’ Z} {g : X â†’ Y}, Continuous g â†’ Continuous (f âˆ˜ g) â†’ Continuous f\n\nPlease note that the function g in the composition needs to be continuous in order for the function f to be continuous.\n"]},
  {"theorem":
   "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "groups":
   [["âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c"],
    ["âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c"]},
  {"theorem":
   "âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R â†’+* S} {a : R},\n  f a = 0 â†’ a = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "groups":
   [["âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R â†’+* S} {a : R},\n  f a = 0 â†’ a = 0",
     "âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R â†’+* S} {a : R},\n  f a = 0 â†’ a = 0"],
    ["âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {a : R}, f a = 0 â†’ a = 0",
     "âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {a : R}, f a = 0 â†’ a = 0"],
    ["âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S},\n  Function.Injective â‡‘f â†’ âˆ€ (r : R), f r = 0 â†’ r = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {a : R},\n  f a = 0 â†’ a = 0",
    "âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R â†’+* S} {a : R},\n  f a = 0 â†’ a = 0",
    "âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} (hf : Function.Injective â‡‘f)\n  (r : R), f r = 0 â†’ r = 0",
    "âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {a : R}, f a = 0 â†’ a = 0",
    "âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R â†’+* S} {a : R},\n  f a = 0 â†’ a = 0"]},
  {"theorem": "âˆ€ {P Q : Prop}, (P â†” Q) â†’ (P â†’ Q) âˆ§ (Q â†’ P)",
   "some-correct": null,
   "prompt": "Implication `â†’` is symmetric. If `P â†’ Q` then `Q â†’ P`.",
   "groups": [["âˆ€ {P Q : Prop}, (P â†” Q) â†’ (P â†’ Q) âˆ§ (Q â†’ P)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Although the statement is expressed as a theorem, it's important to note that in classical logic, implication is not a symmetric relation. Therefore, the statement \"If `P â†’ Q` then `Q â†’ P`\" is not generally true, and it can't be represented in Lean without additional assumptions. However, if we consider only the cases where `P` and `Q` are logically equivalent, we can state the desired theorem as follows:\n\n```lean\nâˆ€ {P Q : Prop}, (P â†” Q) â†’ (P â†’ Q) âˆ§ (Q â†’ P)\n```"]},
  {"theorem": "âˆ€ {n m : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n âˆ§ p âˆ£ m) â†” n = m",
   "some-correct": null,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "groups":
   [["âˆ€ {n m : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n âˆ§ p âˆ£ m) â†” n = m",
     "âˆ€ {m n : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
     "âˆ€ {m n : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
     "âˆ€ {a b : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ a âˆ§ p âˆ£ b) â†” a = b",
     "âˆ€ {m n : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {n m : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n âˆ§ p âˆ£ m) â†” n = m",
    "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {a b : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ a âˆ§ p âˆ£ b) â†” a = b",
    "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {m n : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {m n : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n",
    "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n"]}],
 "elaborated": 37}