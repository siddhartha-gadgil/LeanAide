{"theorem":"âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","text":"If `r` is rational (`r â‰  0`) and `x` is irrational, prove that `r+x` is irrational.","result":true,"gps":[["âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {x : â„} (r : â„š), r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {x : â„} (r : â„š), r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ","âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) "]}
{"theorem":"Â¬âˆƒ q, q ^ 2 = 12","text":"Prove that there is no rational number whose square is `12`.","result":true,"gps":[["Â¬âˆƒ q, q ^ 2 = 12","Â¬âˆƒ q, q ^ 2 = 12","Â¬âˆƒ q, q ^ 2 = 12"],["Â¬âˆƒ q, q * q = 12","Â¬âˆƒ q, q * q = 12","Â¬âˆƒ q, q * q = 12"],["Irrational (Real.sqrt 12)","Irrational (Real.sqrt 12)"],["Â¬âˆƒ a b, b â‰  0 âˆ§ a * a = 12 * (b * b)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Â¬âˆƒ (q : â„š), q * q = 12 ","Â¬âˆƒ (q : â„š), q ^ 2 = 12 ","Â¬âˆƒ q : â„š, q ^ 2 = 12 ","Irrational (Real.sqrt 12) ","Â¬âˆƒ (a b : â„¤), b â‰  0 âˆ§ (a * a = 12 * (b * b)) ","Â¬âˆƒ q : â„š, q * q = 12 ","Â¬âˆƒ (q : â„š), q ^ 2 = 12 ","Irrational (Real.sqrt 12) ","Â¬âˆƒ q : â„š, q * q = 12 "]}
{"theorem":"âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A)","text":"Let `A` be a nonempty set of real numbers which is bounded below. Let `-A` be the set of all numbers `-x`, where `x âˆˆ A`. Prove that `inf A = -sup (-A)`.","result":true,"gps":[["âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A)","âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A)","âˆ€ {A : Set â„}, Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A)","âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A)","âˆ€ {A : Set â„}, Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A) ","âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A) ","âˆ€ {A : Set â„}, Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A) ","âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A) ","âˆ€ {A : Set â„}, Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A) "]}
{"theorem":"âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ ?m.1464420 z r w = 1 âˆ§ z = r * w","text":"If `z` is a complex number, prove that there exists an `r â‰¥ 0` and a complex number `w` with `| w | = 1` such that `z = rw`.","result":true,"gps":[["âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ ?m.1464420 z r w = 1 âˆ§ z = r * w","âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ ?m.1464420 z r w = 1 âˆ§ z = r * w"],["âˆ€ (z : â„‚), âˆƒ r w, r â‰¥ 0 âˆ§ ?m.1466215 z r w = 1 âˆ§ z = r â€¢ w","âˆ€ (z : â„‚), âˆƒ r w, r â‰¥ 0 âˆ§ ?m.1466215 z r w = 1 âˆ§ z = r â€¢ w"],["âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ ?m.1464026 z r w = 1 âˆ§ z = â†‘r * w"],["âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w"],["âˆ€ (z : â„‚), âˆƒ r w, r â‰¥ 0 âˆ§ ?m.1465903 z r w = 1 âˆ§ z = r * w"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = â†‘r * w ","âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ","âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ Complex.abs w = 1 âˆ§ z = r * w ","âˆ€ (z : â„‚), âˆƒ r w, r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ","âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ","âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r â€¢ w ","âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r â€¢ w "]}
{"theorem":"âˆ€ {x y : â„‚}, â†‘Complex.abs (â†‘(â†‘Complex.abs x) - â†‘(â†‘Complex.abs y)) â‰¤ â†‘Complex.abs (x - y)","text":"If `x, y` are complex, prove that `||x|-|y|| â‰¤ |x-y|`.","result":true,"gps":[["âˆ€ {x y : â„‚}, â†‘Complex.abs (â†‘(â†‘Complex.abs x) - â†‘(â†‘Complex.abs y)) â‰¤ â†‘Complex.abs (x - y)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {x y : â„‚}, Complex.abs (Complex.abs x - Complex.abs y) â‰¤ Complex.abs (x - y) "]}
{"theorem":"âˆ€ {k : â„•} [inst : LinearOrderedField â„] [inst_1 : NormedAddCommGroup (Fin k â†’ â„)] [inst_2 : NormedSpace â„ (Fin k â†’ â„)]\n  {x y : Fin k â†’ â„} {r d : â„},\n  k â‰¥ 3 â†’\n    dist x y = d â†’\n      d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f, Function.Injective f âˆ§ âˆ€ (n : â„¤), dist (f n) x = r âˆ§ dist (f n) y = r","text":"Suppose `k â‰¥ 3`, `x, y âˆˆ â„^k`, `|x - y| = d > 0`, and `r > 0`. Prove that if `2r > d`, there are infinitely many `z âˆˆ â„^k` such that `|z-x|=|z-y|=r`.","result":true,"gps":[["âˆ€ {k : â„•} [inst : LinearOrderedField â„] [inst_1 : NormedAddCommGroup (Fin k â†’ â„)] [inst_2 : NormedSpace â„ (Fin k â†’ â„)]\n  {x y : Fin k â†’ â„} {r d : â„},\n  k â‰¥ 3 â†’\n    dist x y = d â†’\n      d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f, Function.Injective f âˆ§ âˆ€ (n : â„¤), dist (f n) x = r âˆ§ dist (f n) y = r"],["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E} {r d : â„},\n  3 â‰¤ FiniteDimensional.finrank â„ E â†’\n    dist x y = d â†’ 0 < d â†’ 0 < r â†’ 2 * r > d â†’ âˆƒ A, Set.Infinite A âˆ§ âˆ€ (z : E), z âˆˆ A â†’ dist z x = r âˆ§ dist z y = r"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E} {r d : â„},\n  3 â‰¤ FiniteDimensional.finrank â„ E â†’\n  dist x y = d â†’ 0 < d â†’ 0 < r â†’ 2 * r > d â†’ âˆƒ A : Set E, Set.Infinite A âˆ§ âˆ€ z, z âˆˆ A â†’ dist z x = r âˆ§ dist z y = r ","âˆ€ {k : â„•} [inst : LinearOrderedField â„] [inst_1 : NormedAddCommGroup (Fin k â†’ â„)] [inst_2 : NormedSpace â„ (Fin k â†’ â„)]\n  {x y : Fin k â†’ â„} {r d : â„},\n  k â‰¥ 3 â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f : â„¤ â†’ Fin k â†’ â„, Function.Injective f âˆ§ âˆ€ n : â„¤, dist (f n) x = r âˆ§ dist (f n) y = r "]}
{"theorem":"âˆ€ {k : â„} {a b c r : â„}, (âˆ€ (x : â„), |x - a| = 2 * |x - b| â†” |x - c| = r) â†’ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * |b - a|","text":"Suppose `a, b âˆˆ â„^k`. Find `c âˆˆ â„^k` and `r > 0` such that `|x-a|=2|x-b|` if and only if `| x - c | = r`. Prove that `3c = 4b - a` and `3r = 2 |b - a|`.","result":true,"gps":[["âˆ€ {k : â„} {a b c r : â„}, (âˆ€ (x : â„), |x - a| = 2 * |x - b| â†” |x - c| = r) â†’ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * |b - a|"],["âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace V]\n  [inst_3 : NormedAddTorsor V V] {a b c : V} {r : â„},\n  (âˆ€ (x : V), dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} {r : â„},\n  (âˆ€ x : P, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ","âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace V] [inst_3 : NormedAddTorsor V V],\n  âˆ€ {a b c : V} {r : â„},\n    (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) â†’\n      3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ","âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} (r : â„),\n  (âˆ€ x : P, dist x a = 2 * dist x b â†” dist x c = r) â†’\n    3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ","âˆ€ {k a b c : â„} {r : â„},\n  (âˆ€ (x : â„), |x - a| = 2 * |x - b| â†” |x - c| = r) â†’\n    3 * c = 4 * b - a âˆ§ 3 * r = 2 * |b - a| ","âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P],\n  âˆ€ {a b c : P} {r : â„},\n    (âˆ€ x : P, dist x a = 2 * dist x b â†” dist x c = r) â†’\n      3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ","âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} {r : â„},\n  (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a "]}
{"theorem":"âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, tâ‚ âŠ† s âˆ§ tâ‚‚ âŠ† s âˆ§ Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚","text":"Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.","result":true,"gps":[["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, tâ‚ âŠ† s âˆ§ tâ‚‚ âŠ† s âˆ§ Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚"],["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P C, Perfect P âˆ§ Set.Countable C âˆ§ s = P âˆª C"],["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t, Set.Countable t âˆ§ s = s \\ t âˆª s âˆ© t âˆ§ Perfect (s \\ t)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ (P : Set Î±), âˆƒ (C : Set Î±),\n      Perfect P âˆ§ Set.Countable C âˆ§ s = P âˆª C ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P A, Perfect P âˆ§ Set.Countable A âˆ§ s = P âˆª A ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P A, Perfect P âˆ§ Set.Countable A âˆ§ s = P âˆª A ","forall {Î± : Type u} [inst : MetricSpace Î±] [TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t, Set.Countable t âˆ§ s = (s \\ t) âˆª (s âˆ© t) âˆ§ Perfect (s \\ t) ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, tâ‚ âŠ† s âˆ§ tâ‚‚ âŠ† s âˆ§ Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î±] {C : Set Î±},\n  IsClosed C â†’ âˆƒ P V, Perfect P âˆ§ Set.Countable V âˆ§ C = P âˆª V ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ","forall {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ","âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Set.Countable tâ‚ âˆ§ Perfect tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ "]}
{"theorem":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedRing Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {s : Î² â†’ Î±} {a : Î±} {f : Filter Î²},\n  Filter.Tendsto s f (nhds a) â†’ Filter.Tendsto (fun x => |s x|) f (nhds |a|)","text":"Prove that convergence of `{s_n}` implies convergence of `{|s_n|}`.","result":true,"gps":[["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedRing Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {s : Î² â†’ Î±} {a : Î±} {f : Filter Î²},\n  Filter.Tendsto s f (nhds a) â†’ Filter.Tendsto (fun x => |s x|) f (nhds |a|)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedRing Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {s : Î² â†’ Î±} {a : Î±} {f : Filter Î²},\n  Filter.Tendsto s f (nhds a) â†’ Filter.Tendsto (fun x => abs (s x)) f (nhds (abs a)) "]}
{"theorem":"âˆ€ (s : â„• â†’ â„),\n  s 0 = Real.sqrt 2 â†’\n    (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) â†’\n      (âˆƒ l, Filter.Tendsto s Filter.atTop (nhds l)) âˆ§ âˆ€ (n : â„•), s n < 2","text":"If `s_1=âˆš2`, and `s_{n+1}=âˆš(2+âˆšs_n)` for `(n=1,2,3, ...)`, prove that `{s_n}` converges, and that `s_n < 2` for `n=1,2,3, ...`.","result":true,"gps":[["âˆ€ (s : â„• â†’ â„),\n  s 0 = Real.sqrt 2 â†’\n    (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) â†’\n      (âˆƒ l, Filter.Tendsto s Filter.atTop (nhds l)) âˆ§ âˆ€ (n : â„•), s n < 2"],["âˆ€ (n : â„•), 0 < Real.sqrtTwoAddSeries (0 / 1) n âˆ§ Real.sqrtTwoAddSeries (0 / 1) n < 2"],["âˆ€ (n : â„•), 0 < n â†’ Real.sqrtTwoAddSeries 0 n < 2"],["âˆ€ (n : â„•), Real.sqrt (2 + Real.sqrtTwoAddSeries (0 / 1) n) < 2"],["âˆ€ (n : â„•),\n  Real.sqrt (2 + Real.sqrtTwoAddSeries (0 / 1) n) < 2 âˆ§ Filter.Tendsto Real.sqrtTwoAddSeries Filter.atTop (nhds 0)"],["âˆ€ (s : â„• â†’ â„),\n  s 0 = Real.sqrt 2 â†’\n    (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) â†’\n      Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) âˆ§ âˆ€ (n : â„•), s n < 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ (n : â„•), 0 < Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n âˆ§ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ","s_nat_converges_lt_2 : âˆ€ (n : â„•), 0 < n â†’ Real.sqrtTwoAddSeries 0 n < 2 ","âˆ€ (n : â„•), Real.sqrt (2 + Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n) < 2 ","âˆ€ (n : â„•), Real.sqrt (2 + Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n) < 2 âˆ§ Filter.Tendsto Real.sqrtTwoAddSeries Filter.atTop (nhds 0) ","âˆ€ (s : â„• â†’ â„),\n  s 0 = Real.sqrt 2 â†’ (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n)))\n  â†’ Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) âˆ§ âˆ€ (n : â„•), s n < 2 ","âˆ€ (s : â„• â†’ â„), (s 0 = Real.sqrt 2) â†’ (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) â†’ (âˆƒ l, Filter.Tendsto s Filter.atTop (nhds l)) âˆ§ âˆ€ n, s n < 2 "]}
{"theorem":"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop","text":"Prove that `lim_{nâ†’âˆ} Î£_{i<n} a_i = âˆ`, where `a_i = âˆš(i + 1) - âˆši`.","result":true,"gps":[["âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop"],["âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt â†‘(i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop"],["âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop\n    Filter.atTop"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ","âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘(i + 1)) - Real.sqrt â†‘i) Filter.atTop Filter.atTop ","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop Filter.atTop ","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ","âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) (Î»i => (Real.sqrt (i + 1) - Real.sqrt i))) Filter.atTop Filter.atTop "]}
{"theorem":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)","text":"Suppose `{p_n}` is a Cauchy sequence in a metric space `X`, and some sequence `{p_{n l}}` converges to a point `p âˆˆ X`. Prove that the full sequence `{p_n}` converges to `p`.","result":true,"gps":[["âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)"],["âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)"],["âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±}\n  {Î¹ : Type u_12} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n  CauchySeq u â†’\n    Filter.Tendsto f p Filter.atTop â†’\n      âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)"],["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {l : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto l p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ l) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)"],["âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {l : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto l p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ l) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±}\n  {Î¹ : Type*} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n  CauchySeq u â†’\n    Filter.Tendsto f p Filter.atTop â†’\n      âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) "]}
{"theorem":"âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {G : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)","text":"Suppose `X` is a nonempty complete metric space, and `{G_n}` is a sequence of dense open sets of `X`. Prove Baire's theorem, namely, that `âˆ©_{n=1}^{âˆ} G_n` is not empty.","result":true,"gps":[["âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {G : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)","âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n) âˆ§ Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n)","âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n) âˆ§ Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)","âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)","âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)"],["âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n) âˆ§ Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)","âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n)"],["âˆ€ {Î± : Type u_2} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {Î² : Type u_1} [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s)"],["âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {Î² : Type u_2} [inst_2 : Encodable Î²]\n  {G : Î² â†’ Set X}, (âˆ€ (n : Î²), IsOpen (G n)) â†’ (âˆ€ (n : Î²), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : Î²), G n)"],["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (S n)) â†’ (âˆ€ (n : â„•), Dense (S n)) â†’ Set.Nonempty (â‹‚ (n : â„•), S n)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {Î² : Type u_2} [inst_2 : Encodable Î²]\n  {G : Î² â†’ Set X}, (âˆ€ (n : Î²), IsOpen (G n)) â†’ (âˆ€ (n : Î²), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : Î²), G n) ","âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {G : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ","âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : â„• â†’ Set X},\n  (âˆ€ n, IsOpen (G n) âˆ§ Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ","forall {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n) âˆ§ Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ","forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : â„• â†’ Set Î±},\n  (âˆ€ n, IsOpen (S n)) â†’ (âˆ€ n, Dense (S n)) â†’ Set.Nonempty (â‹‚ n, S n) ","âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ n, IsOpen (G n) âˆ§ Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ","âˆ€ {Î± : Type u_2} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {Î² : Type u_1} [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ","forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ","forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ n, IsOpen (G n)) â†’ (âˆ€ n, Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ","forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) "]}
{"theorem":"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X â†’ Y},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))","text":"If `f` is a continuous mapping of a metric space `X` into a metric space `Y`, prove that `f(âˆ‚E) âŠ† âˆ‚f(E)` for every set `E âŠ† X`. (`âˆ‚E` denotes the closure of `E`).","result":true,"gps":[["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X â†’ Y},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y) (E : Set X),\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))"],["âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))","âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))","âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X â†’ Y},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ","forall {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y]\n  {f : X â†’ Y} {E : Set X},\n    Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ","âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ","forall {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y) (E : Set X),\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) "," âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ","âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) "]}
{"theorem":"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : X â†’ Y} {E : Set X}, Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E)","text":"Let `f` and `g` be continuous mappings of a metric space `X` into a metric space `Y`, and let `E` be a dense subset of `X`. Prove that `f(E)` is dense in `f(X)`.","result":true,"gps":[["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : X â†’ Y} {E : Set X}, Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E)","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y]\n  [inst_3 : MetricSpace Y] {f : X â†’ Y} {E : Set X} {g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E)","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y]\n  [inst_3 : MetricSpace Y] {f g : X â†’ Y} {E : Set X}, Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E)"],["âˆ€ {X : Type u_12} {Y : Type u_13} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : X â†’ Y} (E : Set X), Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E)"],["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E) ","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ","forall {X Y : Type*} [topological_space X] [topological_space Y] [metric_space X] [metric_space Y] {f g : X â†’ Y} (E : set X),\n  dense E â†’ continuous f â†’ continuous g â†’ dense (f '' E) ","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y]\n  {f : X â†’ Y} {E : Set X} {g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E) ","forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y] {f g : X -> Y} {E : Set X},\n  Dense E ->\n  Continuous f ->\n  Continuous g ->\n  Dense (f '' E) "]}
{"theorem":"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(â†‘E, â„)),\n  IsClosed E â†’ âˆƒ g, ContinuousMap.restrict E g = f","text":"If `f` is a real continuous function defined on a closed set `E âŠ† â„`, prove that there exist continuous real functions `g` on `â„` such that `g(x)=f(x)` for all `x âˆˆ E`.","result":true,"gps":[["âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(â†‘E, â„)),\n  IsClosed E â†’ âˆƒ g, ContinuousMap.restrict E g = f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(â†‘E, â„)),\n  IsClosed E â†’ âˆƒ g, ContinuousMap.restrict E g = f "]}
{"theorem":"âˆ€ {E : Set â„}, Metric.Bounded E â†’ âˆƒ f, UniformContinuous f âˆ§ âˆ€ (C : â„), âˆƒ x, x âˆˆ E âˆ§ C < |f x|","text":"Let `E` be a bounded set in `â„^1`. Prove that there exists a real function `f` such that `f` is uniformly continuous and is not bounded on `E`.","result":true,"gps":[["âˆ€ {E : Set â„}, Metric.Bounded E â†’ âˆƒ f, UniformContinuous f âˆ§ âˆ€ (C : â„), âˆƒ x, x âˆˆ E âˆ§ C < |f x|"],["âˆ€ {E : Set â„}, Metric.Bounded E â†’ âˆƒ f, UniformContinuous f âˆ§ âˆ€ (M : â„), âˆƒ x H, M < f x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {E : Set â„} (hE : Metric.Bounded E),\n  âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ (M : â„), âˆƒ (x : â„) (H : x âˆˆ E), M < f x ","âˆ€ {E : Set â„}, Metric.Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ (C : â„), âˆƒ x âˆˆ E, C < |f x| "]}
{"theorem":"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {g : Î± â†’ Î²} {f : Î² â†’ Î³},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (f âˆ˜ g)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {g : Î± â†’ Î²} {f : Î² â†’ Î³},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (f âˆ˜ g)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] (g : Î² â†’ Î³) (f : Î± â†’ Î²),\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î± â†’ Î²} {f : Î² â†’ Î³},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (f âˆ˜ g) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (g : Î² â†’ Î³) (f : Î± â†’ Î²),\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "]}
{"theorem":"âˆ€ {f : â„ â†’ â„},\n  (âˆ€ {a b c : â„}, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, x âˆˆ Set.Ioo a b âˆ§ f x = c) â†’\n    (âˆ€ (q : â„š), IsClosed {x | f x = â†‘q}) â†’ Continuous f","text":"Suppose `f` is a real function with domain `â„^1` which has the intermediate value property: if `f(a) < c < f(b)`, then `f(x) = c` for some `x` between `a` and `b`. Suppose also, for every rational `r`, that the set of all `x` with `f(x) = r` is closed. Prove that `f` is continuous.","result":true,"gps":[["âˆ€ {f : â„ â†’ â„},\n  (âˆ€ {a b c : â„}, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, x âˆˆ Set.Ioo a b âˆ§ f x = c) â†’\n    (âˆ€ (q : â„š), IsClosed {x | f x = â†‘q}) â†’ Continuous f"],["âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (a b c : â„), f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n    (âˆ€ (q : â„š), IsClosed {x | f x = â†‘q}) â†’ Continuous f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {f : â„ â†’ â„},\n  (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ q : â„š, is_closed {x | f x = q}) â†’\n  continuous f ","forall {f : â„ â†’ â„},\n  (âˆ€ {a b : â„} {c : â„}, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, x âˆˆ set.Ioo a b âˆ§ f x = c) â†’\n  (âˆ€ (q : â„š), is_closed {x : â„ | f x = â†‘q}) â†’\n  continuous f ","forall {f : â„ â†’ â„} (hmono : âˆ€ a b : â„, a < b â†’ a < f a â†’ f a < f b â†’ f b < b),\n  (forall (q : â„š) (x : â„), f x = q â†’ âˆƒ s hs, x âˆˆ s âˆ§ IsClosed s) â†’\n  Continuous f "]}
{"theorem":"âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f","text":"Assume that `f` is a continuous real function defined in `(a, b)` such that `f((x+y)/2) â‰¤ (f(x)+f(y))/2` for all `x, y âˆˆ (a, b)`. Prove that `f` is convex.","result":true,"gps":[["âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f","âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f","âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f","âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f","âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f"],["âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f"],["âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ] {s : Set ğ•œ}\n  {f : ğ•œ â†’ ğ•œ},\n  ContinuousOn f s â†’ (âˆ€ â¦ƒx : ğ•œâ¦„, x âˆˆ s â†’ âˆ€ â¦ƒy : ğ•œâ¦„, y âˆˆ s â†’ x < y â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’ ConvexOn ğ•œ s f"],["âˆ€ {s : Set â„} {f : â„ â†’ â„},\n  Convex â„ s â†’\n    (âˆ€ â¦ƒx y : â„â¦„, x âˆˆ s â†’ y âˆˆ s â†’ âˆ€ â¦ƒa b : â„â¦„, 0 < a â†’ 0 < b â†’ a + b = 2 â†’ f ((a â€¢ x + b â€¢ y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ s f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ] {s : Set ğ•œ}\n  {f : ğ•œ â†’ ğ•œ},\n  ContinuousOn f s â†’\n    (âˆ€ â¦ƒx : ğ•œâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : ğ•œâ¦„, y âˆˆ s â†’ x < y â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn ğ•œ s f ","âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ x y : â„, x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f ","forall {a b : â„} (hab : a < b),\n  âˆ€ {f : â„ â†’ â„},\n    ContinuousOn f (Set.Ioo a b) â†’\n    (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n    ConvexOn â„ (Set.Ioo a b) f ","âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f ","âˆ€ {s : Set â„} {f : â„ â†’ â„},\n  Convex â„ s â†’\n    (âˆ€ â¦ƒx y : â„â¦„,\n        x âˆˆ s â†’\n          y âˆˆ s â†’ âˆ€ â¦ƒa b : â„â¦„, 0 < a â†’ 0 < b â†’ a + b = 2 â†’ f ((a â€¢ x + b â€¢ y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ s f ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ (âˆ€ (z : E), z = (x + y) / 2 â†’ f z â‰¤ (f x + f y) / 2)) â†’\n      ConvexOn ğ•œ s f ","âˆ€ {a b : â„} (hab : a < b) {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ioo a b) â†’\n    (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ (Set.Ioo a b) f ","forall {a b : â„} (hab : a < b) {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ioo a b) â†’\n    (âˆ€ x y : â„, x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ (Set.Ioo a b) f "]}
{"theorem":"âˆ€ {f : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n    StrictMono f âˆ§\n      âˆ€ {x : â„},\n        x âˆˆ Set.Ioo a b â†’ âˆƒ g, (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ (g âˆ˜ f) y = y) âˆ§ HasDerivAt g (deriv f x)â»Â¹ (f x)","text":"Suppose `f'(x) > 0` in `(a, b)`. Prove that `f` is strictly increasing in `(a, b)`, and let `g` be its inverse function. Prove that `g` is differentiable, and that `g'(f(x)) = 1/f'(x)` for `(a < x < b)`.","result":true,"gps":[["âˆ€ {f : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n    StrictMono f âˆ§\n      âˆ€ {x : â„},\n        x âˆˆ Set.Ioo a b â†’ âˆƒ g, (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ (g âˆ˜ f) y = y) âˆ§ HasDerivAt g (deriv f x)â»Â¹ (f x)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {f : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n    (StrictMono f âˆ§\n      âˆ€ {x : â„},\n        x âˆˆ Set.Ioo a b â†’\n          âˆƒ g, (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ (g âˆ˜ f) y = y) âˆ§\n                    HasDerivAt g (deriv f x)â»Â¹ (f x)) ","âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n        StrictMonoOn f (Set.Ioo a b) âˆ§\n          âˆƒ (g : â„ â†’ â„),\n            ContinuousOn g (Set.Icc (f a) (f b)) âˆ§\n              (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ HasDerivAt g (1 / f' (g y)) y) ","âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n    (StrictMono f âˆ§ âˆƒ g, âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ (HasDerivAt f (f' x) x âˆ§ HasDerivAt g (1 / f' (g x)) (f x))) ","âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n    (StrictMono f âˆ§\n      âˆ€ {g : â„ â†’ â„},\n        (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x) â†’ âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (1 / f' (f x)) (f x)) ","âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n      StrictMono f âˆ§\n        âˆ€ {g : â„ â†’ â„},\n          (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ g (f x) = x) â†’\n            (âˆ€ (y : â„), y âˆˆ Set.Icc (f a) (f b) â†’ ContinuousOn g (Set.Icc (f a) (f b))) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (1 / deriv f (g (f x))) (f x)) "]}
{"theorem":"âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’ MonotoneOn (deriv f) (Set.Ioi 0) â†’ MonotoneOn (fun x => f x / x) (Set.Ioi 0)","text":"Suppose (a) `f` is continuous for `x â‰¥ 0`, (b) `f'(x)` exists for `x > 0`, (c) `f(0) = 0`, (d) `f'` is monotonically increasing. Put `g(x) = f(x)/x` for `(x > 0)` and prove that `g` is monotonically increasing.","result":true,"gps":[["âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’ MonotoneOn (deriv f) (Set.Ioi 0) â†’ MonotoneOn (fun x => f x / x) (Set.Ioi 0)"],["âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’ f 0 = 0 â†’ Monotone (deriv f) â†’ âˆ€ â¦ƒx y : â„â¦„, 0 < x â†’ x â‰¤ y â†’ f x / x â‰¤ f y / y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        Monotone (deriv f) â†’ âˆ€ â¦ƒx y : â„â¦„, 0 < x â†’ x â‰¤ y â†’ f x / x â‰¤ f y / y ","âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          MonotoneOn (fun x => f x / x) (Set.Ioi 0) ","âˆ€ {f : â„ â†’ â„},\n  (âˆ€ x, 0 â‰¤ x â†’ ContinuousAt f x) â†’\n  (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’\n  f 0 = 0 â†’\n  (âˆ€ x y, 0 < x â†’ x < y â†’ deriv f x â‰¤ deriv f y) â†’\n  âˆ€ â¦ƒx y : â„â¦„,\n    0 < x â†’ x < y â†’ (f x) / x â‰¤ (f y) / y "]}
{"theorem":"âˆ€ {a : â„} {f : â„ â†’ â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      (âˆ€ (x : â„), a < x â†’ |f x| â‰¤ Mâ‚€) â†’\n        (âˆ€ (x : â„), a < x â†’ |deriv f x| â‰¤ Mâ‚) â†’ (âˆ€ (x : â„), a < x â†’ |deriv^[2] f x| â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚","text":"Suppose `a âˆˆ â„^1`, `f` is a twice-differentiable real function on `(a, âˆ)`, and `M_0, M_1, M_2` are the least upper bounds of `|f(x)|`, `|f'(x)|`, `|f''(x)|`, respectively, on `(a, âˆ)`. Prove that `M_1^2 â‰¤ 4 M_0 M_2`.","result":true,"gps":[["âˆ€ {a : â„} {f : â„ â†’ â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      (âˆ€ (x : â„), a < x â†’ |f x| â‰¤ Mâ‚€) â†’\n        (âˆ€ (x : â„), a < x â†’ |deriv f x| â‰¤ Mâ‚) â†’ (âˆ€ (x : â„), a < x â†’ |deriv^[2] f x| â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {a : â„} {f : â„ â†’ â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n      (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n        (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ "]}
{"theorem":"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","text":"Let `X` be a topological space; let `A` be a subset of `X`. Suppose that for each `x âˆˆ A` there is an open set `U` containing `x` such that `U âŠ† A`. Show that `A` is open in `X`.","result":true,"gps":[["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A"],["âˆ€ {X : Type u} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A"],["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, x âˆˆ U âˆ§ IsOpen U âˆ§ U âŠ† A) â†’ IsOpen A"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, x âˆˆ U âˆ§ IsOpen U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x, x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x, x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ","âˆ€ {X : Type u} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A "]}
{"theorem":"{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X","text":"If `T_Î±` is a family of topologies on `X`, show that `âˆ© T_Î±` is a topology on `X`.","result":true,"gps":[["{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X","{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X","{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X","{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X","{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X","{X : Type u} â†’ {Î¹ : Type u_1} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X"],["{X : Type u_1} â†’ {Î¹ : Type u} â†’ (Î¹ â†’ TopologicalSpace X) â†’ TopologicalSpace X"],["{X : Type u_1} â†’ {Î¹ : Type u_2} â†’ {T : Î¹ â†’ TopologicalSpace X} â†’ TopologicalSpace X"],["{X : Type u} â†’ Set (TopologicalSpace X) â†’ TopologicalSpace X"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ","âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  TopologicalSpace X ","âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ","âˆ€ {X : Type u} (T : Set (TopologicalSpace X)),\n  TopologicalSpace X ","âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ","âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ","âˆ€ {X : Type u_1} {Î¹ : Type u} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ","âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ","âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X "]}
{"theorem":"âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X), âˆƒ! Tâ‚€, âˆ€ (i : Î¹), T i â‰¤ Tâ‚€","text":"Let `T_Î±` be a family of topologies on `X`. Show that there is a unique smallest topology on `X` containing all the collections `T_Î±`.","result":true,"gps":[["âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X), âˆƒ! Tâ‚€, âˆ€ (i : Î¹), T i â‰¤ Tâ‚€","âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X}, âˆƒ! Tâ‚€, âˆ€ (i : Î¹), T i â‰¤ Tâ‚€","âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X}, âˆƒ! t, âˆ€ (i : Î¹), T i â‰¤ t"],["âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ t, (âˆ€ (i : Î¹), T i â‰¤ t) âˆ§ âˆ€ (t' : TopologicalSpace X), (âˆ€ (i : Î¹), T i â‰¤ t') â†’ t â‰¤ t'","âˆ€ {X : Type u_1} {Î¹ : Type u_2} {t : Î¹ â†’ TopologicalSpace X},\n  âˆƒ T_inf, (âˆ€ (i : Î¹), t i â‰¤ T_inf) âˆ§ âˆ€ {T : TopologicalSpace X}, (âˆ€ (i : Î¹), t i â‰¤ T) â†’ T_inf â‰¤ T","âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ t, (âˆ€ (i : Î¹), T i â‰¤ t) âˆ§ âˆ€ (t' : TopologicalSpace X), (âˆ€ (i : Î¹), T i â‰¤ t') â†’ t â‰¤ t'"],["âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X}, âˆƒ! _inst, âˆ€ (i : Î¹), T i â‰¤ _inst","âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X), âˆƒ! T_min, âˆ€ (i : Î¹), T i â‰¤ T_min","âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X}, âˆƒ! t, âˆ€ (i : Î¹), T i â‰¤ t"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ t : TopologicalSpace X, (âˆ€ i : Î¹, T i â‰¤ t) âˆ§ âˆ€ t' : TopologicalSpace X, (âˆ€ i : Î¹, T i â‰¤ t') â†’ t â‰¤ t' ","âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! _inst : TopologicalSpace X, âˆ€ (i : Î¹), T i â‰¤ _inst ","âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ","âˆ€ {X : Type u_1} {Î¹ : Type u_2} {t : Î¹ â†’ TopologicalSpace X},\n  âˆƒ T_inf : TopologicalSpace X, (âˆ€ i, t i â‰¤ T_inf) âˆ§ âˆ€ {T : TopologicalSpace X}, (âˆ€ i, t i â‰¤ T) â†’ T_inf â‰¤ T ","âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (T_min : TopologicalSpace X), âˆ€ i, T i â‰¤ T_min ","âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ","âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ t : TopologicalSpace X, (âˆ€ i, T i â‰¤ t) âˆ§ âˆ€ t' : TopologicalSpace X, (âˆ€ i, T i â‰¤ t') â†’ t â‰¤ t' ","âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (t : TopologicalSpace X), âˆ€ i, T i â‰¤ t ","âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (t : TopologicalSpace X), âˆ€ i, T i â‰¤ t "]}
{"theorem":"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, a < b â†’ Â¬b â‰¤ a","text":"Show that the lower limit topology `â„_l` and the `K`-topology `â„_K` are not comparable.","result":true,"gps":[["âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, a < b â†’ Â¬b â‰¤ a"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["not_le_of_gt : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, a < b â†’ Â¬b â‰¤ a "]}
{"theorem":"âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst","text":"A map `f: X â†’ Y` is said to be an open map if for every open set `U` of `X`, the set `f(U)` is open in `Y`. Show that `Ï€â‚: X Ã— Y â†’ X` and `Ï€â‚‚: X Ã— Y â†’ Y` are open maps.","result":true,"gps":[["âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst","âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst"],["âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd","âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd"],["âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst"],["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst"],["âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd"],["âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ","âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst ","âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst ","forall {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ","âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ","âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst "]}
{"theorem":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)","text":"Show that if `U` is open in `X` and `A` is closed in `X`, then `U - A` is open in `X`, and `A - U` is closed in `X`.","result":true,"gps":[["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)"],["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) "]}
{"theorem":"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x)","text":"Let `Y` be an ordered set in the order topology. Let `f, g: X â†’ Y` be continuous. Let `h: X â†’ Y` be the function `h(x) = min {f(x), g(x)}`. Show that `h` is continuous.","result":true,"gps":[["âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x)","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x)","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] (f g : X â†’ Y), Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x)","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x)"],["âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {f g : X â†’ Î±}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x)"],["âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g h : X â†’ Y},\n  (âˆ€ (x : X), h x = min (f x) (g x)) â†’ Continuous f â†’ Continuous g â†’ Continuous h"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ","forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [LinearOrder Y]\n  [OrderTopology Y] (f g : X â†’ Y),\n  Continuous f â†’ Continuous g â†’ Continuous (fun x => min (f x) (g x)) ","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n[inst_3 : OrderTopology Y] {f g h : X â†’ Y},\n(âˆ€ (x : X), h x = min (f x) (g x)) â†’ Continuous f â†’ Continuous g â†’ Continuous h ","âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ","âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) "]}
{"theorem":"âˆ€ {J : Type u_1} {X : J â†’ Type u_2} [inst : (j : J) â†’ TopologicalSpace (X j)] {x : (j : J) â†’ X j}\n  {x_i : â„• â†’ (j : J) â†’ X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j))","text":"Let `x_1, x_2, ...` be a sequence of the points of the product space `Î  X_Î±`. Show that this sequence converges to the point `x` if and only if the sequence `Ï€_Î±(x_i)` converges to `Ï€_Î±(x)` for each `Î±`.","result":true,"gps":[["âˆ€ {J : Type u_1} {X : J â†’ Type u_2} [inst : (j : J) â†’ TopologicalSpace (X j)] {x : (j : J) â†’ X j}\n  {x_i : â„• â†’ (j : J) â†’ X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j))","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i}\n  {x_1 : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i))","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i}\n  {x_seq : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i))","âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {X : Î± â†’ Type u_2}\n  [inst_1 : (a : Î±) â†’ TopologicalSpace (X a)] {x : (a : Î±) â†’ X a} {xÎ¹ : â„• â†’ (a : Î±) â†’ X a},\n  Filter.Tendsto xÎ¹ Filter.atTop (nhds x) â†” âˆ€ (a : Î±), Filter.Tendsto (fun n => xÎ¹ n a) Filter.atTop (nhds (x a))"],["âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {p : â„• â†’ (i : Î¹) â†’ Ï€ i}\n  {x : (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto p Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i))","âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i}\n  {x_i : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i))"],["âˆ€ {Î± : Type u_2} {X : Î± â†’ Type u_1} [inst : (a : Î±) â†’ TopologicalSpace (X a)] {x : (a : Î±) â†’ X a}\n  {xâ‚€ : â„• â†’ (a : Î±) â†’ X a},\n  Filter.Tendsto xâ‚€ Filter.atTop (nhds x) â†” âˆ€ (a : Î±), Filter.Tendsto (fun n => xâ‚€ n a) Filter.atTop (nhds (x a))","âˆ€ {Î¹ : Type u_2} {X : Î¹ â†’ Type u_1} [_i : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i}\n  {x' : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i))"],["âˆ€ {Î± : Type u_3} {Ï€ : Î± â†’ Type u_1} [inst : (i : Î±) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î±) â†’ Ï€ i}\n  {x_seq : â„• â†’ (i : Î±) â†’ Ï€ i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) â†” âˆ€ (i : Î±), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {J : Type u_1} {X : J â†’ Type u_2} [inst : (j : J) â†’ TopologicalSpace (X j)] {x : (j : J) â†’ X j} {x_i : â„• â†’ (j : J) â†’ X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j)) ","âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {p : â„• â†’ Î  i, Ï€ i} {x : Î  i, Ï€ i},\n  Filter.Tendsto p Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i)) ","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i} {x_1 : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i)) ","âˆ€ {Î± : Type u_2} {X : Î± â†’ Type u_1} [inst : (a : Î±) â†’ TopologicalSpace (X a)] {x : (a : Î±) â†’ X a} {xâ‚€ : â„• â†’ (a : Î±) â†’ X a},\n  Filter.Tendsto xâ‚€ Filter.atTop (nhds x) â†” âˆ€ a, Filter.Tendsto (fun n => xâ‚€ n a) Filter.atTop (nhds (x a)) ","âˆ€ {Î± : Type u_3} {Ï€ : Î± â†’ Type u_1} [inst : (i : Î±) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î±) â†’ Ï€ i} {x_seq : â„• â†’ (i : Î±) â†’ Ï€ i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) â†” âˆ€ (i : Î±), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i)) ","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i} {x_seq : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (Î» n => x_seq n i) Filter.atTop (nhds (x i)) ","âˆ€ {Î¹ : Type u_2} {X : Î¹ â†’ Type u_1} [_i : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i} {x' : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i)) ","âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {X : Î± â†’ Type u_2} [inst_1 : (a : Î±) â†’ TopologicalSpace (X a)]\n  {x : (a : Î±) â†’ X a} {xÎ¹ : â„• â†’ (a : Î±) â†’ X a},\n  Filter.Tendsto xÎ¹ Filter.atTop (nhds x) â†” âˆ€ (a : Î±), Filter.Tendsto (fun n => xÎ¹ n a) Filter.atTop (nhds (x a)) ","âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i} {x_i : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i)) "]}
{"theorem":"âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","text":"Define `f_n: [0,1] â†’ â„` by the equation `f_n(x) = x^n`. Show that the sequence `(f_n(x))` converges for each `x âˆˆ [0,1]`.","result":true,"gps":[["âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","â„• â†’ âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ (x : â„), 0 â‰¤ x âˆ§ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ {x : â„}, 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)"],["âˆ€ (x : â„), x âˆˆ [0, 1] â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ (x : â„) (hx : 0 â‰¤ x) (hx' : x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ (n : â„•) (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ (x : â„), 0 â‰¤ x âˆ§ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ (x : â„), x âˆˆ [0, 1] â†’ Filter.Tendsto (fun n => x^n) Filter.atTop (nhds 0) ","âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ {x : â„} (hx : 0 â‰¤ x) (hx' : x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ (x : â„) (hx : x âˆˆ Set.Icc 0 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","forall (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","âˆ€ (x : â„) (hx : x âˆˆ Set.Icc 0 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) "]}
{"theorem":"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","text":"Let `X` be a topological space and let `Y` be a metric space. Let `f_n: X â†’ Y` be a sequence of continuous functions. Let `x_n` be a sequence of points of `X` converging to `x`. Show that if the sequence `(f_n)` converges uniformly to `f`, then `(f_n(x_n))` converges to `f(x)`.","result":true,"gps":[["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {x : X} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ ContinuousAt f x â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))"],["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))"],["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {x : X} {f : X â†’ Y}\n  {f_n : â„• â†’ X â†’ Y} {x_n : â„• â†’ X},\n  Filter.Tendsto x_n Filter.atTop (nhds x) â†’\n    TendstoUniformly f_n f Filter.atTop â†’ Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {fn : â„• â†’ X â†’ Y},\n  TendstoUniformly (fun n x => fn n x) f Filter.atTop â†’\n    âˆ€ {x : X} {xn : â„• â†’ X},\n      Filter.Tendsto xn Filter.atTop (nhds x) â†’ Filter.Tendsto (fun n => fn n (xn n)) Filter.atTop (nhds (f x))"],["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f_n : â„• â†’ X â†’ Y} {f : X â†’ Y}\n  {x_n : â„• â†’ X} {x : X},\n  TendstoUniformly f_n f Filter.atTop â†’\n    Filter.Tendsto x_n Filter.atTop (nhds x) â†’\n      ContinuousAt f x â†’ Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {f_n : â„• â†’ X â†’ Y}\n  {x_n : â„• â†’ X} {x : X},\n  TendstoUniformly (fun n => f_n n) f Filter.atTop â†’\n    Filter.Tendsto x_n Filter.atTop (nhds x) â†’\n      ContinuousAt f x â†’ Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","âˆ€ {X : Type u_1} {Y : Type u_2} [inst : Topol