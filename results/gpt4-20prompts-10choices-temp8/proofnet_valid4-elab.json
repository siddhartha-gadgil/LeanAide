{"total-prompts": 25,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["Define `Î›(n) = log p` if `n` is a power of `p` and zero otherwise. Prove that `Î£_{d | n} Î¼(n / d) log d = Î›(n)`.",
  "Show that there are infinitely many primes congruent to `-1` modulo 6.",
  "Show that if `a` is negative, then `p â‰¡ q (4a)` together with `p âˆ¤ a` imply `(a / p) = (a / q)`.",
  "Suppose `f` is continuous in a region `Î©`. Prove that any two primitives of `f` (if they exist) differ by a constant.",
  "Show that there is no holomorphic function `f` in the unit disc `D` that extends continuously to `âˆ‚D` such that `f(z) = 1/z` for `z âˆˆ âˆ‚D`."],
 "elaborated-prompts":
 [{"theorem": "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
   "some-correct": null,
   "prompt":
   "Show that the equation `7x^3 + 2 = y^3` has no solution in integers.",
   "groups":
   [["âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ {x y : â„¤}, 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3",
     "âˆ€ {x y : â„¤}, 7 * x ^ 3 + 2 â‰  y ^ 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
    "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "no_solution_7x3_plus_2_eq_y3 : âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
    "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "no_solution_7x3_plus_2_eq_y3 : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "âˆ€ {x y : â„¤}, 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "integers_7x3_plus_2_ne_y3 : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
    "forall {x y : â„¤}, 7 * x^3 + 2 â‰  y^3 "]},
  {"theorem":
   "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ IsCoprime n (p * q) â†’ â†‘(n ^ (q - 1)) â‰¡ 1 [ZMOD â†‘p * â†‘q]",
   "some-correct": null,
   "prompt":
   "Let `p` and `q` be distinct odd primes such that `p - 1` divides `q - 1`. If `(n, pq) = 1`, show that `n^(q 1) â‰¡ 1 (mod pq)`.",
   "groups":
   [["âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ IsCoprime n (p * q) â†’ â†‘(n ^ (q - 1)) â‰¡ 1 [ZMOD â†‘p * â†‘q]",
     "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ IsCoprime n (p * q) â†’ â†‘(n ^ (q - 1)) â‰¡ 1 [ZMOD â†‘p * â†‘q]",
     "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ IsCoprime n (p * q) â†’ â†‘(n ^ (q - 1)) â‰¡ 1 [ZMOD â†‘p * â†‘q]",
     "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ âˆ€ {n : â„•}, IsCoprime n (p * q) â†’ â†‘(n ^ (q - 1)) â‰¡ 1 [ZMOD â†‘p * â†‘q]"],
    ["âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘(p * q)]",
     "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘p * â†‘q]",
     "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ âˆ€ {n : â„¤}, IsCoprime n (â†‘p * â†‘q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘p * â†‘q]"],
    ["âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ IsCoprime n (p * q) â†’ â†‘(n ^ (q - 1)) â‰¡ 1 [ZMOD â†‘p * â†‘q]"],
    ["âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ p - 1 âˆ£ q - 1 â†’ âˆ€ {n : â„•}, IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [MOD p * q]"],
    ["âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ p - 1 âˆ£ q - 1 â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘(p * q)]"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
    "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘(p * q)] ",
    "forall {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
    "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (â†‘p * â†‘q)] ",
    "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„•}, IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [MOD (p * q)] ",
    "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (n ^ (q - 1)) â‰¡ 1 [ZMOD (p * q)] ",
    "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘(p * q)] ",
    "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (n ^ (q - 1)) â‰¡ 1 [ZMOD (p * q)] ",
    "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n (â†‘p * â†‘q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (â†‘p * â†‘q)] ",
    "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„•}, IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] "]},
  {"theorem":
   "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ {a : â„•}, IsPrimitiveRoot a p â†” orderOf (-â†‘a) = (p - 1) / 2",
   "some-correct": null,
   "prompt":
   "Consider a prime `p` of the form `4t + 3`. Show that `a` is a primitive root modulo `p` if and only if `-a` has order `(p - 1) / 2`.",
   "groups":
   [["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ {a : â„•}, IsPrimitiveRoot a p â†” orderOf (-â†‘a) = (p - 1) / 2"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), p % 4 = 3 â†’ (IsPrimitiveRoot a p â†” orderOf (-a) = (p - 1) / 2)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), p % 4 = 3 â†’ (is_primitive_root a p â†” order_of (-a) = (p - 1) / 2) ",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ {a : â„•}, IsPrimitiveRoot a p â†” orderOf (-a : ZMod p) = (p - 1) / 2 ",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£),\n  p % 4 = 3 â†’ is_primitive_root a (p - 1) â†” order_of (-a) = (p - 1) / 2 "]},
  {"theorem":
   "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)],\n  p % 2 = 1 â†’ âˆ€ (a : â„•), IsPrimitiveRoot a p â†” âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1",
   "some-correct": null,
   "prompt":
   "Let `p` be an odd prime. Show that `a` is a primitive root modulo `p` if and only if `a^((p - 1) / q) â‰¢ 1 (mod p)` for all prime divisors `q` of `p - 1`.",
   "groups":
   [["âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)],\n  p % 2 = 1 â†’ âˆ€ (a : â„•), IsPrimitiveRoot a p â†” âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•},\n  (a â‰  0 â†’ Nat.gcd a p = 1 â†’ âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ Â¬a ^ ((p - 1) / q) â‰¡ 1 [MOD p]) â†” IsPrimitiveRoot a p"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p},\n  IsPrimitiveRoot a p â†” âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•},\n  (a â‰  0 â†’ âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” IsPrimitiveRoot a p"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)],\n  p % 2 = 1 â†’ âˆ€ {a : ZMod p}, IsPrimitiveRoot a p â†” âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, a â‰  0 â†’ Nat.gcd a p = 1 â†’ (âˆ€ q, Nat.Prime q â†’ q âˆ£ p - 1 â†’ Â¬(a ^ ((p - 1) / q) â‰¡ 1 [MOD p])) â†” IsPrimitiveRoot a p ",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, a â‰  0 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” is_primitive_root a p ",
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a : ZMod p}, IsPrimitiveRoot a p â†” (âˆ€ q : â„•, Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
    "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ (a : â„•), is_primitive_root a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ (p - 1) â†’ a ^ ((p - 1) / q) â‰  1) "]},
  {"theorem": "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
   "some-correct": null,
   "prompt":
   "Show that any prime divisor of `x^4 - x^2 + 1` is congruent to 1 modulo 12.",
   "groups":
   [["âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1",
     "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1"],
    ["âˆ€ {x p : â„•} [inst : Fact (Nat.Prime p)], p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•} [inst : Fact (Nat.Prime p)], p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•} (hp : Nat.Prime p), p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
    "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 "]},
  {"theorem":
   "âˆƒ x1 y1 x2 y2, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ x1 ^ 3 + y1 ^ 3 = 1729",
   "some-correct": null,
   "prompt":
   "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
   "groups":
   [["âˆƒ x1 y1 x2 y2, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ x1 ^ 3 + y1 ^ 3 = 1729"],
    ["âˆƒ a b c d, a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ a â‰  c âˆ§ 0 < a âˆ§ a < b âˆ§ c < d âˆ§ 0 < c âˆ§ a ^ 3 + b ^ 3 = 1729"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["â„•.smallest_two_diff_cube_sum_two_ways : âˆƒ a b c d, a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ a â‰  c âˆ§ 0 < a âˆ§ a < b âˆ§ c < d âˆ§ 0 < c âˆ§ a ^ 3 + b ^ 3 = 1729 ",
    "smallest_1729 : âˆƒ x1 y1 x2 y2, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ x1 ^ 3 + y1 ^ 3 = 1729 "]},
  {"theorem":
   "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ (f x).re = (f x).re) â†’ âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y",
   "some-correct": null,
   "prompt":
   "Suppose that `f` is holomorphic in an open set `Î©`. Prove that if `Re(f)` is constant, then `f` is constant.",
   "groups":
   [["âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ (f x).re = (f x).re) â†’ âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ (f x).re = (f x).re) â†’ âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y "]},
  {"theorem":
   "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {Î© : Set E},\n  IsOpen Î© â†’\n    DifferentiableOn â„‚ f Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ â†‘Complex.abs (f x) = â†‘Complex.abs (f 0)) â†’ âˆ€ (x : E), x âˆˆ Î© â†’ f x = f 0",
   "some-correct": null,
   "prompt":
   "Suppose that `f` is holomorphic in an open set `Î©`. Prove that if `|f|` is constant, then `f` is constant.",
   "groups":
   [["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {Î© : Set E},\n  IsOpen Î© â†’\n    DifferentiableOn â„‚ f Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ â†‘Complex.abs (f x) = â†‘Complex.abs (f 0)) â†’ âˆ€ (x : E), x âˆˆ Î© â†’ f x = f 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {Î© : Set E},\n  IsOpen Î© â†’ DifferentiableOn â„‚ f Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f 0)) â†’ âˆ€ (x : E), x âˆˆ Î© â†’ f x = f 0 "]},
  {"theorem":
   "âˆ€ (z : â„‚), â†‘Complex.abs z = 1 â†’ Summable fun n => z ^ n / (n + 1) ^ 2",
   "some-correct": null,
   "prompt":
   "Prove that the power series `Î£ zn/n^2` converges at every point of the unit circle.",
   "groups":
   [["âˆ€ (z : â„‚), â†‘Complex.abs z = 1 â†’ Summable fun n => z ^ n / (n + 1) ^ 2",
     "âˆ€ (z : â„‚), â†‘Complex.abs z = 1 â†’ Summable fun n => z ^ n / (n + 1) ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (z : â„‚), Complex.abs z = 1 â†’ Summable (Î» n => z ^ n / (â†‘n + 1) ^ 2) ",
    "âˆ€ (z : â„‚), Complex.abs z = 1 â†’ Summable (Î» n => z ^ n / (â†‘n + 1) ^ 2) "]},
  {"theorem":
   "âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’ âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’ âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = z + (Ï• zâ‚€ - zâ‚€)",
   "some-correct": null,
   "prompt":
   "Let `Î©` be a bounded open subset of `â„‚`, and `Ï•: Î© â†’ Î©` a holomorphic function. Prove that if there exists a point `zâ‚€ âˆˆ Î©` such that `Ï•(zâ‚€) = zâ‚€` and `Ï•'(zâ‚€) = 1`, then `Ï•` is linear.",
   "groups":
   [["âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’ âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’ âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = z + (Ï• zâ‚€ - zâ‚€)"],
    ["âˆ€ {Î© : Set â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      âˆ€ {Ï• : â„‚ â†’ â„‚},\n        DifferentiableOn â„‚ Ï• Î© â†’\n          Set.MapsTo Ï• Î© Î© â†’\n            âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’ âˆƒ a, âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + a * (z - zâ‚€)"],
    ["âˆ€ {Î© : Set â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      âˆ€ {Ï• : â„‚ â†’ â„‚},\n        (âˆ€ (z : â„‚), z âˆˆ Î© â†’ AnalyticAt â„‚ Ï• z) â†’\n          âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’ âˆƒ a b, âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = a * z + b"],
    ["âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’ Set.MapsTo Ï• Î© Î© â†’ âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivWithinAt Ï• 1 Î© zâ‚€ â†’ IsLinearMap â„‚ Ï•"],
    ["âˆ€ {Î© : Set â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      âˆ€ {Ï• : â„‚ â†’ â„‚},\n        DifferentiableOn â„‚ Ï• Î© â†’\n          Set.MapsTo Ï• Î© Î© â†’ âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’ âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + (z - zâ‚€)"],
    ["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {Î© : Set â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      âˆ€ {Ï• : â„‚ â†’ â„‚},\n        DifferentiableOn â„‚ Ï• Î© â†’\n          Set.MapsTo Ï• Î© Î© â†’ âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ (Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’ âˆƒ a b, âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = a * z + b)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î© : Set â„‚} (hÎ© : IsOpen Î©) (h_bdd : Metric.Bounded Î©) {Ï• : â„‚ â†’ â„‚},\n  DifferentiableOn â„‚ Ï• Î© â†’\n    Set.MapsTo Ï• Î© Î© â†’\n      âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’ âˆƒ (a : â„‚), âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + a * (z - zâ‚€) ",
    "theorem linear_if_deriv_eq_one\n  {Î© : Set â„‚} (hÎ© : IsOpen Î©) (hbdd : Metric.Bounded Î©) {Ï• : â„‚ â†’ â„‚}\n  (hÏ• : âˆ€ z âˆˆ Î©, AnalyticAt â„‚ Ï• z) {zâ‚€ : â„‚} (hzâ‚€ : zâ‚€ âˆˆ Î©)\n  (hfâ‚ : Ï• zâ‚€ = zâ‚€) (hf' : HasDerivAt Ï• 1 zâ‚€) :\n  âˆƒ (a b : â„‚), âˆ€ z âˆˆ Î©, Ï• z = a * z + b ",
    "âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’\n          âˆƒ (zâ‚€ : â„‚), zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivWithinAt Ï• 1 Î© zâ‚€ â†’ IsLinearMap â„‚ Ï• ",
    "âˆ€ {Î© : Set â„‚},\n  IsOpen Î© â†’\n  Metric.Bounded Î© â†’\n  âˆ€ {Ï• : â„‚ â†’ â„‚},\n    DifferentiableOn â„‚ Ï• Î© â†’ Set.MapsTo Ï• Î© Î© â†’\n      âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’\n        âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + (z - zâ‚€) ",
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {Î© : Set â„‚}, IsOpen Î© â†’ Metric.Bounded Î© â†’\n  âˆ€ {Ï• : â„‚ â†’ â„‚}, DifferentiableOn â„‚ Ï• Î© â†’ Set.MapsTo Ï• Î© Î© â†’\n    âˆƒ zâ‚€ âˆˆ Î©, Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’\n      âˆƒ (a : â„‚) (b : â„‚), âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = a * z + b ",
    "âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’\n          âˆƒ (zâ‚€ : â„‚), zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’\n            âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = z + (Ï• zâ‚€ - zâ‚€) "]},
  {"theorem":
   "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a",
   "some-correct": null,
   "prompt":
   "Show that `âˆ«_{-âˆ}^{âˆ} cos x / (x^2 + a^2) dx = Ï€ e^{-a} / a` for `a > 0`.",
   "groups":
   [["âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a",
     "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a",
     "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a",
     "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) / a ",
    "âˆ€ (a : â„), 0 < a â†’ âˆ« x in Set.Iic âŠ¤, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a ",
    "forall {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * (Real.exp (-a)) / a ",
    "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, (Real.cos x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) / a ",
    "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x^2 + a^2) = Real.pi * rexp (-a) / a "]},
  {"theorem":
   "âˆ« (x : â„) in ?m.14072390, Real.log (Real.sin (Real.pi * x)) = -Real.log 2",
   "some-correct": null,
   "prompt": "Show that `âˆ«_0^1 log(sin Ï€ x) dx = -log 2`.",
   "groups":
   [["âˆ« (x : â„) in ?m.14072390, Real.log (Real.sin (Real.pi * x)) = -Real.log 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x))) = -Real.log 2 "]},
  {"theorem":
   "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  â†‘Complex.abs zâ‚ = 1 â†’\n    zâ‚ â‰  1 â†’\n      â†‘Complex.abs zâ‚‚ = 1 â†’\n        zâ‚‚ â‰  1 â†’\n          â†‘Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ â†‘Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0",
   "some-correct": null,
   "prompt":
   "For `j âˆˆ {1, 2, 3, 4}`, let `z_j` be a complex number with `|z_j| = 1` and `z_j â‰  1`. Prove that `3 - z_1 - z_2 - z_3 - z_4 + z_1 z_2 z_3 z_4 â‰  0`.",
   "groups":
   [["âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  â†‘Complex.abs zâ‚ = 1 â†’\n    zâ‚ â‰  1 â†’\n      â†‘Complex.abs zâ‚‚ = 1 â†’\n        zâ‚‚ â‰  1 â†’\n          â†‘Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ â†‘Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0",
     "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  zâ‚ â‰  1 â†’\n    â†‘Complex.abs zâ‚ = 1 â†’\n      zâ‚‚ â‰  1 â†’\n        â†‘Complex.abs zâ‚‚ = 1 â†’\n          zâ‚ƒ â‰  1 â†’ â†‘Complex.abs zâ‚ƒ = 1 â†’ zâ‚„ â‰  1 â†’ â†‘Complex.abs zâ‚„ = 1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0",
     "âˆ€ (z1 z2 z3 z4 : â„‚),\n  â†‘Complex.abs z1 = 1 â†’\n    z1 â‰  1 â†’\n      â†‘Complex.abs z2 = 1 â†’\n        z2 â‰  1 â†’\n          â†‘Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ â†‘Complex.abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0",
     "âˆ€ {z1 z2 z3 z4 : â„‚},\n  â†‘Complex.abs z1 = 1 â†’\n    z1 â‰  1 â†’\n      â†‘Complex.abs z2 = 1 â†’\n        z2 â‰  1 â†’\n          â†‘Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ â†‘Complex.abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0",
     "âˆ€ {z1 z2 z3 z4 : â„‚},\n  â†‘Complex.abs z1 = 1 â†’\n    z1 â‰  1 â†’\n      â†‘Complex.abs z2 = 1 â†’\n        z2 â‰  1 â†’\n          â†‘Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ â†‘Complex.abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0",
     "âˆ€ (zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚),\n  â†‘Complex.abs zâ‚ = 1 â†’\n    zâ‚ â‰  1 â†’\n      â†‘Complex.abs zâ‚‚ = 1 â†’\n        zâ‚‚ â‰  1 â†’\n          â†‘Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ â†‘Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0"],
    ["âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  â†‘Complex.normSq zâ‚ = 1 â†’\n    zâ‚ â‰  1 â†’\n      â†‘Complex.normSq zâ‚‚ = 1 â†’\n        zâ‚‚ â‰  1 â†’\n          â†‘Complex.normSq zâ‚ƒ = 1 â†’\n            zâ‚ƒ â‰  1 â†’ â†‘Complex.normSq zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0",
     "âˆ€ {z1 z2 z3 z4 : â„‚},\n  z1 â‰  1 â†’\n    z2 â‰  1 â†’\n      z3 â‰  1 â†’\n        z4 â‰  1 â†’\n          â†‘Complex.normSq z1 = 1 â†’\n            â†‘Complex.normSq z2 = 1 â†’\n              â†‘Complex.normSq z3 = 1 â†’ â†‘Complex.normSq z4 = 1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0",
     "âˆ€ {z1 z2 z3 z4 : â„‚},\n  â†‘Complex.normSq z1 = 1 âˆ§ z1 â‰  1 â†’\n    â†‘Complex.normSq z2 = 1 âˆ§ z2 â‰  1 â†’\n      â†‘Complex.normSq z3 = 1 âˆ§ z3 â‰  1 â†’ â†‘Complex.normSq z4 = 1 âˆ§ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0",
     "âˆ€ {z_1 z_2 z_3 z_4 : â„‚},\n  â†‘Complex.normSq z_1 = 1 â†’\n    z_1 â‰  1 â†’\n      â†‘Complex.normSq z_2 = 1 â†’\n        z_2 â‰  1 â†’\n          â†‘Complex.normSq z_3 = 1 â†’\n            z_3 â‰  1 â†’ â†‘Complex.normSq z_4 = 1 â†’ z_4 â‰  1 â†’ 3 - z_1 - z_2 - z_3 - z_4 + z_1 * z_2 * z_3 * z_4 â‰  0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚}, Complex.abs zâ‚ = 1 â†’ zâ‚ â‰  1 â†’ Complex.abs zâ‚‚ = 1 â†’ zâ‚‚ â‰  1 â†’ Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’\n  3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
    "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  zâ‚ â‰  1 â†’ Complex.abs zâ‚ = 1 â†’\n  zâ‚‚ â‰  1 â†’ Complex.abs zâ‚‚ = 1 â†’\n  zâ‚ƒ â‰  1 â†’ Complex.abs zâ‚ƒ = 1 â†’\n  zâ‚„ â‰  1 â†’ Complex.abs zâ‚„ = 1 â†’\n  3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
    "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚}, Complex.normSq zâ‚ = 1 â†’ zâ‚ â‰  1 â†’ Complex.normSq zâ‚‚ = 1 â†’ zâ‚‚ â‰  1 â†’ Complex.normSq zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ Complex.normSq zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
    "âˆ€ {z1 z2 z3 z4 : â„‚}, z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ Complex.normSq z1 = 1 â†’ Complex.normSq z2 = 1 â†’ Complex.normSq z3 = 1 â†’ Complex.normSq z4 = 1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
    "âˆ€ {z1 z2 z3 z4 : â„‚},\n  (Complex.normSq z1 = 1 âˆ§ z1 â‰  1) â†’\n  (Complex.normSq z2 = 1 âˆ§ z2 â‰  1) â†’\n  (Complex.normSq z3 = 1 âˆ§ z3 â‰  1) â†’\n  (Complex.normSq z4 = 1 âˆ§ z4 â‰  1) â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
    "âˆ€ (z1 z2 z3 z4 : â„‚),\n  Complex.abs z1 = 1 â†’ z1 â‰  1 â†’\n  Complex.abs z2 = 1 â†’ z2 â‰  1 â†’\n  Complex.abs z3 = 1 â†’ z3 â‰  1 â†’\n  Complex.abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
    "âˆ€ {z1 z2 z3 z4 : â„‚}, Complex.abs z1 = 1 â†’ z1 â‰  1 â†’ Complex.abs z2 = 1 â†’ z2 â‰  1 â†’ Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ Complex.abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
    "âˆ€ {z1 z2 z3 z4 : â„‚}, Complex.abs z1 = 1 â†’ z1 â‰  1 â†’ Complex.abs z2 = 1 â†’ z2 â‰  1 â†’ Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ Complex.abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
    "âˆ€ (zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚), Complex.abs zâ‚ = 1 â†’ zâ‚ â‰  1 â†’ Complex.abs zâ‚‚ = 1 â†’ zâ‚‚ â‰  1 â†’ Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
    "âˆ€ {z_1 z_2 z_3 z_4 : â„‚}, Complex.normSq z_1 = 1 â†’ z_1 â‰  1 â†’ Complex.normSq z_2 = 1 â†’ z_2 â‰  1 â†’ Complex.normSq z_3 = 1 â†’ z_3 â‰  1 â†’ Complex.normSq z_4 = 1 â†’ z_4 â‰  1 â†’ 3 - z_1 - z_2 - z_3 - z_4 + z_1 * z_2 * z_3 * z_4 â‰  0 "]},
  {"theorem":
   "âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), ?m.27834600 z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.Chebyshev.T â„‚ n) z",
   "some-correct": null,
   "prompt":
   "Let `n` be a positive integer, and let `f_n(z) = n + (n - 1)z + (n - 2)z^2 + â‹¯ + z^(n - 1)`. Prove that `f_n` has no roots in the closed unit disk `{z âˆˆ â„‚: |z| â‰¤ 1}`.",
   "groups":
   [["âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), ?m.27834600 z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.Chebyshev.T â„‚ n) z"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.Chebyshev.T â„‚ n) z "]},
  {"theorem":
   "âˆ€ (f : â„• â†’ â„š),\n  (âˆ€ (n : â„•), f n = 0 âˆ¨ f n = 1) â†’\n    âˆ‘' (n : â„•), f n * (2 / 3) ^ n = 3 / 2 â†’ Irrational (âˆ‘' (n : â„•), â†‘(f n) * (1 / 2) ^ â†‘n)",
   "some-correct": null,
   "prompt":
   "Suppose that `f(x) = Î£ c_i x^i` is a power series for which each coefficient `c_i` is 0 or 1. Show that if `f(2/3) = 3/2`, then `f(1/2)` must be irrational.",
   "groups":
   [["âˆ€ (f : â„• â†’ â„š),\n  (âˆ€ (n : â„•), f n = 0 âˆ¨ f n = 1) â†’\n    âˆ‘' (n : â„•), f n * (2 / 3) ^ n = 3 / 2 â†’ Irrational (âˆ‘' (n : â„•), â†‘(f n) * (1 / 2) ^ â†‘n)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall (f : â„• â†’ â„š) (h : âˆ€ n, f n = 0 âˆ¨ f n = 1),\n  ((âˆ‘' (n : â„•), f n * (2/3)^n) = 3/2) â†’ Irrational (âˆ‘' (n : â„•), f n * (1/2)^n) "]},
  {"theorem":
   "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
   "some-correct": null,
   "prompt":
   "Prove that for each positive integer `n`, the number `10^(10^(10^n)) + 10^(10^n) + 10^n - 1` is not prime.",
   "groups":
   [["âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)",
     "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), (0 < n) â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
    "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
    "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
    "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
    "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
    "âˆ€ {n : â„•}, 0 < n â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
    "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
    "âˆ€ (n : â„•), n > 0 â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
    "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
    "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) "]},
  {"theorem":
   "âˆ€ (N : â„•), âˆƒ n, N < n âˆ§ âˆƒ x1 y1 x2 y2 x3 y3, n = x1 ^ 2 + y1 ^ 2 âˆ§ n + 1 = x2 ^ 2 + y2 ^ 2 âˆ§ n + 2 = x3 ^ 2 + y3 ^ 2",
   "some-correct": null,
   "prompt":
   "Prove that there exist infinitely many integers `n` such that `n, n + 1, n + 2` are each the sum of the squares of two integers.",
   "groups":
   [["âˆ€ (N : â„•), âˆƒ n, N < n âˆ§ âˆƒ x1 y1 x2 y2 x3 y3, n = x1 ^ 2 + y1 ^ 2 âˆ§ n + 1 = x2 ^ 2 + y2 ^ 2 âˆ§ n + 2 = x3 ^ 2 + y3 ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆƒá¶  (n : â„¤) in Filter.atTop, (âˆƒ x y, n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, n + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, n + 2 = r ^ 2 + s ^ 2) ",
    "âˆƒ (f : â„• â†’ â„•), âˆ€ (n : â„•), (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f (n + 1) = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f (n + 2) = x ^ 2 + y ^ 2) ",
    "âˆƒ f : â„• â†’ â„•, StrictMono f âˆ§ âˆ€ n, (âˆƒ xâ‚ yâ‚, f n = xâ‚ ^ 2 + yâ‚ ^ 2) âˆ§ (âˆƒ xâ‚‚ yâ‚‚, f n + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2) âˆ§ (âˆƒ xâ‚ƒ yâ‚ƒ, f n + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
    "âˆƒá¶  (n : â„¤) in Filter.atTop, (âˆƒ a b, n = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, n + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, n + 2 = e ^ 2 + f ^ 2) ",
    "âˆƒ (f : â„• â†’ â„•), âˆ€ N, âˆƒ n, N â‰¤ n âˆ§ (âˆƒ x y, n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, n + 1 = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, n + 2 = x ^ 2 + y ^ 2) ",
    "âˆƒ f : â„• â†’ â„•, âˆ€ n : â„•, (âˆƒ a b, (f n) = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, (f n) + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, (f n) + 2 = e ^ 2 + f ^ 2) ",
    "âˆ€ (N : â„¤), âˆƒ n, N â‰¤ n âˆ§ (âˆƒ xâ‚ yâ‚ xâ‚‚ yâ‚‚ xâ‚ƒ yâ‚ƒ : â„¤, n = xâ‚ ^ 2 + yâ‚ ^ 2 âˆ§ n + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2 âˆ§ n + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
    "âˆ€ (N : â„•), âˆƒ n : â„•, N < n âˆ§ (âˆƒ x1 y1 x2 y2 x3 y3 : â„•, n = x1 ^ 2 + y1 ^ 2 âˆ§ n + 1 = x2 ^ 2 + y2 ^ 2 âˆ§ n + 2 = x3 ^ 2 + y3 ^ 2) ",
    "âˆƒá¶  (n : â„¤) in Filter.atTop, (âˆƒ a b, n = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, n + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, n + 2 = e ^ 2 + f ^ 2) ",
    "âˆƒ (f : â„• â†’ â„•), StrictMono f âˆ§ âˆ€ (n : â„•), (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f n + 1 = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f n + 2 = x ^ 2 + y ^ 2) "]},
  {"theorem":
   "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n    (âˆ€ {x : â„}, DifferentiableAt â„ (deriv f) x) â†’\n      Continuous (deriv (deriv (deriv f))) â†’\n        âˆƒ a, deriv (deriv (deriv f)) a * a = 2 * deriv (deriv f) a - 2 * f a + 4 * deriv f a - 6 * a",
   "some-correct": null,
   "prompt":
   "Let `f` be a real function on the real line with continuous third derivative. Prove that there exists a point `a` such that...",
   "groups":
   [["âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n    (âˆ€ {x : â„}, DifferentiableAt â„ (deriv f) x) â†’\n      Continuous (deriv (deriv (deriv f))) â†’\n        âˆƒ a, deriv (deriv (deriv f)) a * a = 2 * deriv (deriv f) a - 2 * f a + 4 * deriv f a - 6 * a"],
    ["âˆ€ {f : â„ â†’ â„}, (Differentiable â„ f âˆ§ âˆ€ (x : â„), deriv^[3] f x = 0) â†’ âˆƒ a, deriv f a = 0 âˆ§ deriv^[2] f a = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {f : â„ â†’ â„},\n  (Differentiable â„ f âˆ§ âˆ€ (x : â„), (deriv^[3] f) x = 0) â†’\n    âˆƒ a, deriv f a = 0 âˆ§ deriv^[2] f a = 0 ",
    "âˆ€ {f : â„ â†’ â„} (hderiv : âˆ€ x, DifferentiableAt â„ (deriv^[3]) x) (x y z : â„),\n  âˆƒ a, deriv^[3] a (x * y * z) = (x * y * z) * (deriv^[3] a x + deriv^[3] a y + deriv^[3] a z) ",
    "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n  (âˆ€ {x : â„}, DifferentiableAt â„ (deriv f) x) â†’\n  Continuous (deriv (deriv (deriv f))) â†’\n  âˆƒ a, deriv (deriv (deriv f)) a * a = 2 * (deriv (deriv f) a) - 2 * f a + 4 * deriv f a - 6 * a ",
    "âˆ€ {f : â„ â†’ â„},\n  Continuous (deriv^[3] f) â†’\n  âˆƒ a, deriv^[3] f a = 0 âˆ§ deriv f a = 0 âˆ§ deriv^[2] f a = 0 ",
    "âˆ€ (f : â„ â†’ â„),\n  Continuous (deriv^[3] f) â†’\n  âˆƒ a, IsLocalExtr (deriv^[2] f) a âˆ§ deriv (deriv f) a = 0 âˆ§ deriv^[3] f a â‰  0 "]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds a) â†’ (q = fun k => p (f k)) â†’ Filter.Tendsto q Filter.atTop (nhds a)",
   "some-correct": null,
   "prompt":
   "Let `(p_n)` be a sequence and `f: â„• â†’ â„•`. The sequence `(q_k)_{k âˆˆ â„•}` with `q_k = p_{f(k)}` is called a rearrangement of `(p_n)`. Show that if `f` is an injection, the limit of a sequence is unaffected by rearrangement.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds a) â†’ (q = fun k => p (f k)) â†’ Filter.Tendsto q Filter.atTop (nhds a)"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n    (âˆ€ (k : â„•), q k = p (f k)) â†’ (Filter.Tendsto p Filter.atTop (nhds a) â†” Filter.Tendsto q Filter.atTop (nhds a))"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a : Î±} {f : â„• â†’ â„•}\n  {p : â„• â†’ Î±},\n  Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => p (f n)) Filter.atTop (nhds a)"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  (Function.Injective f â†’ âˆƒ a, Filter.Tendsto p Filter.atTop (nhds a)) â†”\n    âˆƒ a, Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds a)"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’\n    âˆ€ (l : Î±), Filter.Tendsto p Filter.atTop (nhds l) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n  (âˆ€ k, q k = p (f k)) â†’ (Filter.Tendsto p Filter.atTop (nhds a) â†” Filter.Tendsto q Filter.atTop (nhds a)) ",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a : Î±} {f : â„• â†’ â„•}\n  {p : â„• â†’ Î±},\n    Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds a) â†’\n    Filter.Tendsto (fun n => p (f n)) Filter.atTop (nhds a) ",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’\n  (âˆƒ a : Î±, Filter.Tendsto p Filter.atTop (nhds a)) â†”\n  (âˆƒ a : Î±, Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds a)) ",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’\n    (âˆ€ l, Filter.Tendsto p Filter.atTop (nhds l) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l)) ",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n  Filter.Tendsto p Filter.atTop (nhds a) â†’\n  (q = fun k => p (f k)) â†’\n  Filter.Tendsto q Filter.atTop (nhds a) "]},
  {"theorem":
   "âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ f,\n    (âˆ€ (U : Set M), IsOpen U â†’ IsClosed (f U)) âˆ§\n      (âˆ€ (K : Set M), IsClosed K â†’ IsOpen (f K)) âˆ§\n        (âˆ€ (Uâ‚ Uâ‚‚ : Set M), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ f Uâ‚ = f Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) âˆ§\n          âˆ€ (Kâ‚ Kâ‚‚ : Set M), IsClosed Kâ‚ â†’ IsClosed Kâ‚‚ â†’ f Kâ‚ = f Kâ‚‚ â†’ Kâ‚ = Kâ‚‚",
   "some-correct": null,
   "prompt":
   "Let `ğ’¯` be the collection of open subsets of a metric space `M`, and `ğ’¦` the collection of closed subsets. Show that there is a bijection from `ğ’¯` onto `ğ’¦`.",
   "groups":
   [["âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ f,\n    (âˆ€ (U : Set M), IsOpen U â†’ IsClosed (f U)) âˆ§\n      (âˆ€ (K : Set M), IsClosed K â†’ IsOpen (f K)) âˆ§\n        (âˆ€ (Uâ‚ Uâ‚‚ : Set M), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ f Uâ‚ = f Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) âˆ§\n          âˆ€ (Kâ‚ Kâ‚‚ : Set M), IsClosed Kâ‚ â†’ IsClosed Kâ‚‚ â†’ f Kâ‚ = f Kâ‚‚ â†’ Kâ‚ = Kâ‚‚"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ (f : Set M â†’ Set M), (âˆ€ (U : Set M), IsOpen U â†’ IsClosed (f U)) âˆ§ (âˆ€ (K : Set M), IsClosed K â†’ IsOpen (f K)) âˆ§\n    (âˆ€ (Uâ‚ Uâ‚‚ : Set M), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ f Uâ‚ = f Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) âˆ§\n    (âˆ€ (Kâ‚ Kâ‚‚ : Set M), IsClosed Kâ‚ â†’ IsClosed Kâ‚‚ â†’ f Kâ‚ = f Kâ‚‚ â†’ Kâ‚ = Kâ‚‚) "]}],
 "elaborated": 20}