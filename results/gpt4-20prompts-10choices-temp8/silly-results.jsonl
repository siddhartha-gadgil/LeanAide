{"docString": "Every prime number is `2` or odd.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1 :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- Every prime number is `2` or odd. -/\ntheorem", "choices": ["âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 "]}
{"docString": "There are infinitely many odd natural numbers.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\": \"âˆ€ (n : â„•), PGame.Numeric â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\",\n  \"isProp\": true,\n  \"docString\": \"Ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem âˆ€ (n : â„•), PGame.Numeric â†‘n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- Ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b} :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤ :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- There are infinitely many odd natural numbers. -/\ntheorem", "choices": ["Filter.frequently (fun n => Odd n) Filter.atTop ", "Set.Infinite {n : â„• | Odd n} ", "Filter.eventually (fun a => Odd a) Filter.atTop ", "Set.Infinite {n : â„• | Odd n} ", "Set.Infinite {n : â„• | Odd n} ", "Set.Infinite {x : â„• | Odd x} ", "Filter.Frequently (fun m => Odd m) Filter.atTop ", "âˆƒá¶  (m : â„•) in Filter.atTop, Odd m ", "Filter.frequently (fun n => Odd n) Filter.atTop ", "Set.Infinite {n : â„• | Odd n} "]}
{"docString": "The smallest odd prime is `3`.", "prompts": "[{\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    Odd p â†’\\n      âˆ€ {x y : â„¤},\\n        â†‘p âˆ£ x - y â†’\\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"theorem\": \"âˆ€ (n : â„•), 3 âˆ£ n â†” 3 âˆ£ List.sum (Nat.digits 10 n)\",\n  \"isProp\": true,\n  \"docString\": \"**Divisibility by 3 Rule** \"},\n {\"theorem\": \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 0 R = 1\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth cyclotomic polyomial is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"}]\n", "prompt_cons": "/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    Odd p â†’\n      âˆ€ {x y : â„¤},\n        â†‘p âˆ£ x - y â†’\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1 :=\n\n/-- **Divisibility by 3 Rule** -/\ntheorem âˆ€ (n : â„•), 3 âˆ£ n â†” 3 âˆ£ List.sum (Nat.digits 10 n) :=\n\n/-- The zeroth cyclotomic polyomial is `1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 0 R = 1 :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- The smallest odd prime is `3`. -/\ntheorem", "choices": ["Nat.Prime.min_odd_prime_is_3 : Nat.Prime 3 âˆ§ âˆ€ (n : â„•), Nat.Prime n â†’ n % 2 = 1 â†’ 3 â‰¤ n ", "Nat.minOddPrime 0 = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_fac_odd_prime : âˆ€ {p : â„•}, Nat.Prime p â†’ p % 2 = 1 â†’ p = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_fac_eq 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime = 3 "]}
{"docString": "There are infinitely many odd prime numbers.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    Odd p â†’\\n      âˆ€ {x y : â„¤},\\n        â†‘p âˆ£ x - y â†’\\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    Odd p â†’\n      âˆ€ {x y : â„¤},\n        â†‘p âˆ£ x - y â†’\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ FermatPsp n 1 :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤ :=\n\n/-- There are infinitely many odd prime numbers. -/\ntheorem", "choices": ["Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p : â„• | Nat.Prime p âˆ§ Nat.Odd p} "]}
{"docString": "If a vector space has dimension `2` then it is finite dimensional.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x âˆˆ AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x âˆˆ vectorSpan k (insert p â†‘s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ð•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ð•œ F]\\n  [inst_10 : FiniteDimensional ð•œ E] [inst_11 : FiniteDimensional ð•œ F], FiniteDimensional ð•œ (E â†’L[ð•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [hnorm : NontriviallyNormedField ð•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ð•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ð•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ð•œ F] [inst_10 : CompleteSpace ð•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional ð•œ E] [inst_14 : FiniteDimensional ð•œ F],\\n  Nonempty (E â‰ƒL[ð•œ] F) â†” FiniteDimensional.finrank ð•œ E = FiniteDimensional.finrank ð•œ F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Coplanar k s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of coplanar points is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ð•œ : Type u_1} [inst_1 : Field ð•œ] [inst_2 : Module ð•œ M] (f : M â†’â‚—[ð•œ] M),\\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ð•œ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    â†‘(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹ :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\n  [inst_4 : FiniteDimensional k { x // x âˆˆ AffineSubspace.direction s }] (p : P),\n  FiniteDimensional k { x // x âˆˆ vectorSpan k (insert p â†‘s) } :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ð•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ð•œ F]\n  [inst_10 : FiniteDimensional ð•œ E] [inst_11 : FiniteDimensional ð•œ F], FiniteDimensional ð•œ (E â†’L[ð•œ] F) :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem âˆ€ {ð•œ : Type u} [hnorm : NontriviallyNormedField ð•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ð•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ð•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ð•œ F] [inst_10 : CompleteSpace ð•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional ð•œ E] [inst_14 : FiniteDimensional ð•œ F],\n  Nonempty (E â‰ƒL[ð•œ] F) â†” FiniteDimensional.finrank ð•œ E = FiniteDimensional.finrank ð•œ F :=\n\n/-- The `vectorSpan` of coplanar points is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Coplanar k s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ð•œ : Type u_1} [inst_1 : Field ð•œ] [inst_2 : Module ð•œ M] (f : M â†’â‚—[ð•œ] M),\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ð•œ M :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    â†‘(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- If a vector space has dimension `2` then it is finite dimensional. -/\ntheorem", "choices": ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V "]}
{"docString": "Every field is a division ring.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (â†‘f (MulOpposite.unop (â†‘f x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  (x : K), â†‘(algebraMap K L) x âˆˆ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"An intermediate field contains the image of the smaller field. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalSeminormedRing Î±], TopologicalRing Î±\",\n  \"isProp\": true,\n  \"docString\": \"A seminormed ring is a topological ring. \"}]\n", "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î± :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- A subfield is closed under division. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/-- A subring contains the ring's 1. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s :=\n\n/-- A subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S :=\n\n/-- Every ring involution must be its own inverse -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (â†‘f (MulOpposite.unop (â†‘f x))) = x :=\n\n/-- An intermediate field contains the image of the smaller field. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  (x : K), â†‘(algebraMap K L) x âˆˆ S :=\n\n/-- A seminormed ring is a topological ring. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NonUnitalSeminormedRing Î±], TopologicalRing Î± :=\n\n/-- Every field is a division ring. -/\ntheorem", "choices": ["âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u} [inst : Field K], DivisionRing K ", "forall (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u} [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u} [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u} [inst : Field K], DivisionRing K "]}
{"docString": "If a space has dimension `2` then it is finite dimensional.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ð•œ : Type u_1} [inst_1 : Field ð•œ] [inst_2 : Module ð•œ M] (f : M â†’â‚—[ð•œ] M),\\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ð•œ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ð•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ð•œ F]\\n  [inst_10 : FiniteDimensional ð•œ E] [inst_11 : FiniteDimensional ð•œ F], FiniteDimensional ð•œ (E â†’L[ð•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]\\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚],\\n  (M â‰ƒâ‚—[R] Mâ‚‚) â†’ FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : Finite Î¹]\\n  [inst_2 : âˆ€ (i : Î¹), DiscreteTopology (Ï€ i)], DiscreteTopology ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"A finite product of discrete spaces is discrete. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V], 0 < FiniteDimensional.finrank K V â†’ Nontrivial V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite dimensional space is nontrivial if it has positive `finrank`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] [inst : T2Space Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"Spaces that are both Noetherian and Hausdorff are finite. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V], 0 < FiniteDimensional.finrank K V â†” âˆƒ x, x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite dimensional space has positive `finrank` iff it has a nonzero element. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A â†’ FiniteDimensional K { x // x âˆˆ Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ð•œ : Type u_1} [inst_1 : Field ð•œ] [inst_2 : Module ð•œ M] (f : M â†’â‚—[ð•œ] M),\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ð•œ M :=\n\n/-- A compact discrete space is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î± :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ð•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ð•œ F]\n  [inst_10 : FiniteDimensional ð•œ E] [inst_11 : FiniteDimensional ð•œ F], FiniteDimensional ð•œ (E â†’L[ð•œ] F) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup Mâ‚‚]\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚],\n  (M â‰ƒâ‚—[R] Mâ‚‚) â†’ FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚ :=\n\n/-- A finite product of discrete spaces is discrete. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : Finite Î¹]\n  [inst_2 : âˆ€ (i : Î¹), DiscreteTopology (Ï€ i)], DiscreteTopology ((i : Î¹) â†’ Ï€ i) :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V], 0 < FiniteDimensional.finrank K V â†’ Nontrivial V :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- Spaces that are both Noetherian and Hausdorff are finite. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] [inst : T2Space Î±], Finite Î± :=\n\n/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], 0 < FiniteDimensional.finrank K V â†” âˆƒ x, x â‰  0 :=\n\n/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem âˆ€ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\n  Set.Finite A â†’ FiniteDimensional K { x // x âˆˆ Submodule.span K A } :=\n\n/-- If a space has dimension `2` then it is finite dimensional. -/\ntheorem", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V "]}
{"docString": "Every natural number has a successor.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ (a : Ordinal.{u}), âˆƒ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\",\n  \"isProp\": true,\n  \"docString\": \"Every ordinal has a fundamental sequence. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : â„•),\\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from â„• to a graded semiring respects successors.\"},\n {\"theorem\": \"âˆ€ {n : â„•+}, n â‰  1 â†’ âˆƒ k, n = k + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n : â„•+` is different from `1`, then it is the successor of some `k : â„•+`. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•}, 0 âˆˆ S â†’ (âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) â†’ âˆ€ (n : â„•), n âˆˆ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset of `â„•` containing zero and closed under `Nat.succ` contains all of `â„•`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), PGame.Numeric â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ {n k : â„•} {S : Set â„•}, k âˆˆ S â†’ (âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) â†’ k â‰¤ n â†’ n âˆˆ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset of `â„•` containing `k : â„•` and closed under `Nat.succ` contains every `n â‰¥ k`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {x y z : M}, y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural number powers of an element of a monoid is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Every ordinal has a fundamental sequence. -/\ntheorem âˆ€ (a : Ordinal.{u}), âˆƒ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The canonical map from â„• to a graded semiring respects successors. -/\ntheorem âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\n  [self : DirectSum.GSemiring A] (n : â„•),\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one :=\n\n/-- If `n : â„•+` is different from `1`, then it is the successor of some `k : â„•+`. -/\ntheorem âˆ€ {n : â„•+}, n â‰  1 â†’ âˆƒ k, n = k + 1 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l :=\n\n/-- A subset of `â„•` containing zero and closed under `Nat.succ` contains all of `â„•`. -/\ntheorem âˆ€ {S : Set â„•}, 0 âˆˆ S â†’ (âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) â†’ âˆ€ (n : â„•), n âˆˆ S :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem âˆ€ (n : â„•), PGame.Numeric â†‘n :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- A subset of `â„•` containing `k : â„•` and closed under `Nat.succ` contains every `n â‰¥ k`. -/\ntheorem âˆ€ {n k : â„•} {S : Set â„•}, k âˆˆ S â†’ (âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) â†’ k â‰¤ n â†’ n âˆˆ S :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {x y z : M}, y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- Every natural number has a successor. -/\ntheorem", "choices": ["âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ (m : â„•), m = n + 1 ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ (m : â„•), m = n + 1 "]}
{"docString": "Every natural number is less than its successor.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [self : CompleteLattice Î±] (x : Î±), x â‰¤ âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"Any element is less than the top one. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b â‰¥ 2 \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [self : ZeroLEOneClass Î±], 0 â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Zero is less than or equal to one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ (x : â„•), x âˆˆ l â†’ x < b) â†’ Nat.ofDigits b l < b ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b is less than b^n if b > 1 \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ (b o : Ordinal.{u_1}), List.Sorted (fun x x_1 => x > x_1) (List.map Prod.fst (Ordinal.CNF b o))\",\n  \"isProp\": true,\n  \"docString\": \"The exponents of the Cantor normal form are decreasing. \"},\n {\"theorem\":\n  \"âˆ€ {b o : Ordinal.{u}}, 1 < b â†’ âˆ€ {x : Ordinal.{u} Ã— Ordinal.{u}}, x âˆˆ Ordinal.CNF b o â†’ x.snd < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every coefficient in the Cantor normal form `CNF b o` is less than `b`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LE Î±] [self : NoBotOrder Î±] (a : Î±), âˆƒ b, Â¬a â‰¤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For each term `a`, there is some `b` which is either incomparable or strictly smaller. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (self : ClosureOperator Î±) (x : Î±), x â‰¤ â†‘self.toOrderHom x\",\n  \"isProp\": true,\n  \"docString\": \"An element is less than or equal its closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"}]\n", "prompt_cons": "/-- Any element of a set is less than the set supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- Any element is less than the top one. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteLattice Î±] (x : Î±), x â‰¤ âŠ¤ :=\n\n/-- The digits in the base b expansion of n are all less than b, if b â‰¥ 2 -/\ntheorem âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- Zero is less than or equal to one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [self : ZeroLEOneClass Î±], 0 â‰¤ 1 :=\n\n/-- A finite set is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- an n-digit number in base b is less than b^n if b > 1 -/\ntheorem âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ (x : â„•), x âˆˆ l â†’ x < b) â†’ Nat.ofDigits b l < b ^ List.length l :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- The exponents of the Cantor normal form are decreasing. -/\ntheorem âˆ€ (b o : Ordinal.{u_1}), List.Sorted (fun x x_1 => x > x_1) (List.map Prod.fst (Ordinal.CNF b o)) :=\n\n/-- Every coefficient in the Cantor normal form `CNF b o` is less than `b`. -/\ntheorem âˆ€ {b o : Ordinal.{u}}, 1 < b â†’ âˆ€ {x : Ordinal.{u} Ã— Ordinal.{u}}, x âˆˆ Ordinal.CNF b o â†’ x.snd < b :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- For each term `a`, there is some `b` which is either incomparable or strictly smaller. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LE Î±] [self : NoBotOrder Î±] (a : Î±), âˆƒ b, Â¬a â‰¤ b :=\n\n/-- An element is less than or equal its closure -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (self : ClosureOperator Î±) (x : Î±), x â‰¤ â†‘self.toOrderHom x :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a :=\n\n/-- Every natural number is less than its successor. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, n < n + 1 ", "âˆ€ (n : â„•), n < n + 1 ", "âˆ€ {n : â„•}, n < n + 1 ", "âˆ€ n : â„•, n < n + 1 ", "âˆ€ (n : â„•), n < n + 1 ", "âˆ€ {n : â„•}, n < Nat.succ n ", "âˆ€ {n : â„•}, n < Nat.succ n ", "âˆ€ {n : â„•}, n < n + 1 ", "âˆ€ (n : â„•), n < n.succ ", "âˆ€ {n : â„•}, n < n + 1 "]}
{"docString": "Every set is Lebesgue measurable.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\\n  âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ â†‘â†‘Î¼ t = â†‘â†‘Î¼ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\\n  OpensMeasurableSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„}, Measurable f â†’ MeasurableSet {p | p.snd = f p.fst}\",\n  \"isProp\": true,\n  \"docString\": \"The graph of a measurable function is a measurable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt ð•œ f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_3) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)},\\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : SeminormedRing ð•œ] [inst_1 : SMul ð•œ E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E}, sâ‚ âŠ† sâ‚‚ â†’ Bornology.IsVonNBounded ð•œ sâ‚‚ â†’ Bornology.IsVonNBounded ð•œ sâ‚\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of bounded sets are bounded. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : CompactSpace Î±], Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, all sets are bounded \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_2 : MeasureTheory.SigmaFinite Î¼] {f : Î± Ã— Î² â†’ ENNReal},\\n  Measurable f â†’ Measurable fun y => âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\\nthe symmetric version of Tonelli's theorem is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²}\\n  [inst_2 : MeasureTheory.SigmaFinite Î½] {f : Î± Ã— Î² â†’ ENNReal},\\n  Measurable f â†’ Measurable fun x => âˆ«â» (y : Î²), f (x, y) âˆ‚Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\\nTonelli's theorem is measurable. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {f : Î± â†’ Î²},\\n  MeasurableEmbedding f â†’ âˆ€ â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ MeasurableSet (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a measurable set under a measurable embedding is a measurable set. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) {K : Set F},\\n  IsComplete K â†’ MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function, with derivative in a given complete\\nset, is Borel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {f g : Î± â†’ â„} {s : Set Î±}\\n  [inst_1 : MeasureTheory.SigmaFinite Î¼],\\n  AEMeasurable f â†’\\n    AEMeasurable g â†’\\n      MeasurableSet s â†’\\n        â†‘â†‘(MeasureTheory.Measure.prod Î¼ MeasureTheory.volume) (regionBetween f g s) =\\n          âˆ«â» (y : Î±) in s, ENNReal.ofReal ((g - f) y) âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"The volume of the region between two almost everywhere measurable functions on a measurable set\\ncan be represented as a Lebesgue integral. \"}]\n", "prompt_cons": "/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼) :=\n\n/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For every set there exists a measurable superset of the same measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ â†‘â†‘Î¼ t = â†‘â†‘Î¼ s :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  OpensMeasurableSpace Î± :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s :=\n\n/-- The graph of a measurable function is a measurable set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„}, Measurable f â†’ MeasurableSet {p | p.snd = f p.fst} :=\n\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt ð•œ f x} :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_3) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)},\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K} :=\n\n/-- Subsets of bounded sets are bounded. -/\ntheorem âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : SeminormedRing ð•œ] [inst_1 : SMul ð•œ E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E}, sâ‚ âŠ† sâ‚‚ â†’ Bornology.IsVonNBounded ð•œ sâ‚‚ â†’ Bornology.IsVonNBounded ð•œ sâ‚ :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- In a compact space, all sets are bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : CompactSpace Î±], Metric.Bounded s :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.SigmaFinite Î¼] {f : Î± Ã— Î² â†’ ENNReal},\n  Measurable f â†’ Measurable fun y => âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nTonelli's theorem is measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²}\n  [inst_2 : MeasureTheory.SigmaFinite Î½] {f : Î± Ã— Î² â†’ ENNReal},\n  Measurable f â†’ Measurable fun x => âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ :=\n\n/-- In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume :=\n\n/-- The image of a measurable set under a measurable embedding is a measurable set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {f : Î± â†’ Î²},\n  MeasurableEmbedding f â†’ âˆ€ â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ MeasurableSet (f '' s) :=\n\n/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) {K : Set F},\n  IsComplete K â†’ MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K} :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- The volume of the region between two almost everywhere measurable functions on a measurable set\ncan be represented as a Lebesgue integral. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {f g : Î± â†’ â„} {s : Set Î±}\n  [inst_1 : MeasureTheory.SigmaFinite Î¼],\n  AEMeasurable f â†’\n    AEMeasurable g â†’\n      MeasurableSet s â†’\n        â†‘â†‘(MeasureTheory.Measure.prod Î¼ MeasureTheory.volume) (regionBetween f g s) =\n          âˆ«â» (y : Î±) in s, ENNReal.ofReal ((g - f) y) âˆ‚Î¼ :=\n\n/-- Every set is Lebesgue measurable. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], MeasurableSet (Set Î±) ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], LebesgueMeasurableSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : BorelSpace Î±], MeasurableSet Î± ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], âˆ€ s : Set Î±, MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], IsComplete (Set Î±) ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], (inst : MeasurableSpace Î±).measurable_set' Set.Univ ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : BorelSpace Î±], âˆ€ (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace â„], MeasurableSet (Set Î±) ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±], MeasurableSet (Set.Univ : Set Î±) ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : BorelSpace Î±], @LebesgueMeasurable Î± inst_1 "]}
{"docString": "Every set of Borel measure zero is Lebesgue measurable.", "prompts": "[{\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\\n  OpensMeasurableSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt ð•œ f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `â„ Ã— â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {m : MeasurableSpace Î±}\\n  [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±]\\n  [inst : BorelSpace Î±] (Î¼ Î½ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (a : Î±), â†‘â†‘Î¼ (Set.Iic a) = â†‘â†‘Î½ (Set.Iic a)) â†’ Î¼ = Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\\nintervals. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½], Î½ â‰  0 â†’ MeasureTheory.Measure.AbsolutelyContinuous Î¼ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {m : MeasurableSpace Î±}\\n  [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±]\\n  [inst : BorelSpace Î±] (Î¼ Î½ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (a : Î±), â†‘â†‘Î¼ (Set.Ici a) = â†‘â†‘Î½ (Set.Ici a)) â†’ Î¼ = Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\\nintervals. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_3) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)},\\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a Ïƒ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹], MeasureTheory.Measure.hausdorffMeasure â†‘(Fintype.card Î¹) = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `Î¹ â†’ â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  OpensMeasurableSpace Î± :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt ð•œ f x} :=\n\n/-- In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- In the space `â„ Ã— â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume :=\n\n/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {m : MeasurableSpace Î±}\n  [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±]\n  [inst : BorelSpace Î±] (Î¼ Î½ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (a : Î±), â†‘â†‘Î¼ (Set.Iic a) = â†‘â†‘Î½ (Set.Iic a)) â†’ Î¼ = Î½ :=\n\n/-- Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½], Î½ â‰  0 â†’ MeasureTheory.Measure.AbsolutelyContinuous Î¼ Î½ :=\n\n/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {m : MeasurableSpace Î±}\n  [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±]\n  [inst : BorelSpace Î±] (Î¼ Î½ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (a : Î±), â†‘â†‘Î¼ (Set.Ici a) = â†‘â†‘Î½ (Set.Ici a)) â†’ Î¼ = Î½ :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_3) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)},\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K} :=\n\n/-- A set in a Ïƒ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0 :=\n\n/-- In the space `Î¹ â†’ â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹], MeasureTheory.Measure.hausdorffMeasure â†‘(Fintype.card Î¹) = MeasureTheory.volume :=\n\n/-- Every set of Borel measure zero is Lebesgue measurable. -/\ntheorem", "choices": ["forall {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_3 : BorelSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "forall {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.Measure.IsLebesgueMeasure Î¼]\n  (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "forall {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_3 : BorelSpace Î±] (s : Set Î±) (Î¼ : MeasureTheory.Measure Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},\n  â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±] {s : Set Î±}\n  (Î¼ : MeasureTheory.Measure Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_3 : BorelSpace Î±] {s : Set Î±}, â†‘â†‘(MeasureTheory.volume : MeasureTheory.Measure Î±) s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_3 : OpensMeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {m0 : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.IsFiniteMeasure m0],\n  MeasureTheory.Measure.IsLebesgueMeasurable m0 â†’ âˆ€ (s : Set Î±), â†‘â†‘m0 s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.Measure.IsLebesgueMeasure Î¼]\n  (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s "]}
{"docString": "No prime number is a perfect square.", "prompts": "[{\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I], I â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The prime ideal is not the entire ring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"}]\n", "prompt_cons": "/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The prime ideal is not the entire ring. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I], I â‰  âŠ¤ :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- No prime number is a perfect square. -/\ntheorem", "choices": ["âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•} [Fact (Nat.Prime p)], Â¬âˆƒ t, t * t = p ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Â¬âˆƒ t, t * t = p ", "âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬âˆƒ t, t * t = n ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ a, a * a = p ", "âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬âˆƒ t, t * t = n ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p "]}
{"docString": "Every odd prime number is greater than `2`.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    Odd p â†’\\n      âˆ€ {x y : â„¤},\\n        â†‘p âˆ£ x - y â†’\\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    Odd p â†’\n      âˆ€ {x y : â„¤},\n        â†‘p âˆ£ x - y â†’\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- Every odd prime number is greater than `2`. -/\ntheorem", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ 2 < p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ 2 < p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2 ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2 "]}
{"docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => â†‘(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\",\n  \"isProp\": true,\n  \"docString\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Representation of a difference of two squares in a commutative ring as a product. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 â†’ R),\\n  Matrix.dotProduct (â†‘(â†‘crossProduct u) v) (â†‘(â†‘crossProduct w) x) =\\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w\",\n  \"isProp\": true,\n  \"docString\":\n  \"The scalar quadruple product identity, related to the Binet-Cauchy identity. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] [inst_3 : MeasureTheory.SigmaFinite Î¼]\\n  {Î¼Î½ : MeasureTheory.Measure (Î± Ã— Î²)},\\n  (âˆ€ (s : Set Î±) (t : Set Î²), MeasurableSet s â†’ MeasurableSet t â†’ â†‘â†‘Î¼Î½ (s Ã—Ë¢ t) = â†‘â†‘Î¼ s * â†‘â†‘Î½ t) â†’\\n    MeasureTheory.Measure.prod Î¼ Î½ = Î¼Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"A measure on a product space equals the product measure if they are equal on rectangles. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of two positive elements is positive. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"âˆ€ (n : â„•+), PrimeMultiset.prod (PNat.factorMultiset n) = n\",\n  \"isProp\": true,\n  \"docString\": \"The product of the factors is the original number \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k :=\n\n/-- Expressing the product of two polynomials as a double sum. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\n  p * q =\n    Finset.sum (Polynomial.support p) fun i =>\n      Polynomial.sum q fun j a => â†‘(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- Representation of a difference of two squares in a commutative ring as a product. -/\ntheorem âˆ€ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b) :=\n\n/-- The scalar quadruple product identity, related to the Binet-Cauchy identity. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 â†’ R),\n  Matrix.dotProduct (â†‘(â†‘crossProduct u) v) (â†‘(â†‘crossProduct w) x) =\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w :=\n\n/-- A measure on a product space equals the product measure if they are equal on rectangles. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] [inst_3 : MeasureTheory.SigmaFinite Î¼]\n  {Î¼Î½ : MeasureTheory.Measure (Î± Ã— Î²)},\n  (âˆ€ (s : Set Î±) (t : Set Î²), MeasurableSet s â†’ MeasurableSet t â†’ â†‘â†‘Î¼Î½ (s Ã—Ë¢ t) = â†‘â†‘Î¼ s * â†‘â†‘Î½ t) â†’\n    MeasureTheory.Measure.prod Î¼ Î½ = Î¼Î½ :=\n\n/-- Multiplication is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x :=\n\n/-- The product of two positive elements is positive. -/\ntheorem âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The product of the factors is the original number -/\ntheorem âˆ€ (n : â„•+), PrimeMultiset.prod (PNat.factorMultiset n) = n :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem", "choices": ["âˆ€ {a b x y u v w s t : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = w ^ 2 + s ^ 2 + t ^ 2 â†’ âˆƒ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ", "âˆ€ {xâ‚€ xâ‚ xâ‚‚ xâ‚ƒ yâ‚€ yâ‚ yâ‚‚ yâ‚ƒ : â„•},\n  âˆƒ a b c d,\n    (xâ‚€ ^ 2 + xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2) * (yâ‚€ ^ 2 + yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2) = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v : â„•},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’\n  b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’\n  âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 + (u * x + v * y) ^ 2 + (u * y - v * x) ^ 2 ", "âˆ€ (a b c d u v w x : â„•),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) =\n    (a * u + b * v + c * w + d * x) ^ 2 + (a * v - b * u - c * x + d * w) ^ 2 +\n      (a * w + b * x - c * u - d * v) ^ 2 + (a * x - b * w + c * v - d * u) ^ 2 ", "âˆ€ (a b x y u v r s : â„•),\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = r ^ 2 + s ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v w z : â„•},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’\n  b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 â†’\n  âˆƒ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 "]}
{"docString": "Every compact topological space is locally compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A proper space is locally compact \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼) :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U :=\n\n/-- A proper space is locally compact -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], LocallyCompactSpace Î± :=\n\n/-- Every compact topological space is locally compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± "]}
{"docString": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} [inst_1 : Subsingleton Î¹],\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ âˆ€ {f : Î¹ â†’ Î± â†’ Î²}, (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UnifIntegrable f p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A single function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformlyOn F f p s â†’\\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"}]\n", "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- A single function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} [inst_1 : Subsingleton Î¹],\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ âˆ€ {f : Î¹ â†’ Î± â†’ Î²}, (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UnifIntegrable f p Î¼ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousAt f x :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ Equicontinuous F :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformlyOn F f p s â†’\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DiscreteUniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±]\n  (f : Î± â†’ Î²), Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±]\n  {f : Î± â†’ Î²}, Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun ", "forall {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DiscreteUniformSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "forall {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±],\n  âˆ€ (f : Î± â†’ Î²), Continuous f â†’ UniformContinuous f "]}
{"docString": "`6` is not the sum of two distinct prime numbers.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Monoid (M i)] (self : FreeProduct.Word M),\\n  List.Chain' (fun l l' => l.fst â‰  l'.fst) self.toList\",\n  \"isProp\": true,\n  \"docString\": \"Adjacent letters are not from the same summand. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n R` is different from `0`. \"},\n {\"theorem\": \"Â¬Summable fun n => 1 / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the first two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the first two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ƒ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the last two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, Nat.coprime a b â†’ Disjoint (Nat.factorization a).support (Nat.factorization b).support\",\n  \"isProp\": true,\n  \"docString\": \"The prime factorizations of coprime `a` and `b` are disjoint \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ƒ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the last two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I], I â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The prime ideal is not the entire ring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(-Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `-Ï€ / 2`, the first two points are not equal. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- Adjacent letters are not from the same summand. -/\ntheorem âˆ€ {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Monoid (M i)] (self : FreeProduct.Word M),\n  List.Chain' (fun l l' => l.fst â‰  l'.fst) self.toList :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x â‰  1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- `cyclotomic n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0 :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem Â¬Summable fun n => 1 / â†‘n :=\n\n/-- `cyclotomic' n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0 :=\n\n/-- If the angle between three points is `Ï€ / 2`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- If the angle between three points is `Ï€`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- If the angle between three points is `Ï€ / 2`, the last two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ƒ â‰  pâ‚‚ :=\n\n/-- The prime factorizations of coprime `a` and `b` are disjoint -/\ntheorem âˆ€ {a b : â„•}, Nat.coprime a b â†’ Disjoint (Nat.factorization a).support (Nat.factorization b).support :=\n\n/-- If the angle between three points is `Ï€`, the last two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ƒ â‰  pâ‚‚ :=\n\n/-- The prime ideal is not the entire ring. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I], I â‰  âŠ¤ :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If the angle between three points is `-Ï€ / 2`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(-Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `6` is not the sum of two distinct prime numbers. -/\ntheorem", "choices": ["Â¬âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ a â‰  b âˆ§ a + b = 6 ", "Â¬âˆƒ (x y : â„•), Nat.Prime x âˆ§ Nat.Prime y âˆ§ x â‰  y âˆ§ x + y = 6 ", "Â¬âˆƒ (pâ‚ pâ‚‚ : â„•), Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ pâ‚ â‰  pâ‚‚ âˆ§ pâ‚ + pâ‚‚ = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ 6 = p + q ", "Â¬âˆƒ (a b : â„•), a â‰  b âˆ§ Nat.Prime a âˆ§ Nat.Prime b âˆ§ a + b = 6 ", "âˆ€ {p q : â„•}, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q â‰  6 ", "Â¬âˆƒ x y : â„•, Nat.Prime x âˆ§ Nat.Prime y âˆ§ x â‰  y âˆ§ x + y = 6 ", "âˆ€ {a b : â„•}, Nat.Prime a â†’ Nat.Prime b â†’ a â‰  b â†’ a + b â‰  6 "]}
{"docString": "No integer is irrational.", "prompts": "[{\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"âˆ€ {a b : â„¤}, a âˆ£ b â†’ Int.natAbs b < Int.natAbs a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : LinearOrderedField ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : OrderTopology ð•œ]\\n  [inst_3 : Archimedean ð•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x âˆˆ nonZeroDivisors R }),\\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v â†‘x â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero divisors have nonzero valuation. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Râ‚ K]\\n  [frac : IsFractionRing Râ‚ K] [inst_3 : IsDomain Râ‚] [inst_4 : IsNoetherianRing Râ‚]\\n  (I : FractionalIdeal (nonZeroDivisors Râ‚) K), IsNoetherian Râ‚ { x // x âˆˆ â†‘I }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every fractional ideal of a noetherian integral domain is noetherian. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x âˆˆ nonZeroDivisors R }),\\n  0 < IsDedekindDomain.HeightOneSpectrum.intValuationDef v â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero divisors have valuation greater than zero. \"},\n {\"theorem\": \"âˆ€ (self : â„š), self.den â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The denominator is nonzero. \"}]\n", "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2} :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem âˆ€ {a b : â„¤}, a âˆ£ b â†’ Int.natAbs b < Int.natAbs a â†’ b = 0 :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ð•œ : Type u_1} [inst : LinearOrderedField ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : OrderTopology ð•œ]\n  [inst_3 : Archimedean ð•œ], DenseRange Rat.cast :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- Nonzero divisors have nonzero valuation. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x âˆˆ nonZeroDivisors R }),\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v â†‘x â‰  0 :=\n\n/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem âˆ€ {Râ‚ : Type u_1} [inst : CommRing Râ‚] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra Râ‚ K]\n  [frac : IsFractionRing Râ‚ K] [inst_3 : IsDomain Râ‚] [inst_4 : IsNoetherianRing Râ‚]\n  (I : FractionalIdeal (nonZeroDivisors Râ‚) K), IsNoetherian Râ‚ { x // x âˆˆ â†‘I } :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- Nonzero divisors have valuation greater than zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x âˆˆ nonZeroDivisors R }),\n  0 < IsDedekindDomain.HeightOneSpectrum.intValuationDef v â†‘x :=\n\n/-- The denominator is nonzero. -/\ntheorem âˆ€ (self : â„š), self.den â‰  0 :=\n\n/-- No integer is irrational. -/\ntheorem", "choices": ["âˆ€ (n : â„¤), Â¬Irrational â†‘n ", "âˆ€ (z : â„¤), Â¬Irrational â†‘z ", "âˆ€ (z : â„¤), Â¬Irrational (â†‘z) ", "âˆ€ (z : â„¤), Â¬Irrational (â†‘z) ", "âˆ€ (n : â„¤), Â¬Irrational â†‘n ", "âˆ€ (n : â„¤), Â¬Irrational â†‘n ", "âˆ€ (z : â„¤), Â¬Irrational (â†‘z) ", "âˆ€ (z : â„¤), Â¬Irrational (â†‘z) ", "âˆ€ (z : â„¤), Â¬Irrational â†‘z ", "âˆ€ (z : â„¤), Â¬Irrational â†‘z "]}
{"docString": "The identity element in a ring is a unit.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MulOneClass Î±] [inst_1 : HasDistribNeg Î±] (a : Î±), a * -1 = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends one to one. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\": \"âˆ€ {M : Type u_1} [inst : Monoid M] {x : M}, x âˆˆ powers x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a monoid is in the set of that element's natural number powers. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {a u : Î±}, IsUnit u â†’ u âˆ£ a\",\n  \"isProp\": true,\n  \"docString\": \"Units of a monoid divide any element of the monoid. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : Nontrivial Mâ‚€] (u : Mâ‚€Ë£), â†‘u â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of the unit group of a nonzero monoid with zero represented as an element\\nof the monoid is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CancelCommMonoidWithZero M] {q : Associates M} {n : â„•},\\n  n â‰  0 â†’\\n    âˆ€ {c : Fin (n + 1) â†’ Associates M},\\n      StrictMono c â†’ (âˆ€ {r : Associates M}, r â‰¤ q â†” âˆƒ i, r = c i) â†’ q â‰  0 â†’ Irreducible (c 1)\",\n  \"isProp\": true,\n  \"docString\": \"The second element of a chain is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring contains the ring's 0. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Semiring Î±], IsSemiringHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a semiring homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an additive group homomorphism.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (S : Type v) [inst : AddMonoidWithOne R] [inst_1 : AddMonoidWithOne S] (p : â„•) [inst_2 : CharP R p]\\n  [inst_3 : CharP S p], CharP (R Ã— S) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The characteristic of the product of two rings of the same characteristic\\nis the same as the characteristic of the rings \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"}]\n", "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id :=\n\n/-- A subring contains the ring's 1. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. -/\ntheorem âˆ€ {Î± : Type u} [inst : MulOneClass Î±] [inst_1 : HasDistribNeg Î±] (a : Î±), a * -1 = -a :=\n\n/-- A ring isomorphism sends one to one. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1 :=\n\n/-- The identity is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0 :=\n\n/-- A subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤ :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {x : M}, x âˆˆ powers x :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {a u : Î±}, IsUnit u â†’ u âˆ£ a :=\n\n/-- An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : Nontrivial Mâ‚€] (u : Mâ‚€Ë£), â†‘u â‰  0 :=\n\n/-- The second element of a chain is irreducible. -/\ntheorem âˆ€ {M : Type u_1} [inst : CancelCommMonoidWithZero M] {q : Associates M} {n : â„•},\n  n â‰  0 â†’\n    âˆ€ {c : Fin (n + 1) â†’ Associates M},\n      StrictMono c â†’ (âˆ€ {r : Associates M}, r â‰¤ q â†” âˆƒ i, r = c i) â†’ q â‰  0 â†’ Irreducible (c 1) :=\n\n/-- A non-unital subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s :=\n\n/-- The identity map is a semiring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±], IsSemiringHom id :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R â‰ƒ+* S), â†‘f 0 = 0 :=\n\n/-- The characteristic of the product of two rings of the same characteristic\nis the same as the characteristic of the rings -/\ntheorem âˆ€ (R : Type u_1) (S : Type v) [inst : AddMonoidWithOne R] [inst_1 : AddMonoidWithOne S] (p : â„•) [inst_2 : CharP R p]\n  [inst_3 : CharP S p], CharP (R Ã— S) p :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- The identity element in a ring is a unit. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : MonoidWithZero R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {Î± : Type u} [inst : MonoidWithZero Î±], IsUnit (1 : Î±) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]}
{"docString": "Every subgroup of a group is a group.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup contains the group's 1. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x âˆˆ H â†’ xâ»Â¹ âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under inverse. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup of a nilpotent group is nilpotent \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [hSM : AddSubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x - y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"An additive subgroup is closed under subtraction.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"}]\n", "prompt_cons": "/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k) :=\n\n/-- A subgroup contains the group's 1. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 âˆˆ H :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- A subgroup is closed under inverse. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x âˆˆ H â†’ xâ»Â¹ âˆˆ H :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1 :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- A subgroup of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x âˆˆ H } :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- An additive subgroup is closed under subtraction. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [hSM : AddSubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x - y âˆˆ H :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- Every subgroup of a group is a group. -/\ntheorem", "choices": ["forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group {x // x âˆˆ H} ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } "]}
{"docString": "The sum of two natural numbers is a natural number.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"theorem\": \"âˆ€ (n : â„•), PGame.Numeric â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] {n : â„•âˆž}\\n  {f g : E â†’ F}, ContDiff ð•œ n f â†’ ContDiff ð•œ n g â†’ ContDiff ð•œ n fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two `C^n`functions is `C^n`. \"},\n {\"theorem\":\n  \"âˆ€ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b â‰ˆ Ordinal.toPGame (Ordinal.nadd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of ordinals as games corresponds to natural addition of ordinals. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_2} {F : Type u_1} [inst : MulZeroOneClass A] [inst_1 : MonoidWithZeroHomClass F â„• A] (f g : F),\\n  (âˆ€ {n : â„•}, 0 < n â†’ â†‘f n = â†‘g n) â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `MonoidWithZeroHom`s agree on the positive naturals they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Add Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±}\\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1]\\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1],\\n  Monotone f â†’ Monotone g â†’ Monotone fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two monotone functions is monotone.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Add Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±}\\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\\n  StrictMono f â†’ StrictMono g â†’ StrictMono fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two strictly monotone functions is strictly monotone.\"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a âˆˆ self.carrier â†’ b âˆˆ self.carrier â†’ a + b âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} {a b : Î±},\\n  a â‰  b â†’ âˆ‘á¶  (i : Î±) (_ : i âˆˆ {a, b}), f i = f a + f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of `f i` over `i âˆˆ {a, b}`, `a â‰  b`, is equal to `f a + f b`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- The sum of two finite adÃ¨les is a finite adÃ¨le. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem âˆ€ (n : â„•), PGame.Numeric â†‘n :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- The sum of two `C^n`functions is `C^n`. -/\ntheorem âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] {n : â„•âˆž}\n  {f g : E â†’ F}, ContDiff ð•œ n f â†’ ContDiff ð•œ n g â†’ ContDiff ð•œ n fun x => f x + g x :=\n\n/-- The sum of ordinals as games corresponds to natural addition of ordinals. -/\ntheorem âˆ€ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b â‰ˆ Ordinal.toPGame (Ordinal.nadd a b) :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- If two `MonoidWithZeroHom`s agree on the positive naturals they are equal. -/\ntheorem âˆ€ {A : Type u_2} {F : Type u_1} [inst : MulZeroOneClass A] [inst_1 : MonoidWithZeroHomClass F â„• A] (f g : F),\n  (âˆ€ {n : â„•}, 0 < n â†’ â†‘f n = â†‘g n) â†’ f = g :=\n\n/-- The sum of two monotone functions is monotone. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Add Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±}\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1]\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1],\n  Monotone f â†’ Monotone g â†’ Monotone fun x => f x + g x :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l :=\n\n/-- The sum of two strictly monotone functions is strictly monotone. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Add Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±}\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMono f â†’ StrictMono g â†’ StrictMono fun x => f x + g x :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- The sum of two elements of an additive subsemigroup belongs to the subsemigroup. -/\ntheorem âˆ€ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\n  a âˆˆ self.carrier â†’ b âˆˆ self.carrier â†’ a + b âˆˆ self.carrier :=\n\n/-- The sum of `f i` over `i âˆˆ {a, b}`, `a â‰  b`, is equal to `f a + f b`. -/\ntheorem âˆ€ {Î± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} {a b : Î±},\n  a â‰  b â†’ âˆ‘á¶  (i : Î±) (_ : i âˆˆ {a, b}), f i = f a + f b :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- The sum of two natural numbers is a natural number. -/\ntheorem", "choices": ["âˆ€ (a b : â„•), âˆƒ c, a + b = c ", "âˆ€ (a b : â„•), âˆƒ (c : â„•), a + b = c ", "âˆ€ (a b : â„•), â„• ", "âˆ€ (a b : â„•), âˆƒ c : â„•, a + b = c ", "âˆ€ (a b : â„•), âˆƒ c, c = a + b ", "âˆ€ (a b : â„•), âˆƒ c : â„•, a + b = c ", "âˆ€ (a b : â„•), âˆƒ c : â„•, a + b = c ", "âˆ€ (a b : â„•), âˆƒ c, a + b = c ", "âˆ€ (m n : â„•), âˆƒ k : â„•, m + n = k ", "âˆ€ (a b : â„•), âˆƒ c : â„•, a + b = c "]}
{"docString": "The identity element of a group has finite order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an additive group homomorphism.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Monoid (Gs i)] {x : (i : Î·) â†’ Gs i},\\n  IsOfFinOrder x â†’ âˆ€ (i : Î·), IsOfFinOrder (x i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a direct product has finite order then so does each component. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"}]\n", "prompt_cons": "/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- The identity is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y) :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Monoid (Gs i)] {x : (i : Î·) â†’ Gs i},\n  IsOfFinOrder x â†’ âˆ€ (i : Î·), IsOfFinOrder (x i) :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G :=\n\n/-- The identity element of a group has finite order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) "]}
{"docString": "`7` is a prime number.", "prompts": "[{\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\",\n  \"isProp\": true,\n  \"docString\": \"The factors of `n` are the prime divisors \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-2) â†” Fintype.card F % 8 â‰  5 âˆ§ Fintype.card F % 8 â‰  7\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square in `F` iff `#F` is not congruent to `5` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\\n  Fintype.card (ClassGroup R) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The class number of a principal ideal domain is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"}]\n", "prompt_cons": "/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The factors of `n` are the prime divisors -/\ntheorem âˆ€ (n : â„•), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n) :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1 :=\n\n/-- `-2` is a square in `F` iff `#F` is not congruent to `5` or `7` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-2) â†” Fintype.card F % 8 â‰  5 âˆ§ Fintype.card F % 8 â‰  7 :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- The class number of a principal ideal domain is `1`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\n  Fintype.card (ClassGroup R) = 1 :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- `7` is a prime number. -/\ntheorem", "choices": ["Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) "]}
{"docString": "There are `3` prime numbers below `8`.", "prompts": "[{\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\",\n  \"isProp\": true,\n  \"docString\": \"The factors of `n` are the prime divisors \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ (n : â„•), 3 âˆ£ n â†” 3 âˆ£ List.sum (Nat.digits 10 n)\",\n  \"isProp\": true,\n  \"docString\": \"**Divisibility by 3 Rule** \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b â‰¥ 2 \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"}]\n", "prompt_cons": "/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- The factors of `n` are the prime divisors -/\ntheorem âˆ€ (n : â„•), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n) :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- **Divisibility by 3 Rule** -/\ntheorem âˆ€ (n : â„•), 3 âˆ£ n â†” 3 âˆ£ List.sum (Nat.digits 10 n) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- The digits in the base b expansion of n are all less than b, if b â‰¥ 2 -/\ntheorem âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5 :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- There are `3` prime numbers below `8`. -/\ntheorem", "choices": ["(Card (Finset.filter Nat.Prime (Finset.range 8)) = 3) ", "Nat.Prime.card_finite 8 = 3 ", "Nat.card_primes_below 8 = 3 ", "Fact (Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3) ", "Prime.card_lt_bit1_bit0 (by norm_num) ", "Nat.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Nat.card_prime_lt 8 = 3 ", "List.length (Prime.take 3) = 3 ", "Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Prime.card_prime_partition 8 = 3 "]}
{"docString": "The empty set is contained in every finite set.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is concyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±], Finset.shadow âˆ… = âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The shadow of the empty set is empty. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], affineSpan k âˆ… = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"The span of the empty set is `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : MetricSpace P] [inst_1 : Nonempty P], EuclideanGeometry.Cospherical âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is cospherical. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Coplanar k âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is coplanar. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  â‹ƒ (n : â„•), CompactExhaustion.toFun self n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"}]\n", "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- The empty set is concyclic. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic âˆ… :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\n  TendstoUniformlyOn F f p âˆ… :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- The shadow of the empty set is empty. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±], Finset.shadow âˆ… = âˆ… :=\n\n/-- The span of the empty set is `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k âˆ… = âŠ¥ :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- The empty set is cospherical. -/\ntheorem âˆ€ {P : Type u_1} [inst : MetricSpace P] [inst_1 : Nonempty P], EuclideanGeometry.Cospherical âˆ… :=\n\n/-- The empty set is collinear. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k âˆ… :=\n\n/-- Finite product of finite sets is finite -/\ntheorem âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t) :=\n\n/-- A finite set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s :=\n\n/-- The empty set is coplanar. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Coplanar k âˆ… :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- The union of all sets in a compact exhaustion equals the entire space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  â‹ƒ (n : â„•), CompactExhaustion.toFun self n = Set.univ :=\n\n/-- The empty set is contained in every finite set. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ âˆ… âŠ† a ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {A : Finset Î±}, âˆ… âŠ† â†‘A ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s "]}
{"docString": "Every infinite set contains a finite set.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {I : Set Î²} {s : Î² â†’ Set Î±},\\n  Set.Finite I â†’ (Metric.Bounded (â‹ƒ (i : Î²) (_ : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ Metric.Bounded (s i))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of bounded sets is bounded \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M}\\n  {x : M}, x âˆˆ Submodule.span R S â†’ âˆƒ T, â†‘T âŠ† S âˆ§ x âˆˆ Submodule.span R â†‘T\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every element in the span of a set, there exists a finite subset of the set\\nsuch that the element is contained in the span of the subset. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\": \"Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact â„)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Under the coercion from `â„¤` to `â„`, inverse images of compact sets are finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {I : Set Î²} {S : Î² â†’ Set Î±},\\n  Set.Finite I â†’ (BddBelow (â‹ƒ (i : Î²) (_ : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ BddBelow (S i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite union of sets which are all bounded below is still bounded below.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {_m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\\n  MeasureTheory.SigmaFinite Î¼\",\n  \"isProp\": true,\n  \"docString\": \"Every finite measure is Ïƒ-finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} [inst : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼] â¦ƒK : Set Î±â¦„, IsCompact K â†’ â†‘â†‘Î¼ K < âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact subset has finite measure for a measure which is finite on compacts. \"}]\n", "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- A finite set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- Finite product of finite sets is finite -/\ntheorem âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t) :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- A finite set is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- A finite set is bounded above. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- A finite union of bounded sets is bounded -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {I : Set Î²} {s : Î² â†’ Set Î±},\n  Set.Finite I â†’ (Metric.Bounded (â‹ƒ (i : Î²) (_ : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ Metric.Bounded (s i)) :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M}\n  {x : M}, x âˆˆ Submodule.span R S â†’ âˆƒ T, â†‘T âŠ† S âˆ§ x âˆˆ Submodule.span R â†‘T :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- Under the coercion from `â„¤` to `â„`, inverse images of compact sets are finite. -/\ntheorem Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact â„) :=\n\n/-- A finite union of sets which are all bounded below is still bounded below. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {I : Set Î²} {S : Î² â†’ Set Î±},\n  Set.Finite I â†’ (BddBelow (â‹ƒ (i : Î²) (_ : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ BddBelow (S i)) :=\n\n/-- Every finite measure is Ïƒ-finite. -/\ntheorem âˆ€ {Î± : Type u_1} {_m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼],\n  MeasureTheory.SigmaFinite Î¼ :=\n\n/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} [inst : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼] â¦ƒK : Set Î±â¦„, IsCompact K â†’ â†‘â†‘Î¼ K < âŠ¤ :=\n\n/-- Every infinite set contains a finite set. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆ€ (n : â„•), âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Finset.card t = n ", "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆ€ (n : â„•), âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Finset.card t = n ", "âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Finite s â†’ âˆƒ t : Finset Î±, â†‘t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆ€ (n : â„•), âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Finset.card t = n ", "âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Finite s â†’ âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Finite s â†’ âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Finite s â†’ âˆƒ (t : Finset Î±), â†‘t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆ€ (n : â„•), âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Finset.card t = n ", "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆ€ {n : â„•}, âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Finset.card t = n "]}
{"docString": "Every commutative ring is a monoid.", "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\": \"âˆ€ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"A monoid is a submonoid of itself. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\\n  IsMonoidHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : MulOneClass Î³] {g : Î² â†’ Î³}, IsMonoidHom g â†’ IsMonoidHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative monoids has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of monoid homomorphisms is associative. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => x * y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left multiplication in a ring is an additive monoid morphism. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right multiplication in a ring is an additive monoid morphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a â†’ IsRegular a\",\n  \"isProp\": true,\n  \"docString\": \"A unit in a monoid is regular. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†” Subsingleton Mâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"theorem\": \"âˆ€ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), 1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"A submonoid contains the monoid's 1. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\\n  IsMonoidHom f â†’ âˆ€ (x y : Î±), f (x * y) = f x * f y\",\n  \"isProp\": true,\n  \"docString\": \"A monoid homomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"A submonoid is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M â†’* P}\\n  (H : c â‰¤ Con.ker f) (x : M), â†‘(Con.lift c f H) â†‘x = â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagram describing the universal property for quotients of monoids commutes. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of additive monoid homomorphisms is associative.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {x y z : M}, y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural number powers of an element of a monoid is closed under multiplication. \"}]\n", "prompt_cons": "/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ :=\n\n/-- The composite of two monoid homomorphisms is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\n  IsMonoidHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : MulOneClass Î³] {g : Î² â†’ Î³}, IsMonoidHom g â†’ IsMonoidHom (g âˆ˜ f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- The category of commutative monoids has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax :=\n\n/-- Composition of monoid homomorphisms is associative. -/\ntheorem âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f) :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => x * y :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x :=\n\n/-- A unit in a monoid is regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a â†’ IsRegular a :=\n\n/-- In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†” Subsingleton Mâ‚€ :=\n\n/-- A submonoid contains the monoid's 1. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), 1 âˆˆ S :=\n\n/-- A monoid homomorphism preserves multiplication. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\n  IsMonoidHom f â†’ âˆ€ (x y : Î±), f (x * y) = f x * f y :=\n\n/-- A submonoid is closed under multiplication. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S :=\n\n/-- The diagram describing the universal property for quotients of monoids commutes. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M â†’* P}\n  (H : c â‰¤ Con.ker f) (x : M), â†‘(Con.lift c f H) â†‘x = â†‘f x :=\n\n/-- Composition of additive monoid homomorphisms is associative. -/\ntheorem âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f) :=\n\n/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {x y z : M}, y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x :=\n\n/-- Every commutative ring is a monoid. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R], IsMonoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u_1} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u_1} [inst : CommRing R], IsMonoidHom (Ring.toMonoidHom R) ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {Î± : Type u} [inst : CommRing Î±], Monoid Î± ", "âˆ€ {Î± : Type u} [inst : CommRing Î±], IsMonoid Î± "]}
{"docString": "There is no field of order `10`.", "prompts": "[{\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\",\n  \"isProp\": true,\n  \"docString\": \"Ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\": \"Â¬IsField â„¤\",\n  \"isProp\": true,\n  \"docString\": \"`â„¤` with its usual ring structure is not a field. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P), Â¬p âˆˆ âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"No points are in `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LT Î±] {a b : Î±} [inst_1 : DenselyOrdered Î±], Â¬a â‹– b\",\n  \"isProp\": true,\n  \"docString\": \"In a dense order, nothing covers anything. \"},\n {\"theorem\": \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield contains the field's 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The order of the formal power series `1` is `0`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R],\\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), â†‘Polynomial.C x âˆˆ I â†’ x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under subtraction \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} {r : Setoid Î±}, Â¬âˆ… âˆˆ Setoid.classes r\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is not an equivalence class. \"},\n {\"theorem\": \"âˆ€ (a : Ordinal.{u}), Ordinal.lift a = a\",\n  \"isProp\": true,\n  \"docString\": \"An ordinal lifted to the zero universe equals itself. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±], 0 â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"In a strict ordered ring, `0 â‰¤ 1`. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R], Â¬IsField (Polynomial R)\",\n  \"isProp\": true,\n  \"docString\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x : L}, x âˆˆ S â†’ -x âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under negation. \"}]\n", "prompt_cons": "/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- Ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b} :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b} :=\n\n/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem Â¬IsField â„¤ :=\n\n/-- No points are in `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), Â¬p âˆˆ âŠ¥ :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤ :=\n\n/-- In a dense order, nothing covers anything. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LT Î±] {a b : Î±} [inst_1 : DenselyOrdered Î±], Â¬a â‹– b :=\n\n/-- A subfield contains the field's 0. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K), 0 âˆˆ s :=\n\n/-- The order of the formal power series `1` is `0`. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0 :=\n\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R],\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), â†‘Polynomial.C x âˆˆ I â†’ x = 0 :=\n\n/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- An intermediate field is closed under subtraction -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- The empty set is not an equivalence class. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Setoid Î±}, Â¬âˆ… âˆˆ Setoid.classes r :=\n\n/-- An ordinal lifted to the zero universe equals itself. -/\ntheorem âˆ€ (a : Ordinal.{u}), Ordinal.lift a = a :=\n\n/-- In a strict ordered ring, `0 â‰¤ 1`. -/\ntheorem âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±], 0 â‰¤ 1 :=\n\n/-- `R[X]` is never a field for any ring `R`. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R], Â¬IsField (Polynomial R) :=\n\n/-- An intermediate field is closed under negation. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x : L}, x âˆˆ S â†’ -x âˆˆ S :=\n\n/-- There is no field of order `10`. -/\ntheorem", "choices": ["Â¬âˆƒ (K : Type) (H : Field K), Fintype.card K = 10 ", "Â¬âˆƒ (F : Type u) [inst : Field F], Fintype.card F = 10 ", "âˆ€ (F : Type u) [inst : Field F] (h : Fintype.card F = 10), False ", "Â¬âˆƒ (K : Type u) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (F : Type u) [inst : Field F], Fintype.card F = 10 ", "Â¬âˆƒ (F : Type u) [inst : Field F], Fintype.card F = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (K : Type u) [inst : Field K], Fintype.card K = 10 "]}
{"docString": "Every odd natural number is the sum of two distinct natural numbers.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"âˆ€ (n : â„•), PGame.Numeric â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The sum of two finite adÃ¨les is a finite adÃ¨le. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem âˆ€ (n : â„•), PGame.Numeric â†‘n :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- Every odd natural number is the sum of two distinct natural numbers. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y : â„•, x â‰  y âˆ§ n = x + y ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ x y, x â‰  y âˆ§ n = x + y ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, n = a + b âˆ§ a â‰  b ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b "]}
{"docString": "Every element in the trivial group has finite order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Monoid (Gs i)] {x : (i : Î·) â†’ Gs i},\\n  IsOfFinOrder x â†’ âˆ€ (i : Î·), IsOfFinOrder (x i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a direct product has finite order then so does each component. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y) :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Monoid (Gs i)] {x : (i : Î·) â†’ Gs i},\n  IsOfFinOrder x â†’ âˆ€ (i : Î·), IsOfFinOrder (x i) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Every element in the trivial group has finite order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x ", "forall {G : Type u_1} [inst : Group G] (x : G), x âˆˆ trivial G â†’ IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsTrivial G], âˆ€ (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Monoid G] [Subsingleton G] (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Unique G], âˆ€ x : G, IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsTrivial G], âˆ€ (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) "]}
{"docString": "The square of an even number is even.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z},\\n  CategoryTheory.CommSq f g h i â†’ CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\",\n  \"isProp\": true,\n  \"docString\": \"The square commutes. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {F : CategoryTheory.Functor D C} {A B : C} {X Y : D} {i : A âŸ¶ B} {p : X âŸ¶ Y}\\n  {u : G.obj A âŸ¶ X} {v : G.obj B âŸ¶ Y} (sq : CategoryTheory.CommSq u (G.map i) p v) (adj : G âŠ£ F),\\n  CategoryTheory.CommSq.HasLift\\n      (_ :\\n        CategoryTheory.CommSq (â†‘(CategoryTheory.Adjunction.homEquiv adj A X) u) i (F.map p)\\n          (â†‘(CategoryTheory.Adjunction.homEquiv adj B Y) v)) â†”\\n    CategoryTheory.CommSq.HasLift sq\",\n  \"isProp\": true,\n  \"docString\":\n  \"A square has a lifting if and only if its (right) adjoint square has a lifting. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ (Finset.sum Finset.univ fun a => â†‘(quadraticChar F) a) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over the values of the quadratic character is zero when the characteristic is odd. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"}]\n", "prompt_cons": "/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- The square commutes. -/\ntheorem âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z},\n  CategoryTheory.CommSq f g h i â†’ CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- A square has a lifting if and only if its (right) adjoint square has a lifting. -/\ntheorem âˆ€ {C : Type u_1} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {F : CategoryTheory.Functor D C} {A B : C} {X Y : D} {i : A âŸ¶ B} {p : X âŸ¶ Y}\n  {u : G.obj A âŸ¶ X} {v : G.obj B âŸ¶ Y} (sq : CategoryTheory.CommSq u (G.map i) p v) (adj : G âŠ£ F),\n  CategoryTheory.CommSq.HasLift\n      (_ :\n        CategoryTheory.CommSq (â†‘(CategoryTheory.Adjunction.homEquiv adj A X) u) i (F.map p)\n          (â†‘(CategoryTheory.Adjunction.homEquiv adj B Y) v)) â†”\n    CategoryTheory.CommSq.HasLift sq :=\n\n/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F â‰  2 â†’ (Finset.sum Finset.univ fun a => â†‘(quadraticChar F) a) = 0 :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- The square of the symbol is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- **Euler's four-square identity**. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- The square of an even number is even. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, Even n â†’ Even (n ^ 2) ", "âˆ€ {n : â„•}, n % 2 = 0 â†’ (n * n) % 2 = 0 ", "âˆ€ (n : â„•), n % 2 = 0 â†’ (n * n) % 2 = 0 ", "âˆ€ {n : â„•}, even n â†’ even (n ^ 2) ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, Even x â†’ Even (x * x) ", "âˆ€ {n : â„•}, Even n â†’ Even (n ^ 2) ", "âˆ€ {n : â„•}, even n â†’ even (n ^ 2) ", "âˆ€ {n : â„•}, Even n â†’ Even (n ^ 2) ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, Even x â†’ Even (x * x) ", "âˆ€ {n : â„•}, Even n â†’ Even (n ^ 2) "]}
{"docString": "Every commutative division ring is a field.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"}]\n", "prompt_cons": "/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R) :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A subfield is closed under division. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S :=\n\n/-- Modules over the trivial ring are Noetherian. -/\ntheorem âˆ€ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- A subfield is closed under multiplication. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Î±], Archimedean Î± :=\n\n/-- Every commutative division ring is a field. -/\ntheorem", "choices": ["âˆ€ {K : Type u} [inst : DivisionSemiring K] [inst_1 : CommSemiring K], IsField K ", "âˆ€ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ", "âˆ€ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ", "âˆ€ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K ", "âˆ€ {R : Type u} [inst : CommSemiring R] [inst_1 : DivisionRing R], IsField R ", "âˆ€ (K : Type u) [inst : CommRing K] [inst_1 : IsDivRing K], IsField K ", "âˆ€ (K : Type u) [inst : CommRing K] [inst_1 : IsDomain K], IsField K ", "âˆ€ {K : Type u} [inst : CommRing K] [inst_1 : IsDivisionRing K], IsField K ", "âˆ€ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ", "âˆ€ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K "]}
{"docString": "The image of the identity element under the identity map is the identity element.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : MulOneClass Î±], IsMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a monoid homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Mul Î±], IsMulHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves multiplication. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Semiring Î±], IsSemiringHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a semiring homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : AddZeroClass Î±], IsAddMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is an additive monoid homomorphism.\"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1], â†‘(AffineMap.id k P1) = id\",\n  \"isProp\": true,\n  \"docString\": \"The identity affine map acts as the identity. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], Isometry id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an isometry \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Add Î±], IsAddHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves addition\"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an additive group homomorphism.\"},\n {\"theorem\":\n  \"âˆ€ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a b : B} (f : a âŸ¶ b),\\n  CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b) = f\",\n  \"isProp\": true,\n  \"docString\": \"Identity morphisms are right identities for composition. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H),\\n  LocalHomeomorph.refl H âˆˆ StructureGroupoid.maximalAtlas H G\",\n  \"isProp\": true,\n  \"docString\": \"In the model space, the identity is in any maximal atlas. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±), MeasureTheory.Conservative id Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is conservative w.r.t. any measure. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (H : Subgroup G) (f : G â‰ƒ* N),\\n  Subgroup.map (MulEquiv.toMonoidHom f) (Subgroup.normalizer H) =\\n    Subgroup.normalizer (Subgroup.map (MulEquiv.toMonoidHom f) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of the normalizer is equal to the normalizer of the image of an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} {N : Type u_2} [inst_1 : Group N] (f : G â†’* N),\\n  Subgroup.map f (Subgroup.normalizer H) â‰¤ Subgroup.normalizer (Subgroup.map f H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of the normalizer is contained in the normalizer of the image. \"},\n {\"theorem\":\n  \"âˆ€ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X âŸ¶ Y),\\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f = f\",\n  \"isProp\": true,\n  \"docString\": \"Identity morphisms are left identities for composition. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {F : C â†’ D}\\n  [self : CategoryTheory.Functorial F] (X : C),\\n  CategoryTheory.Functorial.map' (CategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id (F X)\",\n  \"isProp\": true,\n  \"docString\": \"A functorial map preserves identities. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N),\\n  AddSubgroup.map f (AddSubgroup.normalizer H) â‰¤ AddSubgroup.normalizer (AddSubgroup.map f H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of the normalizer is contained in the normalizer of the image.\"}]\n", "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id :=\n\n/-- The identity map is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : MulOneClass Î±], IsMonoidHom id :=\n\n/-- The identity map preserves multiplication. -/\ntheorem âˆ€ {Î± : Type u} [inst : Mul Î±], IsMulHom id :=\n\n/-- The identity map is a semiring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±], IsSemiringHom id :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddZeroClass Î±], IsAddMonoidHom id :=\n\n/-- The identity affine map acts as the identity. -/\ntheorem âˆ€ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddTorsor V1 P1], â†‘(AffineMap.id k P1) = id :=\n\n/-- The identity is an isometry -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], Isometry id :=\n\n/-- The identity is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id :=\n\n/-- The identity map preserves addition -/\ntheorem âˆ€ {Î± : Type u} [inst : Add Î±], IsAddHom id :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id :=\n\n/-- Identity morphisms are right identities for composition. -/\ntheorem âˆ€ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a b : B} (f : a âŸ¶ b),\n  CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b) = f :=\n\n/-- In the model space, the identity is in any maximal atlas. -/\ntheorem âˆ€ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H),\n  LocalHomeomorph.refl H âˆˆ StructureGroupoid.maximalAtlas H G :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- The identity map is conservative w.r.t. any measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±), MeasureTheory.Conservative id Î¼ :=\n\n/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (H : Subgroup G) (f : G â‰ƒ* N),\n  Subgroup.map (MulEquiv.toMonoidHom f) (Subgroup.normalizer H) =\n    Subgroup.normalizer (Subgroup.map (MulEquiv.toMonoidHom f) H) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- The image of the normalizer is contained in the normalizer of the image. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} {N : Type u_2} [inst_1 : Group N] (f : G â†’* N),\n  Subgroup.map f (Subgroup.normalizer H) â‰¤ Subgroup.normalizer (Subgroup.map f H) :=\n\n/-- Identity morphisms are left identities for composition. -/\ntheorem âˆ€ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X âŸ¶ Y),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f = f :=\n\n/-- A functorial map preserves identities. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {F : C â†’ D}\n  [self : CategoryTheory.Functorial F] (X : C),\n  CategoryTheory.Functorial.map' (CategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id (F X) :=\n\n/-- The image of the normalizer is contained in the normalizer of the image. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N),\n  AddSubgroup.map f (AddSubgroup.normalizer H) â‰¤ AddSubgroup.normalizer (AddSubgroup.map f H) :=\n\n/-- The image of the identity element under the identity map is the identity element. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Monoid Î±], id (MulOneClass.one Î±) = MulOneClass.one Î± ", "âˆ€ {Î± : Type u} [inst : MulOneClass Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : MulOneClass Î±], id (1 : Î±) = 1 ", "âˆ€ {Î± : Type u} [inst : Monoid Î±], id (1 : Î±) = 1 ", "forall {Î± : Type u} [inst : Monoid Î±], id (1 : Î±) = 1 ", "âˆ€ {Î± : Type u} [inst : MulOneClass Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : Monoid Î±], id (1 : Î±) = 1 ", "âˆ€ {Î± : Type u} [inst : Monoid Î±], id (1 : Î±) = 1 ", "âˆ€ {Î± : Type u} [inst : Monoid Î±], id (1 : Î±) = 1 ", "âˆ€ {Î± : Type u} [inst : MulOneClass Î±], id (1 : Î±) = 1 "]}
{"docString": "Every point is a fixed point of the identity function on a space.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x\",\n  \"isProp\": true,\n  \"docString\": \"Every point is a fixed point of `id`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : Î¹ â†’ P},\\n  AffineIndependent k p â†’ Finite Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {pâ‚ pâ‚‚ : P}, pâ‚ âˆˆ affineSpan k {pâ‚‚} â†” pâ‚ = pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a Tâ‚€ space are equal. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (u v : â„™ K V),\\n  Projectivization.Dependent ![u, v] â†” u = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two points in a projective space are dependent if and only if they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  (AffineIndependent k fun p => â†‘p) â†’ âˆƒ t, s âŠ† t âˆ§ (AffineIndependent k fun p => â†‘p) âˆ§ affineSpan k t = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affinely independent set of points can be extended to such a\\nset that spans the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  Collinear k s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The direction of the affine span of collinear points is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] [inst_5 : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚),\\n  LinearMap.range f = âŠ¤ â†’ FiniteDimensional K Vâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (p : P), Collinear k {p}\",\n  \"isProp\": true,\n  \"docString\": \"A single point is collinear. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  Coplanar k s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The direction of the affine span of coplanar points is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  {K : Submodule ð•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, â†‘(â†‘(orthogonalProjection K) v) = v â†” v âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point equals its orthogonal projection if and only if it lies in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {f : Ordinal.{u} â†’ Ordinal.{u}}, Ordinal.IsNormal f â†’ Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"}]\n", "prompt_cons": "/-- Every point is a fixed point of `id`. -/\ntheorem âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : Î¹ â†’ P},\n  AffineIndependent k p â†’ Finite Î¹ :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- A point is in the affine span of a single point if and only if they are equal. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {pâ‚ pâ‚‚ : P}, pâ‚ âˆˆ affineSpan k {pâ‚‚} â†” pâ‚ = pâ‚‚ :=\n\n/-- Two inseparable points in a Tâ‚€ space are equal. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- Two points in a projective space are dependent if and only if they are equal. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (u v : â„™ K V),\n  Projectivization.Dependent ![u, v] â†” u = v :=\n\n/-- An affinely independent set of points can be extended to such a\nset that spans the whole space. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  (AffineIndependent k fun p => â†‘p) â†’ âˆƒ t, s âŠ† t âˆ§ (AffineIndependent k fun p => â†‘p) âˆ§ affineSpan k t = âŠ¤ :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- The direction of the affine span of collinear points is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  Collinear k s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) } :=\n\n/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] [inst_5 : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚),\n  LinearMap.range f = âŠ¤ â†’ FiniteDimensional K Vâ‚‚ :=\n\n/-- A single point is collinear. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P), Collinear k {p} :=\n\n/-- The direction of the affine span of coplanar points is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  Coplanar k s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) } :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- A point equals its orthogonal projection if and only if it lies in the subspace. -/\ntheorem âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  {K : Submodule ð•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, â†‘(â†‘(orthogonalProjection K) v) = v â†” v âˆˆ K :=\n\n/-- A compact discrete space is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î± :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem âˆ€ {f : Ordinal.{u} â†’ Ordinal.{u}}, Ordinal.IsNormal f â†’ Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- Every point is a fixed point of the identity function on a space. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt (@id Î±) x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt (@id Î±) x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", " âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt (id : Î± â†’ Î±) x "]}
{"docString": "The diameter of a singleton space is `0`.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"A singleton has zero diameter \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of a singleton vanishes \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Metric.diam âˆ… = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], EMetric.diam âˆ… = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of the empty set vanishes \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (finite dimensional) space that is a subsingleton has zero `finrank`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î² : Type u_1} [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TotallyDisconnectedSpace Î²] {f : Î± â†’ Î²}, Continuous f â†’ âˆ€ (a : Î±), f '' connectedComponent a = {f a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T1Space Î±] (x : Î±), IsClosed {x}\",\n  \"isProp\": true,\n  \"docString\": \"A singleton in a Tâ‚ space is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a `T0Space` space is a `T0Space`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, Set.Subsingleton s â†’ EMetric.diam s = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of a subsingleton vanishes. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} (x : Î±), ð’«{x} = {âˆ…, {x}}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The powerset of a singleton contains only `âˆ…` and the singleton itself. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±}, Metric.infDist x {y} = dist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a singleton is the distance to the unique point in this singleton \"},\n {\"theorem\": \"PrimeSpectrum PUnit â†’ False\",\n  \"isProp\": true,\n  \"docString\": \"The prime spectrum of the zero ring is empty. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], affineSpan k âˆ… = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"The span of the empty set is `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : MetricSpace P] [inst_1 : Nonempty P], EuclideanGeometry.Cospherical âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is cospherical. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : â„•), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HÏƒ q) 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"In degree `0`, the null homotopic map `HÏƒ` is zero. \"}]\n", "prompt_cons": "/-- A singleton has zero diameter -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 :=\n\n/-- The diameter of a singleton vanishes -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Metric.diam âˆ… = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], EMetric.diam âˆ… = 0 :=\n\n/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0 :=\n\n/-- The image of a connected component in a totally disconnected space is a singleton. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î² : Type u_1} [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TotallyDisconnectedSpace Î²] {f : Î± â†’ Î²}, Continuous f â†’ âˆ€ (a : Î±), f '' connectedComponent a = {f a} :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x} :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0 :=\n\n/-- A singleton in a Tâ‚ space is a closed set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T1Space Î±] (x : Î±), IsClosed {x} :=\n\n/-- The one point compactification of a `T0Space` space is a `T0Space`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X) :=\n\n/-- The diameter of a subsingleton vanishes. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, Set.Subsingleton s â†’ EMetric.diam s = 0 :=\n\n/-- The powerset of a singleton contains only `âˆ…` and the singleton itself. -/\ntheorem âˆ€ {Î± : Type u} (x : Î±), ð’«{x} = {âˆ…, {x}} :=\n\n/-- The minimal distance to a singleton is the distance to the unique point in this singleton -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±}, Metric.infDist x {y} = dist x y :=\n\n/-- The prime spectrum of the zero ring is empty. -/\ntheorem PrimeSpectrum PUnit â†’ False :=\n\n/-- The span of the empty set is `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k âˆ… = âŠ¥ :=\n\n/-- The empty set is cospherical. -/\ntheorem âˆ€ {P : Type u_1} [inst : MetricSpace P] [inst_1 : Nonempty P], EuclideanGeometry.Cospherical âˆ… :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0 :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x) :=\n\n/-- In degree `0`, the null homotopic map `HÏƒ` is zero. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : â„•), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HÏƒ q) 0 = 0 :=\n\n/-- The diameter of a singleton space is `0`. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 "]}
{"docString": "Every group is non-empty.", "prompts": "[{\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {a b : Ordinal.{u_1}}, b â‰  0 â†’ Set.Nonempty {o | a < b * Order.succ o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of division is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s)\",\n  \"isProp\": true,\n  \"docString\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (self : FilterBasis Î±), Set.Nonempty self.sets\",\n  \"isProp\": true,\n  \"docString\": \"The set of filter basis sets is nonempty. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} GroupCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of groups has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} {r : Setoid Î±}, Â¬âˆ… âˆˆ Setoid.classes r\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is not an equivalence class. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is concyclic. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\": \"âˆ€ {a b : Ordinal.{u_1}}, Set.Nonempty {o | a â‰¤ b + o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of subtraction is nonempty. \"}]\n", "prompt_cons": "/-- Each connected component of the category is nonempty. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- The ideal is nonempty. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- The set in the definition of division is nonempty. -/\ntheorem âˆ€ {a b : Ordinal.{u_1}}, b â‰  0 â†’ Set.Nonempty {o | a < b * Order.succ o} :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s } :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- The set of filter basis sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u_1} (self : FilterBasis Î±), Set.Nonempty self.sets :=\n\n/-- The category of groups has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} GroupCatMax :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The empty set is not an equivalence class. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Setoid Î±}, Â¬âˆ… âˆˆ Setoid.classes r :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G Ã— K) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- The empty set is concyclic. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic âˆ… :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- The set in the definition of subtraction is nonempty. -/\ntheorem âˆ€ {a b : Ordinal.{u_1}}, Set.Nonempty {o | a â‰¤ b + o} :=\n\n/-- Every group is non-empty. -/\ntheorem", "choices": ["âˆ€ (G : Type u) [inst : Group G], Nonempty G ", "âˆ€ {G : Type u_1} [inst : Group G], Nonempty G ", "âˆ€ (G : Type u) [inst : Group G], Nonempty G ", "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u_1} [inst : Group G], Nonempty G ", "âˆ€ (G : Type u) [inst : Group G], Nonempty G ", "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ", "âˆ€ {G : Type u_1} [inst : Group G], Nonempty G ", "âˆ€ (G : Type u) [inst : Group G], Nonempty G "]}
{"docString": "All connected components of a topological space are connected.", "prompts": "[{\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally connected charts, then the space itself is\\nlocally connected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {x : Î±}, connectedComponent x âŠ† â‹‚ (Z : { Z // IsClopen Z âˆ§ x âˆˆ Z }), â†‘Z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The connected component of a point is always a subset of the intersection of all its clopen\\nneighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±},\\n  IsConnected s â†’ âˆ€ (f : Î± â†’ Î²), ContinuousOn f s â†’ IsConnected (f '' s)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y],\\n  SimplyConnectedSpace Y â†” PathConnectedSpace Y âˆ§ âˆ€ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is simply connected iff it is path connected, and there is at most one path\\nup to homotopy between any two points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±] (x : Î±),\\n  connectedComponent x = â‹‚ (Z : { Z // IsClopen Z âˆ§ x âˆˆ Z }), â†‘Z\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact t2 space, the connected component of a point equals the intersection of all\\nits clopen neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (pâ‚ pâ‚‚ : Path x y),\\n  Path.Homotopic pâ‚ pâ‚‚\",\n  \"isProp\": true,\n  \"docString\": \"In a simply connected space, any two paths are homotopic \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î² : Type u_1} [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TotallyDisconnectedSpace Î²] {f : Î± â†’ Î²}, Continuous f â†’ âˆ€ (a : Î±), f '' connectedComponent a = {f a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : ConnectedSpace Î±] [inst_2 : Nontrivial Î±] [inst_3 : T1Space Î±]\\n  (x : Î±), Filter.NeBot (nhdsWithin x {x}á¶œ)\",\n  \"isProp\": true,\n  \"docString\": \"A non-trivial connected T1 space has no isolated points. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"}]\n", "prompt_cons": "/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- Each connected component of the category is connected. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x} :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x) :=\n\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- Each connected component of the category is nonempty. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {x : Î±}, connectedComponent x âŠ† â‹‚ (Z : { Z // IsClopen Z âˆ§ x âˆˆ Z }), â†‘Z :=\n\n/-- The image of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±},\n  IsConnected s â†’ âˆ€ (f : Î± â†’ Î²), ContinuousOn f s â†’ IsConnected (f '' s) :=\n\n/-- A space is simply connected iff it is path connected, and there is at most one path\nup to homotopy between any two points. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y],\n  SimplyConnectedSpace Y â†” PathConnectedSpace Y âˆ§ âˆ€ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y) :=\n\n/-- In a compact t2 space, the connected component of a point equals the intersection of all\nits clopen neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±] (x : Î±),\n  connectedComponent x = â‹‚ (Z : { Z // IsClopen Z âˆ§ x âˆˆ Z }), â†‘Z :=\n\n/-- In a simply connected space, any two paths are homotopic -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (pâ‚ pâ‚‚ : Path x y),\n  Path.Homotopic pâ‚ pâ‚‚ :=\n\n/-- The image of a connected component in a totally disconnected space is a singleton. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î² : Type u_1} [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TotallyDisconnectedSpace Î²] {f : Î± â†’ Î²}, Continuous f â†’ âˆ€ (a : Î±), f '' connectedComponent a = {f a} :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- A non-trivial connected T1 space has no isolated points. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : ConnectedSpace Î±] [inst_2 : Nontrivial Î±] [inst_3 : T1Space Î±]\n  (x : Î±), Filter.NeBot (nhdsWithin x {x}á¶œ) :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- All connected components of a topological space are connected. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±),\n  IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (S : Set Î±), IsConnectedComponent S â†’ IsConnected S ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), IsConnectedComponent s â†’ IsConnected s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (j : ConnectedComponents Î±), IsConnected (Component j) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (j : ConnectedComponents Î±), IsConnected (Component j) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) "]}
{"docString": "The ring of integers has a maximal ideal.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime â†‘p)]\\n  [inst_2 : IsCyclotomicExtension {p} â„š K], IsCyclotomicExtension {p} â„¤ { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of integers of a `p`-th cyclotomic extension of `â„š` is a cyclotomic extension. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\\n  I < J â†’ â†‘J = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {k : â„•} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime â†‘p)]\\n  [inst_2 : IsCyclotomicExtension {p ^ k} â„š K],\\n  IsCyclotomicExtension {p ^ k} â„¤ { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of integers of a `p ^ k`-th cyclotomic extension of `â„š` is a cyclotomic extension. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Ideal.IsPrime (Ideal.span {PowerSeries.X})\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ideal spanned by the variable in the power series ring\\nover an integral domain is a prime ideal.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S â‰¤ nonZeroDivisors R â†’\\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R],\\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), â†‘Polynomial.C x âˆˆ I â†’ x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R â†”\\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R], (âˆƒ! I, Ideal.IsMaximal I) â†’ LocalRing R\",\n  \"isProp\": true,\n  \"docString\": \"A semiring is local if it has a unique maximal ideal. \"}]\n", "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- The ring of integers of a `p`-th cyclotomic extension of `â„š` is a cyclotomic extension. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime â†‘p)]\n  [inst_2 : IsCyclotomicExtension {p} â„š K], IsCyclotomicExtension {p} â„¤ { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\n  I < J â†’ â†‘J = Set.univ :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R :=\n\n/-- The ring of integers of a `p ^ k`-th cyclotomic extension of `â„š` is a cyclotomic extension. -/\ntheorem âˆ€ {p : â„•+} {k : â„•} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime â†‘p)]\n  [inst_2 : IsCyclotomicExtension {p ^ k} â„š K],\n  IsCyclotomicExtension {p ^ k} â„¤ { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I :=\n\n/-- The ideal spanned by the variable in the power series ring\nover an integral domain is a prime ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Ideal.IsPrime (Ideal.span {PowerSeries.X}) :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S â‰¤ nonZeroDivisors R â†’\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R],\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), â†‘Polynomial.C x âˆˆ I â†’ x = 0 :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R â†”\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M :=\n\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I :=\n\n/-- A semiring is local if it has a unique maximal ideal. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R], (âˆƒ! I, Ideal.IsMaximal I) â†’ LocalRing R :=\n\n/-- The ring of integers has a maximal ideal. -/\ntheorem", "choices": ["âˆ€ {K : Type u} [inst : Field K] [o : â„•] [H : Fact (Nat.Prime o)] [hi : IsCyclotomicExtension (SetOf fun o => Nat.Prime o) â„š K], âˆƒ I, Ideal.IsMaximal I ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : IsNumberField K], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {K : Type u_1} [inst : Field K], NumberField.ringOfIntegers K â†’ âˆƒ I, Ideal.IsMaximal I ", "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : IsNumberField K], âˆƒ I, Ideal.IsMaximal (NumberField.maximalIdeal I) ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : NumberField R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {K : Type u} [inst : Field K] [inst_1 : CharZero K] {R : Type u_2} [inst_2 : CommRing R] [inst_3 : IsIntegrallyClosed R],\n  IsIntegrallyClosedIn R K â†’ NumberField.ringOfIntegers K = R â†’ âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ (O : Type u_1) [inst : CommRing O] [inst_1 : IsIntegralDomain O] [inst_2 : IsDedekindDomain O],\n  âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {K : Type u} [inst : Field K] [inst_1 : CharZero K] [inst_2 : NumberField K], âˆƒ M, Ideal.IsMaximal M "]}
{"docString": "The numbers `3`, `4` and `5` form a Pythagorean triple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {x y z : â„¤},\\n  PythagoreanTriple x y z â†’\\n    (PythagoreanTriple x y z â†”\\n      âˆƒ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\": \"PythagoreanTriple 0 0 0\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"theorem\": \"âˆ€ {x y z : â„¤}, PythagoreanTriple x y z â†” PythagoreanTriple y x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\\nThis comes from additive commutativity. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, if-and-only-if vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, subtracting vectors, vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {x y z : â„¤} (k : â„¤), k â‰  0 â†’ (PythagoreanTriple (k * x) (k * y) (k * z) â†” PythagoreanTriple x y z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  (x : E) (S : Submodule ð•œ E) [inst_3 : HasOrthogonalProjection S],\\n  â€–xâ€– ^ 2 = â€–â†‘(orthogonalProjection S) xâ€– ^ 2 + â€–â†‘(orthogonalProjection Sá—®) xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"The Pythagorean theorem, for an orthogonal projection.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, if-and-only-if vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] (p1 p2 p3 : P),\\n  dist p1 p3 * dist p1 p3 = dist p1 p2 * dist p1 p2 + dist p3 p2 * dist p3 p2 â†”\\n    EuclideanGeometry.angle p1 p2 p3 = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\": \"**Pythagorean theorem**, if-and-only-if angle-at-point form. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] (x y z : Î±), edist x y â‰¤ edist z x + edist z y\",\n  \"isProp\": true,\n  \"docString\": \"Triangle inequality for the extended distance \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ = Real.pi â†’ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ}\",\n  \"isProp\": true,\n  \"docString\": \"If the angle between three points is Ï€, they are collinear. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  inner x y = 0 â†’ â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, vector inner product\\nform. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (pâ‚ pâ‚‚ pâ‚ƒ : P), Coplanar k {pâ‚, pâ‚‚, pâ‚ƒ}\",\n  \"isProp\": true,\n  \"docString\": \"Three points are coplanar. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {A B X Y : C} {f : A âŸ¶ X} {i : A âŸ¶ B} {p : X âŸ¶ Y} {g : B âŸ¶ Y}\\n  {sq : CategoryTheory.CommSq f i p g} (self : CategoryTheory.CommSq.LiftStruct sq),\\n  CategoryTheory.CategoryStruct.comp self.l p = g\",\n  \"isProp\": true,\n  \"docString\": \"The lower right triangle commutes. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x - yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\\nroots. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\\n  Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ) = 0 â†’ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sine of the angle between three points is 0, they are collinear. \"}]\n", "prompt_cons": "/-- **Formula for Pythagorean Triples** -/\ntheorem âˆ€ {x y z : â„¤},\n  PythagoreanTriple x y z â†’\n    (PythagoreanTriple x y z â†”\n      âˆƒ k m n,\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple 0 0 0 :=\n\n/-- Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. -/\ntheorem âˆ€ {x y z : â„¤}, PythagoreanTriple x y z â†” PythagoreanTriple y x z :=\n\n/-- Pythagorean theorem, vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- Pythagorean theorem, if-and-only-if vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- Pythagorean theorem, subtracting vectors, vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0 :=\n\n/-- `(k*x, k*y, k*z)` is a Pythagorean triple if and only if\n`(x, y, z)` is also a triple. -/\ntheorem âˆ€ {x y z : â„¤} (k : â„¤), k â‰  0 â†’ (PythagoreanTriple (k * x) (k * y) (k * z) â†” PythagoreanTriple x y z) :=\n\n/-- The Pythagorean theorem, for an orthogonal projection. -/\ntheorem âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  (x : E) (S : Submodule ð•œ E) [inst_3 : HasOrthogonalProjection S],\n  â€–xâ€– ^ 2 = â€–â†‘(orthogonalProjection S) xâ€– ^ 2 + â€–â†‘(orthogonalProjection Sá—®) xâ€– ^ 2 :=\n\n/-- Pythagorean theorem, subtracting vectors, if-and-only-if vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- **Pythagorean theorem**, if-and-only-if angle-at-point form. -/\ntheorem âˆ€ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] (p1 p2 p3 : P),\n  dist p1 p3 * dist p1 p3 = dist p1 p2 * dist p1 p2 + dist p3 p2 * dist p3 p2 â†”\n    EuclideanGeometry.angle p1 p2 p3 = Real.pi / 2 :=\n\n/-- Triangle inequality for the extended distance -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] (x y z : Î±), edist x y â‰¤ edist z x + edist z y :=\n\n/-- If the angle between three points is Ï€, they are collinear. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ = Real.pi â†’ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ} :=\n\n/-- Pythagorean theorem, subtracting vectors, vector inner product\nform. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  inner x y = 0 â†’ â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Three points are coplanar. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (pâ‚ pâ‚‚ pâ‚ƒ : P), Coplanar k {pâ‚, pâ‚‚, pâ‚ƒ} :=\n\n/-- The lower right triangle commutes. -/\ntheorem âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {A B X Y : C} {f : A âŸ¶ X} {i : A âŸ¶ B} {p : X âŸ¶ Y} {g : B âŸ¶ Y}\n  {sq : CategoryTheory.CommSq f i p g} (self : CategoryTheory.CommSq.LiftStruct sq),\n  CategoryTheory.CategoryStruct.comp self.l p = g :=\n\n/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\nroots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x - yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- If the sine of the angle between three points is 0, they are collinear. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\n  Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ) = 0 â†’ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ} :=\n\n/-- The numbers `3`, `4` and `5` form a Pythagorean triple. -/\ntheorem", "choices": ["PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 "]}
{"docString": "A vector space with the empty set as basis is trivial.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_2} [inst : IsROrC ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  {T : E â†’â‚—[ð•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ð•œ E], (â¨† (Î¼ : ð•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], vectorSpan k âˆ… = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of the empty set is `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_2) [inst : IsROrC ð•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  [inst_3 : FiniteDimensional ð•œ E], âˆƒ w b, â†‘b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E],\\n  orthogonalProjection âŠ¥ = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto the trivial submodule is the zero map. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Coplanar k âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is coplanar. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : MetricSpace P] [inst_1 : Nonempty P], EuclideanGeometry.Cospherical âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is cospherical. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {bâ‚ bâ‚‚ : Basis Î¹ R M}, (âˆ€ (i : Î¹), â†‘bâ‚ i = â†‘bâ‚‚ i) â†’ bâ‚ = bâ‚‚\",\n  \"isProp\": true,\n  \"docString\": \"Two bases are equal if their basis vectors are the same. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E],\\n  reflection âŠ¥ = LinearIsometryEquiv.neg ð•œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reflection through the trivial subspace {0} is just negation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ð•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ð•œ ð•œ) (modelWithCornersSelf ð•œ V)) (modelWithCornersSelf ð•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem âˆ€ {ð•œ : Type u_2} [inst : IsROrC ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  {T : E â†’â‚—[ð•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ð•œ E], (â¨† (Î¼ : ð•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥ :=\n\n/-- The empty set is collinear. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k âˆ… :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- The `vectorSpan` of the empty set is `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], vectorSpan k âˆ… = âŠ¥ :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem âˆ€ (ð•œ : Type u_2) [inst : IsROrC ð•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  [inst_3 : FiniteDimensional ð•œ E], âˆƒ w b, â†‘b = Subtype.val :=\n\n/-- The orthogonal projection onto the trivial submodule is the zero map. -/\ntheorem âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E],\n  orthogonalProjection âŠ¥ = 0 :=\n\n/-- The empty set is coplanar. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Coplanar k âˆ… :=\n\n/-- The empty set is cospherical. -/\ntheorem âˆ€ {P : Type u_1} [inst : MetricSpace P] [inst_1 : Nonempty P], EuclideanGeometry.Cospherical âˆ… :=\n\n/-- Two bases are equal if their basis vectors are the same. -/\ntheorem âˆ€ {Î¹ : Type u_1} {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {bâ‚ bâ‚‚ : Basis Î¹ R M}, (âˆ€ (i : Î¹), â†‘bâ‚ i = â†‘bâ‚‚ i) â†’ bâ‚ = bâ‚‚ :=\n\n/-- Reflection through the trivial subspace {0} is just negation. -/\ntheorem âˆ€ {ð•œ : Type u_2} {E : Type u_1} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E],\n  reflection âŠ¥ = LinearIsometryEquiv.neg ð•œ :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\n  TendstoUniformlyOn F f p âˆ… :=\n\n/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ð•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ð•œ ð•œ) (modelWithCornersSelf ð•œ V)) (modelWithCornersSelf ð•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v :=\n\n/-- A vector space with the empty set as basis is trivial. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_1} {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis Î¹ K V â†’ (Î¹ â†’ False) â†’ Subsingleton V ", "âˆ€ {Î¹ : Type u} {K : Type v} {V : Type w} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (b : Basis Î¹ K V), b.repr = 0 â†’ Subsingleton V ", "âˆ€ {Î¹ : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis.Empty Î¹ K V â†’ Subsingleton V ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {h : Basis âˆ… R M},\n  Subsingleton M ", "âˆ€ {Î¹ : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {b : Basis Î¹ K V}, b = Basis.empty K V â†’ Subsingleton V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ Subsingleton V ", "âˆ€ {Î¹ : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (empty Î¹) K V â†’ Subsingleton V ", "âˆ€ {Î¹ : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Basis Î¹ K V), Î¹ â†’ False â†’ V ", "âˆ€ {Î¹ : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : IsEmpty Î¹), Basis Î¹ K V â†’ Subsingleton V ", "âˆ€ {Î¹ : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis Î¹ K V â†’ IsEmpty Î¹ â†’ Subsingleton V "]}
