{"total-prompts": 25,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["If `C_0 + C_1/2 + ⋯ + C_{n-1}/n + C_n/(n+1) = 0`, where `C_0, ..., C_n` are real constants, prove that the equation `C_0 + C_1x + ⋯ + C_{n-1}x^{n-1} + C_nx^n = 0` has at least one real root between 0 and 1.",
  "Show that if `A` is a basis for a topology on `X`, then the topology generated by `A` equals the intersection of all topologies on `X` that contain `A`.",
  "Show that the collection `{(a,b) | a < b, a and b rational}` is a basis that generates a topology different from the lower limit topology on `ℝ`.",
  "A map `f: X → Y` is said to be an open map if for every open set `U` of `X`, the set `f(U)` is open in `Y`. Show that `π₁: X × Y → X` and `π₂: X × Y → Y` are open maps.",
  "If `A ⊆ X`, a retraction of `X` onto `A` is a continuous map `r: X → A` such that `r(a) = a` for each `a ∈ A`. Show that a retraction is a quotient map.",
  "Let `{A_n}` be a sequence of connected subspaces of `X`, such that `A_n ∩ A_{n+1} ≠ ∅` for all `n`. Show that `⋃ A_n` is connected.",
  "Show that if `X` is an infinite set, it is connected in the finite complement topology.",
  "Let `A` be a proper subset of `X`, and let `B` be a proper subset of `Y`. If `X` and `Y` are connected, show that `(X × Y) - (A × B)` is connected.",
  "Let `f: S^1 → ℝ` be a continuous map. Show there exists a point `x` of `S^1` such that `f(x) = f(-x)`.",
  "Let `X` be locally path connected. Show that every connected open set in `X` is path connected.",
  "Let `X` be a compact Hausdorff space. Let `A` be a collection of closed connected subsets of `X` that is simply ordered by proper inclusion. Then `Y = ⋂_{A ∈ A} A` is connected.",
  "Show that a connected metric space having more than one point is uncountable.",
  "Show that `X` is countably compact if and only if every nested sequence `C_1 ⊇ C_2 ⊇ ⋯` of closed nonempty sets of `X` has a nonempty intersection."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {f : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n    StrictMono f ∧\n      ∀ {x : ℝ},\n        x ∈ Set.Ioo a b → ∃ g, (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → (g ∘ f) y = y) ∧ HasDerivAt g (deriv f x)⁻¹ (f x)",
   "some-correct": null,
   "prompt":
   "Suppose `f'(x) > 0` in `(a, b)`. Prove that `f` is strictly increasing in `(a, b)`, and let `g` be its inverse function. Prove that `g` is differentiable, and that `g'(f(x)) = 1/f'(x)` for `(a < x < b)`.",
   "groups":
   [["∀ {f : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n    StrictMono f ∧\n      ∀ {x : ℝ},\n        x ∈ Set.Ioo a b → ∃ g, (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → (g ∘ f) y = y) ∧ HasDerivAt g (deriv f x)⁻¹ (f x)"]],
   "correct": false,
   "comments": "`g` is differentiable condition is missed; also is a^{-1} = 1/a. Similarly for others.",
   "all-elabs":
   ["∀ {f : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n    (StrictMono f ∧\n      ∀ {x : ℝ},\n        x ∈ Set.Ioo a b →\n          ∃ g, (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → (g ∘ f) y = y) ∧\n                    HasDerivAt g (deriv f x)⁻¹ (f x)) ",
    "∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f' x) →\n        StrictMonoOn f (Set.Ioo a b) ∧\n          ∃ (g : ℝ → ℝ),\n            ContinuousOn g (Set.Icc (f a) (f b)) ∧\n              (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → HasDerivAt g (1 / f' (g y)) y) ",
    "∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f' x) →\n    (StrictMono f ∧ ∃ g, ∀ (x : ℝ), x ∈ Set.Ioo a b → (HasDerivAt f (f' x) x ∧ HasDerivAt g (1 / f' (g x)) (f x))) ",
    "∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f' x) →\n    (StrictMono f ∧\n      ∀ {g : ℝ → ℝ},\n        (∀ (x : ℝ), x ∈ Set.Ioo a b → g (f x) = x) → ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (1 / f' (f x)) (f x)) ",
    "∀ {f : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n      StrictMono f ∧\n        ∀ {g : ℝ → ℝ},\n          (∀ (x : ℝ), x ∈ Set.Icc a b → g (f x) = x) →\n            (∀ (y : ℝ), y ∈ Set.Icc (f a) (f b) → ContinuousOn g (Set.Icc (f a) (f b))) →\n              (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (1 / deriv f (g (f x))) (f x)) "]},
  {"theorem":
   "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 → MonotoneOn (deriv f) (Set.Ioi 0) → MonotoneOn (fun x => f x / x) (Set.Ioi 0)",
   "some-correct": null,
   "prompt":
   "Suppose (a) `f` is continuous for `x ≥ 0`, (b) `f'(x)` exists for `x > 0`, (c) `f(0) = 0`, (d) `f'` is monotonically increasing. Put `g(x) = f(x)/x` for `(x > 0)` and prove that `g` is monotonically increasing.",
   "groups":
   [["∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 → MonotoneOn (deriv f) (Set.Ioi 0) → MonotoneOn (fun x => f x / x) (Set.Ioi 0)"],
    ["∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) → f 0 = 0 → Monotone (deriv f) → ∀ ⦃x y : ℝ⦄, 0 < x → x ≤ y → f x / x ≤ f y / y"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        Monotone (deriv f) → ∀ ⦃x y : ℝ⦄, 0 < x → x ≤ y → f x / x ≤ f y / y ",
    "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        MonotoneOn (deriv f) (Set.Ioi 0) →\n          MonotoneOn (fun x => f x / x) (Set.Ioi 0) ",
    "∀ {f : ℝ → ℝ},\n  (∀ x, 0 ≤ x → ContinuousAt f x) →\n  (∀ x, 0 < x → DifferentiableAt ℝ f x) →\n  f 0 = 0 →\n  (∀ x y, 0 < x → x < y → deriv f x ≤ deriv f y) →\n  ∀ ⦃x y : ℝ⦄,\n    0 < x → x < y → (f x) / x ≤ (f y) / y "]},
  {"theorem":
   "∀ {a : ℝ} {f : ℝ → ℝ} {M₀ M₁ M₂ : ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      (∀ (x : ℝ), a < x → |f x| ≤ M₀) →\n        (∀ (x : ℝ), a < x → |deriv f x| ≤ M₁) → (∀ (x : ℝ), a < x → |deriv^[2] f x| ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂",
   "some-correct": null,
   "prompt":
   "Suppose `a ∈ ℝ^1`, `f` is a twice-differentiable real function on `(a, ∞)`, and `M_0, M_1, M_2` are the least upper bounds of `|f(x)|`, `|f'(x)|`, `|f''(x)|`, respectively, on `(a, ∞)`. Prove that `M_1^2 ≤ 4 M_0 M_2`.",
   "groups":
   [["∀ {a : ℝ} {f : ℝ → ℝ} {M₀ M₁ M₂ : ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      (∀ (x : ℝ), a < x → |f x| ≤ M₀) →\n        (∀ (x : ℝ), a < x → |deriv f x| ≤ M₁) → (∀ (x : ℝ), a < x → |deriv^[2] f x| ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂"]],
   "correct": false,
   "comments": "Bounds are not defined to be least upper bounds. Same for the rest.",
   "all-elabs":
   ["forall {a : ℝ} {f : ℝ → ℝ} {M₀ M₁ M₂ : ℝ},\n  Differentiable ℝ f → Differentiable ℝ (deriv f) →\n    (∀ x, a < x → abs (f x) ≤ M₀) →\n      (∀ x, a < x → abs (deriv f x) ≤ M₁) →\n        (∀ x, a < x → abs (deriv^[2] f x) ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂ "]},
  {"theorem":
   "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
   "some-correct": null,
   "prompt":
   "Let `X` be a topological space; let `A` be a subset of `X`. Suppose that for each `x ∈ A` there is an open set `U` containing `x` such that `U ⊆ A`. Show that `A` is open in `X`.",
   "groups":
   [["∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x, x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x ∈ A, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x, x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
    "∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A "]},
  {"theorem":
   "{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X",
   "some-correct": null,
   "prompt":
   "If `T_α` is a family of topologies on `X`, show that `∩ T_α` is a topology on `X`.",
   "groups":
   [["{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X",
     "{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X",
     "{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X",
     "{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X",
     "{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X",
     "{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X"],
    ["{X : Type u_1} → {ι : Type u} → (ι → TopologicalSpace X) → TopologicalSpace X"],
    ["{X : Type u_1} → {ι : Type u_2} → {T : ι → TopologicalSpace X} → TopologicalSpace X"],
    ["{X : Type u} → Set (TopologicalSpace X) → TopologicalSpace X"]],
   "correct": true,
   "comments": "It is true but not capturing the entire essence of the question.",
   "all-elabs":
   ["∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ",
    "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  TopologicalSpace X ",
    "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ",
    "∀ {X : Type u} (T : Set (TopologicalSpace X)),\n  TopologicalSpace X ",
    "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ",
    "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ",
    "∀ {X : Type u_1} {ι : Type u} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ",
    "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ",
    "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X "]},
  {"theorem":
   "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X), ∃! T₀, ∀ (i : ι), T i ≤ T₀",
   "some-correct": null,
   "prompt":
   "Let `T_α` be a family of topologies on `X`. Show that there is a unique smallest topology on `X` containing all the collections `T_α`.",
   "groups":
   [["∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X), ∃! T₀, ∀ (i : ι), T i ≤ T₀",
     "∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X}, ∃! T₀, ∀ (i : ι), T i ≤ T₀",
     "∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X}, ∃! t, ∀ (i : ι), T i ≤ t"],
    ["∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃ t, (∀ (i : ι), T i ≤ t) ∧ ∀ (t' : TopologicalSpace X), (∀ (i : ι), T i ≤ t') → t ≤ t'",
     "∀ {X : Type u_1} {ι : Type u_2} {t : ι → TopologicalSpace X},\n  ∃ T_inf, (∀ (i : ι), t i ≤ T_inf) ∧ ∀ {T : TopologicalSpace X}, (∀ (i : ι), t i ≤ T) → T_inf ≤ T",
     "∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X),\n  ∃ t, (∀ (i : ι), T i ≤ t) ∧ ∀ (t' : TopologicalSpace X), (∀ (i : ι), T i ≤ t') → t ≤ t'"],
    ["∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X}, ∃! _inst, ∀ (i : ι), T i ≤ _inst",
     "∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X), ∃! T_min, ∀ (i : ι), T i ≤ T_min",
     "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X}, ∃! t, ∀ (i : ι), T i ≤ t"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃ t : TopologicalSpace X, (∀ i : ι, T i ≤ t) ∧ ∀ t' : TopologicalSpace X, (∀ i : ι, T i ≤ t') → t ≤ t' ",
    "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃! _inst : TopologicalSpace X, ∀ (i : ι), T i ≤ _inst ",
    "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  ∃! (T₀ : TopologicalSpace X), ∀ (i : ι), T i ≤ T₀ ",
    "∀ {X : Type u_1} {ι : Type u_2} {t : ι → TopologicalSpace X},\n  ∃ T_inf : TopologicalSpace X, (∀ i, t i ≤ T_inf) ∧ ∀ {T : TopologicalSpace X}, (∀ i, t i ≤ T) → T_inf ≤ T ",
    "∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X),\n  ∃! (T_min : TopologicalSpace X), ∀ i, T i ≤ T_min ",
    "∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X},\n  ∃! (T₀ : TopologicalSpace X), ∀ (i : ι), T i ≤ T₀ ",
    "∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X),\n  ∃ t : TopologicalSpace X, (∀ i, T i ≤ t) ∧ ∀ t' : TopologicalSpace X, (∀ i, T i ≤ t') → t ≤ t' ",
    "∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X},\n  ∃! (t : TopologicalSpace X), ∀ i, T i ≤ t ",
    "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃! (t : TopologicalSpace X), ∀ i, T i ≤ t "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a < b → ¬b ≤ a",
   "some-correct": false,
   "prompt":
   "Show that the lower limit topology `ℝ_l` and the `K`-topology `ℝ_K` are not comparable.",
   "groups":
   [["∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a < b → ¬b ≤ a"]],
   "correct": false,
   "comments": "None seem correct.",
   "all-elabs":
   ["not_le_of_gt : ∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a < b → ¬b ≤ a "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)",
   "some-correct": null,
   "prompt":
   "Show that if `U` is open in `X` and `A` is closed in `X`, then `U - A` is open in `X`, and `A - U` is closed in `X`.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)",
     "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)",
     "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)",
     "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)",
     "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) "]},
  {"theorem":
   "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)",
   "some-correct": null,
   "prompt":
   "Let `Y` be an ordered set in the order topology. Let `f, g: X → Y` be continuous. Let `h: X → Y` be the function `h(x) = min {f(x), g(x)}`. Show that `h` is continuous.",
   "groups":
   [["∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)",
     "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)",
     "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] (f g : X → Y), Continuous f → Continuous g → Continuous fun x => min (f x) (g x)",
     "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)"],
    ["∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {f g : X → α}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)"],
    ["∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g h : X → Y},\n  (∀ (x : X), h x = min (f x) (g x)) → Continuous f → Continuous g → Continuous h"]],
   "correct": true,
   "comments": "The question seems a bit ambigous, what do they mean by ordered set?",
   "all-elabs":
   ["∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous fun x => min (f x) (g x) ",
    "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x) ",
    "forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [LinearOrder Y]\n  [OrderTopology Y] (f g : X → Y),\n  Continuous f → Continuous g → Continuous (fun x => min (f x) (g x)) ",
    "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n[inst_3 : OrderTopology Y] {f g h : X → Y},\n(∀ (x : X), h x = min (f x) (g x)) → Continuous f → Continuous g → Continuous h ",
    "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous fun x => min (f x) (g x) ",
    "∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {f g : X → α},\n  Continuous f → Continuous g → Continuous fun x => min (f x) (g x) "]},
  {"theorem":
   "∀ {J : Type u_1} {X : J → Type u_2} [inst : (j : J) → TopologicalSpace (X j)] {x : (j : J) → X j}\n  {x_i : ℕ → (j : J) → X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j))",
   "some-correct": null,
   "prompt":
   "Let `x_1, x_2, ...` be a sequence of the points of the product space `Π X_α`. Show that this sequence converges to the point `x` if and only if the sequence `π_α(x_i)` converges to `π_α(x)` for each `α`.",
   "groups":
   [["∀ {J : Type u_1} {X : J → Type u_2} [inst : (j : J) → TopologicalSpace (X j)] {x : (j : J) → X j}\n  {x_i : ℕ → (j : J) → X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j))",
     "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i}\n  {x_1 : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i))",
     "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i}\n  {x_seq : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i))",
     "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {X : α → Type u_2}\n  [inst_1 : (a : α) → TopologicalSpace (X a)] {x : (a : α) → X a} {xι : ℕ → (a : α) → X a},\n  Filter.Tendsto xι Filter.atTop (nhds x) ↔ ∀ (a : α), Filter.Tendsto (fun n => xι n a) Filter.atTop (nhds (x a))"],
    ["∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {p : ℕ → (i : ι) → π i}\n  {x : (i : ι) → π i},\n  Filter.Tendsto p Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i))",
     "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {x : (i : ι) → π i}\n  {x_i : ℕ → (i : ι) → π i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i))"],
    ["∀ {α : Type u_2} {X : α → Type u_1} [inst : (a : α) → TopologicalSpace (X a)] {x : (a : α) → X a}\n  {x₀ : ℕ → (a : α) → X a},\n  Filter.Tendsto x₀ Filter.atTop (nhds x) ↔ ∀ (a : α), Filter.Tendsto (fun n => x₀ n a) Filter.atTop (nhds (x a))",
     "∀ {ι : Type u_2} {X : ι → Type u_1} [_i : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i}\n  {x' : ℕ → (i : ι) → X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i))"],
    ["∀ {α : Type u_3} {π : α → Type u_1} [inst : (i : α) → TopologicalSpace (π i)] {x : (i : α) → π i}\n  {x_seq : ℕ → (i : α) → π i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : α), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i))"]],
   "correct": true,
   "comments": "Some extra assumptions",
   "all-elabs":
   ["∀ {J : Type u_1} {X : J → Type u_2} [inst : (j : J) → TopologicalSpace (X j)] {x : (j : J) → X j} {x_i : ℕ → (j : J) → X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j)) ",
    "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {p : ℕ → Π i, π i} {x : Π i, π i},\n  Filter.Tendsto p Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i)) ",
    "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i} {x_1 : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i)) ",
    "∀ {α : Type u_2} {X : α → Type u_1} [inst : (a : α) → TopologicalSpace (X a)] {x : (a : α) → X a} {x₀ : ℕ → (a : α) → X a},\n  Filter.Tendsto x₀ Filter.atTop (nhds x) ↔ ∀ a, Filter.Tendsto (fun n => x₀ n a) Filter.atTop (nhds (x a)) ",
    "∀ {α : Type u_3} {π : α → Type u_1} [inst : (i : α) → TopologicalSpace (π i)] {x : (i : α) → π i} {x_seq : ℕ → (i : α) → π i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : α), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i)) ",
    "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i} {x_seq : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (λ n => x_seq n i) Filter.atTop (nhds (x i)) ",
    "∀ {ι : Type u_2} {X : ι → Type u_1} [_i : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i} {x' : ℕ → (i : ι) → X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i)) ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {X : α → Type u_2} [inst_1 : (a : α) → TopologicalSpace (X a)]\n  {x : (a : α) → X a} {xι : ℕ → (a : α) → X a},\n  Filter.Tendsto xι Filter.atTop (nhds x) ↔ ∀ (a : α), Filter.Tendsto (fun n => xι n a) Filter.atTop (nhds (x a)) ",
    "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {x : (i : ι) → π i} {x_i : ℕ → (i : ι) → π i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i)) "]},
  {"theorem":
   "∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
   "some-correct": false,
   "prompt":
   "Define `f_n: [0,1] → ℝ` by the equation `f_n(x) = x^n`. Show that the sequence `(f_n(x))` converges for each `x ∈ [0,1]`.",
   "groups":
   [["∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "ℕ → ∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ (x : ℝ), 0 ≤ x ∧ x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ {x : ℝ}, 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)",
     "∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)"],
    ["∀ (x : ℝ), x ∈ [0, 1] → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)"]],
   "correct": false,
   "comments": "True for all points except x = 1. Is adding extra assumptions.",
   "all-elabs":
   ["∀ (x : ℝ) (hx : 0 ≤ x) (hx' : x ≤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ (n : ℕ) (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ (x : ℝ), 0 ≤ x ∧ x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ (x : ℝ), x ∈ [0, 1] → Filter.Tendsto (fun n => x^n) Filter.atTop (nhds 0) ",
    "∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ {x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "forall (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
    "∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) "]},
  {"theorem":
   "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))",
   "some-correct": false,
   "prompt":
   "Let `X` be a topological space and let `Y` be a metric space. Let `f_n: X → Y` be a sequence of continuous functions. Let `x_n` be a sequence of points of `X` converging to `x`. Show that if the sequence `(f_n)` converges uniformly to `f`, then `(f_n(x_n))` converges to `f(x)`.",
   "groups":
   [["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {x : X} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))"],
    ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))"],
    ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {x : X} {f : X → Y}\n  {f_n : ℕ → X → Y} {x_n : ℕ → X},\n  Filter.Tendsto x_n Filter.atTop (nhds x) →\n    TendstoUniformly f_n f Filter.atTop → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {fn : ℕ → X → Y},\n  TendstoUniformly (fun n x => fn n x) f Filter.atTop →\n    ∀ {x : X} {xn : ℕ → X},\n      Filter.Tendsto xn Filter.atTop (nhds x) → Filter.Tendsto (fun n => fn n (xn n)) Filter.atTop (nhds (f x))"],
    ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f_n : ℕ → X → Y} {f : X → Y}\n  {x_n : ℕ → X} {x : X},\n  TendstoUniformly f_n f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) →\n      ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {f_n : ℕ → X → Y}\n  {x_n : ℕ → X} {x : X},\n  TendstoUniformly (fun n => f_n n) f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) →\n      ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))"]],
   "correct": false,
   "comments": "The condition that `f_n` are continuous is missed. Also it uses a general filter instead of `AtTop` on `nat`. Some other outputs use `AtTop` but still incorrect.",
   "all-elabs":
   ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {x : X} {ι : Type u_3}\n  {p : Filter ι} {F : ι → (X → Y)} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f_n : ℕ → X → Y} {f : X → Y} {x_n : ℕ → X}\n  {x : X},\n  TendstoUniformly f_n f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {f_n : ℕ → X → Y} {x_n : ℕ → X} {x : X},\n  TendstoUniformly (fun n => f_n n) f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
    "forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {x : X} {f : X → Y} {f_n : ℕ → X → Y}\n  {x_n : ℕ → X}, Filter.Tendsto x_n Filter.atTop (nhds x) → TendstoUniformly f_n f Filter.atTop →\n    Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {fn : ℕ → X → Y},\n  TendstoUniformly (fun n x => fn n x) f Filter.atTop →\n    ∀ {x : X} {xn : ℕ → X}, Filter.Tendsto xn Filter.atTop (nhds x) → Filter.Tendsto (fun n => fn n (xn n)) Filter.atTop (nhds (f x)) ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) "]}],
 "elaborated": 12}