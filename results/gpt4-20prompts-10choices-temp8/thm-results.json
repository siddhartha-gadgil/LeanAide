[
  {
    "docString": "If every proper closed subset of a topological space is compact, then the space itself is compact.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"‚àÄ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G ‚Üí LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' :=\n\n/-- The underlying topological space is compact. -/\ntheorem ‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem ‚àÄ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t) :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±) :=\n\n/-- In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤) :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±) :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ± :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§ :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem ‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G ‚Üí LocallyCompactSpace G :=\n\n/-- If every proper closed subset of a topological space is compact, then the space itself is compact. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Nonempty Œ±], (‚àÄ (s : Set Œ±), IsClosed s ‚Üí s ‚â† univ ‚Üí IsCompact s) ‚Üí CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ (K : Set Œ±), IsProper K ‚Üí IsClosed K ‚Üí IsCompact K) ‚Üí CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ (K : Set Œ±), IsClosed K ‚Üí K ‚â† univ ‚Üí IsCompact K) ‚Üí CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\n  (‚àÄ (s : Set Œ±), IsClosed s ‚Üí s ‚â† univ ‚Üí IsCompact s) ‚Üí CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (h : ‚àÄ (K : Set Œ±), IsClosed K ‚àß K ‚â† univ ‚Üí IsCompact K), CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [is_compact_ùì§ : (s : Set Œ±) ‚Üí IsProper s ‚Üí IsClosed s ‚Üí IsCompact s], CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Nonempty Œ±],\n  (‚àÄ (K : Set Œ±), IsProper K ‚Üí IsClosed K ‚Üí IsCompact K) ‚Üí CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], (‚àÄ (s : Set Œ±), IsClosed s ‚Üí s ‚â† ‚ä§ ‚Üí IsCompact s) ‚Üí CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (h : ‚àÄ (s : Set Œ±), IsClosed s ‚Üí s ‚â† univ ‚Üí IsCompact s), CompactSpace Œ± ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  (‚àÄ (s : Set Œ±), IsClosed s ‚Üí s ‚â† univ ‚Üí IsCompact s) ‚Üí CompactSpace Œ± "
    ]
  },
  {
    "docString": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 ‚â† 3 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\":\n  \"‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 ‚Üí q ‚â† 2 ‚Üí legendreSym q ‚Üëp = legendreSym p ‚Üëq\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"‚àÄ {p n : ‚Ñï}, Nat.Prime p ‚Üí p ‚à£ n ‚Üí IsSquare (-1) ‚Üí p % 4 ‚â† 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ‚â† 3`. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare 2 ‚Üî p % 8 = 1 ‚à® p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\": \"‚àÄ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"theorem\":\n  \"‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ‚â† 2 ‚Üí q ‚â† 2 ‚Üí legendreSym q ‚Üëp = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ‚Üëq\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"theorem\":\n  \"‚àÄ {n x y : ‚Ñï}, n = x ^ 2 + y ^ 2 ‚Üí Nat.coprime x y ‚Üí IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ‚â† 2 ‚Üí q ‚â† 2 ‚Üí p ‚â† q ‚Üí legendreSym q ‚Üëp * legendreSym p ‚Üëq = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"‚àÄ {n m : ‚Ñï}, m * m < n ‚Üí n < (m + 1) * (m + 1) ‚Üí ¬¨‚àÉ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m¬≤ and (m+1)¬≤ \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 ‚â† 3 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- **Four squares theorem** -/\ntheorem ‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 ‚Üí q ‚â† 2 ‚Üí legendreSym q ‚Üëp = legendreSym p ‚Üëq :=\n\n/-- A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ‚àÄ (a b c d x y z w : ‚Ñï),\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ‚â† 3`. -/\ntheorem ‚àÄ {p n : ‚Ñï}, Nat.Prime p ‚Üí p ‚à£ n ‚Üí IsSquare (-1) ‚Üí p % 4 ‚â† 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare 2 ‚Üî p % 8 = 1 ‚à® p % 8 = 7) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem ‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem ‚àÄ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ‚â† 2 ‚Üí q ‚â† 2 ‚Üí legendreSym q ‚Üëp = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ‚Üëq :=\n\n/-- Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. -/\ntheorem ‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ‚àÄ {n x y : ‚Ñï}, n = x ^ 2 + y ^ 2 ‚Üí Nat.coprime x y ‚Üí IsSquare (-1) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ‚â† 2 ‚Üí q ‚â† 2 ‚Üí p ‚â† q ‚Üí legendreSym q ‚Üëp * legendreSym p ‚Üëq = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- There are no perfect squares strictly between m¬≤ and (m+1)¬≤ -/\ntheorem ‚àÄ {n m : ‚Ñï}, m * m < n ‚Üí n < (m + 1) * (m + 1) ‚Üí ¬¨‚àÉ t, t * t = n :=\n\n/-- Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem",
    "choices": [
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p ",
      "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 = 1 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p "
    ]
  },
  {
    "docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R] (m k : ‚Ñï),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => ‚Üë(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\",\n  \"isProp\": true,\n  \"docString\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {x y : F},\\n  ‚Äñx + y‚Äñ = Real.sqrt (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ) ‚Üî inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Representation of a difference of two squares in a commutative ring as a product. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 ‚Üí R),\\n  Matrix.dotProduct (‚Üë(‚ÜëcrossProduct u) v) (‚Üë(‚ÜëcrossProduct w) x) =\\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w\",\n  \"isProp\": true,\n  \"docString\":\n  \"The scalar quadruple product identity, related to the Binet-Cauchy identity. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {Œº : MeasureTheory.Measure Œ±}\\n  {ŒΩ : MeasureTheory.Measure Œ≤} [inst_2 : MeasureTheory.SigmaFinite ŒΩ] [inst_3 : MeasureTheory.SigmaFinite Œº]\\n  {ŒºŒΩ : MeasureTheory.Measure (Œ± √ó Œ≤)},\\n  (‚àÄ (s : Set Œ±) (t : Set Œ≤), MeasurableSet s ‚Üí MeasurableSet t ‚Üí ‚Üë‚ÜëŒºŒΩ (s √óÀ¢ t) = ‚Üë‚ÜëŒº s * ‚Üë‚ÜëŒΩ t) ‚Üí\\n    MeasureTheory.Measure.prod Œº ŒΩ = ŒºŒΩ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A measure on a product space equals the product measure if they are equal on rectangles. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of two positive elements is positive. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 ‚â† 3 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï+), PrimeMultiset.prod (PNat.factorMultiset n) = n\",\n  \"isProp\": true,\n  \"docString\": \"The product of the factors is the original number \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ‚àÉ V, ‚ÜëV * ‚ÜëV ‚äÜ ‚ÜëU\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ‚àÄ (a b c d x y z w : ‚Ñï),\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Four squares theorem** -/\ntheorem ‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. -/\ntheorem ‚àÄ (R : Type u_1) [inst : CommRing R] (m k : ‚Ñï),\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k :=\n\n/-- Expressing the product of two polynomials as a double sum. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\n  p * q =\n    Finset.sum (Polynomial.support p) fun i =>\n      Polynomial.sum q fun j a => ‚Üë(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {x y : F},\n  ‚Äñx + y‚Äñ = Real.sqrt (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ) ‚Üî inner x y = 0 :=\n\n/-- Representation of a difference of two squares in a commutative ring as a product. -/\ntheorem ‚àÄ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b) :=\n\n/-- The scalar quadruple product identity, related to the Binet-Cauchy identity. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 ‚Üí R),\n  Matrix.dotProduct (‚Üë(‚ÜëcrossProduct u) v) (‚Üë(‚ÜëcrossProduct w) x) =\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w :=\n\n/-- A measure on a product space equals the product measure if they are equal on rectangles. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {Œº : MeasureTheory.Measure Œ±}\n  {ŒΩ : MeasureTheory.Measure Œ≤} [inst_2 : MeasureTheory.SigmaFinite ŒΩ] [inst_3 : MeasureTheory.SigmaFinite Œº]\n  {ŒºŒΩ : MeasureTheory.Measure (Œ± √ó Œ≤)},\n  (‚àÄ (s : Set Œ±) (t : Set Œ≤), MeasurableSet s ‚Üí MeasurableSet t ‚Üí ‚Üë‚ÜëŒºŒΩ (s √óÀ¢ t) = ‚Üë‚ÜëŒº s * ‚Üë‚ÜëŒΩ t) ‚Üí\n    MeasureTheory.Measure.prod Œº ŒΩ = ŒºŒΩ :=\n\n/-- Multiplication is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x :=\n\n/-- The product of two positive elements is positive. -/\ntheorem ‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 ‚â† 3 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- The product of the factors is the original number -/\ntheorem ‚àÄ (n : ‚Ñï+), PrimeMultiset.prod (PNat.factorMultiset n) = n :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ‚àÉ V, ‚ÜëV * ‚ÜëV ‚äÜ ‚ÜëU :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem",
    "choices": [
      "forall {m n : ‚Ñï}, ‚àÉ a b c d x y z w,\n  m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ‚àß n = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ‚Üí\n  m * n = (a * x + b * y + c * z + d * w) ^ 2 + (a * y - b * x - c * w + d * z) ^ 2 +\n          (a * z + b * w - c * x - d * y) ^ 2 + (a * w - b * z + c * y - d * x) ^ 2 ",
      "‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ‚Üí b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
      "‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ‚Üí b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
      "‚àÄ {a b : ‚Ñï}, ‚àÉ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ",
      "‚àÄ {a b x y u v r s : ‚Ñï},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 ‚Üí b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 ‚Üí\n  ‚àÉ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2 ",
      "‚àÄ {a b x y u v r s : ‚Ñï}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 ‚Üí b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 ‚Üí ‚àÉ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ",
      "‚àÄ (a b : ‚Ñï), ‚àÉ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ",
      "‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ‚Üí b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
      "forall {a‚ÇÄ a‚ÇÅ a‚ÇÇ a‚ÇÉ b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : ‚Ñ§}, ‚àÉ c‚ÇÄ c‚ÇÅ c‚ÇÇ c‚ÇÉ, (a‚ÇÄ ^ 2 + a‚ÇÅ ^ 2 + a‚ÇÇ ^ 2 + a‚ÇÉ ^ 2) * (b‚ÇÄ ^ 2 + b‚ÇÅ ^ 2 + b‚ÇÇ ^ 2 + b‚ÇÉ ^ 2) = c‚ÇÄ ^ 2 + c‚ÇÅ ^ 2 + c‚ÇÇ ^ 2 + c‚ÇÉ ^ 2 ",
      "‚àÄ {a b r s x y u v : ‚Ñï},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 ‚Üí\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 ‚Üí\n  ‚àÉ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 "
    ]
  },
  {
    "docString": "A ring with all elements idempotent is commutative.",
    "prompts": "[{\"theorem\": \"‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S), ‚Üëf 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends one to one. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence closure is idempotent. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {A : Œπ ‚Üí Type u_2} [inst : AddCommMonoid Œπ] [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (A i)]\\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±] [inst_1 : HasDistribNeg Œ±] (a : Œ±), a * -1 = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±] [inst_1 : HasDistribNeg Œ±] (a : Œ±), -1 * a = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive inverse of one multiplied by an element of a ring is the element's additive\\ninverse. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"}]\n",
    "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- A ring isomorphism sends one to one. -/\ntheorem ‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S), ‚Üëf 1 = 1 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem ‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0 :=\n\n/-- Equivalence closure is idempotent. -/\ntheorem ‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a :=\n\n/-- By definition, a ring isomorphism preserves the additive structure. -/\ntheorem ‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b :=\n\n/-- Multiplication is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x :=\n\n/-- Multiplication is commutative -/\ntheorem ‚àÄ {Œπ : Type u_1} {A : Œπ ‚Üí Type u_2} [inst : AddCommMonoid Œπ] [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (A i)]\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ :=\n\n/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e}) :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±] [inst_1 : HasDistribNeg Œ±] (a : Œ±), a * -1 = -a :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive\ninverse. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±] [inst_1 : HasDistribNeg Œ±] (a : Œ±), -1 * a = -a :=\n\n/-- Fields are commutative. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x :=\n\n/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f) :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- A ring with all elements idempotent is commutative. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u_1} [inst : MulZeroClass R] [inst_1 : AddCommGroup R] [self : HasOne R], (‚àÄ (x : R), x * x = x) ‚Üí ‚àÄ (x y : R), x * y = y * x ",
      "‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±], ‚àÄ (x y : Œ±), x * y = y * x ",
      "‚àÄ {Œ± : Type u_1} [self : Mul Œ±] [inst : Add Œ±] (h : ‚àÄ (a : Œ±), a * a = a), ‚àÄ (x y : Œ±), x * y = y * x ",
      "‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±], IsCommutative Œ± (*) ",
      "‚àÄ {R : Type u_1} [inst : MulOneClass R] [inst_1 : HasDistribNeg R] [inst_2 : Add R] [inst_3 : AddCommMonoid R],\n  (‚àÄ (x : R), x * x = x) ‚Üí (‚àÄ (x y : R), x * y = y * x) ",
      "‚àÄ {R : Type u_1} [self : Semiring R], (‚àÄ (x : R), x * x = x) ‚Üí ‚àÄ (x y : R), x * y = y * x ",
      "‚àÄ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [inst_2 : One R] [inst_3 : Zero R],\n  (‚àÄ (a : R), a * a = a) ‚Üí ‚àÄ (a b : R), a * b = b * a ",
      "‚àÄ {Œ± : Type u_1} [self : MulOneClass Œ±] [inst_1 : AddCommGroup Œ±] (h : ‚àÄ (a : Œ±), a * a = a), ‚àÄ (x y : Œ±), x * y = y * x ",
      "‚àÄ {Œ± : Type u_1} [self : Mul Œ±] [self_1 : Add Œ±] [self_2 : Idempotent Œ±], (‚àÄ (x y : Œ±), x * y = y * x) ",
      "‚àÄ {R : Type u_1} [inst : Ring R], (‚àÄ (a : R), a * a = a) ‚Üí ‚àÄ (x y : R), x * y = y * x "
    ]
  },
  {
    "docString": "There are infinitely many pairs of primes that differ exactly by `2`.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 2 = 1 ‚Üî p ‚â† 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±}, 2 ‚â§ a ‚Üí (1 - 1 / a)‚Åª¬π ‚â§ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare 2 ‚Üî p % 8 = 1 ‚à® p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ‚Üî Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Disjoint (Nat.factorization a).support (Nat.factorization b).support\",\n  \"isProp\": true,\n  \"docString\": \"The prime factorizations of coprime `a` and `b` are disjoint \"},\n {\"theorem\":\n  \"‚àÄ (n : ‚Ñï), (‚àë' (i : ‚Ñï), if n ‚â§ i then 2‚Åª¬π ^ i else 0) = 2 * 2‚Åª¬π ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2‚Åª¬π ^ i` for `n ‚â§ i` equals `2 * 2‚Åª¬π ^ n`. \"},\n {\"theorem\": \"‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) q ‚â† 0 ‚Üí p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare (-2) ‚Üî p % 8 = 1 ‚à® p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"}]\n",
    "prompt_cons": "/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 2 = 1 ‚Üî p ‚â† 2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- An inequality involving `2`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±}, 2 ‚â§ a ‚Üí (1 - 1 / a)‚Åª¬π ‚â§ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare 2 ‚Üî p % 8 = 1 ‚à® p % 8 = 7) :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) p = 1 :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n] :=\n\n/-- For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. -/\ntheorem ‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]} :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ‚Üî Fintype.card F % 2 = 0 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- The prime factorizations of coprime `a` and `b` are disjoint -/\ntheorem ‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Disjoint (Nat.factorization a).support (Nat.factorization b).support :=\n\n/-- The sum of `2‚Åª¬π ^ i` for `n ‚â§ i` equals `2 * 2‚Åª¬π ^ n`. -/\ntheorem ‚àÄ (n : ‚Ñï), (‚àë' (i : ‚Ñï), if n ‚â§ i then 2‚Åª¬π ^ i else 0) = 2 * 2‚Åª¬π ^ n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem ‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) q ‚â† 0 ‚Üí p = q :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare (-2) ‚Üî p % 8 = 1 ‚à® p % 8 = 3) :=\n\n/-- There are infinitely many pairs of primes that differ exactly by `2`. -/\ntheorem",
    "choices": [
      "Set.Infinite {(p q : ‚Ñï) | Nat.Prime p ‚àß Nat.Prime q ‚àß p + 2 = q} ",
      "Set.Infinite {p n : ‚Ñï | Nat.Prime p ‚àß Nat.Prime n ‚àß p + 2 = n} ",
      "Set.Infinite {p : ‚Ñï | Nat.Prime p ‚àß Nat.Prime (p + 2)} ",
      "ExistsInfinite ((p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß p + 2 = q) ",
      "Set.Infinite {(p, q) : ‚Ñï √ó ‚Ñï | Nat.Prime p ‚àß Nat.Prime q ‚àß q - p = 2} ",
      "Set.Infinite {p | Nat.Prime p ‚àß Nat.Prime (p + 2)} ",
      "Set.Infinite {p | Nat.Prime p ‚àß ‚àÉ q, Nat.Prime q ‚àß p + 2 = q} ",
      "Set.Infinite {p : ‚Ñï | Nat.Prime p ‚àß Nat.Prime (p + 2)} ",
      "Set.Infinite {p | Nat.Prime p ‚àß Nat.Prime (p + 2)} ",
      "Set.Infinite {p | Nat.Prime p ‚àß Nat.Prime (p + 2)} "
    ]
  },
  {
    "docString": "Every finite division ring is a field.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ (S : Set ‚Ñï+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ‚ÜëS] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"}]\n",
    "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S :=\n\n/-- A field is a valuation ring. -/\ntheorem ‚àÄ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem ‚àÄ (S : Set ‚Ñï+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite ‚ÜëS] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- A subfield is closed under division. -/\ntheorem ‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\n  IsCyclic { x // x ‚àà S } :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ± :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V ‚Üî Module.Finite K V :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§ :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ± :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±) :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S :=\n\n/-- A subfield is closed under multiplication. -/\ntheorem ‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ± :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I :=\n\n/-- Every finite division ring is a field. -/\ntheorem",
    "choices": [
      "‚àÄ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K ",
      "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Finite K], Field K ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K "
    ]
  },
  {
    "docString": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] {M‚ÇÅ : Type v} {M‚ÇÇ : Type v'} [inst_1 : AddCommMonoid M‚ÇÅ] [inst_2 : Module R M‚ÇÅ]\\n  [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M‚ÇÇ] {f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ},\\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üë(LinearMap.dualMap f)\",\n  \"isProp\": true,\n  \"docString\": \"If a linear map is surjective, then its dual is injective. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E ‚âÉ‚Çó[ùïú] F),\\n  Continuous ‚Üëe ‚Üí Continuous ‚Üë(LinearEquiv.symm e)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : { x // x ‚àà LinearMap.ker f } ‚Üí‚Çó[R] M), LinearMap.comp f u = LinearMap.comp f v ‚Üí u = v) ‚Üí\\n    LinearMap.ker f = ‚ä•\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"‚àÄ {X Y : Type u} (f : X ‚ü∂ Y), CategoryTheory.IsIso f ‚Üî Function.Bijective f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid ‚Üí c = d\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map sending a congruence relation to its underlying equivalence relation is injective. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C} (f : X ‚ü∂ Y),\\n  Function.Injective ‚Üëf ‚Üí CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In any concrete category, injective morphisms are monomorphisms. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üî Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Mul M] {c d : Con M}, Setoid.r = Setoid.r ‚Üí c = d\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map sending a congruence relation to its underlying binary relation is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_5} {M‚ÇÇ : Type u_2} [inst_5 : AddCommMonoid M‚ÇÇ]\\n  [inst_6 : Module R M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R] M),\\n  Function.Surjective ‚Üëf ‚Üí Function.Injective fun g => AlternatingMap.compLinearMap g f\",\n  \"isProp\": true,\n  \"docString\": \"Composing with a surjective linear map is injective. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u_1} {Œ± : Type u_2} {A : List Œ≤ ‚Üí Set Œ±},\\n  CantorScheme.Disjoint A ‚Üí Function.Injective (CantorScheme.inducedMap A).snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"A scheme where the children of each set are pairwise disjoint induces an injective map. \"},\n {\"theorem\":\n  \"‚àÄ {E : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam (Sort u_3)} [self : EquivLike E Œ± Œ≤] (e g : E),\\n  EquivLike.coe e = EquivLike.coe g ‚Üí EquivLike.inv e = EquivLike.inv g ‚Üí e = g\",\n  \"isProp\": true,\n  \"docString\": \"The two coercions to functions are jointly injective. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f g : X ‚ü∂ Y}\\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g]\\n  [inst_2 : CategoryTheory.Epi (CategoryTheory.Limits.equalizer.Œπ f g)], f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e e' : LocalHomeomorph Œ± Œ≤},\\n  e ‚âà e' ‚Üí LocalHomeomorph.symm e ‚âà LocalHomeomorph.symm e'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two local homeomorphisms are equivalent, so are their inverses \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S),\\n  Function.Injective ‚Üë(RingHom.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced map from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] {f : V ‚Üí‚Çó[K] V‚ÇÇ},\\n  Function.Injective ‚Üëf ‚Üí FiniteDimensional.finrank K { x // x ‚àà LinearMap.range f } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimensions of the domain and range of an injective linear map are equal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"An epimorphism is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {S : Set X} {f‚ÇÄ f‚ÇÅ : C(X, Y)},\\n  ContinuousMap.HomotopicRel f‚ÇÄ f‚ÇÅ S ‚Üí ContinuousMap.Homotopic f‚ÇÄ f‚ÇÅ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two maps are homotopic relative to a set, then they are homotopic. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f g : X ‚ü∂ Y}\\n  [inst_1 : CategoryTheory.Limits.HasCoequalizer f g]\\n  [inst_2 : CategoryTheory.Mono (CategoryTheory.Limits.coequalizer.œÄ f g)], f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. \"}]\n",
    "prompt_cons": "/-- If a linear map is surjective, then its dual is injective. -/\ntheorem ‚àÄ {R : Type u} [inst : CommSemiring R] {M‚ÇÅ : Type v} {M‚ÇÇ : Type v'} [inst_1 : AddCommMonoid M‚ÇÅ] [inst_2 : Module R M‚ÇÅ]\n  [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M‚ÇÇ] {f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ},\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üë(LinearMap.dualMap f) :=\n\n/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\ntheorem ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E ‚âÉ‚Çó[ùïú] F),\n  Continuous ‚Üëe ‚Üí Continuous ‚Üë(LinearEquiv.symm e) :=\n\n/-- A monomorphism is injective. -/\ntheorem ‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\n  (‚àÄ (u v : { x // x ‚àà LinearMap.ker f } ‚Üí‚Çó[R] M), LinearMap.comp f u = LinearMap.comp f v ‚Üí u = v) ‚Üí\n    LinearMap.ker f = ‚ä• :=\n\n/-- A morphism in `Type u` is an isomorphism if and only if it is bijective. -/\ntheorem ‚àÄ {X Y : Type u} (f : X ‚ü∂ Y), CategoryTheory.IsIso f ‚Üî Function.Bijective f :=\n\n/-- The map sending a congruence relation to its underlying equivalence relation is injective. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid ‚Üí c = d :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf :=\n\n/-- In any concrete category, injective morphisms are monomorphisms. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C} (f : X ‚ü∂ Y),\n  Function.Injective ‚Üëf ‚Üí CategoryTheory.Mono f :=\n\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üî Function.Surjective ‚Üëf :=\n\n/-- The map sending a congruence relation to its underlying binary relation is injective. -/\ntheorem ‚àÄ {M : Type u_1} [inst : Mul M] {c d : Con M}, Setoid.r = Setoid.r ‚Üí c = d :=\n\n/-- Composing with a surjective linear map is injective. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_5} {M‚ÇÇ : Type u_2} [inst_5 : AddCommMonoid M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R] M),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective fun g => AlternatingMap.compLinearMap g f :=\n\n/-- A scheme where the children of each set are pairwise disjoint induces an injective map. -/\ntheorem ‚àÄ {Œ≤ : Type u_1} {Œ± : Type u_2} {A : List Œ≤ ‚Üí Set Œ±},\n  CantorScheme.Disjoint A ‚Üí Function.Injective (CantorScheme.inducedMap A).snd :=\n\n/-- The two coercions to functions are jointly injective. -/\ntheorem ‚àÄ {E : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam (Sort u_3)} [self : EquivLike E Œ± Œ≤] (e g : E),\n  EquivLike.coe e = EquivLike.coe g ‚Üí EquivLike.inv e = EquivLike.inv g ‚Üí e = g :=\n\n/-- If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g]\n  [inst_2 : CategoryTheory.Epi (CategoryTheory.Limits.equalizer.Œπ f g)], f = g :=\n\n/-- If two local homeomorphisms are equivalent, so are their inverses -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e e' : LocalHomeomorph Œ± Œ≤},\n  e ‚âà e' ‚Üí LocalHomeomorph.symm e ‚âà LocalHomeomorph.symm e' :=\n\n/-- The induced map from the quotient by the kernel is injective. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S),\n  Function.Injective ‚Üë(RingHom.kerLift f) :=\n\n/-- The dimensions of the domain and range of an injective linear map are equal. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] {f : V ‚Üí‚Çó[K] V‚ÇÇ},\n  Function.Injective ‚Üëf ‚Üí FiniteDimensional.finrank K { x // x ‚àà LinearMap.range f } = FiniteDimensional.finrank K V :=\n\n/-- An epimorphism is surjective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§ :=\n\n/-- If two maps are homotopic relative to a set, then they are homotopic. -/\ntheorem ‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {S : Set X} {f‚ÇÄ f‚ÇÅ : C(X, Y)},\n  ContinuousMap.HomotopicRel f‚ÇÄ f‚ÇÅ S ‚Üí ContinuousMap.Homotopic f‚ÇÄ f‚ÇÅ :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f) :=\n\n/-- If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasCoequalizer f g]\n  [inst_2 : CategoryTheory.Mono (CategoryTheory.Limits.coequalizer.œÄ f g)], f = g :=\n\n/-- If each of two types can be mapped injectively into the other, then there is a bijection between them. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±),\n  Function.Injective f ‚Üí Function.Injective g ‚Üí Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {Œ± Œ≤ : Type u} (h‚ÇÅ : Nonempty (Œ± ‚Ü™ Œ≤)) (h‚ÇÇ : Nonempty (Œ≤ ‚Ü™ Œ±)), Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2},\n  (‚àÉ (f : Œ± ‚Üí Œ≤), Function.Injective f) ‚Üí (‚àÉ (g : Œ≤ ‚Üí Œ±), Function.Injective g) ‚Üí Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {X Y : Type u},\n  (‚àÉ (f : X ‚Ü™ Y), ‚àÉ (g : Y ‚Ü™ X)) ‚Üí Nonempty (X ‚âÉ Y) ",
      "‚àÄ {Œ± : Type u} {Œ≤ : Type v},\n  (‚àÉ (f : Œ± ‚Ü™ Œ≤), ‚àÉ (g : Œ≤ ‚Ü™ Œ±)) ‚Üí Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±),\n  Function.Injective f ‚Üí Function.Injective g ‚Üí Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e‚ÇÅ : Œ± ‚Üí Œ≤} {e‚ÇÇ : Œ≤ ‚Üí Œ±},\n  Function.Injective e‚ÇÅ ‚Üí Function.Injective e‚ÇÇ ‚Üí Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2},\n  (Nonempty (Œ± ‚Üí Œ≤) ‚àß (‚àÄ (f : Œ± ‚Üí Œ≤), Function.Injective f)) ‚Üí\n  (Nonempty (Œ≤ ‚Üí Œ±) ‚àß (‚àÄ (f : Œ≤ ‚Üí Œ±), Function.Injective f)) ‚Üí\n  Nonempty (Equiv Œ± Œ≤) ",
      "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f‚ÇÅ : Œ± ‚Üí Œ≤) (f‚ÇÇ : Œ≤ ‚Üí Œ±), Function.Injective f‚ÇÅ ‚Üí Function.Injective f‚ÇÇ ‚Üí Nonempty (Œ± ‚âÉ Œ≤) ",
      "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v},\n  (‚àÉ (f : Œ± ‚Üí Œ≤), Function.Injective f) ‚Üí (‚àÉ (g : Œ≤ ‚Üí Œ±), Function.Injective g) ‚Üí\n  Nonempty (Œ± ‚âÉ Œ≤) "
    ]
  },
  {
    "docString": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.minDegree G ‚â§ SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimum degree in the graph is at most the degree of any particular vertex. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ‚ÜëK)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (G : SimpleGraph Œ±) {s : Set Œ±}, SimpleGraph.IsClique G s ‚Üî SimpleGraph.induce s G = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A clique is a set of vertices whose induced graph is complete. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] (x : Œ±) {s : Set Œ±},\\n  s ‚àà nhds x ‚Üí Set.Finite s ‚Üí IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.degree G v ‚â§ SimpleGraph.maxDegree G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximum degree in the graph is at least the degree of any particular vertex. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) {v w : V},\\n  SimpleGraph.Adj G v w ‚Üî v ‚â† w ‚àß ‚àÉ e, e ‚àà SimpleGraph.edgeSet G ‚àß v ‚àà e ‚àß w ‚àà e\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vertices are adjacent iff there is an edge between them. The\\ncondition `v ‚â† w` ensures they are different endpoints of the edge,\\nwhich is necessary since when `v = w` the existential\\n`‚àÉ (e ‚àà G.edgeSet), v ‚àà e ‚àß w ‚àà e` is satisfied by every edge\\nincident to `v`. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G ‚Üí SimpleGraph.Connected G\",\n  \"isProp\": true,\n  \"docString\": \"Graph is connected. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±}, connectedComponent x ‚äÜ ‚ãÇ (Z : { Z // IsClopen Z ‚àß x ‚àà Z }), ‚ÜëZ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The connected component of a point is always a subset of the intersection of all its clopen\\nneighbourhoods. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G ‚Üí SimpleGraph.IsAcyclic G\",\n  \"isProp\": true,\n  \"docString\": \"Graph is acyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : DiscreteTopology Œ±], LocallyConnectedSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±], DiscreteTopology Œ± ‚Üî ‚àÄ (x : Œ±), nhds x = pure x\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma characterizes discrete topological spaces as those whose singletons are\\nneighbourhoods. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\\n  ‚àÉ v, SimpleGraph.minDegree G = SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a vertex of minimal degree. Note the assumption of being nonempty is necessary, as\\nthe lemma implies there exists a vertex. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"}]\n",
    "prompt_cons": "/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem ‚àÄ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\n  SimpleGraph.minDegree G ‚â§ SimpleGraph.degree G v :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ‚ÜëK) :=\n\n/-- A clique is a set of vertices whose induced graph is complete. -/\ntheorem ‚àÄ {Œ± : Type u_1} (G : SimpleGraph Œ±) {s : Set Œ±}, SimpleGraph.IsClique G s ‚Üî SimpleGraph.induce s G = ‚ä§ :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] (x : Œ±) {s : Set Œ±},\n  s ‚àà nhds x ‚Üí Set.Finite s ‚Üí IsOpen {x} :=\n\n/-- The maximum degree in the graph is at least the degree of any particular vertex. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\n  SimpleGraph.degree G v ‚â§ SimpleGraph.maxDegree G :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val :=\n\n/-- Two vertices are adjacent iff there is an edge between them. The\ncondition `v ‚â† w` ensures they are different endpoints of the edge,\nwhich is necessary since when `v = w` the existential\n`‚àÉ (e ‚àà G.edgeSet), v ‚àà e ‚àß w ‚àà e` is satisfied by every edge\nincident to `v`. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) {v w : V},\n  SimpleGraph.Adj G v w ‚Üî v ‚â† w ‚àß ‚àÉ e, e ‚àà SimpleGraph.edgeSet G ‚àß v ‚àà e ‚àß w ‚àà e :=\n\n/-- Graph is connected. -/\ntheorem ‚àÄ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G ‚Üí SimpleGraph.Connected G :=\n\n/-- The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±}, connectedComponent x ‚äÜ ‚ãÇ (Z : { Z // IsClopen Z ‚àß x ‚àà Z }), ‚ÜëZ :=\n\n/-- Graph is acyclic. -/\ntheorem ‚àÄ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G ‚Üí SimpleGraph.IsAcyclic G :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a)) :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : DiscreteTopology Œ±], LocallyConnectedSpace Œ± :=\n\n/-- This lemma characterizes discrete topological spaces as those whose singletons are\nneighbourhoods. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±], DiscreteTopology Œ± ‚Üî ‚àÄ (x : Œ±), nhds x = pure x :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x :=\n\n/-- There exists a vertex of minimal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\n  ‚àÉ v, SimpleGraph.minDegree G = SimpleGraph.degree G v :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices. -/\ntheorem",
    "choices": [
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí SimpleGraph.commonNeighbors G v w = 1) ‚Üí ‚àÉ v, SimpleGraph.degree G v = Fintype.card V - 1 ",
      "‚àÄ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí ‚àÉ! (u : V), SimpleGraph.Adj G v u ‚àß SimpleGraph.Adj G w u) ‚Üí\n  ‚àÉ (v : V), ‚àÄ (w : V), w ‚â† v ‚Üí SimpleGraph.Adj G v w ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí ‚àÉ! u, SimpleGraph.Adj G v u ‚àß SimpleGraph.Adj G w u) ‚Üí ‚àÉ x, ‚àÄ y, x ‚â† y ‚Üí SimpleGraph.Adj G x y ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí ‚àÉ! (u : V), SimpleGraph.Adj G v u ‚àß SimpleGraph.Adj G w u) ‚Üí ‚àÉ (v : V), ‚àÄ (w : V), w ‚â† v ‚Üí SimpleGraph.Adj G v w ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (h : ‚àÄ (v w : V), v ‚â† w ‚Üí (G.commonNeighbors v w).card = 1),\n  ‚àÉ (v : V), ‚àÄ (w : V), w ‚â† v ‚Üí SimpleGraph.Adj G v w ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (x y : V), x ‚â† y ‚Üí ExistsUnique (G.CommonNeighbors x y)) ‚Üí ‚àÉ (v : V), ‚àÄ (w : V), w ‚â† v ‚Üí SimpleGraph.Adj G v w ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí Finset.card (SimpleGraph.commonNeighbors G v w) = 1) ‚Üí\n  ‚àÉ (v : V), ‚àÄ (w : V), w ‚â† v ‚Üí SimpleGraph.Adj G v w ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí ‚àÉ! (x : V), SimpleGraph.Adj G x v ‚àß SimpleGraph.Adj G x w) ‚Üí ‚àÉ (x : V), ‚àÄ (v : V), v ‚â† x ‚Üí SimpleGraph.Adj G x v ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (‚àÄ (v w : V), v ‚â† w ‚Üí ‚àÉ! (x : V), SimpleGraph.Adj G v x ‚àß SimpleGraph.Adj G w x) ‚Üí\n  ‚àÉ (v : V), ‚àÄ (w : V), w ‚â† v ‚Üí SimpleGraph.Adj G v w ",
      "‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (h : ‚àÄ (v w : V), v ‚â† w ‚Üí (SetOf (Œª (u : V), SimpleGraph.Adj G v u ‚àß SimpleGraph.Adj G w u)).Finite ‚àß Finset.card (Finset.filter (Œª (u : V), SimpleGraph.Adj G v u ‚àß SimpleGraph.Adj G w u) Finset.univ) = 1),\n  ‚àÉ v, ‚àÄ w, w ‚â† v ‚Üí SimpleGraph.Adj G v w "
    ]
  },
  {
    "docString": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\\n  {G : SimpleGraph Œ±} {Œµ : ‚Ñù},\\n  Finset.card P.parts * 16 ^ Finset.card P.parts ‚â§ Fintype.card Œ± ‚Üí\\n    ¬¨Finpartition.IsUniform P G Œµ ‚Üí\\n      Finset.card (SzemerediRegularity.increment hP G Œµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The increment partition has a prescribed (very big) size in terms of the original partition. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ‚Üëf.parts\",\n  \"isProp\": true,\n  \"docString\": \"A finpartition gives rise to a setoid partition \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} (a : Œ±), ‚àÉ! b x, a ‚àà b\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence classes partition the type. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {P : Finpartition Finset.univ} {G : SimpleGraph Œ±} {Œµ : ‚Ñù} [inst_1 : Nonempty Œ±]\\n  (hP : Finpartition.IsEquipartition P),\\n  7 ‚â§ Finset.card P.parts ‚Üí\\n    100 < 4 ^ Finset.card P.parts * Œµ ^ 5 ‚Üí\\n      Finset.card P.parts * 16 ^ Finset.card P.parts ‚â§ Fintype.card Œ± ‚Üí\\n        ¬¨Finpartition.IsUniform P G Œµ ‚Üí\\n          Œµ ‚â§ 1 ‚Üí\\n            ‚Üë(Finpartition.energy P G) + Œµ ^ 5 / 4 ‚â§ ‚Üë(Finpartition.energy (SzemerediRegularity.increment hP G Œµ) G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The increment partition has energy greater than the original one by a known fixed amount. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] (R : Setoid Œ±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (Finset.sum s fun x => f x) =\\n    Finset.sum (Finset.image Quotient.mk'' s) fun xbar =>\\n      Finset.sum (Finset.filter (fun x => Quotient.mk R x = xbar) s) fun y => f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí Set Œ±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs (‚Üë(IndexedPartition.out hs) x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indices of `Quotient.out'` and `IndexedPartition.out` are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] (R : Setoid Œ±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí (Finset.sum (Finset.filter (fun y => y ‚âà x) s) fun a => f a) = 0) ‚Üí\\n    (Finset.sum s fun x => f x) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)}, (‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) ‚Üí Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Œ± are disjoint. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : CommMonoid Œ≤] (R : Setoid Œ±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí (Finset.prod (Finset.filter (fun y => y ‚âà x) s) fun a => f a) = 1) ‚Üí\\n    (Finset.prod s fun x => f x) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we can partition a product into subsets that cancel out, then the whole product cancels. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)},\\n  (‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) ‚Üí ‚àÄ {x : Œ±} {b b' : Set Œ±}, b ‚àà c ‚Üí x ‚àà b ‚Üí b' ‚àà c ‚Üí x ‚àà b' ‚Üí b = b'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x ‚àà Œ± is in 2 elements of a set of sets partitioning Œ±, those 2 sets are equal. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ‚Üî Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (hc : Setoid.IsPartition c) {s : Set Œ±},\\n  s ‚àà c ‚Üí ‚àÉ y, s = {x | Setoid.Rel (Setoid.mkClasses c (_ : ‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b)) x y}\",\n  \"isProp\": true,\n  \"docString\":\n  \"All elements of a partition of Œ± are the equivalence class of some y ‚àà Œ±. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type} {d : ‚Ñï} {ds : List ‚Ñï} (x y : Holor Œ± (d :: ds)), Holor.slice x = Holor.slice y ‚Üí x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two holors are equal if all their slices are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : CommMonoid Œ≤] (R : Setoid Œ±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (Finset.prod s fun x => f x) =\\n    Finset.prod (Finset.image Quotient.mk'' s) fun xbar =>\\n      Finset.prod (Finset.filter (fun x => Quotient.mk R x = xbar) s) fun y => f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product can be partitioned into a product of products, each equivalent under a setoid. \"}]\n",
    "prompt_cons": "/-- The increment partition has a prescribed (very big) size in terms of the original partition. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph Œ±} {Œµ : ‚Ñù},\n  Finset.card P.parts * 16 ^ Finset.card P.parts ‚â§ Fintype.card Œ± ‚Üí\n    ¬¨Finpartition.IsUniform P G Œµ ‚Üí\n      Finset.card (SzemerediRegularity.increment hP G Œµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts) :=\n\n/-- The partition is supremum-independent -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- A finpartition gives rise to a setoid partition -/\ntheorem ‚àÄ {Œ± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ‚Üëf.parts :=\n\n/-- Equivalence classes partition the type. -/\ntheorem ‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} (a : Œ±), ‚àÉ! b x, a ‚àà b :=\n\n/-- The increment partition has energy greater than the original one by a known fixed amount. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {P : Finpartition Finset.univ} {G : SimpleGraph Œ±} {Œµ : ‚Ñù} [inst_1 : Nonempty Œ±]\n  (hP : Finpartition.IsEquipartition P),\n  7 ‚â§ Finset.card P.parts ‚Üí\n    100 < 4 ^ Finset.card P.parts * Œµ ^ 5 ‚Üí\n      Finset.card P.parts * 16 ^ Finset.card P.parts ‚â§ Fintype.card Œ± ‚Üí\n        ¬¨Finpartition.IsUniform P G Œµ ‚Üí\n          Œµ ‚â§ 1 ‚Üí\n            ‚Üë(Finpartition.energy P G) + Œµ ^ 5 / 4 ‚â§ ‚Üë(Finpartition.energy (SzemerediRegularity.increment hP G Œµ) G) :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x :=\n\n/-- A sum can be partitioned into a sum of sums, each equivalent under a setoid. -/\ntheorem ‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r],\n  (Finset.sum s fun x => f x) =\n    Finset.sum (Finset.image Quotient.mk'' s) fun xbar =>\n      Finset.sum (Finset.filter (fun x => Quotient.mk R x = xbar) s) fun y => f y :=\n\n/-- The indices of `Quotient.out'` and `IndexedPartition.out` are equal. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí Set Œ±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs (‚Üë(IndexedPartition.out hs) x) :=\n\n/-- If we can partition a sum into subsets that cancel out, then the whole sum cancels. -/\ntheorem ‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r],\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí (Finset.sum (Finset.filter (fun y => y ‚âà x) s) fun a => f a) = 0) ‚Üí\n    (Finset.sum s fun x => f x) = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- Distinct elements of a set of sets partitioning Œ± are disjoint. -/\ntheorem ‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)}, (‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) ‚Üí Set.PairwiseDisjoint c id :=\n\n/-- If we can partition a product into subsets that cancel out, then the whole product cancels. -/\ntheorem ‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : CommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r],\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí (Finset.prod (Finset.filter (fun y => y ‚âà x) s) fun a => f a) = 1) ‚Üí\n    (Finset.prod s fun x => f x) = 1 :=\n\n/-- If x ‚àà Œ± is in 2 elements of a set of sets partitioning Œ±, those 2 sets are equal. -/\ntheorem ‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)},\n  (‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) ‚Üí ‚àÄ {x : Œ±} {b b' : Set Œ±}, b ‚àà c ‚Üí x ‚àà b ‚Üí b' ‚àà c ‚Üí x ‚àà b' ‚Üí b = b' :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ‚Üî Fintype.card F % 2 = 0 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- All elements of a partition of Œ± are the equivalence class of some y ‚àà Œ±. -/\ntheorem ‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (hc : Setoid.IsPartition c) {s : Set Œ±},\n  s ‚àà c ‚Üí ‚àÉ y, s = {x | Setoid.Rel (Setoid.mkClasses c (_ : ‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b)) x y} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq :=\n\n/-- Two holors are equal if all their slices are equal. -/\ntheorem ‚àÄ {Œ± : Type} {d : ‚Ñï} {ds : List ‚Ñï} (x y : Holor Œ± (d :: ds)), Holor.slice x = Holor.slice y ‚Üí x = y :=\n\n/-- A product can be partitioned into a product of products, each equivalent under a setoid. -/\ntheorem ‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : Œ± ‚Üí Œ≤} [inst : CommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r],\n  (Finset.prod s fun x => f x) =\n    Finset.prod (Finset.image Quotient.mk'' s) fun xbar =>\n      Finset.prod (Finset.filter (fun x => Quotient.mk R x = xbar) s) fun y => f y :=\n\n/-- The number of partitions with odd parts is equal to the number of partitions with distinct parts. -/\ntheorem",
    "choices": [
      "Nat.partitions_odd_eq_partitions_distinct ",
      "Nat.odd_part_count_eq_distinct_part_count ",
      "Nat.odd_part_count_eq_disjoint_part_count ",
      "Nat.odd_part_count_eq_distinct_part_count : ‚àÄ n, Nat.oddPartCount n = Nat.distinctPartCount n ",
      "Nat.partitions.parts_odd_eq_parts_distinct ",
      "Nat.odd_parts_eq_distinct_parts ",
      "Nat.oddPartitions_eq_distinctPartitions ",
      "Nat.partitions_eq_distinct_parts_odd ",
      "Nat.odd_part_count_eq_distinct_part_count : ‚àÄ (n : ‚Ñï), Nat.part_count Nat.odd n = Nat.part_count Nat.distinct n ",
      "Nat.partitions_eq_odd_eq_distinct "
    ]
  },
  {
    "docString": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\\nthere is a maximal element.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {c : Set Œ±}, IsChain r c ‚Üí ‚àÉ M, IsMaxChain r M ‚àß c ‚äÜ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\\n\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\\n  c ‚äÜ nonPrincipals R ‚Üí\\n    IsChain (fun x x_1 => x ‚â§ x_1) c ‚Üí\\n      ‚àÄ {K : Ideal R}, K ‚àà c ‚Üí ‚àÉ I, I ‚àà nonPrincipals R ‚àß ‚àÄ (J : Ideal R), J ‚àà c ‚Üí J ‚â§ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any chain in the set of non-principal ideals has an upper bound which is non-principal.\\n(Namely, the union of the chain is such an upper bound.)\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (s : Set Œ±) (a : Œ±), (‚àÄ (b : Œ±), b ‚àà s ‚Üí b ‚â§ a) ‚Üí sSup s ‚â§ a\",\n  \"isProp\": true,\n  \"docString\": \"Any upper bound is more than the set supremum. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] (s : Set Œ±), BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"When there is a global maximum, every set is bounded above. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±},\\n  Set.Finite I ‚Üí (BddAbove (‚ãÉ (i : Œ≤) (_ : i ‚àà I), S i) ‚Üî ‚àÄ (i : Œ≤), i ‚àà I ‚Üí BddAbove (S i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±}, Set.Finite s ‚Üí BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : TopologicalSpace.SecondCountableTopology Œ±],\\n  IsClosed C ‚Üí ¬¨Set.Countable C ‚Üí ‚àÉ D, Perfect D ‚àß Set.Nonempty D ‚àß D ‚äÜ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s ‚Üí TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí sInf s ‚â§ a\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is more than the set infimum. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\\n  ‚àÉ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\\nthe lemma implies there exists a vertex. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\\n  Convex ‚Ñù s ‚Üí Set.Nonempty s ‚Üí IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : Nontrivial A]\\n  (a : A), Set.Nonempty (spectrum ‚ÑÇ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ‚Ñù V] [inst_2 : FiniteDimensional ‚Ñù V] {s : Set V},\\n  Convex ‚Ñù s ‚Üí Set.Nonempty s ‚Üí Set.Nonempty (intrinsicInterior ‚Ñù s)\",\n  \"isProp\": true,\n  \"docString\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {Œ≤ : Type u_2} [inst_1 : Ring Œ≤] {abv : Œ≤ ‚Üí Œ±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Œ≤ abv] (s : CauSeq Œ≤ abv), ‚àÉ b, s ‚âà CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : MeasurableSpace Œ±] (Œº : MeasureTheory.Measure Œ±) {Œµ : ENNReal},\\n  0 < Œµ ‚Üí\\n    ‚àÄ {As : Œπ ‚Üí Set Œ±},\\n      (‚àÄ (i : Œπ), MeasurableSet (As i)) ‚Üí\\n        Pairwise (Disjoint on As) ‚Üí ‚Üë‚ÜëŒº (‚ãÉ (i : Œπ), As i) ‚â† ‚ä§ ‚Üí Set.Finite {i | Œµ ‚â§ ‚Üë‚ÜëŒº (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\nfinitely many members of the union whose measure exceeds any given positive number. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] (a : Œ≥) {s : Set Œ≥}, BddAbove (insert a s) ‚Üî BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"Adding a point to a set preserves its boundedness above. \"}]\n",
    "prompt_cons": "/-- A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element. -/\ntheorem ‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem ‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m :=\n\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem ‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {c : Set Œ±}, IsChain r c ‚Üí ‚àÉ M, IsMaxChain r M ‚àß c ‚äÜ M :=\n\n/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.) -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\n  c ‚äÜ nonPrincipals R ‚Üí\n    IsChain (fun x x_1 => x ‚â§ x_1) c ‚Üí\n      ‚àÄ {K : Ideal R}, K ‚àà c ‚Üí ‚àÉ I, I ‚àà nonPrincipals R ‚àß ‚àÄ (J : Ideal R), J ‚àà c ‚Üí J ‚â§ I :=\n\n/-- Any upper bound is more than the set supremum. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (s : Set Œ±) (a : Œ±), (‚àÄ (b : Œ±), b ‚àà s ‚Üí b ‚â§ a) ‚Üí sSup s ‚â§ a :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] (s : Set Œ±), BddAbove s :=\n\n/-- A finite union of sets which are all bounded above is still bounded above. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±},\n  Set.Finite I ‚Üí (BddAbove (‚ãÉ (i : Œ≤) (_ : i ‚àà I), S i) ‚Üî ‚àÄ (i : Œ≤), i ‚àà I ‚Üí BddAbove (S i)) :=\n\n/-- A finite set is bounded above. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±}, Set.Finite s ‚Üí BddAbove s :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : TopologicalSpace.SecondCountableTopology Œ±],\n  IsClosed C ‚Üí ¬¨Set.Countable C ‚Üí ‚àÉ D, Perfect D ‚àß Set.Nonempty D ‚àß D ‚äÜ C :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem ‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s ‚Üí TotallyBounded s :=\n\n/-- Any element of a set is more than the set infimum. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí sInf s ‚â§ a :=\n\n/-- There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem ‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\n  ‚àÉ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí Set.Nonempty s ‚Üí IsConnected s :=\n\n/-- In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. -/\ntheorem ‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : Nontrivial A]\n  (a : A), Set.Nonempty (spectrum ‚ÑÇ a) :=\n\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\ntheorem ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ‚Ñù V] [inst_2 : FiniteDimensional ‚Ñù V] {s : Set V},\n  Convex ‚Ñù s ‚Üí Set.Nonempty s ‚Üí Set.Nonempty (intrinsicInterior ‚Ñù s) :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {Œ≤ : Type u_2} [inst_1 : Ring Œ≤] {abv : Œ≤ ‚Üí Œ±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Œ≤ abv] (s : CauSeq Œ≤ abv), ‚àÉ b, s ‚âà CauSeq.const abv b :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : MeasurableSpace Œ±] (Œº : MeasureTheory.Measure Œ±) {Œµ : ENNReal},\n  0 < Œµ ‚Üí\n    ‚àÄ {As : Œπ ‚Üí Set Œ±},\n      (‚àÄ (i : Œπ), MeasurableSet (As i)) ‚Üí\n        Pairwise (Disjoint on As) ‚Üí ‚Üë‚ÜëŒº (‚ãÉ (i : Œπ), As i) ‚â† ‚ä§ ‚Üí Set.Finite {i | Œµ ‚â§ ‚Üë‚ÜëŒº (As i)} :=\n\n/-- Adding a point to a set preserves its boundedness above. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] (a : Œ≥) {s : Set Œ≥}, BddAbove (insert a s) ‚Üî BddAbove s :=\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\n  Set.Nonempty Œ± ‚Üí\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : PartialOrder Œ±] [inst_1 : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : PartialOrder Œ±] [inst_1 : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : PartialOrder Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí (‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m) ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m ",
      "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±] [inst_1 : IsPreorder r],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\n    ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m "
    ]
  },
  {
    "docString": "A group whose automorphism group is cyclic is Abelian.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\": \"‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `‚Ñ§` is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ‚â§ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Œº : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Œº] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\n  IsCyclic { x // x ‚àà S } :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Every subgroup of `‚Ñ§` is cyclic. -/\ntheorem ‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a} :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G) :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- The right regular action of an additive group on itself is transitive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ‚â§ 1 :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Œº : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Œº] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Œº :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- A group whose automorphism group is cyclic is Abelian. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], CommGroup G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsCommGroup G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ",
      "‚àÄ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) ‚Üí IsAbelian G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], CommGroup G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsCommutative G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], CommGroup G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], CommGroup G ",
      "‚àÄ {Œ± : Type u} [inst : Group Œ±] (h : IsCyclic (Aut Œ±)), IsCommutative Œ± ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u) ‚Üí ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±),\\n      x ‚àà s ‚Üí\\n        ‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n          u ‚àà uniformity Œ≤ ‚Üí\\n            ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformlyOn F f p s ‚Üí\\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\\n  x ‚àà s ‚Üí\\n    (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n        u ‚àà uniformity Œ≤ ‚Üí\\n          ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {A : Set (Œ≤ ‚Üí Œ±)},\\n  Set.UniformEquicontinuous A ‚Üí Set.UniformEquicontinuous (closure A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of functions is uniformly equicontinuous, its closure for the product topology is also\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº :=\n\n/-- Uniform continuity of the function -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u) ‚Üí ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±),\n      x ‚àà s ‚Üí\n        ‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n          u ‚àà uniformity Œ≤ ‚Üí\n            ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    ContinuousAt f x :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K) :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i) :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformlyOn F f p s ‚Üí\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\n  x ‚àà s ‚Üí\n    (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n        u ‚àà uniformity Œ≤ ‚Üí\n          ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n      ContinuousWithinAt f s x :=\n\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {A : Set (Œ≤ ‚Üí Œ±)},\n  Set.UniformEquicontinuous A ‚Üí Set.UniformEquicontinuous (closure A) :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí Equicontinuous F :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥),\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f) {g : Œ≤ ‚Üí Œ≥} (hg : UniformContinuous g),\n  UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      " ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "forall {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "forall {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u) ‚Üí ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±),\\n      x ‚àà s ‚Üí\\n        ‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n          u ‚àà uniformity Œ≤ ‚Üí\\n            ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformlyOn F f p s ‚Üí\\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\\n  x ‚àà s ‚Üí\\n    (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\\n        u ‚àà uniformity Œ≤ ‚Üí\\n          ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {A : Set (Œ≤ ‚Üí Œ±)},\\n  Set.UniformEquicontinuous A ‚Üí Set.UniformEquicontinuous (closure A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of functions is uniformly equicontinuous, its closure for the product topology is also\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº :=\n\n/-- Uniform continuity of the function -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u) ‚Üí ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±),\n      x ‚àà s ‚Üí\n        ‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n          u ‚àà uniformity Œ≤ ‚Üí\n            ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n    ContinuousAt f x :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformlyOn F f p s ‚Üí (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K) :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i) :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoLocallyUniformlyOn F f p s ‚Üí\n    (‚àÄ·∂† (n : Œπ) in p, ContinuousOn (F n) s) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {x : Œ±} [inst_1 : TopologicalSpace Œ±],\n  x ‚àà s ‚Üí\n    (‚àÄ (u : Set (Œ≤ √ó Œ≤)),\n        u ‚àà uniformity Œ≤ ‚Üí\n          ‚àÉ t, t ‚àà nhdsWithin x s ‚àß ‚àÉ F, ContinuousWithinAt F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\n      ContinuousWithinAt f s x :=\n\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {A : Set (Œ≤ ‚Üí Œ±)},\n  Set.UniformEquicontinuous A ‚Üí Set.UniformEquicontinuous (closure A) :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí Equicontinuous F :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "forall {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3}\n  [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥),\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  (self : Œ± ‚Üí·µ§ Œ≤) (f : Œ≤ ‚Üí·µ§ Œ≥), UniformContinuous (f.to_fun ‚àò self.to_fun) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "forall {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "forall {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥},\n  UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥), UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformContinuous f ‚Üí UniformContinuous g ‚Üí UniformContinuous (g ‚àò f) ",
      "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]\n  {F : Œ≤ ‚Üí Œ±} {G : Œ± ‚Üí Œ≥}, UniformContinuous F ‚Üí UniformContinuous G ‚Üí UniformContinuous (Œª x, G (F x)) "
    ]
  },
  {
    "docString": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : DiscreteTopology Œ±], TopologicalSpace.SeparableSpace Œ± ‚Üî Countable Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : DiscreteTopology Œ±], LocallyConnectedSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : NormalSpace Œ±] (s t : Set Œ±),\\n  IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsSpectralMap f ‚Üí ‚àÄ ‚¶És : Set Œ≤‚¶Ñ, IsOpen s ‚Üí IsCompact s ‚Üí IsCompact (f ‚Åª¬π' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function between topological spaces is spectral if it is continuous and the preimage of\\nevery compact open set is compact open. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤},\\n  t‚ÇÇ ‚â§ t‚ÇÅ ‚Üí ‚àÄ {s : Set Œ±} {f : Œ± ‚Üí Œ≤}, ContinuousOn f s ‚Üí ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤},\\n  t‚ÇÇ ‚â§ t‚ÇÉ ‚Üí ‚àÄ {s : Set Œ±} {f : Œ± ‚Üí Œ≤}, ContinuousOn f s ‚Üí ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤]\\n  [inst_1 : TopologicalSpace.SeparableSpace Œ±] [inst_2 : TopologicalSpace.SeparableSpace Œ≤],\\n  TopologicalSpace.SeparableSpace (Œ± √ó Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SeparableSpace Œ±] {Œπ : Type u_1} {s : Œπ ‚Üí Set Œ±}\\n  {a : Set Œπ},\\n  Set.PairwiseDisjoint a s ‚Üí\\n    (‚àÄ (i : Œπ), i ‚àà a ‚Üí IsOpen (s i)) ‚Üí (‚àÄ (i : Œπ), i ‚àà a ‚Üí Set.Nonempty (s i)) ‚Üí Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (X i)]\\n  [inst_1 : ‚àÄ (i : Œπ), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Œπ],\\n  TopologicalSpace.SeparableSpace ((i : Œπ) ‚Üí X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} (U : Set Œ±), IsOpen U ‚Üî U = ‚àÖ ‚à® U = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [hnorm : NontriviallyNormedField ùïú] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ùïú E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ùïú E] (l : E ‚Üí‚Çó[ùïú] ùïú),\\n  Continuous ‚Üël ‚Üî IsClosed ‚Üë(LinearMap.ker l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any linear form on a topological vector space over a nontrivially normed field is continuous if\\nand only if its kernel is closed. \"}]\n",
    "prompt_cons": "/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem ‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : DiscreteTopology Œ±], TopologicalSpace.SeparableSpace Œ± ‚Üî Countable Œ± :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : DiscreteTopology Œ±], LocallyConnectedSpace Œ± :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : NormalSpace Œ±] (s t : Set Œ±),\n  IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí SeparatedNhds s t :=\n\n/-- A function between topological spaces is spectral if it is continuous and the preimage of\nevery compact open set is compact open. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsSpectralMap f ‚Üí ‚àÄ ‚¶És : Set Œ≤‚¶Ñ, IsOpen s ‚Üí IsCompact s ‚Üí IsCompact (f ‚Åª¬π' s) :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤},\n  t‚ÇÇ ‚â§ t‚ÇÅ ‚Üí ‚àÄ {s : Set Œ±} {f : Œ± ‚Üí Œ≤}, ContinuousOn f s ‚Üí ContinuousOn f s :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤},\n  t‚ÇÇ ‚â§ t‚ÇÉ ‚Üí ‚àÄ {s : Set Œ±} {f : Œ± ‚Üí Œ≤}, ContinuousOn f s ‚Üí ContinuousOn f s :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem ‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤]\n  [inst_1 : TopologicalSpace.SeparableSpace Œ±] [inst_2 : TopologicalSpace.SeparableSpace Œ≤],\n  TopologicalSpace.SeparableSpace (Œ± √ó Œ≤) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SeparableSpace Œ±] {Œπ : Type u_1} {s : Œπ ‚Üí Set Œ±}\n  {a : Set Œπ},\n  Set.PairwiseDisjoint a s ‚Üí\n    (‚àÄ (i : Œπ), i ‚àà a ‚Üí IsOpen (s i)) ‚Üí (‚àÄ (i : Œπ), i ‚àà a ‚Üí Set.Nonempty (s i)) ‚Üí Set.Countable a :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§ :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ‚àÄ {Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (X i)]\n  [inst_1 : ‚àÄ (i : Œπ), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Œπ],\n  TopologicalSpace.SeparableSpace ((i : Œπ) ‚Üí X i) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V) :=\n\n/-- The only open sets in the indiscrete topology are the empty set and the whole space. -/\ntheorem ‚àÄ {Œ± : Type u_1} (U : Set Œ±), IsOpen U ‚Üî U = ‚àÖ ‚à® U = Set.univ :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\nand only if its kernel is closed. -/\ntheorem ‚àÄ {ùïú : Type u} [hnorm : NontriviallyNormedField ùïú] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ùïú E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ùïú E] (l : E ‚Üí‚Çó[ùïú] ùïú),\n  Continuous ‚Üël ‚Üî IsClosed ‚Üë(LinearMap.ker l) :=\n\n/-- A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function. -/\ntheorem",
    "choices": [
      "‚àÄ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X ‚Üî ‚àÄ (A B : Set X), IsClosed A ‚Üí IsClosed B ‚Üí Disjoint A B ‚Üí ‚àÉ f, Continuous f ‚àß f A ‚äÜ ‚ä• ‚àß f B ‚äá ‚ä§ ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], NormalSpace Œ± ‚Üî\n  ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, Continuous f ‚àß f =·∂†[ùìù[s] s] 0 ‚àß f =·∂†[ùìù[t] t] 1 ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  NormalSpace Œ± ‚Üî ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, Continuous f ‚àß ‚àÄ (x : Œ±), f x ‚àà SeparationSpace s t ",
      "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±], NormalSpace Œ± ‚Üî\n  ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, Continuous f ‚àß ‚àÄ x, 0 ‚â§ f x ‚àß f x ‚â§ 1 ‚àß (x ‚àà s ‚Üí f x = 0) ‚àß (x ‚àà t ‚Üí f x = 1) ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  NormalSpace Œ± ‚Üî\n  ‚àÄ {s t : Set Œ±}, IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f : Œ± ‚Üí ‚Ñù, Continuous f ‚àß f '' s ‚äÜ (0, 1 / 3).Icc ‚àß f '' t ‚äÜ (2 / 3, 1).Icc ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  NormalSpace Œ± ‚Üî\n    ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ (f : Œ± ‚Üí ‚Ñù), Continuous f ‚àß f '' s ‚äÜ Iio 0 ‚àß f '' t ‚äÜ Ioi 0 ",
      "‚àÄ {X : Type u_1} [inst : TopologicalSpace X], NormalSpace X ‚Üî\n  ‚àÄ (A B : Set X), IsClosed A ‚Üí IsClosed B ‚Üí Disjoint A B ‚Üí\n    ‚àÉ f : X ‚Üí ‚Ñù, Continuous f ‚àß (‚àÄ (x : X), x ‚àà A ‚Üí f x = 0) ‚àß (‚àÄ (x : X), x ‚àà B ‚Üí f x = 1) ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  NormalSpace Œ± ‚Üî ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ (f : Œ± ‚Üí ‚Ñù), Continuous f ‚àß ‚àÄ (x : Œ±), x ‚àà s ‚Üí f x = 0 ‚àß ‚àÄ (x : Œ±), x ‚àà t ‚Üí f x = 1 ",
      "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±],\n  NormalSpace Œ± ‚Üî ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, ContinuousOn f s ‚àß ContinuousOn f t ‚àß ‚àÄ x, x ‚àà s ‚Üí f x = 0 ‚àß ‚àÄ y, y ‚àà t ‚Üí f y = 1 ",
      "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±],\n  NormalSpace Œ± ‚Üî ‚àÄ (s t : Set Œ±), IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, Continuous f ‚àß f ‚àò coe = id "
    ]
  },
  {
    "docString": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ p‚ÇÖ : P},\\n  p‚ÇÅ ‚àà affineSpan k {p‚ÇÑ, p‚ÇÖ} ‚Üí p‚ÇÇ ‚àà affineSpan k {p‚ÇÑ, p‚ÇÖ} ‚Üí p‚ÇÉ ‚àà affineSpan k {p‚ÇÑ, p‚ÇÖ} ‚Üí Collinear k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points lie in the affine span of two points, the first three points are collinear. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.Cospherical s ‚Üí\\n    ‚àÄ {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, p‚ÇÅ ‚àà s ‚Üí p‚ÇÇ ‚àà s ‚Üí p‚ÇÉ ‚àà s ‚Üí p‚ÇÅ ‚â† p‚ÇÇ ‚Üí p‚ÇÅ ‚â† p‚ÇÉ ‚Üí p‚ÇÇ ‚â† p‚ÇÉ ‚Üí AffineIndependent ‚Ñù ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ]\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any three points in a cospherical set are affinely independent. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x : Œ±), ‚àÉ y, y ‚àà Set.Ico 0 c ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ico a (a + c) ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ico a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (p‚ÇÅ p‚ÇÇ p‚ÇÉ : P), Coplanar k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ}\",\n  \"isProp\": true,\n  \"docString\": \"Three points are coplanar. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P},\\n  ¬¨Collinear ‚Ñù {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} ‚Üí 0 < Real.sin (EuclideanGeometry.angle p‚ÇÅ p‚ÇÇ p‚ÇÉ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points are not collinear, the sine of the angle between them is positive. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.angle p‚ÇÅ p‚ÇÇ p‚ÇÉ = Real.pi ‚Üí Collinear ‚Ñù {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ}\",\n  \"isProp\": true,\n  \"docString\": \"If the angle between three points is œÄ, they are collinear. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ioc a (a + c) ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ioc a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.OrthocentricSystem s ‚Üí\\n    ‚àÄ {p : Fin 3 ‚Üí P}, Set.range p ‚äÜ s ‚Üí Function.Injective p ‚Üí affineSpan ‚Ñù (Set.range p) = affineSpan ‚Ñù s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any three points in an orthocentric system span the same subspace\\nas the whole orthocentric system. \"},\n {\"theorem\":\n  \"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, p‚ÇÅ ‚àà affineSpan k {p‚ÇÇ, p‚ÇÉ} ‚Üí Collinear k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a point lies in the affine span of two points, those three points are collinear. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, ¬¨Collinear ‚Ñù {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} ‚Üí 0 < EuclideanGeometry.angle p‚ÇÅ p‚ÇÇ p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points are not collinear, the angle between them is positive. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a b c : Œ±), a < b ‚Üí 0 < c ‚Üí a * c < b * c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right multiplication by a positive element is strictly monotone. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.OrthocentricSystem s ‚Üí\\n    ‚àÄ {p : Fin 3 ‚Üí P}, Set.range p ‚äÜ s ‚Üí Function.Injective p ‚Üí AffineIndependent ‚Ñù p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any three points in an orthocentric system are affinely independent. \"}]\n",
    "prompt_cons": "/-- Any point is a periodic point of period `0`. -/\ntheorem ‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem ‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x :=\n\n/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem ‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ p‚ÇÖ : P},\n  p‚ÇÅ ‚àà affineSpan k {p‚ÇÑ, p‚ÇÖ} ‚Üí p‚ÇÇ ‚àà affineSpan k {p‚ÇÑ, p‚ÇÖ} ‚Üí p‚ÇÉ ‚àà affineSpan k {p‚ÇÑ, p‚ÇÖ} ‚Üí Collinear k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} :=\n\n/-- Any three points in a cospherical set are affinely independent. -/\ntheorem ‚àÄ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\n  EuclideanGeometry.Cospherical s ‚Üí\n    ‚àÄ {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, p‚ÇÅ ‚àà s ‚Üí p‚ÇÇ ‚àà s ‚Üí p‚ÇÉ ‚àà s ‚Üí p‚ÇÅ ‚â† p‚ÇÇ ‚Üí p‚ÇÅ ‚â† p‚ÇÉ ‚Üí p‚ÇÇ ‚â† p‚ÇÉ ‚Üí AffineIndependent ‚Ñù ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ] :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ico 0 c` such that `f x = f y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x : Œ±), ‚àÉ y, y ‚àà Set.Ico 0 c ‚àß f x = f y :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ico a (a + c)` such that `f x = f y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ico a (a + c) ‚àß f x = f y :=\n\n/-- A continuous, periodic function has compact range. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f) :=\n\n/-- Three points are coplanar. -/\ntheorem ‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ p‚ÇÇ p‚ÇÉ : P), Coplanar k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} :=\n\n/-- If three points are not collinear, the sine of the angle between them is positive. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P},\n  ¬¨Collinear ‚Ñù {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} ‚Üí 0 < Real.sin (EuclideanGeometry.angle p‚ÇÅ p‚ÇÇ p‚ÇÉ) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem ‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº :=\n\n/-- If the angle between three points is œÄ, they are collinear. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.angle p‚ÇÅ p‚ÇÇ p‚ÇÉ = Real.pi ‚Üí Collinear ‚Ñù {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ioc a (a + c)` such that `f x = f y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ioc a (a + c) ‚àß f x = f y :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f) :=\n\n/-- Any three points in an orthocentric system span the same subspace\nas the whole orthocentric system. -/\ntheorem ‚àÄ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\n  EuclideanGeometry.OrthocentricSystem s ‚Üí\n    ‚àÄ {p : Fin 3 ‚Üí P}, Set.range p ‚äÜ s ‚Üí Function.Injective p ‚Üí affineSpan ‚Ñù (Set.range p) = affineSpan ‚Ñù s :=\n\n/-- If a point lies in the affine span of two points, those three points are collinear. -/\ntheorem ‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, p‚ÇÅ ‚àà affineSpan k {p‚ÇÇ, p‚ÇÉ} ‚Üí Collinear k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} :=\n\n/-- If three points are not collinear, the angle between them is positive. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, ¬¨Collinear ‚Ñù {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} ‚Üí 0 < EuclideanGeometry.angle p‚ÇÅ p‚ÇÇ p‚ÇÉ :=\n\n/-- Right multiplication by a positive element is strictly monotone. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a b c : Œ±), a < b ‚Üí 0 < c ‚Üí a * c < b * c :=\n\n/-- If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y :=\n\n/-- Any three points in an orthocentric system are affinely independent. -/\ntheorem ‚àÄ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\n  EuclideanGeometry.OrthocentricSystem s ‚Üí\n    ‚àÄ {p : Fin 3 ‚Üí P}, Set.range p ‚äÜ s ‚Üí Function.Injective p ‚Üí AffineIndependent ‚Ñù p :=\n\n/-- If a function from the unit interval to itself has a point of period three, then it has points of all positive periods. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±},\n  Function.IsPeriodicPt f 3 x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y ",
      "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\n  0 < Set.card (Function.fixed_points f) ‚Üí\n  (‚àÉ (x : Œ±) (n : ‚Ñï), 0 < n ‚àß Function.IsPeriodicPt f n x) ‚Üí\n    ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ x, Function.IsPeriodicPt f n x ",
      "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace.OpensMeasurableSpace Œ±]\n  [inst_3 : MeasurableSpace Œ±] {x : Œ±}, HasMem.Mem x (Set.Icc 0 1) ‚Üí Function.IsPeriodicPt f 3 x ‚Üí ‚àÄ n, ‚àÉ y, Function.IsPeriodicPt f n y ",
      "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) [inst : LinearOrderedField Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±],\n  IsUnitInterval Œ± ‚Üí\n    (‚àÉ x, Function.IsPeriodicPt f 3 x) ‚Üí ‚àÄ n : ‚Ñï, n > 0 ‚Üí ‚àÉ x, Function.IsPeriodicPt f n x ",
      "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) [inst : LinearOrder Œ±] [inst_1 : Nonempty Œ±]\n  [inst_2 : TopologicalSpace Œ±] [inst_3 : OrderTopology Œ±],\n  (‚àÉ x, Function.IsPeriodicPt f 3 x) ‚Üí ‚àÄ n, ‚àÉ x, Function.IsPeriodicPt f n x ",
      "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±] {I : Set Œ±} {f : Œ± ‚Üí Œ±}\n  {x : Œ±}, I = Set.Icc (0 : Œ±) 1 ‚Üí f x = x ‚Üí Function.IsPeriodicPt f 3 x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y ",
      "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] (f : I ‚Üí I) {x : I},\n  Function.IsPeriodicPt f 3 x ‚Üí ‚àÄ n, ‚àÉ y, Function.IsPeriodicPt f n y ",
      "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±] [inst_2 : TopologicalAddGroup Œ±] [inst_3 : Archimedean Œ±]\n  (f : Œ± ‚Üí Œ±) {x : Œ±},\n  f x ‚àà Set.Icc 0 1 ‚Üí\n  Function.IsPeriodicPt f 3 x ‚Üí\n  ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y ‚àß y ‚àà Set.Icc 0 1 ",
      "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) [inst : LinearOrderedField Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : FloorRing Œ±],\n  (‚àÉ x, Function.IsPeriodicPt f 3 x) ‚Üí ‚àÄ n, ‚àÉ x, Function.IsPeriodicPt f n x ",
      "‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±},\n  Function.IsPeriodicPt f 3 x ‚Üí ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚àÉ y, Function.IsPeriodicPt f n y "
    ]
  },
  {
    "docString": "A terminal object in a category is unique up to unique isomorphism.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (X ‚ü∂ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\\n  (‚àÄ (A : C) (f : I ‚ü∂ A), CategoryTheory.IsIso f) ‚Üí CategoryTheory.Limits.HasStrictTerminalObjects C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\\nhas strict terminal objects. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"theorem\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\": \"A category with finite biproducts has a zero object. \"},\n {\"theorem\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.IsSplitMono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is split mono. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\",\n  \"isProp\": true,\n  \"docString\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (‚ä§_ C)) ‚Üí CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}\\n  [inst_2 : CategoryTheory.Simple Y] {f : X ‚ü∂ Y} [inst_3 : CategoryTheory.Mono f], f ‚â† 0 ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero monomorphism to a simple object is an isomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T ‚Üí\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) ‚Üí CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ (C : Type u_1) [inst : CategoryTheory.Category C],\\n  CategoryTheory.IsIdempotentComplete C ‚Üî\\n    ‚àÄ (X : C) (p : X ‚ü∂ X),\\n      CategoryTheory.CategoryStruct.comp p p = p ‚Üí\\n        CategoryTheory.Limits.HasEqualizer (CategoryTheory.CategoryStruct.id X) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A category is idempotent complete iff for all idempotent endomorphisms,\\nthe equalizer of the identity and this idempotent exists. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X Y : C}\\n  [inst_2 : CategoryTheory.Simple X] {f : X ‚ü∂ Y} [inst_3 : CategoryTheory.Epi f], f ‚â† 0 ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonzero epimorphism from a simple object is an isomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.StrongMonoCategory C] {X Y : C} (f : X ‚ü∂ Y)\\n  [inst_1 : CategoryTheory.Mono f], CategoryTheory.StrongMono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A strong mono category is a category in which every monomorphism is strong. \"},\n {\"theorem\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any category with pullbacks and terminal object has binary products. \"},\n {\"theorem\":\n  \"{C : Type u‚ÇÅ} ‚Üí\\n  [inst : CategoryTheory.Category C] ‚Üí\\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí {P : C} ‚Üí CategoryTheory.Limits.IsTerminal P ‚Üí (‚ä§_ C ‚âÖ P)\",\n  \"isProp\": false,\n  \"docString\":\n  \"The (unique) isomorphism between the chosen terminal object and any other terminal object. \"}]\n",
    "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (X ‚ü∂ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\n  (‚àÄ (A : C) (f : I ‚ü∂ A), CategoryTheory.IsIso f) ‚Üí CategoryTheory.Limits.HasStrictTerminalObjects C :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- A category with finite biproducts has a zero object. -/\ntheorem ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- Any morphism from a terminal object is split mono. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.IsSplitMono f :=\n\n/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\n  CategoryTheory.Limits.HasImages C :=\n\n/-- The category `D` has isomorphic objects equal -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (‚ä§_ C)) ‚Üí CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- A nonzero monomorphism to a simple object is an isomorphism. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}\n  [inst_2 : CategoryTheory.Simple Y] {f : X ‚ü∂ Y} [inst_3 : CategoryTheory.Mono f], f ‚â† 0 ‚Üí CategoryTheory.IsIso f :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T ‚Üí\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) ‚Üí CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- A category is idempotent complete iff for all idempotent endomorphisms,\nthe equalizer of the identity and this idempotent exists. -/\ntheorem ‚àÄ (C : Type u_1) [inst : CategoryTheory.Category C],\n  CategoryTheory.IsIdempotentComplete C ‚Üî\n    ‚àÄ (X : C) (p : X ‚ü∂ X),\n      CategoryTheory.CategoryStruct.comp p p = p ‚Üí\n        CategoryTheory.Limits.HasEqualizer (CategoryTheory.CategoryStruct.id X) p :=\n\n/-- A nonzero epimorphism from a simple object is an isomorphism. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X Y : C}\n  [inst_2 : CategoryTheory.Simple X] {f : X ‚ü∂ Y} [inst_3 : CategoryTheory.Epi f], f ‚â† 0 ‚Üí CategoryTheory.IsIso f :=\n\n/-- A strong mono category is a category in which every monomorphism is strong. -/\ntheorem ‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.StrongMonoCategory C] {X Y : C} (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.Mono f], CategoryTheory.StrongMono f :=\n\n/-- Any category with pullbacks and terminal object has binary products. -/\ntheorem ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C :=\n\n/-- The (unique) isomorphism between the chosen terminal object and any other terminal object. -/\ntheorem {C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí {P : C} ‚Üí CategoryTheory.Limits.IsTerminal P ‚Üí (‚ä§_ C ‚âÖ P) :=\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\ntheorem",
    "choices": [
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X ‚Üí CategoryTheory.Limits.IsTerminal Y ‚Üí X ‚âÖ Y ",
      "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category C] ‚Üí\n    CategoryTheory.Limits.HasTerminal C ‚Üí (P Q : C) ‚Üí CategoryTheory.Limits.IsTerminal P ‚Üí CategoryTheory.Limits.IsTerminal Q ‚Üí (P ‚âÖ Q) ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y], X ‚âÖ Y ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] (X Y : C),\n  CategoryTheory.Limits.IsTerminal X ‚Üí CategoryTheory.Limits.IsTerminal Y ‚Üí (X ‚âÖ Y) ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Nonempty (X ‚âÖ Y) ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsTerminal X ‚Üí CategoryTheory.Limits.IsTerminal Y ‚Üí (X ‚âÖ Y) ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y], X ‚âÖ Y ",
      "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí ‚àÄ (Y‚ÇÅ Y‚ÇÇ : C), CategoryTheory.Limits.IsTerminal Y‚ÇÅ ‚Üí CategoryTheory.Limits.IsTerminal Y‚ÇÇ ‚Üí Y‚ÇÅ ‚âÖ Y‚ÇÇ ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y], X ‚âÖ Y ",
      "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {A B : C}\n  (hA : CategoryTheory.Limits.IsTerminal A) (hB : CategoryTheory.Limits.IsTerminal B), Unique (A ‚âÖ B) "
    ]
  },
  {
    "docString": "The complement of the union of two sets is the intersection of their complements.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\\n  s ‚à© t = ‚àÖ ‚Üí\\n    ‚àÄ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C U : Set Œ±}, Preperfect C ‚Üí IsOpen U ‚Üí Preperfect (U ‚à© C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±},\\n  Set.Nonempty (s ‚à© t) ‚Üí Metric.diam (s ‚à™ t) ‚â§ Metric.diam s + Metric.diam t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets intersect, the diameter of the union is bounded by the sum of the diameters. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z a b : Set Œ±},\\n  IsClopen Z ‚Üí Z ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (Z ‚à© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ‚ãÉ (n : ‚Ñï), CompactExhaustion.toFun self n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (‚Ñô K V)),\\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {a : Set (Œ± √ó Œ±)},\\n  a ‚àà uniformity Œ± ‚Üí\\n    ‚àÄ {b : Set (Œ≤ √ó Œ≤)},\\n      b ‚àà uniformity Œ≤ ‚Üí\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ‚à™ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ‚àà\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"}]\n",
    "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t) :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t) :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem ‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\n  s ‚à© t = ‚àÖ ‚Üí\n    ‚àÄ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t) :=\n\n/-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\ntheorem ‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets :=\n\n/-- The intersection of a preperfect set and an open set is preperfect. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C U : Set Œ±}, Preperfect C ‚Üí IsOpen U ‚Üí Preperfect (U ‚à© C) :=\n\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem ‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\ t) :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤) :=\n\n/-- If two sets intersect, the diameter of the union is bounded by the sum of the diameters. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±},\n  Set.Nonempty (s ‚à© t) ‚Üí Metric.diam (s ‚à™ t) ‚â§ Metric.diam s + Metric.diam t :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z a b : Set Œ±},\n  IsClopen Z ‚Üí Z ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (Z ‚à© a) :=\n\n/-- The span of a union of sets is the sup of their spans. -/\ntheorem ‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t :=\n\n/-- The union of all sets in a compact exhaustion equals the entire space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  ‚ãÉ (n : ‚Ñï), CompactExhaustion.toFun self n = Set.univ :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (‚Ñô K V)),\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T :=\n\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem ‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {a : Set (Œ± √ó Œ±)},\n  a ‚àà uniformity Œ± ‚Üí\n    ‚àÄ {b : Set (Œ≤ √ó Œ≤)},\n      b ‚àà uniformity Œ≤ ‚Üí\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ‚à™ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ‚àà\n          UniformSpace.Core.sum.uniformity :=\n\n/-- The complement of the union of two sets is the intersection of their complements. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à© t·∂ú = (s ‚à™ t)·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à© t·∂ú = (s ‚à™ t)·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à© t·∂ú = (s ‚à™ t)·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à© t·∂ú = (s ‚à™ t)·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à© t·∂ú = (s ‚à™ t)·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), s·∂ú ‚à© t·∂ú = (s ‚à™ t)·∂ú ",
      "‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú "
    ]
  },
  {
    "docString": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"‚àÄ {n m : ‚Ñï}, m * m < n ‚Üí n < (m + 1) * (m + 1) ‚Üí ¬¨‚àÉ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m¬≤ and (m+1)¬≤ \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = 1 ‚Üí p‚ÇÅ ‚â† p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first and third points are not\\nequal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = 1 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first two points are not\\nequal. \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {d : ‚Ñ§} {a : Pell.Solution‚ÇÅ d}, Pell.IsFundamental a ‚Üí ‚àÄ {n n' : ‚Ñ§}, a ^ n ‚â† -a ^ n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"A power of a fundamental solution is never equal to the negative of a power of this\\nfundamental solution. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `œÄ / 2`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ ‚â† 0 ‚Üí p‚ÇÅ ‚â† p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is nonzero, the first and third points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚ÜëReal.pi ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `œÄ`, the first two points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚ÜëReal.pi ‚Üí p‚ÇÅ ‚â† p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `œÄ`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ ‚â† 0 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is nonzero, the first two points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `œÄ / 2`, the first two points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(-Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `-œÄ / 2`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = -1 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is negative, the first two points are not\\nequal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = 1 ‚Üí p‚ÇÉ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the last two points are not\\nequal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = -1 ‚Üí p‚ÇÅ ‚â† p‚ÇÉ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is negative, the first and third points are not\\nequal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a b c : Œ±},\\n  Finset.uIcc a c ‚äÜ Finset.uIcc a b ‚à™ Finset.uIcc b c\",\n  \"isProp\": true,\n  \"docString\": \"A sort of triangle inequality. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) ‚â† 0 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is nonzero, the first two points are not\\nequal. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(-Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `-œÄ / 2`, the first two points are not equal. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"}]\n",
    "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/-- There are no perfect squares strictly between m¬≤ and (m+1)¬≤ -/\ntheorem ‚àÄ {n m : ‚Ñï}, m * m < n ‚Üí n < (m + 1) * (m + 1) ‚Üí ¬¨‚àÉ t, t * t = n :=\n\n/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = 1 ‚Üí p‚ÇÅ ‚â† p‚ÇÉ :=\n\n/-- If the sign of the angle between three points is positive, the first two points are not\nequal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = 1 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- A power of a fundamental solution is never equal to the negative of a power of this\nfundamental solution. -/\ntheorem ‚àÄ {d : ‚Ñ§} {a : Pell.Solution‚ÇÅ d}, Pell.IsFundamental a ‚Üí ‚àÄ {n n' : ‚Ñ§}, a ^ n ‚â† -a ^ n' :=\n\n/-- If the angle between three points is `œÄ / 2`, the first and third points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÉ :=\n\n/-- If the angle between three points is nonzero, the first and third points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ ‚â† 0 ‚Üí p‚ÇÅ ‚â† p‚ÇÉ :=\n\n/-- If the angle between three points is `œÄ`, the first two points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚ÜëReal.pi ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- If the angle between three points is `œÄ`, the first and third points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚ÜëReal.pi ‚Üí p‚ÇÅ ‚â† p‚ÇÉ :=\n\n/-- If the angle between three points is nonzero, the first two points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ ‚â† 0 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- If the angle between three points is `œÄ / 2`, the first two points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- If the angle between three points is `-œÄ / 2`, the first and third points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(-Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÉ :=\n\n/-- If the sign of the angle between three points is negative, the first two points are not\nequal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = -1 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- If the sign of the angle between three points is positive, the last two points are not\nequal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = 1 ‚Üí p‚ÇÉ ‚â† p‚ÇÇ :=\n\n/-- If the sign of the angle between three points is negative, the first and third points are not\nequal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) = -1 ‚Üí p‚ÇÅ ‚â† p‚ÇÉ :=\n\n/-- A sort of triangle inequality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a b c : Œ±},\n  Finset.uIcc a c ‚äÜ Finset.uIcc a b ‚à™ Finset.uIcc b c :=\n\n/-- If the sign of the angle between three points is nonzero, the first two points are not\nequal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Real.Angle.sign (EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ) ‚â† 0 ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- If the angle between three points is `-œÄ / 2`, the first two points are not equal. -/\ntheorem ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] [inst_4 : Module.Oriented ‚Ñù V (Fin 2)]\n  {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë(-Real.pi / 2) ‚Üí p‚ÇÅ ‚â† p‚ÇÇ :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2 :=\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\ntheorem",
    "choices": [
      "‚àÄ {x y z : ‚Ñï}, x > 0 ‚Üí y > 0 ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x^3 + y^3 ‚â† z^3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, x > 0 ‚Üí y > 0 ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 ",
      "‚àÄ {x y z : ‚Ñï}, 0 < x ‚Üí 0 < y ‚Üí x ^ 3 + y ^ 3 ‚â† z ^ 3 "
    ]
  },
  {
    "docString": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
    "prompts": "[{\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí ‚àÄ {Œ≥ : Type u_1} [inst_2 : Group Œ≥] {g : Œ≤ ‚Üí Œ≥}, IsGroupHom g ‚Üí IsGroupHom (g ‚àò f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Mul R] [inst_1 : Star R] {x : R} [self : IsStarNormal x], Commute (star x) x\",\n  \"isProp\": true,\n  \"docString\": \"A normal element of a star monoid commutes with its adjoint. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)],\\n  Nat.card { x // x ‚àà commutator G } ‚à£\\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card ‚Üë(commutatorSet G) + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` has `n` commutators `[g‚ÇÅ, g‚ÇÇ]`, then `|G'| ‚à£ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\\nwhere `G'` denotes the commutator of `G`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n",
    "prompt_cons": "/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c) :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y) :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí ‚àÄ {Œ≥ : Type u_1} [inst_2 : Group Œ≥] {g : Œ≤ ‚Üí Œ≥}, IsGroupHom g ‚Üí IsGroupHom (g ‚àò f) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G } :=\n\n/-- A normal element of a star monoid commutes with its adjoint. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Mul R] [inst_1 : Star R] {x : R} [self : IsStarNormal x], Commute (star x) x :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c) :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a :=\n\n/-- If `G` has `n` commutators `[g‚ÇÅ, g‚ÇÇ]`, then `|G'| ‚à£ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\nwhere `G'` denotes the commutator of `G`. -/\ntheorem ‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)],\n  Nat.card { x // x ‚àà commutator G } ‚à£\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card ‚Üë(commutatorSet G) + 1) :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (x : G), x ^ 2 = 1), ‚àÄ (a b : G), Commute a b ",
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (x : G), x^2 = 1), ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (a : G), a ^ 2 = 1), ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (x : G), x * x = 1), ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (x : G), x * x = 1), ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (x : G), x * x = 1), ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G] (n : G), n ^ 2 = 1 ‚Üí ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G], (‚àÄ (x : G), x * x = 1) ‚Üí ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G], (‚àÄ (x : G), x * x = 1) ‚Üí ‚àÄ (x y : G), Commute x y ",
      "‚àÄ {G : Type u_1} [inst : Group G] (h : ‚àÄ (x : G), x * x = 1), ‚àÄ (x y : G), Commute x y "
    ]
  },
  {
    "docString": "The product of two consecutive natural numbers is even.",
    "prompts": "[{\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of two positive elements is positive. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, Even (m ^ n) ‚Üî Even m ‚àß n ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m` and `n` are natural numbers, then the natural number `m^n` is even\\nif and only if `m` is even and `n` is positive. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : Œπ ‚Üí WithTop R},\\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) ‚Üí (Finset.prod s fun i => f i) < ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x ‚Üí\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y ‚Üí DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two finite ad√®les is a finite ad√®le. \"},\n {\"theorem\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [self : OrderedRing Œ±] (a b : Œ±), 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of non-negative elements is non-negative. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x ‚Üí\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y ‚Üí DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite ad√®les is a finite ad√®le. \"},\n {\"theorem\": \"‚àÄ {n a : ‚Ñï}, Even n ‚Üí Even a ‚Üí Even (n % a)\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is even and `a` is even, then `n % a` is even. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : Œ± ‚Üí ENNReal}, (‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚â† ‚ä§) ‚Üí (Finset.sum s fun a => f a) < ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), PGame.Numeric ‚Üën\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"}]\n",
    "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- The product of two positive elements is positive. -/\ntheorem ‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem ‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l :=\n\n/-- If `m` and `n` are natural numbers, then the natural number `m^n` is even\nif and only if `m` is even and `n` is positive. -/\ntheorem ‚àÄ {m n : ‚Ñï}, Even (m ^ n) ‚Üî Even m ‚àß n ‚â† 0 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2 :=\n\n/-- A product of finite numbers is still finite -/\ntheorem ‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : Œπ ‚Üí WithTop R},\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) ‚Üí (Finset.prod s fun i => f i) < ‚ä§ :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3 :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- The product of two finite ad√®les is a finite ad√®le. -/\ntheorem ‚àÄ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x ‚Üí\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y ‚Üí DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x * y) :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0 :=\n\n/-- The product of non-negative elements is non-negative. -/\ntheorem ‚àÄ {Œ± : Type u} [self : OrderedRing Œ±] (a b : Œ±), 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a * b :=\n\n/-- The sum of two finite ad√®les is a finite ad√®le. -/\ntheorem ‚àÄ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x ‚Üí\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y ‚Üí DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- If `n` is even and `a` is even, then `n % a` is even. -/\ntheorem ‚àÄ {n a : ‚Ñï}, Even n ‚Üí Even a ‚Üí Even (n % a) :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : Œ± ‚Üí ENNReal}, (‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚â† ‚ä§) ‚Üí (Finset.sum s fun a => f a) < ‚ä§ :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem ‚àÄ (n : ‚Ñï), PGame.Numeric ‚Üën :=\n\n/-- The product of two consecutive natural numbers is even. -/\ntheorem",
    "choices": [
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) ",
      "‚àÄ (n : ‚Ñï), Even (n * (n + 1)) ",
      "‚àÄ {n : ‚Ñï}, Even (n * (n + 1)) "
    ]
  },
  {
    "docString": "Every index 2 subgroup of a group is normal.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G ‚Üí IsCoatom H ‚Üí Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üî ‚àÉ a, ‚àÄ (b : G), Xor' (b * a ‚àà H) (b ‚àà H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H ‚Üí H = ‚ä• ‚à® H = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `‚ä•` or `‚ä§` \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup contains the group's 1. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (‚àÄ (x : G), x ‚àà H ‚Üî x ‚àà K) ‚Üí H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t ‚Üí s ‚äÜ t ‚Üí Group.normalClosure s ‚äÜ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ‚àà H ‚Üí x‚Åª¬π ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under inverse. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of `s` is a normal subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí ‚àÄ {Œ≥ : Type u_1} [inst_2 : Group Œ≥] {g : Œ≤ ‚Üí Œ≥}, IsGroupHom g ‚Üí IsGroupHom (g ‚àò f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0 :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G ‚Üí IsCoatom H ‚Üí Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y :=\n\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üî ‚àÉ a, ‚àÄ (b : G), Xor' (b * a ‚àà H) (b ‚àà H) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ‚àÄ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- Any normal subgroup is either `‚ä•` or `‚ä§` -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H ‚Üí H = ‚ä• ‚à® H = ‚ä§ :=\n\n/-- A subgroup contains the group's 1. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ‚àà H :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (‚àÄ (x : G), x ‚àà H ‚Üî x ‚àà K) ‚Üí H = K :=\n\n/-- A subgroup is closed under division. -/\ntheorem ‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H :=\n\n/-- The additive subgroup has finite index -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0 :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t ‚Üí s ‚äÜ t ‚Üí Group.normalClosure s ‚äÜ t :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- A subgroup is closed under inverse. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ‚àà H ‚Üí x‚Åª¬π ‚àà H :=\n\n/-- The normal closure of `s` is a normal subgroup. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s) :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí ‚àÄ {Œ≥ : Type u_1} [inst_2 : Group Œ≥] {g : Œ≤ ‚Üí Œ≥}, IsGroupHom g ‚Üí IsGroupHom (g ‚àò f) :=\n\n/-- Every index 2 subgroup of a group is normal. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üí Subgroup.Normal H ",
      "‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 ‚Üí Subgroup.Normal H "
    ]
  },
  {
    "docString": "Every free group is torsion free.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G ‚Üí ¬¨AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"}]\n",
    "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G ‚Üí ¬¨AddMonoid.IsTorsionFree G :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G } :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä• :=\n\n/-- Every free group is torsion free. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype Œ±] (f : Œ± ‚Üí G), Monoid.IsTorsionFree (FreeGroup G) ",
      "‚àÄ {Œ± : Type u_1} (G : FreeGroup Œ±), Monoid.IsTorsionFree G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
      "‚àÄ {G : Type u_1} [inst : Group G], SemidirectProduct.IsFree G ‚Üí Monoid.IsTorsionFree G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
      "‚àÄ {Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí AddCommGroup (M i)] [inst_1 : ‚àÄ i, Module.Free R (M i)],\n  AddMonoid.IsTorsionFree (Œ† i, M i) ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
      "‚àÄ {G : Type u_1} [inst : Group G] (r : ‚Ñï) [inst_1 : FreeGroup.IsFree G r], Monoid.IsTorsionFree G ",
      "‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : Group G] (f : Œ± ‚Üí G), Monoid.IsTorsionFree (Multiplicative.FreeGroup Œ±) ",
      "forall {Œ± : Type u_1} {G : Type u_2} [inst : Group G] [F : FreeGroup Œ±] [f : Œ± ‚Üí G], Monoid.IsTorsionFree G "
    ]
  },
  {
    "docString": "Every natural number greater than `1` is divisible by a prime number.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"‚àÄ (n p : ‚Ñï), Finset.card (Finset.filter (fun e => p ‚à£ e + 1) (Finset.range n)) = n / p\",\n  \"isProp\": true,\n  \"docString\": \"Exactly `n / p` naturals in `[1, n]` are multiples of `p`. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. \"},\n {\"theorem\": \"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"‚àÄ (n p : ‚Ñï), Finset.card (Finset.filter (fun x => p ‚à£ x) (Finset.Ioc 0 n)) = n / p\",\n  \"isProp\": true,\n  \"docString\": \"Exactly `n / p` naturals in `(0, n]` are multiples of `p`. \"},\n {\"theorem\":\n  \"‚àÄ {p k : ‚Ñï}, k ‚â† 0 ‚Üí Nat.Prime p ‚Üí List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] {a b : Œ±}, a * b = 0 ‚Üí a = 0 ‚à® b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"‚àÄ (n : ‚Ñï), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\",\n  \"isProp\": true,\n  \"docString\": \"The factors of `n` are the prime divisors \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n] :=\n\n/-- Exactly `n / p` naturals in `[1, n]` are multiples of `p`. -/\ntheorem ‚àÄ (n p : ‚Ñï), Finset.card (Finset.filter (fun e => p ‚à£ e + 1) (Finset.range n)) = n / p :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem ‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem ‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem ‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1 :=\n\n/-- For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. -/\ntheorem ‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]} :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) p = 1 :=\n\n/-- Exactly `n / p` naturals in `(0, n]` are multiples of `p`. -/\ntheorem ‚àÄ (n p : ‚Ñï), Finset.card (Finset.filter (fun x => p ‚à£ x) (Finset.Ioc 0 n)) = n / p :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem ‚àÄ {p k : ‚Ñï}, k ‚â† 0 ‚Üí Nat.Prime p ‚Üí List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- No zero divisors. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] {a b : Œ±}, a * b = 0 ‚Üí a = 0 ‚à® b = 0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3 :=\n\n/-- The factors of `n` are the prime divisors -/\ntheorem ‚àÄ (n : ‚Ñï), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- Every natural number greater than `1` is divisible by a prime number. -/\ntheorem",
    "choices": [
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), n > 1 ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), n > 1 ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), n > 1 ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n ",
      "‚àÄ (n : ‚Ñï), 1 < n ‚Üí ‚àÉ (p : ‚Ñï), Nat.Prime p ‚àß p ‚à£ n "
    ]
  },
  {
    "docString": "A finite torsion-free group is trivial",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"}]\n",
    "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ± :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\n    Group.IsNilpotent G :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä• :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G] [hG : Monoid.IsTorsionFree G], Subsingleton G ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G ‚Üí Subsingleton G "
    ]
  },
  {
    "docString": "Every finite division ring is a field.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ (S : Set ‚Ñï+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ‚ÜëS] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"}]\n",
    "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S :=\n\n/-- A field is a valuation ring. -/\ntheorem ‚àÄ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem ‚àÄ (S : Set ‚Ñï+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite ‚ÜëS] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- A subfield is closed under division. -/\ntheorem ‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\n  IsCyclic { x // x ‚àà S } :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ± :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V ‚Üî Module.Finite K V :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§ :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem ‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ± :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±) :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S :=\n\n/-- A subfield is closed under multiplication. -/\ntheorem ‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ± :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I :=\n\n/-- Every finite division ring is a field. -/\ntheorem",
    "choices": [
      "‚àÄ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K ",
      "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
      "‚àÄ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Finite K], Field K ",
      "‚àÄ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "
    ]
  },
  {
    "docString": "Every finite topological space is compact.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] [inst : DiscreteTopology Œ±], Finite Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Œ± : Type v) (s : Œ± ‚Üí Set X),\\n  (‚àÄ (a : Œ±), IsOpen (s a)) ‚Üí ‚ãÉ (a : Œ±), s a = Set.univ ‚Üí ‚àÉ Œ≤ t x x, LocallyFinite t ‚àß ‚àÄ (b : Œ≤), ‚àÉ a, t b ‚äÜ s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\\n  Set.Finite s ‚Üí IsCompact (‚Üë(convexHull ‚Ñù) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s ‚Üí TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- The underlying topological space is compact. -/\ntheorem ‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop :=\n\n/-- A compact discrete space is finite. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] [inst : DiscreteTopology Œ±], Finite Œ± :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤) :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem ‚àÄ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Œ± : Type v) (s : Œ± ‚Üí Set X),\n  (‚àÄ (a : Œ±), IsOpen (s a)) ‚Üí ‚ãÉ (a : Œ±), s a = Set.univ ‚Üí ‚àÉ Œ≤ t x x, LocallyFinite t ‚àß ‚àÄ (b : Œ≤), ‚àÉ a, t b ‚äÜ s a :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem ‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Set.Finite s ‚Üí IsCompact (‚Üë(convexHull ‚Ñù) s) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤) :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem ‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s ‚Üí TotallyBounded s :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±) :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W) :=\n\n/-- Every finite topological space is compact. -/\ntheorem",
    "choices": [
      "finite_space_compact {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Fintype Œ±] : CompactSpace Œ± ",
      "finite_compact_space {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Fintype Œ±] : CompactSpace Œ± ",
      "forall {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± ",
      "finite_space.compact_space {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±] : CompactSpace Œ± ",
      "finite_compact {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±] : CompactSpace Œ± ",
      "finite_compact_space {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±] : CompactSpace Œ± ",
      "forall {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Fintype Œ±], CompactSpace Œ± ",
      "finite_compact {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±] : CompactSpace Œ± ",
      "finite_compact {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±] : CompactSpace Œ± ",
      "finite_compact {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±] : CompactSpace Œ± "
    ]
  },
  {
    "docString": "Every surjective homomorphism from a finitely generated free group to itself is injective.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R ‚Üí\\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\\n  Function.Injective ‚Üë(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_5} {M‚ÇÇ : Type u_2} [inst_5 : AddCommMonoid M‚ÇÇ]\\n  [inst_6 : Module R M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R] M),\\n  Function.Surjective ‚Üëf ‚Üí Function.Injective fun g => AlternatingMap.compLinearMap g f\",\n  \"isProp\": true,\n  \"docString\": \"Composing with a surjective linear map is injective. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : { x // x ‚àà LinearMap.ker f } ‚Üí‚Çó[R] M), LinearMap.comp f u = LinearMap.comp f v ‚Üí u = v) ‚Üí\\n    LinearMap.ker f = ‚ä•\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\\n  [inst_4 : Module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)]\\n  [inst_6 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)] (f : (i : Œπ) ‚Üí M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i),\\n  (‚àÄ (i : Œπ), Function.Surjective ‚Üë(f i)) ‚Üí Function.Injective fun g => MultilinearMap.compLinearMap g f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing with a family of surjective linear maps is injective. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"}]\n",
    "prompt_cons": "/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0) :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R ‚Üí\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i) :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem ‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\n  Function.Injective ‚Üë(Con.kerLift f) :=\n\n/-- Composing with a surjective linear map is injective. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_5} {M‚ÇÇ : Type u_2} [inst_5 : AddCommMonoid M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R] M),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective fun g => AlternatingMap.compLinearMap g f :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π :=\n\n/-- A monomorphism is injective. -/\ntheorem ‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\n  (‚àÄ (u v : { x // x ‚àà LinearMap.ker f } ‚Üí‚Çó[R] M), LinearMap.comp f u = LinearMap.comp f v ‚Üí u = v) ‚Üí\n    LinearMap.ker f = ‚ä• :=\n\n/-- Composing with a family of surjective linear maps is injective. -/\ntheorem ‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)]\n  [inst_6 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)] (f : (i : Œπ) ‚Üí M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i),\n  (‚àÄ (i : Œπ), Function.Surjective ‚Üë(f i)) ‚Üí Function.Injective fun g => MultilinearMap.compLinearMap g f :=\n\n/-- The canonical map from the type to the free group is an injection. -/\ntheorem ‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c) :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f :=\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf ",
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf ",
      "‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] (f : FreeGroup Œ± ‚Üí FreeGroup Œ±),\n  Function.Surjective f ‚Üí Function.Injective f ",
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf ",
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf ",
      "‚àÄ {Œ± : Type u} [inst : Fg Œ±] [inst_1 : Group Œ±] (f : Œ± ‚Üí* Œ±), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf ",
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf ",
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí FreeGroup Œ±),\n  Function.Surjective f ‚Üí Function.Injective f ",
      "‚àÄ {Œ± : Type u} (n : ‚Ñï) (f : FreeGroup (Fin n) ‚Üí FreeGroup (Fin n)), Function.Surjective f ‚Üí Function.Injective f ",
      "‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (f : FreeGroup Œ± ‚Üí* FreeGroup Œ±),\n  Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf "
    ]
  },
  {
    "docString": "Every positive even integer can be written as the sum of two primes.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï},\\n  a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ‚à™ List.toFinset (Nat.factors b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of two positive elements is positive. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\n  Irreducible p ‚Üí\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n) :=\n\n/-- If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` -/\ntheorem ‚àÄ {a b : ‚Ñï},\n  a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ‚à™ List.toFinset (Nat.factors b) :=\n\n/-- The product of two positive elements is positive. -/\ntheorem ‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem ‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y :=\n\n/-- Any common divisor of both elements is a divisor of the GCD. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem ‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c :=\n\n/-- For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. -/\ntheorem ‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem ‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem ‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l :=\n\n/-- Every positive even integer can be written as the sum of two primes. -/\ntheorem",
    "choices": [
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí n % 2 = 0 ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n % 2 = 0 ‚Üí n ‚â† 0 ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), 2 ‚â§ n ‚Üí n % 2 = 0 ‚Üí ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí 2 ‚à£ n ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí Even n ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí n % 2 = 0 ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí n % 2 = 0 ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), 0 < n ‚Üí Even n ‚Üí ‚àÉ p q, Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n % 2 = 0 ‚àß n > 2 ‚Üí ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q ",
      "‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí 2 ‚à£ n ‚Üí ‚àÉ (p q : ‚Ñï), Nat.Prime p ‚àß Nat.Prime q ‚àß n = p + q "
    ]
  },
  {
    "docString": "Every matrix satisfies its own characteristic polynomial.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\\n  ‚àÉ n f _hf q, p = ‚Üë(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) {Œπ : Type w} [inst_6 : Fintype Œπ]\\n  (b : Basis Œπ R M), Matrix.charpoly (‚Üë(LinearMap.toMatrix b b) f) = LinearMap.charpoly f\",\n  \"isProp\": true,\n  \"docString\":\n  \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\\n  (p : Polynomial R), ‚Üë(Polynomial.aeval M) p = ‚Üë(Polynomial.aeval M) (p %‚Çò Matrix.charpoly M)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any matrix polynomial `p` is equivalent under evaluation to `p %‚Çò M.charpoly`; that is, `p`\\nis equivalent to a polynomial with degree less than the dimension of the matrix. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] (w : œÉ ‚Üí M)\\n  (œÜ : MvPolynomial œÉ R), ‚àë·∂† (m : M), ‚Üë(MvPolynomial.weightedHomogeneousComponent w m) œÜ = œÜ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every polynomial is the sum of its weighted homogeneous components. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (‚àÄ (n : ‚Ñï), Polynomial.coeff p n ‚àà Ideal.comap Polynomial.C I) ‚Üí p ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} {n : Type u_2} [inst : Zero Œ±], Matrix.IsDiag 0\",\n  \"isProp\": true,\n  \"docString\": \"Every zero matrix is diagonal. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Polynomial.Monic (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is monic. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x ‚Üí Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {œÉ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial œÉ R)) (p : MvPolynomial œÉ R),\\n  (‚àÄ (m : œÉ ‚Üí‚ÇÄ ‚Ñï), MvPolynomial.coeff m p ‚àà Ideal.comap MvPolynomial.C I) ‚Üí p ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\\nmultivariate version. \"},\n {\"theorem\":\n  \"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\\n  {i j : n}, i ‚â† j ‚Üí (‚àÄ (k : n), M k i = M k j) ‚Üí Matrix.det M = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a matrix has a repeated column, the determinant will be zero. \"},\n {\"theorem\":\n  \"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (œÉ : Equiv.Perm n),\\n  Matrix.det (PEquiv.toMatrix (Equiv.toPEquiv œÉ)) = ‚Üë‚Üë(‚ÜëEquiv.Perm.sign œÉ)\",\n  \"isProp\": true,\n  \"docString\": \"The determinant of a permutation matrix equals its sign. \"},\n {\"theorem\":\n  \"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\\n  {i j : n}, i ‚â† j ‚Üí M i = M j ‚Üí Matrix.det M = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a matrix has a repeated row, the determinant will be zero. \"},\n {\"theorem\":\n  \"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A B C : Matrix n n Œ±},\\n  Matrix.mul A B = 1 ‚Üí Matrix.mul A C = 1 ‚Üí B = C\",\n  \"isProp\": true,\n  \"docString\": \"The right inverse of matrix A is unique when existing. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\\n  ‚Üë(Polynomial.aeval M) (Matrix.charpoly M) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,\\napplied to the matrix itself, is zero.\\n\\nThis holds over any commutative ring.\\n\\nSee `LinearMap.aeval_self_charpoly` for the equivalent statement about endomorphisms.\\n\"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : Algebra ‚Ñö R] (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\": \"`‚Ñö`-algebra implies equal characteristic. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type w‚ÇÅ) [inst : CommRing R] (Œπ : Type u_2) [inst_1 : Finite Œπ], Algebra.FinitePresentation R (MvPolynomial Œπ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of polynomials in finitely many variables is finitely presented. \"}]\n",
    "prompt_cons": "/-- Every identity matrix is diagonal. -/\ntheorem ‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1 :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem ‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\n  ‚àÉ n f _hf q, p = ‚Üë(MvPolynomial.rename f) q :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) {Œπ : Type w} [inst_6 : Fintype Œπ]\n  (b : Basis Œπ R M), Matrix.charpoly (‚Üë(LinearMap.toMatrix b b) f) = LinearMap.charpoly f :=\n\n/-- Any matrix polynomial `p` is equivalent under evaluation to `p %‚Çò M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), ‚Üë(Polynomial.aeval M) p = ‚Üë(Polynomial.aeval M) (p %‚Çò Matrix.charpoly M) :=\n\n/-- Every polynomial is the sum of its weighted homogeneous components. -/\ntheorem ‚àÄ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] (w : œÉ ‚Üí M)\n  (œÜ : MvPolynomial œÉ R), ‚àë·∂† (m : M), ‚Üë(MvPolynomial.weightedHomogeneousComponent w m) œÜ = œÜ :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem ‚àÄ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (‚àÄ (n : ‚Ñï), Polynomial.coeff p n ‚àà Ideal.comap Polynomial.C I) ‚Üí p ‚àà I :=\n\n/-- Every zero matrix is diagonal. -/\ntheorem ‚àÄ {Œ± : Type u_1} {n : Type u_2} [inst : Zero Œ±], Matrix.IsDiag 0 :=\n\n/-- A minimal polynomial is monic. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí Polynomial.Monic (minpoly A x) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x ‚Üí Irreducible (minpoly A x) :=\n\n/-- The degree of a minimal polynomial is positive. -/\ntheorem ‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x ‚Üí Prime (minpoly A x) :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. -/\ntheorem ‚àÄ {R : Type u} {œÉ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial œÉ R)) (p : MvPolynomial œÉ R),\n  (‚àÄ (m : œÉ ‚Üí‚ÇÄ ‚Ñï), MvPolynomial.coeff m p ‚àà Ideal.comap MvPolynomial.C I) ‚Üí p ‚àà I :=\n\n/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem ‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\n  {i j : n}, i ‚â† j ‚Üí (‚àÄ (k : n), M k i = M k j) ‚Üí Matrix.det M = 0 :=\n\n/-- The determinant of a permutation matrix equals its sign. -/\ntheorem ‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (œÉ : Equiv.Perm n),\n  Matrix.det (PEquiv.toMatrix (Equiv.toPEquiv œÉ)) = ‚Üë‚Üë(‚ÜëEquiv.Perm.sign œÉ) :=\n\n/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem ‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\n  {i j : n}, i ‚â† j ‚Üí M i = M j ‚Üí Matrix.det M = 0 :=\n\n/-- The right inverse of matrix A is unique when existing. -/\ntheorem ‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A B C : Matrix n n Œ±},\n  Matrix.mul A B = 1 ‚Üí Matrix.mul A C = 1 ‚Üí B = C :=\n\n/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,\napplied to the matrix itself, is zero.\n\nThis holds over any commutative ring.\n\nSee `LinearMap.aeval_self_charpoly` for the equivalent statement about endomorphisms. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  ‚Üë(Polynomial.aeval M) (Matrix.charpoly M) = 0 :=\n\n/-- `‚Ñö`-algebra implies equal characteristic. -/\ntheorem ‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : Algebra ‚Ñö R] (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I) :=\n\n/-- The ring of polynomials in finitely many variables is finitely presented. -/\ntheorem ‚àÄ (R : Type w‚ÇÅ) [inst : CommRing R] (Œπ : Type u_2) [inst_1 : Finite Œπ], Algebra.FinitePresentation R (MvPolynomial Œπ R) :=\n\n/-- Every matrix satisfies its own characteristic polynomial. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ",
      "‚àÄ {n : Type u} [inst : Fintype n] [inst_1 : DecidableEq n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R},\n  Polynomial.eval M (Matrix.charpoly M) = 0 ",
      "forall {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ",
      "forall {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ",
      "forall {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ",
      "‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ",
      "‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.eval M (Matrix.charpoly M) = 0 ",
      "‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.eval (Matrix.eval M) (Matrix.charpoly M) = 0 ",
      "‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Matrix.IsDiag (Matrix.eval (Matrix.charpoly M) M) ",
      "‚àÄ {R : Type u} [inst : CommRing R] {n : Type w} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.evalM M (Matrix.charpoly M) = 0 "
    ]
  },
  {
    "docString": "The square root of an irrational number is irrational.",
    "prompts": "[{\"theorem\": \"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"‚àÄ {p x : ‚Ñù}, LiouvilleWith p x ‚Üí 1 < p ‚Üí Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"},\n {\"theorem\": \"‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"‚àÄ {x y : ‚Ñù}, Irrational (x + y) ‚Üí Irrational x ‚à® Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (‚àÄ (s : R), discrim a b c ‚â† s ^ 2) ‚Üí ‚àÄ (x : R), a * x * x + b * x + c ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\": \"¬¨Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"‚àÄ {x : ‚Ñù} (n : ‚Ñï) (m : ‚Ñ§), x ^ n = ‚Üëm ‚Üí (¬¨‚àÉ y, x = ‚Üëy) ‚Üí 0 < n ‚Üí Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"‚àÄ (Œæ : ‚Ñù), Set.Infinite {q | |Œæ - ‚Üëq| < 1 / ‚Üëq.den ^ 2} ‚Üî Irrational Œæ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of good rational approximations to a real number `Œæ` is infinite if and only if\\n`Œæ` is irrational. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I\",\n  \"isProp\": true,\n  \"docString\": \"An ideal is radical iff it is equal to its radical. \"}]\n",
    "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem ‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1 :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem ‚àÄ {p x : ‚Ñù}, LiouvilleWith p x ‚Üí 1 < p ‚Üí Irrational x :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem ‚àÄ {x y : ‚Ñù}, Irrational (x + y) ‚Üí Irrational x ‚à® Irrational y :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2} :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (‚àÄ (s : R), discrim a b c ‚â† s ^ 2) ‚Üí ‚àÄ (x : R), a * x * x + b * x + c ‚â† 0 :=\n\n/-- The complex numbers are not countable. -/\ntheorem ¬¨Set.Countable Set.univ :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem ‚àÄ {x : ‚Ñù} (n : ‚Ñï) (m : ‚Ñ§), x ^ n = ‚Üëm ‚Üí (¬¨‚àÉ y, x = ‚Üëy) ‚Üí 0 < n ‚Üí Irrational x :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem ‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1 :=\n\n/-- The set of good rational approximations to a real number `Œæ` is infinite if and only if\n`Œæ` is irrational. -/\ntheorem ‚àÄ (Œæ : ‚Ñù), Set.Infinite {q | |Œæ - ‚Üëq| < 1 / ‚Üëq.den ^ 2} ‚Üî Irrational Œæ :=\n\n/-- An ideal is radical iff it is equal to its radical. -/\ntheorem ‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I :=\n\n/-- The square root of an irrational number is irrational. -/\ntheorem",
    "choices": [
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) ",
      "‚àÄ {x : ‚Ñù}, Irrational x ‚Üí Irrational (Real.sqrt x) "
    ]
  },
  {
    "docString": "If the square of a number is even, the number itself is even.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a ‚â† 0 ‚Üí ‚Üë(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\\n  MulChar.IsQuadratic œá ‚Üí ‚àÄ {n : ‚Ñï}, Odd n ‚Üí œá ^ n = œá\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ‚â† 2 ‚Üí (Finset.sum Finset.univ fun a => ‚Üë(quadraticChar F) a) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over the values of the quadratic character is zero when the characteristic is odd. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\\n  MulChar.IsQuadratic œá ‚Üí œá ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of a quadratic character is the trivial character. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñ§} {b : ‚Ñï}, Int.gcd a ‚Üëb = 1 ‚Üí jacobiSym a b ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of `J(a | b)` is `1` when `a` and `b` are coprime. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u_1} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {F : CategoryTheory.Functor D C} {A B : C} {X Y : D} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\\n  {u : G.obj A ‚ü∂ X} {v : G.obj B ‚ü∂ Y} (sq : CategoryTheory.CommSq u (G.map i) p v) (adj : G ‚ä£ F),\\n  CategoryTheory.CommSq.HasLift\\n      (_ :\\n        CategoryTheory.CommSq (‚Üë(CategoryTheory.Adjunction.homEquiv adj A X) u) i (F.map p)\\n          (‚Üë(CategoryTheory.Adjunction.homEquiv adj B Y) v)) ‚Üî\\n    CategoryTheory.CommSq.HasLift sq\",\n  \"isProp\": true,\n  \"docString\":\n  \"A square has a lifting if and only if its (right) adjoint square has a lifting. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\":\n  \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)] {a : ‚Ñ§}, ‚Üëa ‚â† 0 ‚Üí legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p ‚à§ a`. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ‚Üî Fintype.card F % 8 ‚â† 3 ‚àß Fintype.card F % 8 ‚â† 5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare 2 ‚Üî p % 8 = 1 ‚à® p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"}]\n",
    "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ‚àÄ (a b c d x y z w : ‚Ñï),\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a ‚â† 0 ‚Üí ‚Üë(quadraticChar F) a ^ 2 = 1 :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\n  MulChar.IsQuadratic œá ‚Üí ‚àÄ {n : ‚Ñï}, Odd n ‚Üí œá ^ n = œá :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F ‚â† 2 ‚Üí (Finset.sum Finset.univ fun a => ‚Üë(quadraticChar F) a) = 0 :=\n\n/-- The square of a quadratic character is the trivial character. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\n  MulChar.IsQuadratic œá ‚Üí œá ^ 2 = 1 :=\n\n/-- The square of `J(a | b)` is `1` when `a` and `b` are coprime. -/\ntheorem ‚àÄ {a : ‚Ñ§} {b : ‚Ñï}, Int.gcd a ‚Üëb = 1 ‚Üí jacobiSym a b ^ 2 = 1 :=\n\n/-- A square has a lifting if and only if its (right) adjoint square has a lifting. -/\ntheorem ‚àÄ {C : Type u_1} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {F : CategoryTheory.Functor D C} {A B : C} {X Y : D} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {u : G.obj A ‚ü∂ X} {v : G.obj B ‚ü∂ Y} (sq : CategoryTheory.CommSq u (G.map i) p v) (adj : G ‚ä£ F),\n  CategoryTheory.CommSq.HasLift\n      (_ :\n        CategoryTheory.CommSq (‚Üë(CategoryTheory.Adjunction.homEquiv adj A X) u) i (F.map p)\n          (‚Üë(CategoryTheory.Adjunction.homEquiv adj B Y) v)) ‚Üî\n    CategoryTheory.CommSq.HasLift sq :=\n\n/-- **Euler's four-square identity**. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- The square of the symbol is 1 if `p ‚à§ a`. -/\ntheorem ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)] {a : ‚Ñ§}, ‚Üëa ‚â† 0 ‚Üí legendreSym p a ^ 2 = 1 :=\n\n/-- **Four squares theorem** -/\ntheorem ‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ‚Üî Fintype.card F % 8 ‚â† 3 ‚àß Fintype.card F % 8 ‚â† 5 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p ‚â† 2 ‚Üí (IsSquare 2 ‚Üî p % 8 = 1 ‚à® p % 8 = 7) :=\n\n/-- If the square of a number is even, the number itself is even. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {x : Œ±}, Even (x * x) ‚Üí Even x ",
      "‚àÄ {Œ± : Type u} [inst : CommRing Œ±] {x : Œ±}, (x * x) % 2 = 0 ‚Üî x % 2 = 0 ",
      " ‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üí x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 ",
      "‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±}, x * x % 2 = 0 ‚Üî x % 2 = 0 "
    ]
  },
  {
    "docString": "In a finite commutative ring, all prime ideals are maximal.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ {I : Ideal R}, IsUnit ‚ÜëI ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S ‚â§ nonZeroDivisors R ‚Üí\\n    Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ (I I' : FractionalIdeal S A), I * I' = 1 ‚Üí Submodule.IsPrincipal ‚ÜëI\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\":\n  \"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\\n  I < J ‚Üí ‚ÜëJ = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ‚Üëf ‚Üí Ideal.IsMaximal (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R],\\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ‚ÜëPolynomial.C x ‚àà I ‚Üí x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"}]\n",
    "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R],\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I) :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ {I : Ideal R}, IsUnit ‚ÜëI ‚Üí Submodule.IsPrincipal I :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ‚àÄ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S ‚â§ nonZeroDivisors R ‚Üí\n    Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ (I I' : FractionalIdeal S A), I * I' = 1 ‚Üí Submodule.IsPrincipal ‚ÜëI :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä• :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem ‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\n  I < J ‚Üí ‚ÜëJ = Set.univ :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem ‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\n  Function.Surjective ‚Üëf ‚Üí Ideal.IsMaximal (RingHom.ker f) :=\n\n/-- The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R],\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ‚ÜëPolynomial.C x ‚àà I ‚Üí x = 0 :=\n\n/-- The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I :=\n\n/-- In a finite commutative ring, all prime ideals are maximal. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R],\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Ideal.IsMaximal P) ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R],\n  ‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (I : Ideal R), Ideal.IsPrime I ‚Üí Ideal.IsMaximal I ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R),\n  Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R], ‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P ‚Üí Ideal.IsMaximal P ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P ‚Üí Ideal.IsMaximal P "
    ]
  },
  {
    "docString": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X √ó X$.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : T2Space Œ±] [inst_2 : ProperSpace Œ±],\\n  IsCompact s ‚Üî IsClosed s ‚àß Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine‚ÄìBorel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±},\\n  IsClosed s ‚Üí IsClosed t ‚Üí EMetric.hausdorffEdist s t ‚â† ‚ä§ ‚Üí (Metric.hausdorffDist s t = 0 ‚Üî s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"theorem\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s t : Set Œ±},\\n  IsClosed s ‚Üí IsClosed t ‚Üí (EMetric.hausdorffEdist s t = 0 ‚Üî s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±],\\n  TotallyDisconnectedSpace Œ± ‚Üî TotallySeparatedSpace Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Œ≥ : Type w} [inst_6 : MetricSpace Œ≥]\\n  {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥},\\n  Isometry Œ¶ ‚Üí Isometry Œ® ‚Üí GromovHausdorff.ghDist X Y ‚â§ Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"}]\n",
    "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f :=\n\n/-- The **Heine‚ÄìBorel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : T2Space Œ±] [inst_2 : ProperSpace Œ±],\n  IsCompact s ‚Üî IsClosed s ‚àß Metric.Bounded s :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±},\n  IsClosed s ‚Üí IsClosed t ‚Üí EMetric.hausdorffEdist s t ‚â† ‚ä§ ‚Üí (Metric.hausdorffDist s t = 0 ‚Üî s = t) :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem ‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem ‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf :=\n\n/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s t : Set Œ±},\n  IsClosed s ‚Üí IsClosed t ‚Üí (EMetric.hausdorffEdist s t = 0 ‚Üî s = t) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±],\n  TotallyDisconnectedSpace Œ± ‚Üî TotallySeparatedSpace Œ± :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f :=\n\n/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem ‚àÄ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Œ≥ : Type w} [inst_6 : MetricSpace Œ≥]\n  {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥},\n  Isometry Œ¶ ‚Üí Isometry Œ® ‚Üí GromovHausdorff.ghDist X Y ‚â§ Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±],\n  (‚àÄ (x : Œ±), ‚àÉ s, s ‚àà nhds x ‚àß IsCompact s) ‚Üí LocallyCompactSpace Œ± :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U :=\n\n/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem ‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X √ó X$. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], T2Space Œ± ‚Üî IsClosed (diagonal Œ±) ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], T2Space Œ± ‚Üî IsClosed (Diagonal Œ±) ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  T2Space Œ± ‚Üî IsClosed {p : Œ± √ó Œ± | p.fst = p.snd} ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  T2Space Œ± ‚Üî IsClosed (Set.Diagonal Œ±) ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], T2Space Œ± ‚Üî IsClosed {p : Œ± √ó Œ± | p.fst = p.snd} ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], IsClosed (diagonal Œ±) ‚Üî T2Space Œ± ",
      "‚àÄ {X : Type u} [inst : TopologicalSpace X], IsClosed (diagonal X) ‚Üî T2Space X ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], T2Space Œ± ‚Üî IsClosed {p : Œ± √ó Œ± | p.1 = p.2} ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], T2Space Œ± ‚Üî IsClosed (Set.Diagonal Œ±) ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  T2Space Œ± ‚Üî IsClosed (SetOf (Œª (x : Œ± √ó Œ±), x.fst = x.snd)) "
    ]
  },
  {
    "docString": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [t : TopologicalSpace Œ±], t = ‚ä§ ‚Üí ‚àÄ (U : TopologicalSpace.Opens Œ±), U = ‚ä• ‚à® U = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : PreirreducibleSpace Œ±] {s : Set Œ±},\\n  IsOpen s ‚Üí Set.Nonempty s ‚Üí Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SecondCountableTopology Œ±] {Œπ : Type u_1}\\n  (s : Œπ ‚Üí Set Œ±), (‚àÄ (i : Œπ), IsOpen (s i)) ‚Üí ‚àÉ T, Set.Countable T ‚àß ‚ãÉ (i : Œπ) (_ : i ‚àà T), s i = ‚ãÉ (i : Œπ), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±},\\n  Set.Finite s ‚Üí ‚àÉ U, (‚àÄ (x : Œ±), x ‚àà U x ‚àß IsOpen (U x)) ‚àß Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {S U : Set Œ±},\\n  IsPreirreducible S ‚Üí IsOpen U ‚Üí Set.Nonempty (S ‚à© U) ‚Üí S ‚äÜ closure (S ‚à© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : TopologicalSpace.SecondCountableTopology Œ±],\\n  IsClosed C ‚Üí ¬¨Set.Countable C ‚Üí ‚àÉ D, Perfect D ‚àß Set.Nonempty D ‚àß D ‚äÜ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Œº : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Œº IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} (U : Set Œ±), IsOpen U ‚Üî U = ‚àÖ ‚à® U = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (‚Ñô K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ‚â§ W ‚Üî S ‚äÜ ‚ÜëW\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {x : Œ±} {U : Set Œ±},\\n  IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ K, IsCompact K ‚àß x ‚àà interior K ‚àß K ‚äÜ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤], IsOpenMap Prod.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤], IsOpenMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"}]\n",
    "prompt_cons": "/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±}, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, IsClopen V ‚àß x ‚àà V ‚àß V ‚äÜ U :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem ‚àÄ {Œ± : Type u_1} [t : TopologicalSpace Œ±], t = ‚ä§ ‚Üí ‚àÄ (U : TopologicalSpace.Opens Œ±), U = ‚ä• ‚à® U = ‚ä§ :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : PreirreducibleSpace Œ±] {s : Set Œ±},\n  IsOpen s ‚Üí Set.Nonempty s ‚Üí Dense s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SecondCountableTopology Œ±] {Œπ : Type u_1}\n  (s : Œπ ‚Üí Set Œ±), (‚àÄ (i : Œπ), IsOpen (s i)) ‚Üí ‚àÉ T, Set.Countable T ‚àß ‚ãÉ (i : Œπ) (_ : i ‚àà T), s i = ‚ãÉ (i : Œπ), s i :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s} :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±},\n  Set.Finite s ‚Üí ‚àÉ U, (‚àÄ (x : Œ±), x ‚àà U x ‚àß IsOpen (U x)) ‚àß Set.PairwiseDisjoint s U :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {S U : Set Œ±},\n  IsPreirreducible S ‚Üí IsOpen U ‚Üí Set.Nonempty (S ‚à© U) ‚Üí S ‚äÜ closure (S ‚à© U) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : TopologicalSpace.SecondCountableTopology Œ±],\n  IsClosed C ‚Üí ¬¨Set.Countable C ‚Üí ‚àÉ D, Perfect D ‚àß Set.Nonempty D ‚àß D ‚äÜ C :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±) :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem ‚àÄ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Œº : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Œº IsClosed IsOpen :=\n\n/-- The only open sets in the indiscrete topology are the empty set and the whole space. -/\ntheorem ‚àÄ {Œ± : Type u_1} (U : Set Œ±), IsOpen U ‚Üî U = ‚àÖ ‚à® U = Set.univ :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (‚Ñô K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ‚â§ W ‚Üî S ‚äÜ ‚ÜëW :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§ :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {x : Œ±} {U : Set Œ±},\n  IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ K, IsCompact K ‚àß x ‚àà interior K ‚àß K ‚äÜ U :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤], IsOpenMap Prod.fst :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤], IsOpenMap Prod.snd :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ± :=\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ U, IsOpen U ‚àß x ‚àà U ‚àß U ‚äÜ s) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ U, IsOpen U ‚àß x ‚àà U) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ U, IsOpen U ‚àß x ‚àà U ‚àß U ‚äÜ s) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ U, IsOpen U ‚àß x ‚àà U ‚àß U ‚äÜ s) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ (x : Œ±) (H : x ‚àà s), ‚àÉ U, IsOpen U ‚àß x ‚àà U) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ U, IsOpen U ‚àß x ‚àà U) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ (U : Set Œ±), IsOpen U ‚àß x ‚àà U ‚àß U ‚äÜ s) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ U, IsOpen U ‚àß x ‚àà U ‚àß U ‚äÜ s) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ x ‚àà s, ‚àÉ U, IsOpen U ‚àß x ‚àà U) ‚Üí IsOpen s ",
      "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ (U : Set Œ±), IsOpen U ‚àß x ‚àà U ‚àß U ‚äÜ s) ‚Üí IsOpen s "
    ]
  },
  {
    "docString": "Every non-identity element of a free group is of infinite order.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : Monoid G], ¬¨Monoid.IsTorsion G ‚Üî ‚àÉ g, ¬¨IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : Monoid G], ¬¨Monoid.IsTorsionFree G ‚Üî ‚àÉ g, g ‚â† 1 ‚àß IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0\",\n  \"isProp\": true,\n  \"docString\": \"0 is of finite order in any additive monoid.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"}]\n",
    "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x) :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem ‚àÄ (G : Type u_1) [inst : Monoid G], ¬¨Monoid.IsTorsion G ‚Üî ‚àÉ g, ¬¨IsOfFinOrder g :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x) :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y) :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ± :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ‚àÄ (G : Type u_1) [inst : Monoid G], ¬¨Monoid.IsTorsionFree G ‚Üî ‚àÉ g, g ‚â† 1 ‚àß IsOfFinOrder g :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x :=\n\n/-- 0 is of finite order in any additive monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0 :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem ‚àÄ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G :=\n\n/-- Every non-identity element of a free group is of infinite order. -/\ntheorem",
    "choices": [
      "‚àÄ {Œ± : Type u_1} [inst : FreeGroup Œ±], ‚àÄ x : FreeGroup Œ±, x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x ",
      "‚àÄ {Œ± : Type u} [inst : Group Œ±] [self : Group.IsFree Œ±] (x : Œ±), x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x ",
      "‚àÄ {G : Type u_1} [inst : Group G], IsFreeGroup G ‚Üí ‚àÄ (x : G), x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x ",
      "‚àÄ {Œ± : Type u} [inst : Group Œ±] (x : FreeGroup Œ±), x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x ",
      "‚àÄ {Œ± : Type u_1} [inst : Group Œ±] [inst_1 : IsFreeGroup Œ±], ‚àÄ (g : Œ±), g ‚â† 1 ‚Üí ¬¨IsOfFinOrder g ",
      "‚àÄ {Œ± : Type u_1} [inst : Group Œ±] [inst_1 : IsFreeGroup Œ±] {x : Œ±},\n  x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x ",
      "‚àÄ {Œ± : Type u_1} [inst : FreeGroup Œ±] (x : FreeGroup Œ±), x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x ",
      "‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], ‚àÄ g : G, g ‚â† 1 ‚Üí ¬¨IsOfFinOrder g ",
      "‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : IsFreeGroup Œ±], ‚àÄ (a : Œ±), a ‚â† 1 ‚Üí ¬¨IsOfFinOrder a ",
      "‚àÄ {Œ± : Type u} (x : FreeGroup Œ±), x ‚â† 1 ‚Üí ¬¨IsOfFinOrder x "
    ]
  },
  {
    "docString": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u_2} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]\\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : Valuation K Œì‚ÇÄ) {x : K}, ‚Üëv x = 0 ‚Üî x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = ‚ä• ‚Üî ‚àÉ I, I ‚àà s ‚àß I = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\\n  (‚àÉ p, Irreducible p) ‚Üí (‚àÄ ‚¶Ép q : R‚¶Ñ, Irreducible p ‚Üí Irreducible q ‚Üí Associated p q) ‚Üí DiscreteValuationRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unique factorization domain with at least one irreducible element\\nin which all irreducible elements are associated\\nis a discrete valuation ring.\\n\"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ] (u : M‚ÇÄÀ£), ‚Üëu ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of the unit group of a nonzero monoid with zero represented as an element\\nof the monoid is nonzero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `0 : R` equals 0. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), x ‚â† 0 ‚Üí IsDedekindDomain.HeightOneSpectrum.intValuationDef v x ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero elements have nonzero adic valuation. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x ‚àà nonZeroDivisors R }),\\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v ‚Üëx ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero divisors have nonzero valuation. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 ‚â† 1 ‚à® ‚àÄ (a : M‚ÇÄ), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, either zero and one are nonequal, or zero is the only element. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\\n  (Finset.sum Finset.univ fun a => ‚Üë1 a) = ‚Üë(Fintype.card RÀ£)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over all values of the trivial multiplicative character on a finite ring is\\nthe cardinality of its unit group. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] {x : R}, ‚Äñx‚Äñ < 1 ‚Üí Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a normed ring, the powers of an element x with `‚Äñx‚Äñ < 1` tend to zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x ‚àà nonZeroDivisors R }),\\n  0 < IsDedekindDomain.HeightOneSpectrum.intValuationDef v ‚Üëx\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero divisors have valuation greater than zero. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Œì‚ÇÄ]\\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : AddValuation K Œì‚ÇÄ) {x : K}, ‚Üëv x = ‚ä§ ‚Üî x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = ‚ä§` iff `x = 0`. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ‚àà I ‚Üí ‚Äñ1 - x‚Äñ < 1 ‚Üí I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"}]\n",
    "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem ‚àÄ {K : Type u_2} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : Valuation K Œì‚ÇÄ) {x : K}, ‚Üëv x = 0 ‚Üî x = 0 :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = ‚ä• ‚Üî ‚àÉ I, I ‚àà s ‚àß I = ‚ä• :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0 :=\n\n/-- A unique factorization domain with at least one irreducible element\nin which all irreducible elements are associated\nis a discrete valuation ring. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\n  (‚àÉ p, Irreducible p) ‚Üí (‚àÄ ‚¶Ép q : R‚¶Ñ, Irreducible p ‚Üí Irreducible q ‚Üí Associated p q) ‚Üí DiscreteValuationRing R :=\n\n/-- A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. -/\ntheorem ‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I) :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem ‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0 :=\n\n/-- A non-unital subring contains the ring's 0. -/\ntheorem ‚àÄ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 ‚àà s :=\n\n/-- An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ] (u : M‚ÇÄÀ£), ‚Üëu ‚â† 0 :=\n\n/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0 :=\n\n/-- An element is in the kernel if and only if it maps to zero. -/\ntheorem ‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0 :=\n\n/-- Nonzero elements have nonzero adic valuation. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), x ‚â† 0 ‚Üí IsDedekindDomain.HeightOneSpectrum.intValuationDef v x ‚â† 0 :=\n\n/-- In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ :=\n\n/-- Nonzero divisors have nonzero valuation. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x ‚àà nonZeroDivisors R }),\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v ‚Üëx ‚â† 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s } :=\n\n/-- In a monoid with zero, either zero and one are nonequal, or zero is the only element. -/\ntheorem ‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 ‚â† 1 ‚à® ‚àÄ (a : M‚ÇÄ), a = 0 :=\n\n/-- The sum over all values of the trivial multiplicative character on a finite ring is\nthe cardinality of its unit group. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\n  (Finset.sum Finset.univ fun a => ‚Üë1 a) = ‚Üë(Fintype.card RÀ£) :=\n\n/-- In a normed ring, the powers of an element x with `‚Äñx‚Äñ < 1` tend to zero. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] {x : R}, ‚Äñx‚Äñ < 1 ‚Üí Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) :=\n\n/-- Nonzero divisors have valuation greater than zero. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x ‚àà nonZeroDivisors R }),\n  0 < IsDedekindDomain.HeightOneSpectrum.intValuationDef v ‚Üëx :=\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = ‚ä§` iff `x = 0`. -/\ntheorem ‚àÄ {K : Type u_2} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Œì‚ÇÄ]\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : AddValuation K Œì‚ÇÄ) {x : K}, ‚Üëv x = ‚ä§ ‚Üî x = 0 :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ‚àà I ‚Üí ‚Äñ1 - x‚Äñ < 1 ‚Üí I = ‚ä§ :=\n\n/-- An element of a discrete valuation ring is a unit if and only if it has a valuation of zero. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (x : R), x ‚àà (0 : Ideal R).radical ‚Üî DiscreteValuationRing.valuation x = 0 ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (x : R), IsUnit x ‚Üî DiscreteValuationRing.addVal R x = 0 ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ‚Üî DiscreteValuationRing.valuation R (Classical.some inst_2.to_ufd_domain) x = 0 ",
      "‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  DiscreteValuationRing.HasValuation x = 0 ‚Üî IsUnit x ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (œâ : DiscreteValuationRing.AuxValuation R), ‚àÄ (x : R), x ‚â† 0 ‚Üí\n  (IsUnit x ‚Üî DiscreteValuationRing.AuxValuation._apply_œâ x = 0) ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (x : R), x ‚â† 0 ‚Üí DiscreteValuationRing.valuation x = 0 ‚Üî IsUnit x ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (x : R), IsUnit x ‚Üî DiscreteValuationRing.valuation R x = 0 ",
      "‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  IsUnit u ‚Üî DiscreteValuationRing.valuation u = 0 ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  (DiscreteValuationRing.valuation R x = 0) ‚Üî IsUnit x ",
      "‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  DiscreteValuationRing.valuation x = 0 ‚Üî IsUnit x "
    ]
  },
  {
    "docString": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {a b : ‚Ñ§}, a ‚â† 0 ‚Üí IsLeast {n | 0 < n ‚àß ‚àÉ x y, ‚Üën = a * x + b * y} (Int.gcd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï},\\n  a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ‚à™ List.toFinset (Nat.factors b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : OrderedAddCommMonoid Œ±] [self : Archimedean Œ±] (x : Œ±) {y : Œ±}, 0 < y ‚Üí ‚àÉ n, x ‚â§ n ‚Ä¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\\nsuch that `x ‚â§ n ‚Ä¢ y`. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï},\\n  Nat.coprime a b ‚Üí (Nat.factorization (a * b)).support = (Nat.factorization a).support ‚à™ (Nat.factorization b).support\",\n  \"isProp\": true,\n  \"docString\":\n  \"For coprime `a` and `b` the prime factorization `a * b` is the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"‚àÄ {p a b : ‚Ñï}, p ‚àà Nat.factors b ‚Üí a ‚â† 0 ‚Üí p ‚àà Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedMonoid Œ±] {a b : Œ±}, a ‚â§ b ‚Üí ‚àÉ c, b = a * c\",\n  \"isProp\": true,\n  \"docString\": \"For `a ‚â§ b`, there is a `c` so `b = a * c`. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"theorem\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"‚àÄ {p a b : ‚Ñï}, p ‚àà Nat.factors a ‚Üí b ‚â† 0 ‚Üí p ‚àà Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\":\n  \"‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Disjoint (Nat.factorization a).support (Nat.factorization b).support\",\n  \"isProp\": true,\n  \"docString\": \"The prime factorizations of coprime `a` and `b` are disjoint \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"}]\n",
    "prompt_cons": "/-- For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem ‚àÄ {a b : ‚Ñ§}, a ‚â† 0 ‚Üí IsLeast {n | 0 < n ‚àß ‚àÉ x y, ‚Üën = a * x + b * y} (Int.gcd a b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1) :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` -/\ntheorem ‚àÄ {a b : ‚Ñï},\n  a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ‚à™ List.toFinset (Nat.factors b) :=\n\n/-- For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem ‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b :=\n\n/-- For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\nsuch that `x ‚â§ n ‚Ä¢ y`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : OrderedAddCommMonoid Œ±] [self : Archimedean Œ±] (x : Œ±) {y : Œ±}, 0 < y ‚Üí ‚àÉ n, x ‚â§ n ‚Ä¢ y :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ‚â† 0} :=\n\n/-- For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem ‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b :=\n\n/-- For coprime `a` and `b` the prime factorization `a * b` is the union of those of `a` and `b` -/\ntheorem ‚àÄ {a b : ‚Ñï},\n  Nat.coprime a b ‚Üí (Nat.factorization (a * b)).support = (Nat.factorization a).support ‚à™ (Nat.factorization b).support :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem ‚àÄ {p a b : ‚Ñï}, p ‚àà Nat.factors b ‚Üí a ‚â† 0 ‚Üí p ‚àà Nat.factors (a * b) :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- For `a ‚â§ b`, there is a `c` so `b = a * c`. -/\ntheorem ‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedMonoid Œ±] {a b : Œ±}, a ‚â§ b ‚Üí ‚àÉ c, b = a * c :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem ‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem ‚àÄ {p a b : ‚Ñï}, p ‚àà Nat.factors a ‚Üí b ‚â† 0 ‚Üí p ‚àà Nat.factors (a * b) :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem ‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) ‚Üí 0 < List.prod l :=\n\n/-- The prime factorizations of coprime `a` and `b` are disjoint -/\ntheorem ‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Disjoint (Nat.factorization a).support (Nat.factorization b).support :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n] :=\n\n/-- For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\ntheorem",
    "choices": [
      "‚àÄ (a b : ‚Ñï), Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ (x y : ‚Ñï), a * x + b * y ‚â• N ",
      "forall {a b N : ‚Ñï}, Nat.coprime a b ‚Üí a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, a * x + b * y ‚â• N ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, a * x + b * y ‚â• N ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ (N : ‚Ñï), ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y ",
      "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y ",
      "forall {a b : ‚Ñï}, Nat.coprime a b ‚Üí ‚àÄ N, ‚àÉ x y : ‚Ñï, N ‚â§ a * x + b * y "
    ]
  },
  {
    "docString": "Every field is a ring.",
    "prompts": "[{\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x)\",\n  \"isProp\": true,\n  \"docString\": \"Stalks of a locally ringed space are local rings. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±], TopologicalRing Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A seminormed ring is a topological ring. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 1 ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ‚âÉ+* B ‚Üí IsDomain A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"}]\n",
    "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem ‚àÄ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ‚àà S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ‚àà S :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ± :=\n\n/-- Fields are commutative. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem ‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K } :=\n\n/-- Stalks of a locally ringed space are local rings. -/\ntheorem ‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x) :=\n\n/-- A subring contains the ring's 0. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä• :=\n\n/-- Every ring involution must be its own inverse -/\ntheorem ‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x :=\n\n/-- A seminormed ring is a topological ring. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±], TopologicalRing Œ± :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I) :=\n\n/-- A subring contains the ring's 1. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 1 ‚àà s :=\n\n/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\ntheorem ‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ‚âÉ+* B ‚Üí IsDomain A :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ± :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem ‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0 :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ‚àÄ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ‚Üî ‚àÄ (I : Ideal R), Ideal.FG I :=\n\n/-- Every field is a ring. -/\ntheorem",
    "choices": [
      "‚àÄ (K : Type u) [inst : Field K], Ring K ",
      "‚àÄ (F : Type u) [inst : Field F], Ring F ",
      "‚àÄ (F : Type u) [inst : Field F], Ring F ",
      "‚àÄ (K : Type u) [inst : Field K], Ring K ",
      "‚àÄ {K : Type u} [inst : Field K], Ring K ",
      "‚àÄ (K : Type u) [inst : Field K], Ring K ",
      "‚àÄ (F : Type u) [inst : Field F], Ring F ",
      "‚àÄ (K : Type u) [inst : Field K], Ring K ",
      "‚àÄ (K : Type u) [inst : Field K], Ring K ",
      "‚àÄ (K : Type u) [inst : Field K], Ring K "
    ]
  },
  {
    "docString": "The set of units in a ring forms a group.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {k : Set G}, k ‚äÜ ‚Üë(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\":\n  \"LieGroup (modelWithCornersSelf ‚Ñù (EuclideanSpace ‚Ñù (Fin 1))) { x // x ‚àà circle }\",\n  \"isProp\": true,\n  \"docString\": \"The unit circle in `‚ÑÇ` is a Lie group. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 1 ‚àà s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±], TopologicalRing Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A seminormed ring is a topological ring. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\\n  (Finset.sum Finset.univ fun a => ‚Üë1 a) = ‚Üë(Fintype.card RÀ£)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over all values of the trivial multiplicative character on a finite ring is\\nthe cardinality of its unit group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a ‚Üí IsRegular a\",\n  \"isProp\": true,\n  \"docString\": \"A unit in a monoid is regular. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] {s : Set R}, s ‚äÜ ‚Üë(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The subring generated by a set includes the set. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : LocalRing R], LocalRing (MvPowerSeries œÉ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multivariate formal power series over a local ring form a local ring. \"}]\n",
    "prompt_cons": "/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\n  IsCyclic { x // x ‚àà S } :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] {k : Set G}, k ‚äÜ ‚Üë(Subgroup.closure k) :=\n\n/-- The unit circle in `‚ÑÇ` is a Lie group. -/\ntheorem LieGroup (modelWithCornersSelf ‚Ñù (EuclideanSpace ‚Ñù (Fin 1))) { x // x ‚àà circle } :=\n\n/-- A subring contains the ring's 0. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ± :=\n\n/-- A subring contains the ring's 1. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 1 ‚àà s :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G :=\n\n/-- A seminormed ring is a topological ring. -/\ntheorem ‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±], TopologicalRing Œ± :=\n\n/-- The sum over all values of the trivial multiplicative character on a finite ring is\nthe cardinality of its unit group. -/\ntheorem ‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\n  (Finset.sum Finset.univ fun a => ‚Üë1 a) = ‚Üë(Fintype.card RÀ£) :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ± :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- A unit in a monoid is regular. -/\ntheorem ‚àÄ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a ‚Üí IsRegular a :=\n\n/-- The subring generated by a set includes the set. -/\ntheorem ‚àÄ {R : Type u} [inst : Ring R] {s : Set R}, s ‚äÜ ‚Üë(Subring.closure s) :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H :=\n\n/-- Multivariate formal power series over a local ring form a local ring. -/\ntheorem ‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : LocalRing R], LocalRing (MvPowerSeries œÉ R) :=\n\n/-- The set of units in a ring forms a group. -/\ntheorem",
    "choices": [
      "‚àÄ {R : Type u} [inst : Ring R], Group RÀ£ ",
      "‚àÄ {R : Type u_1} [inst : Ring R], Group RÀ£ ",
      "‚àÄ {R : Type u_1} [inst : Ring R], Group RÀ£ ",
      "Group {R : Type u} [inst : Ring R] RÀ£ ",
      "‚àÄ {R : Type u_1} [inst : Ring R], Group RÀ£ ",
      "‚àÄ {R : Type u_1} [inst : Ring R], Group RÀ£ ",
      "‚àÄ {R : Type u_1} [inst : Ring R], Group RÀ£ ",
      "Group { x : R // IsUnit x } ",
      "‚àÄ {R : Type u_1} [inst : Monoid R], Group (units R) ",
      "‚àÄ {R : Type u_1} [inst : Ring R], Group RÀ£ "
    ]
  },
  {
    "docString": "If the direct product of two groups is torsion free then each of the groups is torsion free.",
    "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí\\n    N = MonoidHom.ker f ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set R),\\n  Submodule.torsionBySet R M s = Submodule.torsionBySet R M ‚Üë(Ideal.span s)\",\n  \"isProp\": true,\n  \"docString\": \"Torsion by a set is torsion by the ideal generated by it. \"}]\n",
    "prompt_cons": "/-- Direct products of torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G) :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí\n    N = MonoidHom.ker f ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä• :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H :=\n\n/-- Torsion by a set is torsion by the ideal generated by it. -/\ntheorem ‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set R),\n  Submodule.torsionBySet R M s = Submodule.torsionBySet R M ‚Üë(Ideal.span s) :=\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\ntheorem",
    "choices": [
      "‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G √ó H) ‚Üí Monoid.IsTorsionFree G ‚àß Monoid.IsTorsionFree H ",
      "forall {Œ∑ : Type u_1} {Gs1 Gs2 : Œ∑ ‚Üí Type u_2} [inst1 : (i : Œ∑) ‚Üí Group (Gs1 i)] [inst2 : (i : Œ∑) ‚Üí Group (Gs2 i)],\n  Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs1 i √ó Gs2 i) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs1 i) ‚àß Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs2 i) ",
      "‚àÄ {G‚ÇÅ G‚ÇÇ : Type u_1} [inst‚ÇÅ : Group G‚ÇÅ] [inst‚ÇÇ : Group G‚ÇÇ],\n  Monoid.IsTorsionFree (G‚ÇÅ √ó G‚ÇÇ) ‚Üí Monoid.IsTorsionFree G‚ÇÅ ‚àß Monoid.IsTorsionFree G‚ÇÇ ",
      "forall {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G √ó H) ‚Üí Monoid.IsTorsionFree G ‚àß Monoid.IsTorsionFree H ",
      "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G √ó H) ‚Üí Monoid.IsTorsionFree G ‚àß Monoid.IsTorsionFree H ",
      "‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G √ó H) ‚Üí Monoid.IsTorsionFree G ‚àß Monoid.IsTorsionFree H ",
      "‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G √ó H) ‚Üí Monoid.IsTorsionFree G ‚àß Monoid.IsTorsionFree H ",
      "‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) ‚Üí ‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i) ",
      "‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i) ‚Üí ‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i) ",
      "forall {G‚ÇÅ G‚ÇÇ : Type u_1} [instG‚ÇÅ : Group G‚ÇÅ] [instG‚ÇÇ : Group G‚ÇÇ],\n  Monoid.IsTorsionFree (G‚ÇÅ √ó G‚ÇÇ) ‚Üí Monoid.IsTorsionFree G‚ÇÅ ‚àß Monoid.IsTorsionFree G‚ÇÇ "
    ]
  }
]