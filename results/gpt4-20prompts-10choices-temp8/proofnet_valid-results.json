[
  {
    "docString": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\\nit suffices to show it holds when `x â‰  y`. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `x * r`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, LiouvilleWith p x â†’ r â‰  0 â†’ LiouvilleWith p (x * â†‘r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  â†‘(Polynomial.aeval r) p = 0 â†’ IsFractionRing.num A r âˆ£ Polynomial.coeff p 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 1:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the numerator of `r` divides the constant coefficient \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  â†‘(Polynomial.aeval r) p = 0 â†’ â†‘(IsFractionRing.den A r) âˆ£ Polynomial.leadingCoeff p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 2:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the denominator of `r` divides the leading coefficient \"},\n {\"theorem\":\n  \"âˆ€ {Î¾ : â„}, Irrational Î¾ â†’ âˆ€ (q : â„š), âˆƒ q', |Î¾ - â†‘q'| < 1 / â†‘q'.den ^ 2 âˆ§ |Î¾ - â†‘q'| < |Î¾ - â†‘q|\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any rational approximation `q` to the irrational real number `Î¾`, there is\\na good rational approximation `q'` such that `|Î¾ - q'| < |Î¾ - q|`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand x is an element of an A-algebra that is integral over A, then x is integral over R.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ],\\n  Filter.Tendsto (fun r => râ»Â¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {q r : â„š},\\n  q + r â‰  0 â†’ min (padicValRat p q) (padicValRat p r) â‰¤ padicValRat p (q + r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimum of the valuations of `q` and `r` is at most the valuation of `q + r`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ Â¬EuclideanDomain.r (a * b) a\",\n  \"isProp\": true,\n  \"docString\": \"An additional constraint on `r`. \"}]\n",
    "prompt_cons": "/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\nit suffices to show it holds when `x â‰  y`. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y :=\n\n/-- The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x) :=\n\n/-- The product `x * r`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, LiouvilleWith p x â†’ r â‰  0 â†’ LiouvilleWith p (x * â†‘r) :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- Rational root theorem part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  â†‘(Polynomial.aeval r) p = 0 â†’ IsFractionRing.num A r âˆ£ Polynomial.coeff p 0 :=\n\n/-- Rational root theorem part 2:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the denominator of `r` divides the leading coefficient -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  â†‘(Polynomial.aeval r) p = 0 â†’ â†‘(IsFractionRing.den A r) âˆ£ Polynomial.leadingCoeff p :=\n\n/-- Given any rational approximation `q` to the irrational real number `Î¾`, there is\na good rational approximation `q'` such that `|Î¾ - q'| < |Î¾ - q|`. -/\ntheorem âˆ€ {Î¾ : â„}, Irrational Î¾ â†’ âˆ€ (q : â„š), âˆƒ q', |Î¾ - â†‘q'| < 1 / â†‘q'.den ^ 2 âˆ§ |Î¾ - â†‘q'| < |Î¾ - â†‘q| :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x :=\n\n/-- The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ],\n  Filter.Tendsto (fun r => râ»Â¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0)) :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- The minimum of the valuations of `q` and `r` is at most the valuation of `q + r`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {q r : â„š},\n  q + r â‰  0 â†’ min (padicValRat p q) (padicValRat p r) â‰¤ padicValRat p (q + r) :=\n\n/-- An additional constraint on `r`. -/\ntheorem âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ Â¬EuclideanDomain.r (a * b) a :=\n\n/-- If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational. -/\ntheorem",
    "choices": [
      " âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} (r : â„š), r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} {r : â„š}, Irrational x â†’ r â‰  0 â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} (r : â„š), r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) "
    ]
  },
  {
    "docString": "Prove that there is no rational number whose square is $12$.",
    "prompts": "[{\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"âˆ€ (self : â„š), self.den â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The denominator is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"},\n {\"theorem\": \"âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"}]\n",
    "prompt_cons": "/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2} :=\n\n/-- The denominator is nonzero. -/\ntheorem âˆ€ (self : â„š), self.den â‰  0 :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x :=\n\n/-- Prove that there is no rational number whose square is $12$. -/\ntheorem",
    "choices": [
      "Â¬âˆƒ q : â„š, q * q = 12 ",
      "âˆ€ {r : â„š}, r * r â‰  12 ",
      "Â¬âˆƒ q : â„š, q ^ 2 = 12 ",
      "Â¬âˆƒ r : â„š, r ^ 2 = 12 ",
      "âˆ€ {q : â„š}, q * q â‰  Rat.of_int 12 ",
      "Â¬âˆƒ q : â„š, q ^ 2 = 12 ",
      "Â¬âˆƒ q : â„š, q ^ 2 = 12 ",
      "Â¬âˆƒ q : â„š, q ^ 2 = 12 ",
      "âˆ€ (q : â„š), q * q â‰  12 ",
      "Â¬âˆƒ {q : â„š}, q ^ 2 = 12 "
    ]
  },
  {
    "docString": "Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\\n  BddBelow s â†’ BddBelow t â†’ Set.Nonempty (s âˆ© t) â†’ sInf s âŠ” sInf t â‰¤ sInf (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of an intersection of two sets is bounded below by the maximum of the\\ninfima of each set, if all sets are bounded below and nonempty.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ‚ B â†’ Finset.toColex A < Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A âŠ‚ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\\n`âŠ†` is not a linear order. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a â‰¤ -b â†’ b â‰¤ -a` on ereal \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²} {s t : Set Î±},\\n  AntitoneOn f t â†’ s âŠ† t â†’ Set.Nonempty (lowerBounds s âˆ© t) â†’ BddAbove (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an antitone function of a set which is bounded below is bounded above. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  Set.Nonempty â†‘s1 â†’\\n    Set.Nonempty â†‘s2 â†’\\n      â†‘s1 âˆ© â†‘s2 = âˆ… â†’ AffineSubspace.direction s1 âŠ” AffineSubspace.direction s2 < AffineSubspace.direction (s1 âŠ” s2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sup of the directions of two nonempty affine subspaces with empty intersection is less than\\nthe direction of their sup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : CompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : CompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²}\\n  {s : Set Î±}, ContinuousAt f (sInf s) â†’ Antitone f â†’ Set.Nonempty s â†’ f (sInf s) = sSup (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antitone function continuous at the infimum of a nonempty set sends this infimum to\\nthe supremum of the image of this set. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a â‰¤ b â†” -b â‰¤ a` on `EReal`. \"},\n {\"theorem\": \"âˆ€ {a b : Ordinal.{u_1}}, Set.Nonempty {o | a â‰¤ b + o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of subtraction is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : Countable Î¹]\\n  {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), MeasurableSet (s i)) â†’\\n    Directed (fun x x_1 => x âŠ‡ x_1) s â†’ (âˆƒ i, â†‘â†‘Î¼ (s i) â‰  âŠ¤) â†’ â†‘â†‘Î¼ (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), â†‘â†‘Î¼ (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Continuity from above: the measure of the intersection of a decreasing sequence of measurable\\nsets is the infimum of the measures. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\\n  Antitone f â†’ âˆ€ {s : Set Î±}, BddAbove s â†’ BddBelow (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an antitone function of a set which is bounded above is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ sInf s â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is more than the set infimum. \"}]\n",
    "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u)) :=\n\n/-- The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\n  BddBelow s â†’ BddBelow t â†’ Set.Nonempty (s âˆ© t) â†’ sInf s âŠ” sInf t â‰¤ sInf (s âˆ© t) :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s :=\n\n/-- If `A âŠ‚ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`âŠ†` is not a linear order. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ‚ B â†’ Finset.toColex A < Finset.toColex B :=\n\n/-- `a â‰¤ -b â†’ b â‰¤ -a` on ereal -/\ntheorem âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a :=\n\n/-- The image under an antitone function of a set which is bounded below is bounded above. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²} {s t : Set Î±},\n  AntitoneOn f t â†’ s âŠ† t â†’ Set.Nonempty (lowerBounds s âˆ© t) â†’ BddAbove (f '' s) :=\n\n/-- The sup of the directions of two nonempty affine subspaces with empty intersection is less than\nthe direction of their sup. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  Set.Nonempty â†‘s1 â†’\n    Set.Nonempty â†‘s2 â†’\n      â†‘s1 âˆ© â†‘s2 = âˆ… â†’ AffineSubspace.direction s1 âŠ” AffineSubspace.direction s2 < AffineSubspace.direction (s1 âŠ” s2) :=\n\n/-- A finite set is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s :=\n\n/-- An antitone function continuous at the infimum of a nonempty set sends this infimum to\nthe supremum of the image of this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : CompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : CompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²}\n  {s : Set Î±}, ContinuousAt f (sInf s) â†’ Antitone f â†’ Set.Nonempty s â†’ f (sInf s) = sSup (f '' s) :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- `-a â‰¤ b â†” -b â‰¤ a` on `EReal`. -/\ntheorem âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a :=\n\n/-- The set in the definition of subtraction is nonempty. -/\ntheorem âˆ€ {a b : Ordinal.{u_1}}, Set.Nonempty {o | a â‰¤ b + o} :=\n\n/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the infimum of the measures. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : Countable Î¹]\n  {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), MeasurableSet (s i)) â†’\n    Directed (fun x x_1 => x âŠ‡ x_1) s â†’ (âˆƒ i, â†‘â†‘Î¼ (s i) â‰  âŠ¤) â†’ â†‘â†‘Î¼ (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), â†‘â†‘Î¼ (s i) :=\n\n/-- The image under an antitone function of a set which is bounded above is bounded below. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Antitone f â†’ âˆ€ {s : Set Î±}, BddAbove s â†’ BddBelow (f '' s) :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- Any element of a set is more than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ sInf s â‰¤ a :=\n\n/-- Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {A : Set Î±},\n  BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (Neg.neg '' A) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {A : Set Î±},\n  BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (-A) ",
      "forall {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {A : Set Î±},\n  BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (HasNegPart.neg â»Â¹' A) ",
      "âˆ€ {A : Set â„}, BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (-A) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {s : Set Î±},\n  BddBelow s â†’ Set.Nonempty s â†’ sInf s = -sSup (Set.Image (fun x => -x) s) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {A : Set Î±},\n  BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (-A) ",
      "âˆ€ {A : Set â„}, BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (HasNegPart.neg â»Â¹' A) ",
      "forall {A : Set â„} (hâ‚ : BddBelow A) (hâ‚‚ : Set.Nonempty A),\n  inf A = -sup (-A) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {A : Set Î±},\n  Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A) "
    ]
  },
  {
    "docString": "If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "prompts": "[{\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„‚ Ã— â„‚}, 0 < p.fst.re âˆ¨ p.fst.im â‰  0 â†’ ContinuousAt (fun x => x.fst ^ x.snd) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\\n`(-âˆ, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\\nworks for `z = 0` but assumes `0 < re w`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\": \"`Complex.exp z â†’ 0` as `Complex.re z â†’ -âˆ`.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  r â‰  0 â†’\\n    âˆ€ {a : â„},\\n      a âˆˆ Set.Ioo (-1) 1 â†’\\n        ((fun n => â€–p nâ€– * â†‘r ^ n) =O[Filter.atTop] fun x => a ^ x) â†’ â†‘r < FormalMultilinearSeries.radius p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : DivisionRing R] [inst_1 : CharZero R] {p r : R} {z : â„¤},\\n  z â‰  0 â†’ (z â€¢ r âˆˆ AddSubgroup.zmultiples p â†” âˆƒ k, r - â†‘k â€¢ (p / â†‘z) âˆˆ AddSubgroup.zmultiples p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`z â€¢ r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 â‰¤ k < |z|`. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„},\\n  a â‰¤ 0 â†’\\n    âˆ€ {z : â„‚},\\n      |z.im| â‰¤ b â†’\\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R|\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. \"},\n {\"theorem\": \"Cardinal.mk â†‘Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\": \"âˆ€ (s : â„‚), riemannCompletedZeta (1 - s) = riemannCompletedZeta s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann zeta functional equation, formulated for `Î›`: for any complex `s` we have\\n`Î› (1 - s) = Î› s`. \"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\n`(-âˆ, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\nworks for `z = 0` but assumes `0 < re w`. -/\ntheorem âˆ€ {p : â„‚ Ã— â„‚}, 0 < p.fst.re âˆ¨ p.fst.im â‰  0 â†’ ContinuousAt (fun x => x.fst ^ x.snd) p :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- `Complex.exp z â†’ 0` as `Complex.re z â†’ -âˆ`. -/\ntheorem Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0) :=\n\n/-- If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  r â‰  0 â†’\n    âˆ€ {a : â„},\n      a âˆˆ Set.Ioo (-1) 1 â†’\n        ((fun n => â€–p nâ€– * â†‘r ^ n) =O[Filter.atTop] fun x => a ^ x) â†’ â†‘r < FormalMultilinearSeries.radius p :=\n\n/-- `z â€¢ r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 â‰¤ k < |z|`. -/\ntheorem âˆ€ {R : Type u_1} [inst : DivisionRing R] [inst_1 : CharZero R] {p r : R} {z : â„¤},\n  z â‰  0 â†’ (z â€¢ r âˆˆ AddSubgroup.zmultiples p â†” âˆƒ k, r - â†‘k â€¢ (p / â†‘z) âˆˆ AddSubgroup.zmultiples p) :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem âˆ€ {a b : â„},\n  a â‰¤ 0 â†’\n    âˆ€ {z : â„‚},\n      |z.im| â‰¤ b â†’\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. -/\ntheorem âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R| :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk â†‘Set.univ = Cardinal.continuum :=\n\n/-- Riemann zeta functional equation, formulated for `Î›`: for any complex `s` we have\n`Î› (1 - s) = Î› s`. -/\ntheorem âˆ€ (s : â„‚), riemannCompletedZeta (1 - s) = riemannCompletedZeta s :=\n\n/-- If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$. -/\ntheorem",
    "choices": [
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§  z = r â€¢ w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), 0 â‰¤ r âˆ§ z = r * w âˆ§ â†‘Complex.abs w = 1 ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ |w| = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ Complex.abs w = 1 âˆ§ z = â†‘r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ (â†‘Complex.abs w = 1) âˆ§ z = â†‘r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r â€¢ w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = â†‘r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = â†‘r * w ",
      "âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ Complex.abs w = 1 âˆ§ z = r * w "
    ]
  },
  {
    "docString": "If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\\n  Â¬SameRay â„ x y â†’ â€–x + yâ€– < â€–xâ€– + â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a strictly convex space, if `x` and `y` are not in the same ray, then `â€–x + yâ€– < â€–xâ€– + â€–yâ€–`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\ndoesn't assume `0â‰¤K`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\nassumes `0â‰¤K`. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a â‰¤ b â†” -b â‰¤ a` on `EReal`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner (x - y) (x - y) = inner x x - 2 * inner x y + inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Expand `âŸªx - y, x - yâŸ«_â„` \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {x y : Î±}, x = y â†’ y â‰¤ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x = y` then `y â‰¤ x`. Note: this lemma uses `y â‰¤ x` instead of `x â‰¥ y`, because `le` is used\\nalmost exclusively in mathlib. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a â‰¤ -b â†’ b â‰¤ -a` on ereal \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E},\\n  SameRay â„ x y â†’ â€–x + yâ€– = â€–xâ€– + â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\\nspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ (a b : NNReal) {p q : â„}, Real.IsConjugateExponent p q â†’ a * b â‰¤ a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Young's inequality, `â„â‰¥0` version with real conjugate exponents. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [self : Archimedean Î±] (x : Î±) {y : Î±}, 0 < y â†’ âˆƒ n, x â‰¤ n â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\\nsuch that `x â‰¤ n â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ (-y)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x ^ (-y)` tends to `0` at `+âˆ` for any positive real `y`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\\nand `y` with positive coefficients has norm strictly less than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E],\\n  (âˆ€ (x y : E), â€–xâ€– = 1 â†’ â€–yâ€– = 1 â†’ x â‰  y â†’ âˆƒ a b, a + b = 1 âˆ§ â€–a â€¢ x + b â€¢ yâ€– < 1) â†’ StrictConvexSpace â„ E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Strict convexity is equivalent to `â€–a â€¢ x + b â€¢ yâ€– < 1` for all `x` and `y` of norm at most `1`\\nand all strictly positive `a` and `b` such that `a + b = 1`. This lemma shows that it suffices to\\ncheck this for points of norm one and some `a`, `b` such that `a + b = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y z : E}\\n  {a b r : â„},\\n  x âˆˆ Metric.closedBall z r â†’\\n    y âˆˆ Metric.closedBall z r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ Metric.ball z r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x â‰  y` belong to the same closed ball, then a convex combination of `x` and `y` with\\npositive coefficients belongs to the corresponding open ball. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x y : R),\\n  MulHom.toFun self.toMulHom (x + y) â‰¤ MulHom.toFun self.toMulHom x + MulHom.toFun self.toMulHom y\",\n  \"isProp\": true,\n  \"docString\": \"The absolute value satisfies the triangle inequality \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] {S : AddSubgroup M} (x : M â§¸ S), â€–-xâ€– = â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The norm on the quotient satisfies `â€–-xâ€– = â€–xâ€–`. \"}]\n",
    "prompt_cons": "/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `â€–x + yâ€– < â€–xâ€– + â€–yâ€–`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\n  Â¬SameRay â„ x y â†’ â€–x + yâ€– < â€–xâ€– + â€–yâ€– :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\ndoesn't assume `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\nassumes `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f :=\n\n/-- `-a â‰¤ b â†” -b â‰¤ a` on `EReal`. -/\ntheorem âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a :=\n\n/-- Expand `âŸªx - y, x - yâŸ«_â„` -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner (x - y) (x - y) = inner x x - 2 * inner x y + inner y y :=\n\n/-- If `x = y` then `y â‰¤ x`. Note: this lemma uses `y â‰¤ x` instead of `x â‰¥ y`, because `le` is used\nalmost exclusively in mathlib. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {x y : Î±}, x = y â†’ y â‰¤ x :=\n\n/-- It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s :=\n\n/-- `a â‰¤ -b â†’ b â‰¤ -a` on ereal -/\ntheorem âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a :=\n\n/-- If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\nspace. -/\ntheorem âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E},\n  SameRay â„ x y â†’ â€–x + yâ€– = â€–xâ€– + â€–yâ€– :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Young's inequality, `â„â‰¥0` version with real conjugate exponents. -/\ntheorem âˆ€ (a b : NNReal) {p q : â„}, Real.IsConjugateExponent p q â†’ a * b â‰¤ a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q :=\n\n/-- For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\nsuch that `x â‰¤ n â€¢ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [self : Archimedean Î±] (x : Î±) {y : Î±}, 0 < y â†’ âˆƒ n, x â‰¤ n â€¢ y :=\n\n/-- The function `x ^ (-y)` tends to `0` at `+âˆ` for any positive real `y`. -/\ntheorem âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ (-y)) Filter.atTop (nhds 0) :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\nand `y` with positive coefficients has norm strictly less than `r`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r :=\n\n/-- Strict convexity is equivalent to `â€–a â€¢ x + b â€¢ yâ€– < 1` for all `x` and `y` of norm at most `1`\nand all strictly positive `a` and `b` such that `a + b = 1`. This lemma shows that it suffices to\ncheck this for points of norm one and some `a`, `b` such that `a + b = 1`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E],\n  (âˆ€ (x y : E), â€–xâ€– = 1 â†’ â€–yâ€– = 1 â†’ x â‰  y â†’ âˆƒ a b, a + b = 1 âˆ§ â€–a â€¢ x + b â€¢ yâ€– < 1) â†’ StrictConvexSpace â„ E :=\n\n/-- If `x â‰  y` belong to the same closed ball, then a convex combination of `x` and `y` with\npositive coefficients belongs to the corresponding open ball. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y z : E}\n  {a b r : â„},\n  x âˆˆ Metric.closedBall z r â†’\n    y âˆˆ Metric.closedBall z r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ Metric.ball z r :=\n\n/-- The absolute value satisfies the triangle inequality -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x y : R),\n  MulHom.toFun self.toMulHom (x + y) â‰¤ MulHom.toFun self.toMulHom x + MulHom.toFun self.toMulHom y :=\n\n/-- The norm on the quotient satisfies `â€–-xâ€– = â€–xâ€–`. -/\ntheorem âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] {S : AddSubgroup M} (x : M â§¸ S), â€–-xâ€– = â€–xâ€– :=\n\n/-- If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$. -/\ntheorem",
    "choices": [
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {z x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, | |x| - |y| | â‰¤ |x - y| ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, | |x| - |y| | â‰¤ |x - y| ",
      "âˆ€ {x y : â„‚}, abs (x.abs - y.abs) â‰¤ (x - y).abs "
    ]
  },
  {
    "docString": "Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.",
    "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\\n  {r : ENNReal}, r < dimH s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\\nsecond countable topology, then there exists a point `x âˆˆ s` such that every neighborhood\\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s t : Set Î±} {r : ENNReal},\\n  x âˆˆ s â†’ EMetric.hausdorffEdist s t < r â†’ âˆƒ y, y âˆˆ t âˆ§ edist x y < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the Hausdorff distance is `< r`, then any point in one of the sets has\\na corresponding point at distance `< r` in the other set \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} (d : X â†’ X â†’ NNReal) (dist_self : âˆ€ (x : X), d x x = 0) (dist_comm : âˆ€ (x y : X), d x y = d y x),\\n  (âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))) â†’ âˆ€ (x y : X), â†‘(d x y) â‰¤ 2 * dist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a function `d : X â†’ X â†’ â„â‰¥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y â‰¤ d x y`, see\\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\\ninequality: `d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚, d xâ‚‚ xâ‚ƒ, d xâ‚ƒ xâ‚„)`. Then `d x y â‰¤ 2 * dist x y` for all\\n`x`, `y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\\nfor some `0 < a < 1` and `C > 0`, `â€–p nâ€– * r ^ n â‰¤ C * a ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, 1 < Pell.Solutionâ‚.x a âˆ§ 0 < Pell.Solutionâ‚.y a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a solution\\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„},\\n  Set.Nonempty s â†’ (Metric.infDist x s < r â†” âˆƒ y, y âˆˆ s âˆ§ dist x y < r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’\\n    âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => a ^ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\\nfor some `0 < a < 1`, `â€–p nâ€– râ¿ = o(aâ¿)`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\\nand `y` with positive coefficients has norm strictly less than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s : Set Î±} {r : ENNReal},\\n  EMetric.infEdist x s < r â†” âˆƒ y, y âˆˆ s âˆ§ edist x y < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The edist to a set is `< r` iff there exists a point in the set at edistance `< r` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿ = o(1)`. \"},\n {\"theorem\": \"âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_2 : MeasureTheory.Measure.OuterRegular Î¼] (A : Set Î±) (r : ENNReal),\\n  â†‘â†‘Î¼ A < r â†’ âˆƒ U, U âŠ‡ A âˆ§ IsOpen U âˆ§ â†‘â†‘Î¼ U < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `r` larger than the measure of a set `A`, there exists an open superset of `A` with\\nmeasure less than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"}]\n",
    "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\nsecond countable topology, then there exists a point `x âˆˆ s` such that every neighborhood\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\n  {r : ENNReal}, r < dimH s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t :=\n\n/-- If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s t : Set Î±} {r : ENNReal},\n  x âˆˆ s â†’ EMetric.hausdorffEdist s t < r â†’ âˆƒ y, y âˆˆ t âˆ§ edist x y < r :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- Consider a function `d : X â†’ X â†’ â„â‰¥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y â‰¤ d x y`, see\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚, d xâ‚‚ xâ‚ƒ, d xâ‚ƒ xâ‚„)`. Then `d x y â‰¤ 2 * dist x y` for all\n`x`, `y`. -/\ntheorem âˆ€ {X : Type u_1} (d : X â†’ X â†’ NNReal) (dist_self : âˆ€ (x : X), d x x = 0) (dist_comm : âˆ€ (x y : X), d x y = d y x),\n  (âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))) â†’ âˆ€ (x y : X), â†‘(d x y) â‰¤ 2 * dist x y :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`, `â€–p nâ€– * r ^ n â‰¤ C * a ^ n`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C * a ^ n :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a solution\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. -/\ntheorem âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, 1 < Pell.Solutionâ‚.x a âˆ§ 0 < Pell.Solutionâ‚.y a :=\n\n/-- The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„},\n  Set.Nonempty s â†’ (Metric.infDist x s < r â†” âˆƒ y, y âˆˆ s âˆ§ dist x y < r) :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1`, `â€–p nâ€– râ¿ = o(aâ¿)`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’\n    âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => a ^ x :=\n\n/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\nand `y` with positive coefficients has norm strictly less than `r`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- The edist to a set is `< r` iff there exists a point in the set at edistance `< r` -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s : Set Î±} {r : ENNReal},\n  EMetric.infEdist x s < r â†” âˆƒ y, y âˆˆ s âˆ§ edist x y < r :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿ = o(1)`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => 1 :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1 :=\n\n/-- Given `r` larger than the measure of a set `A`, there exists an open superset of `A` with\nmeasure less than `r`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.Measure.OuterRegular Î¼] (A : Set Î±) (r : ENNReal),\n  â†‘â†‘Î¼ A < r â†’ âˆƒ U, U âŠ‡ A âˆ§ IsOpen U âˆ§ â†‘â†‘Î¼ U < r :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$. -/\ntheorem",
    "choices": [
      "âˆ€ {k : â„•} {x y : â„^k}, k â‰¥ 3 â†’ dist x y > 0 â†’ âˆ€ {r : â„}, r > 0 â†’ 2 * r > dist x y â†’\n  âˆƒ (f : â„• â†’ â„^k), (âˆ€ (n : â„•), dist (f n) x = r âˆ§ dist (f n) y = r) âˆ§ âˆ€ (n m : â„•), n â‰  m â†’ f n â‰  f m ",
      "âˆ€ {k : â„•} {x y : â„^k} {r d : â„},\n  3 â‰¤ k â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ (zâ‚€ : â„^k) (a : â„), âˆ€ (t : â„), dist (zâ‚€ + a â€¢ t) x = r âˆ§ dist (zâ‚€ + a â€¢ t) y = r ",
      "âˆ€ {k : â„•} [inst : NormedField â„] [inst_1 : NormedAddCommGroup (Finâ‚“ (k+1) â†’ â„)]\n  [inst_2 : NormedSpace â„ (Finâ‚“ (k+1) â†’ â„)] {x y : Finâ‚“ (k+1) â†’ â„} {d r : â„},\n  k â‰¥ 3 â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒâ‚€ z : Finâ‚“ (k+1) â†’ â„, dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {E : Type u_1} [inst : NormedGroup E] [inst_1 : NormedSpace â„ E] {x y : E} {r d : â„},\n  2 < dim E â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ t : Set E, Set.Infinite t âˆ§ âˆ€ z, z âˆˆ t â†’ dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ k} {r d : â„}, dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  Set.Infinite {z : EuclideanSpace â„ k | dist z x = r âˆ§ dist z y = r} ",
      "âˆ€ {k : â„•} [inst : LinearOrderedField â„] [inst_1 : NormedSpace â„ â„] {x y : Finâ‚“ (k + 1) â†’ â„} {d r : â„},\n  3 â‰¤ k â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f : â„• â†’ Finâ‚“ (k + 1) â†’ â„, (âˆ€ n, dist (f n) x = r) âˆ§ (âˆ€ n, dist (f n) y = r) âˆ§ âˆ€ m n, m â‰  n â†’ f m â‰  f n ",
      "âˆ€ {k : â„•} {x y : EuclideanSpace â„ k} {r d : â„},\n  k â‰¥ 3 â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ f : â„• â†’ EuclideanSpace â„ k, (âˆ€ n, dist (f n) x = r) âˆ§ (âˆ€ n, dist (f n) y = r) âˆ§ âˆ€ n m, n â‰  m â†’ f n â‰  f m ",
      "âˆ€ {E : Type u} [inst : NormedGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {x y : E} {r d : â„}, FiniteDimensional.finrank â„ E â‰¥ 3 â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n    âˆƒ f : â„• â†’ E, (âˆ€ (n : â„•), dist (f n) x = r) âˆ§ (âˆ€ (n : â„•), dist (f n) y = r) âˆ§ âˆ€ (nâ‚ nâ‚‚ : â„•), nâ‚ â‰  nâ‚‚ â†’ f nâ‚ â‰  f nâ‚‚ ",
      "âˆ€ {k : â„•}, k â‰¥ 3 â†’ âˆ€ {x y : â„^k}, âˆ€ {d r : â„}, dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒá¶  (z : â„^k) in Filter.atTop, dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] (x y : â„^k) {d r : â„},\n  dist x y = d â†’ 0 < d â†’ 0 < r â†’ 2 * r > d â†’\n    âˆƒ (z : â„^k) (H : Infinite (Set {z : â„^k | dist z x = r âˆ§ dist z y = r})),\n      dist z x = r âˆ§ dist z y = r "
    ]
  },
  {
    "docString": "If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\\n`x : M` such that `B x x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} {x y : E}, Dense â†‘K â†’ x - y âˆˆ Ká—® â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [inst : CommRing R] [inst_1 : Field K]\\n  [inst_2 : CommRing T] [inst_3 : Algebra R K] [inst_4 : Algebra K T] [inst_5 : Algebra R T]\\n  [inst_6 : IsScalarTower R K T] [inst_7 : CommSemiring U] [inst_8 : Algebra K U] [inst_9 : Algebra R U]\\n  [inst_10 : IsScalarTower R K U] (x : T) (y : U),\\n  â†‘(Polynomial.aeval y) (minpoly K x) = 0 â†’ â†‘(Polynomial.aeval y) (minpoly R x) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `y` is a conjugate of `x` over a field `K`, then it is a conjugate over a subring `R`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±},\\n  âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i â‰  0 â†’ âˆƒ x, x âˆˆ s âˆ§ f x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the product of `f i` over `i âˆˆ s` is not equal to `0`, then there is some `x âˆˆ s`\\nsuch that `f x â‰  0`.\"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 â‰¤ x â†’ âˆ€ (y z : â„), x ^ y * x ^ z â‰¤ x ^ (y + z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `0 â‰¤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\\nThe inequality is always true, though, and given in this lemma. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ (k : â„•) {r : â„}, |r| < 1 â†’ Filter.Tendsto (fun n => â†‘n ^ k * r ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. \"},\n {\"theorem\": \"âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:â„•` divides coprime `a` and `b` then `k = 1` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : CommSemiring Î±] (x y : Î±) (n : â„•),\\n  (Finset.sum (Finset.range n) fun i => (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"$x^n-y^n = (x-y) \\\\sum x^ky^{n-1-k}$ reformulated without `-` signs. \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x â‰  0`. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A) :=\n\n/-- If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} {x y : E}, Dense â†‘K â†’ x - y âˆˆ Ká—® â†’ x = y :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- If `y` is a conjugate of `x` over a field `K`, then it is a conjugate over a subring `R`. -/\ntheorem âˆ€ (R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [inst : CommRing R] [inst_1 : Field K]\n  [inst_2 : CommRing T] [inst_3 : Algebra R K] [inst_4 : Algebra K T] [inst_5 : Algebra R T]\n  [inst_6 : IsScalarTower R K T] [inst_7 : CommSemiring U] [inst_8 : Algebra K U] [inst_9 : Algebra R U]\n  [inst_10 : IsScalarTower R K U] (x : T) (y : U),\n  â†‘(Polynomial.aeval y) (minpoly K x) = 0 â†’ â†‘(Polynomial.aeval y) (minpoly R x) = 0 :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x :=\n\n/-- If the product of `f i` over `i âˆˆ s` is not equal to `0`, then there is some `x âˆˆ s`\nsuch that `f x â‰  0`. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±},\n  âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i â‰  0 â†’ âˆƒ x, x âˆˆ s âˆ§ f x â‰  0 :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- For `0 â‰¤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\nThe inequality is always true, though, and given in this lemma. -/\ntheorem âˆ€ {x : â„}, 0 â‰¤ x â†’ âˆ€ (y z : â„), x ^ y * x ^ z â‰¤ x ^ (y + z) :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem âˆ€ (k : â„•) {r : â„}, |r| < 1 â†’ Filter.Tendsto (fun n => â†‘n ^ k * r ^ n) Filter.atTop (nhds 0) :=\n\n/-- If `k:â„•` divides coprime `a` and `b` then `k = 1` -/\ntheorem âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1 :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M :=\n\n/-- $x^n-y^n = (x-y) \\sum x^ky^{n-1-k}$ reformulated without `-` signs. -/\ntheorem âˆ€ {Î± : Type u} [inst : CommSemiring Î±] (x y : Î±) (n : â„•),\n  (Finset.sum (Finset.range n) fun i => (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n :=\n\n/-- If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$ -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : CommRing R] {k : â„•} (x : Finâ‚“ k â†’ R), 2 â‰¤ k â†’ âˆƒ y : Finâ‚“ k â†’ R, y â‰  0 âˆ§ (x â¬â‚œ y = 0) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {k : â„•} {x : Fin k â†’ R}, k â‰¥ 2 â†’ âˆƒ y : Fin k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ (Î» i, x i * y i)) = 0 ",
      "âˆ€ {R : Type u_1} [inst : Ring R] {k : â„•} (x : Finâ‚“ (k + 2) â†’ R),\n  (âˆƒ y : Finâ‚“ (k + 2) â†’ R, y â‰  0 âˆ§ x â¬áµ¥ y = 0) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : Invertible 2] {k : â„•} (x : Finâ‚“ k â†’ R), 2 â‰¤ k â†’ âˆƒ y, y â‰  0 âˆ§ Finâ‚“.sum_univ (Î» i, x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} [inst : Ring R] {k : â„•} {x : Finâ‚“ (k + 2) â†’ R},\n  (âˆƒ y : Finâ‚“ (k + 2) â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ (Î» i, x i * y i)) = 0) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] {k : â„•} {x : Finâ‚“ k â†’ R}, 2 â‰¤ k â†’ âˆƒ y : Finâ‚“ k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} [inst : Ring R] {k : â„•} (x : R^k), 2 â‰¤ k â†’ âˆƒ (y : R^k), y â‰  0 âˆ§ Matrix.dotProduct x y = 0 ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : CommSemiring R] [inst_1 : DecidableEq R] [inst_2 : Fintype R] (x : Finâ‚“ k â†’ R),\n  2 â‰¤ k â†’ âˆƒ y : Finâ‚“ k â†’ R, y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {k : â„•} (x : Finâ‚“ (k+2) â†’ R),\n  âˆƒ (y : Finâ‚“ (k+2) â†’ R), y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Nontrivial R] {k : â„•} {x : Finâ‚“ (k + 2) â†’ R},\n  âˆƒ y : Finâ‚“ (k + 2) â†’ R, y â‰  0 âˆ§ Matrix.dotProduct x y = 0 "
    ]
  },
  {
    "docString": "Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c\",\n  \"isProp\": true,\n  \"docString\": \"For `a â‰¤ b`, there is a `c` so `b = a * c`. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, a % b = c â†’ b âˆ£ a - c\",\n  \"isProp\": true,\n  \"docString\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"theorem\": \"âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:â„•` divides coprime `a` and `b` then `k = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CircularPreorder Î±] {a b c : Î±}, btw a b c â†’ btw b c a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` is between `a` and `c`, then `c` is between `b` and `a`.\\nThis is motivated by imagining three points on a circle. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ EuclideanDomain.r (EuclideanDomain.remainder a b) b\",\n  \"isProp\": true,\n  \"docString\": \"The relation `r` satisfies `r (a % b) b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, c âˆˆ Set.uIcc a b â†’ |b - c| â‰¤ |b - a|\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x âˆˆ [a, b]`, then the distance between `c` and `b` is less than or equal to\\nthat of `a` and `b`  \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a < m â†’ m < f' b â†’ m âˆˆ f' '' Set.Ioo a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' a < m < f' b`, then `f' c = m` for some\\n`c âˆˆ (a, b)`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a + c\",\n  \"isProp\": true,\n  \"docString\": \"For `a â‰¤ b`, there is a `c` so `b = a + c`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a â‰¤ -b â†’ b â‰¤ -a` on ereal \"}]\n",
    "prompt_cons": "/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c) :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- For `a â‰¤ b`, there is a `c` so `b = a * c`. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ b âˆ£ a - c :=\n\n/-- If `k:â„•` divides coprime `a` and `b` then `k = 1` -/\ntheorem âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1 :=\n\n/-- If `b` is between `a` and `c`, then `c` is between `b` and `a`.\nThis is motivated by imagining three points on a circle. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CircularPreorder Î±] {a b c : Î±}, btw a b c â†’ btw b c a :=\n\n/-- The relation `r` satisfies `r (a % b) b`. -/\ntheorem âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ EuclideanDomain.r (EuclideanDomain.remainder a b) b :=\n\n/-- If `x âˆˆ [a, b]`, then the distance between `c` and `b` is less than or equal to\nthat of `a` and `b` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, c âˆˆ Set.uIcc a b â†’ |b - c| â‰¤ |b - a| :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' a < m < f' b`, then `f' c = m` for some\n`c âˆˆ (a, b)`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a < m â†’ m < f' b â†’ m âˆˆ f' '' Set.Ioo a b :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- For `a â‰¤ b`, there is a `c` so `b = a + c`. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a + c :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- `a â‰¤ -b â†’ b â‰¤ -a` on ereal -/\ntheorem âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a :=\n\n/-- Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [metric_space R] {a b : R}, a â‰  b â†’\n  (âˆƒ c r, r > 0 âˆ§ (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) âˆ§ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a) ",
      "âˆ€ {R : Type u_1} [inst : NormedRing R] {k : â„•} [self : NondiscreteNormedField R] (a b : Finâ‚“ k â†’ R), (âˆƒ c : Finâ‚“ k â†’ R, âˆƒ r : R, r > 0 âˆ§ (âˆ€ x : Finâ‚“ k â†’ R, (âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥ â†” âˆ¥x - câˆ¥ = r))) â†’ (3 â€¢ c = 4 â€¢ b - a) âˆ§ (3 â€¢ r = 2 * âˆ¥b - aâˆ¥) ",
      "âˆ€ {R : Type u_1} [inst : NormedRing R] {a b c : R} {r : â„},\n  (âˆ€ (x : R), 2 * dist x b = dist x a â†” dist x c = r) â†’\n    3 * c = 4 * b - a âˆ§ 3 * r = 2 * dist b a ",
      "forall {ğ•œ : Type*} [normed_field ğ•œ] {E : Type*} [normed_group E] [normed_space ğ•œ E] {a b : E},\n  âˆƒ c r : E, r > 0 âˆ§\n    (âˆ€ x : E, âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥ â†” âˆ¥x - câˆ¥ = r) âˆ§\n      3 * c = 4 * b - a âˆ§ 3 * r = 2 * âˆ¥b - aâˆ¥ ",
      "forall\n  {R : Type u_1} [metric_space R] [self : NormedGroup R] {a b : R},\n  âˆƒ c r : R, r > 0 âˆ§\n  (âˆ€ x : R, dist x a = 2 * dist x b â†” dist x c = r) âˆ§\n  (3 â€¢ c = 4 â€¢ b - a) âˆ§\n  (3 â€¢ r = 2 * dist b a) ",
      "âˆ€ {R : Type u_1} [inst : NormedRing R] [inst : NormedAlgebra â„ R] {a b : R},\n  âˆƒ c : R, âˆƒ r : â„, (r > 0 âˆ§ (âˆ€ x : R, âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥ â†” âˆ¥x - câˆ¥ = r)) âˆ§ (3 * c = 4 * b - a) âˆ§ (3 * r = 2 * âˆ¥b - aâˆ¥) ",
      "âˆ€ {R : Type u_1} [inst : NormedField R] [inst_1 : NormedSpace R R] (k : â„•) {a b : Fin k â†’ R},\n  (âˆƒ c : Fin k â†’ R, âˆƒ r : R,\n    (âˆ€ x : Fin k â†’ R, (âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥) â†” (âˆ¥x - câˆ¥ = r)) âˆ§\n    (3 â€¢ c = 4 â€¢ b - a) âˆ§\n    (3 * r = 2 * âˆ¥b - aâˆ¥)) ",
      "âˆ€ {R : Type u_1} {k : â„•} [inst : NormedField R] [NormedSpace R (Finâ‚“ (k + 1) â†’ R)], \n  âˆ€ (a b c : Finâ‚“ (k + 1) â†’ R) (r : R),\n    (âˆ€ x, (âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥) â†” (âˆ¥x - câˆ¥ = r)) â†’ \n      (3 â€¢ c = 4 â€¢ b - a) âˆ§ (3 * r = 2 * âˆ¥b - aâˆ¥) ",
      " âˆ€ {k : Type u_1} [inst : NormedField k] {a b c : k} {r : k},\n  (âˆ€ x : k, |x - a| = 2 * |x - b| â†” |x - c| = r) â†’\n  (3 * c = 4 * b - a) âˆ§ (3 * r = 2 * |b - a|) ",
      "/-- Suppose `a, b` are elements of `R^k`. Find `c` in `R^k` and `r > 0` such that `|x-a|=2|x-b|`\n    if and only if `| x - c | = r`. Prove that `3 * c = 4 * b - a` and `3 * r = 2 * |b - a|`. -/\ntheorem find_c_and_r {k : Type u_1} [inst : NormedField k] {R : Type u_2} [inst : NormedSpace k R]\n  (a b : R) (c : R) (r : k) (hr : 0 < r)\n  (hx : âˆ€ (x : R), (âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥) â†” (âˆ¥x - câˆ¥ = r)) :\n  3 * c = 4 * b - a âˆ§ 3 * r = 2 * âˆ¥b - aâˆ¥ "
    ]
  },
  {
    "docString": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±], âˆƒ f, Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separable metric space embeds isometrically in `â„“^âˆ(â„•)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {f : Î² â†’ Î±} [inst_1 : TopologicalSpace Î²],\\n  Inducing f â†’ âˆ€ {s : Set Î±}, TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f â»Â¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a separable set by an inducing map is separable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²] [inst_3 : MeasurableSpace Î²] [inst_4 : BorelSpace Î²]\\n  {Î¹ : Type u_1} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [inst_5 : Filter.NeBot u]\\n  [inst_6 : Filter.IsCountablyGenerated u], (âˆ€ (i : Î¹), Measurable (f i)) â†’ Filter.Tendsto f u (nhds g) â†’ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\\nmeasurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²] [inst_3 : MeasurableSpace Î²] [inst_4 : BorelSpace Î²]\\n  {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}, (âˆ€ (i : â„•), Measurable (f i)) â†’ Filter.Tendsto f Filter.atTop (nhds g) â†’ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequential limit of measurable functions valued in a (pseudo) metrizable space is\\nmeasurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\\n  Metric.Bounded s â†’\\n    âˆ€ {x : â„• â†’ X},\\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\\nevery bounded sequence has a converging subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst : LinearOrder Î¹]\\n  [inst_1 : TopologicalSpace Î¹] [inst_2 : OrderTopology Î¹] [inst_3 : DenselyOrdered Î¹]\\n  [inst_4 : TopologicalSpace.FirstCountableTopology Î¹] {s : Î¹ â†’ Set Î±} {a : Î¹},\\n  (âˆ€ (r : Î¹), r > a â†’ MeasurableSet (s r)) â†’\\n    (âˆ€ (i j : Î¹), a < i â†’ i â‰¤ j â†’ s i âŠ† s j) â†’\\n      (âˆƒ r, r > a âˆ§ â†‘â†‘Î¼ (s r) â‰  âŠ¤) â†’\\n        Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) (nhdsWithin a (Set.Ioi a)) (nhds (â†‘â†‘Î¼ (â‹‚ (r : Î¹) (_ : r > a), s r)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of the intersection of a decreasing sequence of measurable\\nsets indexed by a linear order with first countable topology is the limit of the measures. \"}]\n",
    "prompt_cons": "/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Every separable metric space embeds isometrically in `â„“^âˆ(â„•)`. -/\ntheorem âˆ€ (Î± : Type u) [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±], âˆƒ f, Isometry f :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- The preimage of a separable set by an inducing map is separable. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {f : Î² â†’ Î±} [inst_1 : TopologicalSpace Î²],\n  Inducing f â†’ âˆ€ {s : Set Î±}, TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f â»Â¹' s) :=\n\n/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²] [inst_3 : MeasurableSpace Î²] [inst_4 : BorelSpace Î²]\n  {Î¹ : Type u_1} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [inst_5 : Filter.NeBot u]\n  [inst_6 : Filter.IsCountablyGenerated u], (âˆ€ (i : Î¹), Measurable (f i)) â†’ Filter.Tendsto f u (nhds g) â†’ Measurable g :=\n\n/-- A sequential limit of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²] [inst_3 : MeasurableSpace Î²] [inst_4 : BorelSpace Î²]\n  {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}, (âˆ€ (i : â„•), Measurable (f i)) â†’ Filter.Tendsto f Filter.atTop (nhds g) â†’ Measurable g :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\n  Metric.Bounded s â†’\n    âˆ€ {x : â„• â†’ X},\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a) :=\n\n/-- The measure of the intersection of a decreasing sequence of measurable\nsets indexed by a linear order with first countable topology is the limit of the measures. -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst : LinearOrder Î¹]\n  [inst_1 : TopologicalSpace Î¹] [inst_2 : OrderTopology Î¹] [inst_3 : DenselyOrdered Î¹]\n  [inst_4 : TopologicalSpace.FirstCountableTopology Î¹] {s : Î¹ â†’ Set Î±} {a : Î¹},\n  (âˆ€ (r : Î¹), r > a â†’ MeasurableSet (s r)) â†’\n    (âˆ€ (i j : Î¹), a < i â†’ i â‰¤ j â†’ s i âŠ† s j) â†’\n      (âˆƒ r, r > a âˆ§ â†‘â†‘Î¼ (s r) â‰  âŠ¤) â†’\n        Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) (nhdsWithin a (Set.Ioi a)) (nhds (â†‘â†‘Î¼ (â‹‚ (r : Î¹) (_ : r > a), s r))) :=\n\n/-- Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] (H : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, IsLimitPointOf s x),\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ (X : Type u_1) [inst : MetricSpace X] (H : âˆ€ s : Set X, Set.Infinite s â†’ âˆƒ x, IsLimitPoint X x s),\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x H, IsLimitPoint x s],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.IsProper X], TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, x âˆˆ closure s],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, x âˆˆ closure s], TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.SeparableSpace X],\n  (âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, TopologicalSpace.IsLimitPoint x s) â†’\n    TopologicalSpace.SeparableSpace X ",
      "âˆ€ (X : Type u) [inst : MetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x âˆˆ s, IsLimitPoint x s],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.SeparableSpace X]\n  (h : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, IsLimitPoint x s), TopologicalSpace.SeparableSpace X ",
      "âˆ€ (X : Type u) [inst : PseudoMetricSpace X] [inst_1 : TopologicalSpace.PseudoMetrizableSpace X],\n  (âˆ€ (s : Set X), Set.Infinite s â†’ Set.Nonempty (s.LimitPoints)) â†’ TopologicalSpace.SeparableSpace X "
    ]
  },
  {
    "docString": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\\n  IsComplete s â†’\\n    âˆ€ (hsf : Set.MapsTo f s s),\\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\\n        âˆ€ {x : Î±},\\n          x âˆˆ s â†’\\n            edist x (f x) â‰  âŠ¤ â†’\\n              âˆƒ y,\\n                y âˆˆ s âˆ§\\n                  Function.IsFixedPt f y âˆ§\\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Banach fixed-point theorem for maps contracting on a complete subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\\ncan be written as the union of a countable set and a perfect set.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [inst : MetricSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : SemilatticeSup Î¹] [inst_2 : Nonempty Î¹] [inst_3 : Countable Î¹] {f : Î¹ â†’ Î± â†’ Î²}\\n  {g : Î± â†’ Î²} [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : Î¹), MeasureTheory.StronglyMeasurable (f n)) â†’\\n    MeasureTheory.StronglyMeasurable g â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n        âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰¤ ENNReal.ofReal Îµ âˆ§ TendstoUniformlyOn f g Filter.atTop tá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"Egorov's theorem for finite measure spaces. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\\n  (s : Set Î²),\\n  IsCompact s â†’\\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\\n      IsClosed A â†’\\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence a.e. implies convergence in measure in a finite measure space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s â†’ TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"}]\n",
    "prompt_cons": "/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- Banach fixed-point theorem for maps contracting on a complete subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\n  IsComplete s â†’\n    âˆ€ (hsf : Set.MapsTo f s s),\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\n        âˆ€ {x : Î±},\n          x âˆˆ s â†’\n            edist x (f x) â‰  âŠ¤ â†’\n              âˆƒ y,\n                y âˆˆ s âˆ§\n                  Function.IsFixedPt f y âˆ§\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K) :=\n\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Egorov's theorem for finite measure spaces. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [inst : MetricSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : SemilatticeSup Î¹] [inst_2 : Nonempty Î¹] [inst_3 : Countable Î¹] {f : Î¹ â†’ Î± â†’ Î²}\n  {g : Î± â†’ Î²} [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : Î¹), MeasureTheory.StronglyMeasurable (f n)) â†’\n    MeasureTheory.StronglyMeasurable g â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n        âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰¤ ENNReal.ofReal Îµ âˆ§ TendstoUniformlyOn f g Filter.atTop tá¶œ :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- The intersection of a preperfect set and an open set is preperfect. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C) :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\n  (s : Set Î²),\n  IsCompact s â†’\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\n      IsClosed A â†’\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\n  TendstoUniformlyOn F f p âˆ… :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- Convergence a.e. implies convergence in measure in a finite measure space. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s â†’ TotallyBounded s :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a :=\n\n/-- Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  [inst_2 : T2Space Î±],\n  âˆ€ (E : Set Î±), Â¬Set.Countable E â†’ Perfect (CondensationPoints E) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {E : Set Î±},\n  Â¬Set.Countable E â†’\n    âˆ€ {P : Set Î±},\n      P = SetOf (IsCondensationPoint E) â†’ Perfect P ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {E : Set Î±},\n  Â¬Set.Countable E â†’ Perfect (Set.CondensationPoints E) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {E : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed E â†’ Â¬Set.Countable E â†’ IsPerfect (CondensationPoints E) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsUncountable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† Closure C ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {E : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ P âŠ† E ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [_inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±],\n  âˆ€ {s : Set Î±}, Set.Countable s â†’ Â¬âˆƒ x, IsPerfect (sá¶œ âˆ© Ioi x) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î±] {E P : Set Î±},\n  IsClosed P â†’\n    (âˆ€ (x : Î±), x âˆˆ P â†’ (Â¬Set.Countable (E âˆ© Metric.Ball x ({Î´ : â„ | 0 < Î´}))) â†’\n      Perfect P âˆ§ P âŠ† E ",
      "âˆ€ {Î± : Type u_1} [inst : EmetricSpace Î±] {E : Set Î±}, Not (Set.Countable E) â†’ Perfect (CondensationPoints E) ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : TopologicalSpace.SecondCountableTopology E] [inst_2 : LinearOrder E]\n  [inst_3 : OrderTopology E],\n  Â¬Set.Countable E â†’ âˆƒ P, Perfect P âˆ§ P âŠ† E "
    ]
  },
  {
    "docString": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\\ncan be written as the union of a countable set and a perfect set.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\\n    Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\ncountably many members of the union whose measure is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {Îµ : ENNReal},\\n  0 < Îµ â†’\\n    âˆ€ {As : Î¹ â†’ Set Î±},\\n      (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\\n        Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Finite {i | Îµ â‰¤ â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\nfinitely many members of the union whose measure exceeds any given positive number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\\n  IsCompact s â†’ âˆ€ {e : â„}, 0 < e â†’ âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ (x : Î±) (_ : x âˆˆ t), Metric.ball x e\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any compact set in a pseudometric space can be covered by finitely many balls of a given\\npositive radius \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\\nspace from countably many data. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"}]\n",
    "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\n    Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)} :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {Îµ : ENNReal},\n  0 < Îµ â†’\n    âˆ€ {As : Î¹ â†’ Set Î±},\n      (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\n        Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Finite {i | Îµ â‰¤ â†‘â†‘Î¼ (As i)} :=\n\n/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\n  IsCompact s â†’ âˆ€ {e : â„}, 0 < e â†’ âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ (x : Î±) (_ : x âˆˆ t), Metric.ball x e :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\nspace from countably many data. -/\ntheorem âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [t : MetricSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {A : Set Î±},\n  IsClosed A â†’ âˆƒ P C, Perfect P âˆ§ Set.Countable C âˆ§ A = P âˆª C ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P, Perfect P âˆ§ Set.Nonempty P âˆ§ P âŠ† s âˆ§ âˆƒ Q, Set.Countable Q âˆ§ s = P âˆª Q ",
      "forall {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t, Set.Countable t âˆ§ s = closure t âˆª Perfect s ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t u, Perfect t âˆ§ Set.Countable u âˆ§ s = t âˆª u ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ tâ‚ âŠ† s âˆ§ Set.Countable tâ‚‚ âˆ§ tâ‚‚ âŠ† s âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P A, Set.Countable A âˆ§ Perfect P âˆ§ s = A âˆª P ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t h, Perfect t âˆ§ Set.Countable h âˆ§ s = t âˆª h ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Set.Countable tâ‚ âˆ§ Perfect tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ sâ‚ sâ‚‚, Perfect sâ‚ âˆ§ Set.Countable sâ‚‚ âˆ§ s = sâ‚ âˆª sâ‚‚ "
    ]
  },
  {
    "docString": "Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)},\\n  â†‘â†‘(MeasureTheory.Measure.prod Î¼ Î½) s = 0 â†’ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [MeasureTheory.Measure.ae Î¼] 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\\n`p Ã—Ë¢ ğ“Ÿ s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence a.e. implies convergence in measure in a finite measure space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g\",\n  \"isProp\": true,\n  \"docString\": \"Convergence in Lp implies convergence in measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±], IsCompact s â†’ (TendstoLocallyUniformlyOn F f p s â†” TendstoUniformlyOn F f p s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\\n  UniformContinuous g â†’ TendstoUniformly F f p â†’ TendstoUniformly (fun i => g âˆ˜ F i) (g âˆ˜ f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing on the left by a uniformly continuous function preserves uniform convergence \"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©} {Î¼ : MeasureTheory.FiniteMeasure Î©},\\n  Filter.Tendsto Î¼s F (nhds Î¼) â†’\\n    Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds (MeasureTheory.FiniteMeasure.mass Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence of finite measures implies the convergence of their total masses. \"}]\n",
    "prompt_cons": "/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)},\n  â†‘â†‘(MeasureTheory.Measure.prod Î¼ Î½) s = 0 â†’ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [MeasureTheory.Measure.ae Î¼] 0 :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p Ã—Ë¢ ğ“Ÿ s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Convergence a.e. implies convergence in measure in a finite measure space. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g :=\n\n/-- Convergence in Lp implies convergence in measure. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±], IsCompact s â†’ (TendstoLocallyUniformlyOn F f p s â†” TendstoUniformlyOn F f p s) :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\n  UniformContinuous g â†’ TendstoUniformly F f p â†’ TendstoUniformly (fun i => g âˆ˜ F i) (g âˆ˜ f) p :=\n\n/-- Convergence of finite measures implies the convergence of their total masses. -/\ntheorem âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©} {Î¼ : MeasureTheory.FiniteMeasure Î©},\n  Filter.Tendsto Î¼s F (nhds Î¼) â†’\n    Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds (MeasureTheory.FiniteMeasure.mass Î¼)) :=\n\n/-- Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] {s : â„• â†’ Î±} {a : Î±}, Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => âˆ¥s nâˆ¥) Filter.atTop (nhds (âˆ¥aâˆ¥)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : NormedGroup Î²] {f : Î± â†’ Î²} {g : Î± â†’ Î²} {s : Î± â†’ Î²} {l : Filter Î±},\n  Filter.Tendsto s l g â†’ Filter.Tendsto (Î» x, âˆ¥s xâˆ¥) l (Filter.map âˆ¥gâˆ¥) ",
      "âˆ€ {Î± : Type u} [inst : NormedLatticeAddCommGroup Î±] {u : â„• â†’ Î±},\n  Filter.Tendsto u Filter.atTop (nhds (Limsup Filter.atTop u)) â†’\n  Filter.Tendsto (fun n => âˆ¥u nâˆ¥) Filter.atTop (nhds (Limsup Filter.atTop (fun n => âˆ¥u nâˆ¥))) ",
      "âˆ€ {Î± : Type u} {s : â„• â†’ Î±} {a : Î±} [inst : NormedAddCommGroup Î±], Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (Î» n, abs (s n)) Filter.atTop (nhds (abs a)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹},\n  Filter.Tendsto F p (nhds f) â†’ Filter.Tendsto (Î» n, |F n|) p (nhds (|f|)) ",
      "âˆ€ {Î± : Type u_1} [inst : NormedGroup Î±] {s : â„• â†’ Î±} {a : Î±},\n  Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => âˆ¥s nâˆ¥) Filter.atTop (nhds (âˆ¥aâˆ¥)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : SemilatticeSup Î²] {s : Î² â†’ Î±},\n  CauchySeq s â†’ CauchySeq (fun n => dist (s n) 0) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : NormedAddCommGroup Î²] {s : â„• â†’ Î± â†’ Î²} {f : Î± â†’ Î²},\n  Filter.Tendsto s Filter.atTop (nhds f) â†’ Filter.Tendsto (fun n => fun x => âˆ¥s n xâˆ¥) Filter.atTop (nhds fun x => âˆ¥f xâˆ¥) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {Î² : Type u_2} [inst_1 : SemilatticeSup Î²] {s : Î² â†’ Î±},\n  Convergent s â†’ Convergent (Î» n, abs (s n)) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {s : â„• â†’ Î±} {a : Î±},\n  Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs a)) "
    ]
  },
  {
    "docString": "If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {s : â„}, 0 < s â†’ MeasureTheory.IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Set.Ioi 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Euler integral for the `Î“` function converges for positive real `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"If `s` has a least element, then it is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)},\\n  â†‘â†‘(MeasureTheory.Measure.prod Î¼ Î½) s = 0 â†’ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [MeasureTheory.Measure.ae Î¼] 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a b : Î±},\\n  a < b â†’\\n    âˆ€ (s : Set Î±),\\n      List.TFAE\\n        [s âˆˆ nhdsWithin a (Set.Ioi a), s âˆˆ nhdsWithin a (Set.Ioc a b), s âˆˆ nhdsWithin a (Set.Ioo a b),\\n          âˆƒ u, u âˆˆ Set.Ioc a b âˆ§ Set.Ioo a u âŠ† s, âˆƒ u, u âˆˆ Set.Ioi a âˆ§ Set.Ioo a u âŠ† s]\",\n  \"isProp\": true,\n  \"docString\":\n  \"The following statements are equivalent:\\n\\n0. `s` is a neighborhood of `a` within `(a, +âˆ)`;\\n1. `s` is a neighborhood of `a` within `(a, b]`;\\n2. `s` is a neighborhood of `a` within `(a, b)`;\\n3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`;\\n4. `s` includes `(a, u)` for some `u > a`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"}]\n",
    "prompt_cons": "/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- The Euler integral for the `Î“` function converges for positive real `s`. -/\ntheorem âˆ€ {s : â„}, 0 < s â†’ MeasureTheory.IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Set.Ioi 0) :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- If `s` has a least element, then it is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ BddBelow s :=\n\n/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)},\n  â†‘â†‘(MeasureTheory.Measure.prod Î¼ Î½) s = 0 â†’ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [MeasureTheory.Measure.ae Î¼] 0 :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `a` within `(a, +âˆ)`;\n1. `s` is a neighborhood of `a` within `(a, b]`;\n2. `s` is a neighborhood of `a` within `(a, b)`;\n3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`;\n4. `s` includes `(a, u)` for some `u > a`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a b : Î±},\n  a < b â†’\n    âˆ€ (s : Set Î±),\n      List.TFAE\n        [s âˆˆ nhdsWithin a (Set.Ioi a), s âˆˆ nhdsWithin a (Set.Ioc a b), s âˆˆ nhdsWithin a (Set.Ioo a b),\n          âˆƒ u, u âˆˆ Set.Ioc a b âˆ§ Set.Ioo a u âŠ† s, âˆƒ u, u âˆˆ Set.Ioi a âˆ§ Set.Ioo a u âŠ† s] :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$. -/\ntheorem",
    "choices": [
      "Real.sqrtTwoAddSeries (0:â„) n < 2 âˆ§ Filter.Tendsto (Real.sqrtTwoAddSeries 0) Filter.atTop (nhds 2) ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 âˆ§ Filter.Tendsto (fun n => Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n) Filter.atTop (nhds 2) ",
      "(âˆƒ L : â„, Filter.Tendsto (fun n => Real.sqrt (2 + Real.sqrt (Real.sqrtTwoAddSeries 0 n))) Filter.atTop (nhds L) âˆ§ L < 2) ",
      "Real.sqrtTwoAddSeries.tendsto_zero : Filter.Tendsto (Real.sqrtTwoAddSeries (â†‘0 / â†‘1)) Filter.atTop (nhds 0) ",
      "Real.sqrtTwoAddSeriesTendsToTwo : Filter.Tendsto (Real.sqrtTwoAddSeries (â†‘0 / â†‘1)) Filter.atTop (nhds 2) ",
      "Real.sqrt_two_add_series_tendsto ",
      "âˆ€ (n : â„•), Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 âˆ§ Filter.Tendsto Real.sqrtTwoAddSeries Filter.atTop (nhds 2) ",
      "Real.sqrt_series_converges : âˆ€ (n : â„•), Real.sqrtTwoAddSeries 0 n < 2 ",
      "âˆ€ (n : â„•), 0 < Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n âˆ§ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ",
      "Real.sqrt_two_add_series_tendsto : Filter.Tendsto (Real.sqrtTwoAddSeries (â†‘0 / â†‘1)) Filter.atTop (nhds 2) "
    ]
  },
  {
    "docString": "Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_3} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : Î± â†’ â„}\\n  {f : Î± â†’ Î² â†’ F},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : Î²), â€–f n xâ€– â‰¤ u n) â†’\\n      TendstoUniformly (fun t x => Finset.sum t fun n => f n x) (fun x => âˆ‘' (n : Î±), f n x) Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion with general index set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : Î± â†’ â„}\\n  {f : Î± â†’ Î² â†’ F},\\n  Summable u â†’\\n    âˆ€ {s : Set Î²},\\n      (âˆ€ (n : Î±) (x : Î²), x âˆˆ s â†’ â€–f n xâ€– â‰¤ u n) â†’\\n        TendstoUniformlyOn (fun t x => Finset.sum t fun n => f n x) (fun x => âˆ‘' (n : Î±), f n x) Filter.atTop s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion relative to a set, with general index set. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\\n  Summable u â†’\\n    (âˆ€ (n : â„•) (x : Î²), â€–f n xâ€– â‰¤ u n) â†’\\n      TendstoUniformly (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x) Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion with index set `â„•`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\\n  Summable u â†’\\n    âˆ€ {s : Set Î²},\\n      (âˆ€ (n : â„•) (x : Î²), x âˆˆ s â†’ â€–f n xâ€– â‰¤ u n) â†’\\n        TendstoUniformlyOn (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x)\\n          Filter.atTop s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion relative to a set, with index set `â„•`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Ici a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval [a, âˆ). \"}]\n",
    "prompt_cons": "/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion with general index set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_3} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : Î± â†’ â„}\n  {f : Î± â†’ Î² â†’ F},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : Î²), â€–f n xâ€– â‰¤ u n) â†’\n      TendstoUniformly (fun t x => Finset.sum t fun n => f n x) (fun x => âˆ‘' (n : Î±), f n x) Filter.atTop :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion relative to a set, with general index set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : Î± â†’ â„}\n  {f : Î± â†’ Î² â†’ F},\n  Summable u â†’\n    âˆ€ {s : Set Î²},\n      (âˆ€ (n : Î±) (x : Î²), x âˆˆ s â†’ â€–f n xâ€– â‰¤ u n) â†’\n        TendstoUniformlyOn (fun t x => Finset.sum t fun n => f n x) (fun x => âˆ‘' (n : Î±), f n x) Filter.atTop s :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion with index set `â„•`. -/\ntheorem âˆ€ {Î² : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\n  Summable u â†’\n    (âˆ€ (n : â„•) (x : Î²), â€–f n xâ€– â‰¤ u n) â†’\n      TendstoUniformly (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x) Filter.atTop :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion relative to a set, with index set `â„•`. -/\ntheorem âˆ€ {Î² : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\n  Summable u â†’\n    âˆ€ {s : Set Î²},\n      (âˆ€ (n : â„•) (x : Î²), x âˆˆ s â†’ â€–f n xâ€– â‰¤ u n) â†’\n        TendstoUniformlyOn (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x)\n          Filter.atTop s :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- The cardinality of the interval [a, âˆ). -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Ici a) = Cardinal.continuum :=\n\n/-- Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$. -/\ntheorem",
    "choices": [
      "Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "theorem real.tendsto_sum_i_sqrt_diff : Filter.Tendsto (Î» (n : â„•), Finset.sum (Finset.range n) (Î» (i : â„•), Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "Real.tendsto_sum_nat_sqrt_minus_one_at_top : Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop Filter.atTop ",
      "Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "forall (a : â„• â†’ â„), a = (Î» n, Real.sqrt (n+1) - Real.sqrt n) â†’ Filter.Tendsto (Î» n, Finset.sum (Finset.range n) a) Filter.atTop Filter.atTop ",
      "Filter.Tendsto (fun n : â„• => Finset.sum (Finset.range n) fun i => (Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±], Filter.Tendsto (fun n => âˆ‘ (i : â„•) in Finset.range n, (sqrt (i+1) - sqrt i)) Filter.atTop Filter.atTop ",
      "Filter.Tendsto (fun n : â„• => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "Filter.Tendsto (Î»n, Finset.sum (Finset.range n) (Î»i, Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop "
    ]
  },
  {
    "docString": "If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {u : â„• â†’ â„} (h : Subadditive u),\\n  BddBelow (Set.range fun n => u n / â†‘n) â†’ Filter.Tendsto (fun n => u n / â†‘n) Filter.atTop (nhds (Subadditive.lim h))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fekete's lemma: a subadditive sequence which is bounded below converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\\n  Metric.Bounded s â†’\\n    âˆ€ {x : â„• â†’ X},\\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\\nevery bounded sequence has a converging subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±},\\n  Dense s â†’\\n    (âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) â†’\\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) f u) _autoâœ â†’\\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¥ x_1) f u) _autoâœÂ¹ â†’ âˆƒ c, Filter.Tendsto u f (nhds c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\\nworks if `a` and `b` are restricted to a dense subset.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²] {f : Î± â†’ Î²}\\n  {s : Set Î±}, MonotoneOn f s â†’ BddBelow (f '' s) â†’ BddAbove (f '' s) â†’ âˆƒ g, Monotone g âˆ§ Set.EqOn f g s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is monotone and is bounded on a set `s`, then it admits a monotone extension to\\nthe whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {p : Filter Î¹} {g : Î¹ â†’ Î²} {b : Î²},\\n  Filter.Tendsto g p (nhds b) â†’ âˆ€ (s : Set Î±), TendstoUniformlyOn (fun n x => g n) (fun x => b) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence `g` converges to some `b`, then the sequence of constant functions\\n`fun n â†¦ fun a â†¦ g n` converges to the constant function `fun a â†¦ b` on any set `s` \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {u : â„‚},\\n  0 < u.re â†’ âˆ€ (v : â„‚), IntervalIntegrable (fun x => â†‘x ^ (u - 1) * (1 - â†‘x) ^ (v - 1)) MeasureTheory.volume 0 (1 / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma for `betaIntegral_convergent`, showing convergence at the left endpoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\\n    Filter.Tendsto x l f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence converges if every subsequence has a convergent subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : InfConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsGLB s a â†’ Filter.Tendsto CoeTC.coe Filter.atBot (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ -âˆ`\"}]\n",
    "prompt_cons": "/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- Fekete's lemma: a subadditive sequence which is bounded below converges. -/\ntheorem âˆ€ {u : â„• â†’ â„} (h : Subadditive u),\n  BddBelow (Set.range fun n => u n / â†‘n) â†’ Filter.Tendsto (fun n => u n / â†‘n) Filter.atTop (nhds (Subadditive.lim h)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\n  Metric.Bounded s â†’\n    âˆ€ {x : â„• â†’ X},\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a) :=\n\n/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±},\n  Dense s â†’\n    (âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) â†’\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) f u) _autoâœ â†’\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¥ x_1) f u) _autoâœÂ¹ â†’ âˆƒ c, Filter.Tendsto u f (nhds c) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- If a function is monotone and is bounded on a set `s`, then it admits a monotone extension to\nthe whole space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²] {f : Î± â†’ Î²}\n  {s : Set Î±}, MonotoneOn f s â†’ BddBelow (f '' s) â†’ BddAbove (f '' s) â†’ âˆƒ g, Monotone g âˆ§ Set.EqOn f g s :=\n\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`fun n â†¦ fun a â†¦ g n` converges to the constant function `fun a â†¦ b` on any set `s` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {p : Filter Î¹} {g : Î¹ â†’ Î²} {b : Î²},\n  Filter.Tendsto g p (nhds b) â†’ âˆ€ (s : Set Î±), TendstoUniformlyOn (fun n x => g n) (fun x => b) p s :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t) :=\n\n/-- Auxiliary lemma for `betaIntegral_convergent`, showing convergence at the left endpoint. -/\ntheorem âˆ€ {u : â„‚},\n  0 < u.re â†’ âˆ€ (v : â„‚), IntervalIntegrable (fun x => â†‘x ^ (u - 1) * (1 - â†‘x) ^ (v - 1)) MeasureTheory.volume 0 (1 / 2) :=\n\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\n    Filter.Tendsto x l f :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ -âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : InfConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsGLB s a â†’ Filter.Tendsto CoeTC.coe Filter.atBot (nhds a) :=\n\n/-- If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {a b : â„• â†’ Î±},\n  Summable a â†’\n    (Monotone b âˆ¨ Monotone (fun n => -b n)) â†’ Bounded (Set.Range b) â†’ Summable (fun n => a n * b n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : OrderedAddCommMonoid Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  Summable a â†’ Monotone b â†’ BddAbove (Set.range b) â†’\n    Summable (Î» (n : â„•), a n â€¢ b n) ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} [inst : Semiring Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSemiring Î±] {f g : Î¹ â†’ Î±},\n  Summable f â†’\n    (âˆ€ (n m : Î¹), n â‰¤ m â†’ g n â‰¤ g m) â†’ BddBelow (Set.range g) â†’ BddAbove (Set.range g) â†’ Summable (Î» n => f n * g n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedAddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalAddGroup Î±] [inst_3 : OrderClosedTopology Î±]\n  [inst_4 : TopologicalSpace Î²] [inst_5 : LinearOrder Î²] [inst_6 : OrderTopology Î²] [inst_7 : ProperSpace Î²],\n  (âˆ€ {a : â„• â†’ Î±}, Summable a â†’ âˆ€ {b : â„• â†’ Î²}, Monotone b â†’ BddAbove (Set.Range b) â†’ Summable (a * b)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedAddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : OrderedAddCommMonoid Î²] [inst_4 : OrderTopology Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²}, Summable a â†’\n    Monotone b â†’ BddAbove (Set.range b) â†’ âˆƒ l, HasSum (fun n => a n * b n) l ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommSemiring Î±] [inst_1 : OrderedCommSemiring Î²] {a b : â„• â†’ Î±},\n  Summable a â†’\n    Monotone b â†’ (BddAbove (Set.Range b) âˆ¨ BddBelow (Set.Range b)) â†’ Summable (Î» n => a n * b n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommSemiring Î±] [inst_1 : OrderedCommSemiring Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  Summable a â†’\n    (Monotone b âˆ§ BddAbove (Set.Range b) âˆ¨ Monotone (fun n => -b n) âˆ§ BddAbove (Set.Range fun n => -b n)) â†’\n      Summable fun n => a n * b n ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedAddCommMonoid Î±] [inst_1 : OrderedCancelAddCommMonoid Î²] {f g : â„• â†’ Î²} {a : Î±},\n  Summable f â†’\n    Monotone g â†’ BddAbove (Set.Range g) â†’\n      (âˆ€ (n : â„•), f n * g n â‰¤ a) â†’ Summable (fun n => f n * g n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : OrderedCommMonoid Î²]\n  [inst_2 : TopologicalSpace Î±] [inst_3 : TopologicalSpace Î²] [inst_4 : OrderClosedTopology Î±]\n  [inst_5 : OrderClosedTopology Î²] {f : â„• â†’ Î±} {f_sum : Î±} {g : â„• â†’ Î²},\n  HasSum f f_sum â†’ Monotone g â†’ BddAbove (Set.Range g) â†’ HasSum (Î» n, f n * g n) (f_sum * sup (Set.Range g)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst_1 : OrderedAddCommGroup Î±] [inst_2 : TopologicalSpace Î±] [inst_3 : TopologicalAddGroup Î±]\n  [inst_4 : OrderClosedTopology Î±] [inst_5 : OrderedAddCommGroup Î²] [inst_6 : TopologicalSpace Î²] [inst_7 : OrderClosedTopology Î²]\n  {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  Summable a â†’\n  Monotone b â†’ BddAbove (Set.Range b) â†’ BddBelow (Set.Range b) â†’ Summable (Î» n, a n â€¢ b n) "
    ]
  },
  {
    "docString": "Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g\",\n  \"isProp\": true,\n  \"docString\": \"Convergence in Lp implies convergence in measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ dist (u m) (u n) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\\nthe distance between its elements is arbitrarily small \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²]\\n  {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : Set Î³},\\n  UniformCauchySeqOn F Filter.atTop s â†”\\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ dist (F m x) (F n x) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\\neventually, the distance between all its elements is uniformly, arbitrarily small \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries ğ•œ E F),\\n  0 < FormalMultilinearSeries.radius p â†’\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\\n  Metric.Bounded s â†’\\n    âˆ€ {x : â„• â†’ X},\\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\\nevery bounded sequence has a converging subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (n : Î²), n â‰¥ N â†’ dist (u n) (u N) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variation around the pseudometric characterization of Cauchy sequences \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : UniformSpace Î±] [self : CompleteSpace Î±] {f : Filter Î±}, Cauchy f â†’ âˆƒ x, f â‰¤ nhds x\",\n  \"isProp\": true,\n  \"docString\": \"In a complete uniform space, every Cauchy filter converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type v} [inst : NormedField Î²] [inst_1 : CauSeq.IsComplete Î² norm], CompleteSpace Î²\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complete normed field is complete as a metric space, as Cauchy sequences converge by\\nassumption and this suffices to characterize completeness. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†” âˆ€ (Îµ : ENNReal), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), N â‰¤ m â†’ âˆ€ (n : Î²), N â‰¤ n â†’ edist (u m) (u n) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\\nthe pseudoedistance between its elements is arbitrarily small \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  1 â‰¤ p â†’\\n    p â‰  âŠ¤ â†’\\n      (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n        MeasureTheory.Memâ„’p g p â†’\\n          MeasureTheory.UnifIntegrable f p Î¼ â†’\\n            MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\\n              Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\\nconverge in Lp to `g`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {Î¼ : MeasureTheory.Measure Î±},\\n  p â‰  0 â†’\\n    p â‰  âŠ¤ â†’\\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\\nsets and is closed under addition (of functions with disjoint support). \"}]\n",
    "prompt_cons": "/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Convergence in Lp implies convergence in measure. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g :=\n\n/-- In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\nthe distance between its elements is arbitrarily small -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ dist (u m) (u n) < Îµ :=\n\n/-- In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\neventually, the distance between all its elements is uniformly, arbitrarily small -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²]\n  {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : Set Î³},\n  UniformCauchySeqOn F Filter.atTop s â†”\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ dist (F m x) (F n x) < Îµ :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries ğ•œ E F),\n  0 < FormalMultilinearSeries.radius p â†’\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\n  Metric.Bounded s â†’\n    âˆ€ {x : â„• â†’ X},\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a) :=\n\n/-- A variation around the pseudometric characterization of Cauchy sequences -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (n : Î²), n â‰¥ N â†’ dist (u n) (u N) < Îµ :=\n\n/-- In a complete uniform space, every Cauchy filter converges. -/\ntheorem âˆ€ {Î± : Type u} [inst : UniformSpace Î±] [self : CompleteSpace Î±] {f : Filter Î±}, Cauchy f â†’ âˆƒ x, f â‰¤ nhds x :=\n\n/-- A complete normed field is complete as a metric space, as Cauchy sequences converge by\nassumption and this suffices to characterize completeness. -/\ntheorem âˆ€ {Î² : Type v} [inst : NormedField Î²] [inst_1 : CauSeq.IsComplete Î² norm], CompleteSpace Î² :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†” âˆ€ (Îµ : ENNReal), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), N â‰¤ m â†’ âˆ€ (n : Î²), N â‰¤ n â†’ edist (u m) (u n) < Îµ :=\n\n/-- Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\nconverge in Lp to `g`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  1 â‰¤ p â†’\n    p â‰  âŠ¤ â†’\n      (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n        MeasureTheory.Memâ„’p g p â†’\n          MeasureTheory.UnifIntegrable f p Î¼ â†’\n            MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\n              Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0) :=\n\n/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {Î¼ : MeasureTheory.Measure Î±},\n  p â‰  0 â†’\n    p â‰  âŠ¤ â†’\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f :=\n\n/-- Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) "
    ]
  },
  {
    "docString": "Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"One of the most useful consequences of Baire theorem: if a countable union of closed sets\\ncovers the space, then one of the sets has nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {s t : Set Î±},\\n  IsGÎ´ s â†’ IsGÎ´ t â†’ Dense s â†’ Dense t â†’ Dense (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: the intersection of two dense GÎ´ sets is dense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsGÎ´ (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  Metric.Bounded s â†’ IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `â„•`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  IsClosed s â†’ Metric.Bounded s â†’ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, a closed bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- Baire theorem: the intersection of two dense GÎ´ sets is dense. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {s t : Set Î±},\n  IsGÎ´ s â†’ IsGÎ´ t â†’ Dense s â†’ Dense t â†’ Dense (s âˆ© t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s) :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsGÎ´ (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s) :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  Metric.Bounded s â†’ IsCompact (closure s) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `â„•`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) :=\n\n/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  IsClosed s â†’ Metric.Bounded s â†’ IsCompact s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : MetricSpace Î±] [inst_3 : Nonempty Î±]\n  {f : â„• â†’ Set Î±}, (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "forall {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ n, IsOpen (f n)) â†’ (âˆ€ n, Dense (f n)) â†’ Set.Nonempty (â‹‚ n, f n) ",
      "forall {Î± : Type u_2} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Nonempty Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "forall {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Nonempty Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "âˆ€ {Î± : Type u_2} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Nonempty Î±]\n  {f : â„• â†’ Set Î±}, (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î±] [inst_2 : CompleteSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "âˆ€ {Î± : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : CompleteSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "forall {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Nonempty Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±] [inst_3 : MetricSpace Î±]\n  [is_complete : complete_space Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : CompleteSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : MetricSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (s : â„•), IsOpen (f s)) â†’ (âˆ€ (s : â„•), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : â„•), f s) "
    ]
  },
  {
    "docString": "If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„), IsClosed (FunLike.coe '' Metric.closedBall fâ‚€ r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of functions `f : E â†’ F` that represent continuous linear maps `f : E â†’SL[Ïƒâ‚â‚‚] F`\\nat distance `â‰¤ r` from `fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F` is closed in the topology of pointwise convergence.\\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ BoundedContinuousFunction.compContinuous g e = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ IsClosed t â†’ Set.MapsTo f (closure s) t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : C(X, â„)) (e : X â†’ Y), ClosedEmbedding e â†’ âˆƒ g, â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\\ncontinuous real-valued function `g : C(Y, â„)` such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\\n`g.restrict s = f`. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- The set of functions `f : E â†’ F` that represent continuous linear maps `f : E â†’SL[Ïƒâ‚â‚‚] F`\nat distance `â‰¤ r` from `fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F` is closed in the topology of pointwise convergence.\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„), IsClosed (FunLike.coe '' Metric.closedBall fâ‚€ r) :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ UniformContinuous f :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ BoundedContinuousFunction.compContinuous g e = f :=\n\n/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ IsClosed t â†’ Set.MapsTo f (closure s) t :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\ncontinuous real-valued function `g : C(Y, â„)` such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : C(X, â„)) (e : X â†’ Y), ClosedEmbedding e â†’ âˆƒ g, â†‘g âˆ˜ e = â†‘f :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\n`g.restrict s = f`. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f :=\n\n/-- If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$). -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y},\n  Continuous f â†’ âˆ€ {E : Set X}, closure (f '' E) âŠ† f '' closure E ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y]\n  {f : X â†’ Y}, Continuous f â†’ âˆ€ (E : Set X), f '' closure E âŠ† closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X â†’ Y},\n  Continuous f â†’ closure (f '' E) âŠ† f '' closure E ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : PseudoMetricSpace X] [inst_1 : PseudoMetricSpace Y] {f : X â†’ Y},\n  Continuous f â†’ âˆ€ (E : Set X), f '' closure E âŠ† closure (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y]\n  {s : Set X} {f : X â†’ Y}, Continuous f â†’ Set.MapsTo f (closure s) (closure (f '' s)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : PseudoMetricSpace X] [inst_1 : PseudoMetricSpace Y] {f : X â†’ Y}\n  {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y}, Continuous f â†’ âˆ€ {E : Set X}, closure (f '' E) âŠ† f '' closure E ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : MetricSpace Î±] [inst_3 : MetricSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ âˆ€ {E : Set Î±}, Set.MapsTo f (closure E) (closure (f '' E)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : MetricSpace Î±]\n  [inst_3 : MetricSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  Continuous f â†’ IsClosed (closure s) â†’ Set.MapsTo f (closure s) (closure (f '' s)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ IsClosed (closure E) â†’ Set.MapsTo f (closure E) (closure (f '' E)) "
    ]
  },
  {
    "docString": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\\n  [inst_5 : FiniteDimensional â„ F] {f : E â†’ F} {s t : Set E},\\n  ContDiffOn â„ 1 f s â†’ Convex â„ s â†’ t âŠ† s â†’ dimH t < â†‘(FiniteDimensional.finrank â„ F) â†’ Dense (f '' t)á¶œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A particular case of Sard's Theorem. Let `f : E â†’ F` be a map between finite dimensional real\\nvector spaces. Suppose that `f` is `CÂ¹` smooth on a convex set `s` of Hausdorff dimension strictly\\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : C(X, â„)) (e : X â†’ Y), ClosedEmbedding e â†’ âˆƒ g, â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\\ncontinuous real-valued function `g : C(Y, â„)` such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ BoundedContinuousFunction.compContinuous g e = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  [inst_3 : Nonempty X] (f : BoundedContinuousFunction X â„) {e : X â†’ Y},\\n  ClosedEmbedding e â†’ âˆƒ g, (âˆ€ (y : Y), âˆƒ xâ‚ xâ‚‚, â†‘g y âˆˆ Set.Icc (â†‘f xâ‚) (â†‘f xâ‚‚)) âˆ§ â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\\nexists a bounded continuous function `g : Y â†’áµ‡ â„` such that `g âˆ˜ e = f` and each value `g y` belongs\\nto a closed interval `[f xâ‚, f xâ‚‚]` for some `xâ‚` and `xâ‚‚`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two continuous functions to a t2-space that agree on the dense range of a function are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\\n`g.restrict s = f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²] {f : X â†’ Y}\\n  [inst : TopologicalSpace.SecondCountableTopology â†‘(Set.range f)],\\n  Measurable f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable (Set.restrict (Set.range f) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a Borel measurable map from a Polish space to a topological space with second\\ncountable topology, then for any measurable space `Î²` and `g : Y â†’ Î²`, the composition `g âˆ˜ f` is\\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) {e : X â†’ Y}, ClosedEmbedding e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\\nembedding and unbundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : C(X, â„)) {t : Set â„} {e : X â†’ Y} [hs : Set.OrdConnected t],\\n  (âˆ€ (x : X), â†‘f x âˆˆ t) â†’ Set.Nonempty t â†’ ClosedEmbedding e â†’ âˆƒ g, (âˆ€ (y : Y), â†‘g y âˆˆ t) âˆ§ â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Let `t` be a nonempty\\nconvex set of real numbers (we use `OrdConnected` instead of `Convex` to automatically deduce this\\nargument by typeclass search) such that `f x âˆˆ t` for all `x`. Then there exists a continuous\\nreal-valued function `g : C(Y, â„)` such that `g y âˆˆ t` for all `y` and `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"}]\n",
    "prompt_cons": "/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- A particular case of Sard's Theorem. Let `f : E â†’ F` be a map between finite dimensional real\nvector spaces. Suppose that `f` is `CÂ¹` smooth on a convex set `s` of Hausdorff dimension strictly\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. -/\ntheorem âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\n  [inst_5 : FiniteDimensional â„ F] {f : E â†’ F} {s t : Set E},\n  ContDiffOn â„ 1 f s â†’ Convex â„ s â†’ t âŠ† s â†’ dimH t < â†‘(FiniteDimensional.finrank â„ F) â†’ Dense (f '' t)á¶œ :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\ncontinuous real-valued function `g : C(Y, â„)` such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : C(X, â„)) (e : X â†’ Y), ClosedEmbedding e â†’ âˆƒ g, â†‘g âˆ˜ e = â†‘f :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ BoundedContinuousFunction.compContinuous g e = f :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\nexists a bounded continuous function `g : Y â†’áµ‡ â„` such that `g âˆ˜ e = f` and each value `g y` belongs\nto a closed interval `[f xâ‚, f xâ‚‚]` for some `xâ‚` and `xâ‚‚`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  [inst_3 : Nonempty X] (f : BoundedContinuousFunction X â„) {e : X â†’ Y},\n  ClosedEmbedding e â†’ âˆƒ g, (âˆ€ (y : Y), âˆƒ xâ‚ xâ‚‚, â†‘g y âˆˆ Set.Icc (â†‘f xâ‚) (â†‘f xâ‚‚)) âˆ§ â†‘g âˆ˜ e = â†‘f :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\n`g.restrict s = f`. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- If `f : X â†’ Y` is a Borel measurable map from a Polish space to a topological space with second\ncountable topology, then for any measurable space `Î²` and `g : Y â†’ Î²`, the composition `g âˆ˜ f` is\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²] {f : X â†’ Y}\n  [inst : TopologicalSpace.SecondCountableTopology â†‘(Set.range f)],\n  Measurable f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable (Set.restrict (Set.range f) g) :=\n\n/-- If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and unbundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) {e : X â†’ Y}, ClosedEmbedding e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ â†‘g âˆ˜ e = â†‘f :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Let `t` be a nonempty\nconvex set of real numbers (we use `OrdConnected` instead of `Convex` to automatically deduce this\nargument by typeclass search) such that `f x âˆˆ t` for all `x`. Then there exists a continuous\nreal-valued function `g : C(Y, â„)` such that `g y âˆˆ t` for all `y` and `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : C(X, â„)) {t : Set â„} {e : X â†’ Y} [hs : Set.OrdConnected t],\n  (âˆ€ (x : X), â†‘f x âˆˆ t) â†’ Set.Nonempty t â†’ ClosedEmbedding e â†’ âˆƒ g, (âˆ€ (y : Y), â†‘g y âˆˆ t) âˆ§ â†‘g âˆ˜ e = â†‘f :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {E : Set X} {f g : X â†’ Y},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u_2} {Y : Type u_1} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] {f g : X â†’ Y} {s : Set X},\n  Dense s â†’ Dense (f '' s) ",
      "forall {X Y : Type*} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {E : Set X} {f g : X â†’ Y},\n  Dense E â†’ Continuous f â†’ âˆ€ (y : Y), âˆƒ (x : X), f x = y â†’ âˆƒ (e : E), f e = y ",
      "âˆ€ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : EmetricSpace X] [inst_3 : EmetricSpace Y] {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Dense (f '' E) ",
      "forall {X Y : Type*} [topological_space X] [metric_space X] [dense_inducing_pseudoemetric_space X]\n  [topological_space Y] [metric_space Y] [dense_inducing_pseudoemetric_space Y]\n  {f g : X â†’ Y} (hf : continuous f) (hg : continuous g) {E : set X},\n  dense E â†’ dense (f '' E) ",
      "forall {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y] {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ âˆ€ {E : Set X}, Dense E â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ âˆ€ {x : X}, âˆƒ (y : X) (H : y âˆˆ E), f y = g x ",
      "forall {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {E : Set X} {f g : X â†’ Y}, Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "forall {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y]\n[inst_3 : MetricSpace Y] {f g : X â†’ Y} {E : Set X}, Dense E â†’\n  Dense (f '' E) "
    ]
  },
  {
    "docString": "If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\\n            LowerSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\\n            UpperSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\\n`U`, then they are equal on `closure U`. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\\n`g.restrict s = f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n    PartitionOfUnity.IsSubordinate f U â†’\\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\\n`U`, then they are equal on `U`. \"}]\n",
    "prompt_cons": "/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\n            LowerSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\n            UpperSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ :=\n\n/-- If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\n`U`, then they are equal on `closure U`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g (closure U) :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\n`g.restrict s = f`. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n    PartitionOfUnity.IsSubordinate f U â†’\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼ :=\n\n/-- If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\n`U`, then they are equal on `U`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g U :=\n\n/-- If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$. -/\ntheorem",
    "choices": [
      "forall {E : Type u} [inst : TopologicalSpace E] [inst_1 : LinearOrderedAddCommGroup E] [inst_2 : TopologicalSpace â„]\n  [inst_3 : OrderTopology E] [inst_4 : OrderClosedTopology E] {s : Set E} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, Continuous g âˆ§ Set.EqOn g f s ",
      "âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "forall {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {E : Type u} [inst : TopologicalSpace â„] [inst_1 : NormalSpace â„] {s : Set â„} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, Continuous g âˆ§ g =á¶ [restrict (MeasureTheory.Measure.dirac s)] f ",
      "forall {E : Type u} [inst : TopologicalSpace E] [inst_1 : NormalSpace E] {s : Set E} (f : E â†’ â„),\n  IsClosed s â†’ âˆƒ g, Continuous g âˆ§ Set.EqOn f g s ",
      "âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {E : Set â„} (f : C(â†‘E, â„)),\n  IsClosed E â†’ âˆƒ g : C(â„, â„), ContinuousMap.restrict E g = f ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace â„] [inst_1 : NormalSpace â„] {s : Set â„} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f "
    ]
  },
  {
    "docString": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³},\\n  s âŠ† f â»Â¹' e.source â†’ (ContinuousOn f s â†” ContinuousOn (â†‘e âˆ˜ f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E}, DiffContOnCl â„‚ f (Metric.ball c â†‘R) â†’ 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on an open disc of positive radius and is continuous\\non its closure, then it is analytic on the open disc with coefficients of the power series given by\\nCauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„}, Measurable f â†’ MeasurableSet {p | p.snd = f p.fst}\",\n  \"isProp\": true,\n  \"docString\": \"The graph of a measurable function is a measurable set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` continuous on a compact set `K` is integrable on this set with respect to any\\nlocally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : TopologicalSpace.MetrizableSpace X],\\n  Continuous f â†’ HasCompactSupport f â†’ MeasureTheory.Integrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function with compact support is integrable on the whole space. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, Continuous â†‘f.linear â†” Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is continuous iff `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] {s : Set Î²},\\n  IsCompact s â†’ Set.Nonempty s â†’ âˆ€ {f : Î² â†’ Î±}, ContinuousOn f s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **extreme value theorem**: a continuous function realizes its minimum on a compact set. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s)) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³},\n  s âŠ† f â»Â¹' e.source â†’ (ContinuousOn f s â†” ContinuousOn (â†‘e âˆ˜ f) s) :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E}, DiffContOnCl â„‚ f (Metric.ball c â†‘R) â†’ 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- The graph of a measurable function is a measurable set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„}, Measurable f â†’ MeasurableSet {p | p.snd = f p.fst} :=\n\n/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any\nlocally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z :=\n\n/-- A continuous function with compact support is integrable on the whole space. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : TopologicalSpace.MetrizableSpace X],\n  Continuous f â†’ HasCompactSupport f â†’ MeasureTheory.Integrable f :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- If `f` is an affine map, then its linear part is continuous iff `f` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, Continuous â†‘f.linear â†” Continuous â†‘f :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- The **extreme value theorem**: a continuous function realizes its minimum on a compact set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {s : Set Î²},\n  IsCompact s â†’ Set.Nonempty s â†’ âˆ€ {f : Î² â†’ Î±}, ContinuousOn f s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y :=\n\n/-- If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {E : Set Î²} {f : Î² â†’ Î±},\n  IsCompact E â†’ (IsCompact (Function.Graph f E) â†” ContinuousOn f E) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î±]\n  [inst_3 : OrderClosedTopology Î±] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’\n    (ContinuousOn f E â†” IsCompact (Set.Graph f E)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (IsCompact (SetOf (Î» p, p.1 âˆˆ E âˆ§ p.2 = f p.1)) â†” ContinuousOn f E) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (IsCompact (Set.Graph f E) â†” ContinuousOn f E) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (IsCompact (SetOf (Î» p, p.snd = f p.fst)) â†” ContinuousOn f E) ",
      "forall {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  {f : Î± â†’ Î²}, Continuous f â†” IsCompact (Set.Graph f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±}\n  {f : Î± â†’ Î²},\n  IsCompact E â†’ (ContinuousOn f E â†” IsCompact (Function.Graph f E)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  {E : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f E â†” IsCompact (SetOf (Î» p : Î± Ã— Î², p.snd = f p.fst)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î±]\n  [inst_3 : OrderClosedTopology Î±] {E : Set Î²} {f : Î² â†’ Î±},\n  IsCompact E â†’ (ContinuousOn f E â†” IsCompact (SetOf (Prod.mk <$> E <*> f))) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (IsCompact (Set.Graph f E) â†” ContinuousOn f E) "
    ]
  },
  {
    "docString": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst : NormedSpace ğ•œ E] [inst : Nontrivial E] (c : â„), âˆƒ x, c < â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a nontrivial normed space over a nontrivially normed field `ğ•œ`, then `E` is unbounded:\\nfor any `c : â„`, there exists a vector `x : E` with norm strictly greater than `c`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  x âˆˆ s â†’\\n    (âˆ€ (u : Set (Î² Ã— Î²)),\\n        u âˆˆ uniformity Î² â†’\\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {K : NNReal} {f : Î± â†’ Î²},\\n  LipschitzWith K f â†’ UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"A Lipschitz function is uniformly continuous \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If `E` is a nontrivial normed space over a nontrivially normed field `ğ•œ`, then `E` is unbounded:\nfor any `c : â„`, there exists a vector `x : E` with norm strictly greater than `c`. -/\ntheorem âˆ€ (ğ•œ : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst : NormedSpace ğ•œ E] [inst : Nontrivial E] (c : â„), âˆƒ x, c < â€–xâ€– :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  x âˆˆ s â†’\n    (âˆ€ (u : Set (Î² Ã— Î²)),\n        u âˆˆ uniformity Î² â†’\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n      ContinuousWithinAt f s x :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {K : NNReal} {f : Î± â†’ Î²},\n  LipschitzWith K f â†’ UniformContinuous f :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : UniformSpace â„], Metric.Bounded E â†’ âˆƒ f : â„ â†’ â„, UniformContinuous f âˆ§ Â¬ BddAbove (f '' E) ",
      "âˆ€ {E : Set â„}, BddAbove E â†’ BddBelow E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬BddAbove (f '' E) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬ BddAbove (f '' E) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±] [inst_4 : Bounded Î±],\n  âˆƒ (f : Î± â†’ â„), UniformContinuous f âˆ§ Â¬BddAbove (f '' Set.Univ) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : UniformSpace â„], Metric.Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬BddAbove (f '' E) ",
      "âˆ€ {E : Set â„}, Metric.Bounded E â†’ âˆƒ f : â„ â†’ â„, UniformContinuous f âˆ§ Â¬BddAbove (f '' E) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ (âˆ€ (x : â„), x âˆˆ E â†’ Â¬BddAbove (f '' E)) ",
      "âˆ€ (E : Set â„), Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬Bounded (f '' E) ",
      "âˆ€ {E : set â„} [inst : UniformSpace â„], Metric.Bounded E â†’ âˆƒf : â„ â†’ â„, UniformContinuous f âˆ§ Â¬ Bounded (f '' E) ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : UniformSpace â„],\n  Metric.Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬Metric.Bounded (f '' E) "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformlyOn F f p s â†’\\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  x âˆˆ s â†’\\n    (âˆ€ (u : Set (Î² Ã— Î²)),\\n        u âˆˆ uniformity Î² â†’\\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {A : Set (Î² â†’ Î±)},\\n  Set.UniformEquicontinuous A â†’ Set.UniformEquicontinuous (closure A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of functions is uniformly equicontinuous, its closure for the product topology is also\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousAt f x :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformlyOn F f p s â†’\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  x âˆˆ s â†’\n    (âˆ€ (u : Set (Î² Ã— Î²)),\n        u âˆˆ uniformity Î² â†’\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n      ContinuousWithinAt f s x :=\n\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {A : Set (Î² â†’ Î±)},\n  Set.UniformEquicontinuous A â†’ Set.UniformEquicontinuous (closure A) :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ Equicontinuous F :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (g : Î³ â†’ Î²) (f : Î± â†’ Î³), UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f) ",
      "forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î² â†’ Î³}\n  {g : Î± â†’ Î²},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3}\n  [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "
    ]
  },
  {
    "docString": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„},\\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` takes either its maximum\\nor its minimum value at a point in the interior of the interval. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\\n  [inst_6 : OrderClosedTopology Î´] {a b : Î±} {f : Î± â†’ Î´},\\n  ContinuousOn f (Set.uIcc a b) â†’ Set.uIcc (f a) (f b) âŠ† f '' Set.uIcc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\\nof the interval, then its integral over `a..b` is strictly positive. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\\ncontinuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\\nfrom the left.\\n\\nThe assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the\\nfunction `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\\n`a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\\n  [inst_6 : OrderClosedTopology Î´] {a b : Î±},\\n  a â‰¤ b â†’ âˆ€ {f : Î± â†’ Î´}, ContinuousOn f (Set.Icc a b) â†’ Set.Icc (f b) (f a) âŠ† f '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate Value Theorem** for continuous functions on closed intervals, case\\n`f a â‰¥ t â‰¥ f b`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\\n  [inst_6 : OrderClosedTopology Î´] {a b : Î±},\\n  a â‰¤ b â†’ âˆ€ {f : Î± â†’ Î´}, ContinuousOn f (Set.Icc a b) â†’ Set.Icc (f a) (f b) âŠ† f '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate Value Theorem** for continuous functions on closed intervals, case\\n`f a â‰¤ t â‰¤ f b`.\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’\\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) c b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\\nfinite limit `c` almost surely at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `c` at `b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Ici a) â†’\\n      (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousWithinAt f (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function strictly monotone on a right neighborhood of `a` and the\\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\\ncontinuous at `a` from the right.\\n\\nThe assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the\\nfunction `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at\\n`a = 0`. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„},\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/\ntheorem âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\n  [inst_6 : OrderClosedTopology Î´] {a b : Î±} {f : Î± â†’ Î´},\n  ContinuousOn f (Set.uIcc a b) â†’ Set.uIcc (f a) (f b) âŠ† f '' Set.uIcc a b :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\ncontinuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\nfrom the left.\n\nThe assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the\nfunction `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\n`a = 0`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a :=\n\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a â‰¥ t â‰¥ f b`. -/\ntheorem âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\n  [inst_6 : OrderClosedTopology Î´] {a b : Î±},\n  a â‰¤ b â†’ âˆ€ {f : Î± â†’ Î´}, ContinuousOn f (Set.Icc a b) â†’ Set.Icc (f b) (f a) âŠ† f '' Set.Icc a b :=\n\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a â‰¤ t â‰¤ f b`. -/\ntheorem âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\n  [inst_6 : OrderClosedTopology Î´] {a b : Î±},\n  a â‰¤ b â†’ âˆ€ {f : Î± â†’ Î´}, ContinuousOn f (Set.Icc a b) â†’ Set.Icc (f a) (f b) âŠ† f '' Set.Icc a b :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\nfinite limit `c` almost surely at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `c` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) c b :=\n\n/-- If `f` is a function strictly monotone on a right neighborhood of `a` and the\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\ncontinuous at `a` from the right.\n\nThe assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the\nfunction `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at\n`a = 0`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Ici a) â†’\n      (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousWithinAt f (Set.Ici a) a :=\n\n/-- Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (a b : â„) (y : â„), a â‰¤ b â†’ f a â‰¤ y â†’ y â‰¤ f b â†’ âˆƒ (x : â„), x âˆˆ Set.Icc a b âˆ§ f x = y) â†’\n  (âˆ€ (r : â„š), IsClosed (f â»Â¹' {r})) â†’ Continuous f ",
      "forall {f : â„ â†’ â„},\n  (forall a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (forall q : â„š, IsClosed (f â»Â¹' {â†‘q})) â†’ Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ {a b : â„} {c : â„}, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ (r : â„š), IsClosed (f â»Â¹' {â†‘r})) â†’ Continuous f ",
      "forall {f : â„ â†’ â„},\n  (âˆ€ (a b : â„) (c : â„), f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ (r : â„), âˆƒ q : â„š, r = â†‘q â†’ IsClosed (f â»Â¹' {r})) â†’ Continuous f ",
      "forall {f : â„ â†’ â„},\n  (forall a b c, a < b -> f a < c -> c < f b -> âˆƒ x, a â‰¤ x âˆ§ x â‰¤ b âˆ§ f x = c) ->\n  (forall r : â„š, is_closed (f â»Â¹' {r})) ->\n  continuous f ",
      "forall {f : â„ â†’ â„} (hivp : âˆ€ a b c : â„, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x âˆˆ Set.Ioo a b, f x = c)\n  (hrc : âˆ€ r : â„š, IsClosed (f â»Â¹' {r})), Continuous f ",
      "forall {Î± : Type} [linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±]\n  {f : Î± â†’ â„}, (âˆ€ {a b : Î±}, a < b â†’ Set.Ioo (f a) (f b) âŠ† f '' Set.Ioo a b) â†’\n    (âˆ€ q : â„š, is_closed (f â»Â¹' {q})) â†’ continuous f ",
      "forall {f : â„ â†’ â„},\n  (âˆ€ {a b : â„}, a â‰¤ b â†’ âˆ€ (y : â„), f a â‰¤ y â†’ y â‰¤ f b â†’ âˆƒ x, x âˆˆ Set.Icc a b âˆ§ f x = y) â†’\n    (âˆ€ (q : â„š), IsClosed (f â»Â¹' {â†‘q})) â†’ Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (a b : â„) (c : â„), a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, x âˆˆ Set.Ioo a b âˆ§ f x = c) â†’\n    (âˆ€ (r : â„š), IsClosed (f â»Â¹' {â†‘r})) â†’ Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ (a b : â„) (hâ‚ : f a < f b) (c : â„), f a < c â†’ c < f b â†’ âˆƒ x, a â‰¤ x âˆ§ x â‰¤ b âˆ§ f x = c) â†’\n  (âˆ€ (r : â„š), IsClosed (f â»Â¹' {r})) â†’ Continuous f "
    ]
  },
  {
    "docString": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\\n      ConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\\nverify the inequality `a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`. The\\nmain use case is `E = â„` however one can apply it, e.g., to `â„^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) â†’\\n      StrictConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\\nto verify the inequality `a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Monotone (deriv f) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `â„` then `f` is convex. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y) â†’\\n      StrictConvexOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\\nto verify the inequality `f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\\n      ConvexOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\\nverify the inequality `f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y` only for `x < y` and positive `a`,\\n`b`. The main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},\\n  ConvexOn ğ•œ s (-f) â†” ConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\": \"A function `-f` is convex iff `f` is concave. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  ConvexOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is convex iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\\nthen `f` is convex on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `â„`, and `f''` is strictly positive on `â„`,\\nthen `f` is strictly convex on `â„`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly positive, except at at most one point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\\n  {a b : â„},\\n  a â‰¤ b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\\n`âˆ« y in a..b, f' y` equals `f b - f a`. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„},\\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` takes either its maximum\\nor its minimum value at a point in the interior of the interval. \"}]\n",
    "prompt_cons": "/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\nverify the inequality `a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`. The\nmain use case is `E = â„` however one can apply it, e.g., to `â„^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\n      ConcaveOn ğ•œ s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\nto verify the inequality `a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) â†’\n      StrictConcaveOn ğ•œ s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `â„` then `f` is convex. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Monotone (deriv f) â†’ ConvexOn â„ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ f y - f x < C * (y - x) :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\nto verify the inequality `f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y) â†’\n      StrictConvexOn ğ•œ s f :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\nverify the inequality `f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y` only for `x < y` and positive `a`,\n`b`. The main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A function `-f` is convex iff `f` is concave. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},\n  ConvexOn ğ•œ s (-f) â†” ConcaveOn ğ•œ s f :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is convex iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  ConvexOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y) :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\nthen `f` is convex on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- If a function `f` is continuous on `â„`, and `f''` is strictly positive on `â„`,\nthen `f` is strictly convex on `â„`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly positive, except at at most one point. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\n`âˆ« y in a..b, f' y` equals `f b - f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\n  {a b : â„},\n  a â‰¤ b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a :=\n\n/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„},\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c :=\n\n/-- Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex. -/\ntheorem",
    "choices": [
      "âˆ€ {s : Set â„} {f : â„ â†’ â„},\n  Convex â„ s â†’\n    (âˆ€ â¦ƒx y : â„â¦„,\n        x âˆˆ s â†’\n          y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : â„â¦„, 0 < a â†’ 0 < b â†’ a + b = 2 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn â„ s f ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\nConvex ğ•œ s â†’\n  (âˆ€ â¦ƒx y : Eâ¦„,\n      x âˆˆ s â†’\n        y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f ((a / 2) â€¢ x + (b / 2) â€¢ y) â‰¤ (f x + f y) / 2) â†’\n    ConvexOn ğ•œ s f ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\n      ConcaveOn ğ•œ s f ",
      "forall {f : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Ioo a b) â†’\n      (âˆ€ x y : â„, x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n        ConvexOn â„ (Set.Ioo a b) f ",
      "âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  (âˆ€ â¦ƒx y : ğ•œâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’ ConvexOn ğ•œ s f ",
      "âˆ€ {ğ•œ : Type u_1} [inst : OrderedSemiring ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx y : ğ•œâ¦„,\n        x âˆˆ s â†’\n          y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x â‰  y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Ioo a b) â†’\n      (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n        ConvexOn â„ (Set.Ioo a b) f ",
      "âˆ€ {s : Set â„} {f : â„ â†’ â„},\n  Convex â„ s â†’\n    (âˆ€ â¦ƒx y : â„â¦„,\n        x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : â„â¦„, 0 < a â†’ 0 < b â†’ a + b = 2 â†’ f ((a â€¢ x + b â€¢ y) / 2) â‰¤ (a â€¢ f x + b â€¢ f y) / 2) â†’\n      ConvexOn â„ s f ",
      "âˆ€ {s : Set â„} {f : â„ â†’ â„},\n  Convex â„ s â†’\n    (âˆ€ â¦ƒx y : â„â¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : â„â¦„, 0 < a â†’ 0 < b â†’ a + b = 2 â†’ a â€¢ f x + b â€¢ f y â‰¥ f (a â€¢ x + b â€¢ y)) â†’\n      ConvexOn â„ s f "
    ]
  },
  {
    "docString": "Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x â‰¤ B' x` on `[a, b)`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\\n  ContinuousAt g a â†’\\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\\nin the strict sense.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\\ninverse function. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\\n  ContinuousAt g a â†’\\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\\nof the interval, then its integral over `a..b` is strictly positive. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\\n  {f f' : â„ â†’ â„} {g : â„ â†’ E},\\n  ContinuousOn f (Set.uIcc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo (min a b) (max a b) â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) â†’\\n      ContinuousOn g (f '' Set.Ioo (min a b) (max a b)) â†’\\n        MeasureTheory.IntegrableOn g (f '' Set.uIcc a b) â†’\\n          MeasureTheory.IntegrableOn (fun x => f' x â€¢ (g âˆ˜ f) x) (Set.uIcc a b) â†’\\n            âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u\",\n  \"isProp\": true,\n  \"docString\":\n  \"Change of variables, general form. If `f` is continuous on `[a, b]` and has\\nright-derivative `f'` in `(a, b)`, `g` is continuous on `f '' (a, b)` and integrable on\\n`f '' [a, b]`, and `f' x â€¢ (g âˆ˜ f) x` is integrable on `[a, b]`,\\nthen we can substitute `u = f x` to get `âˆ« x in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« u in f a..f b, g u`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    âˆ€ {B B' : â„ â†’ â„},\\n      f a â‰¤ B a â†’\\n        ContinuousOn B (Set.Icc a b) â†’\\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n            (âˆ€ (x : â„),\\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by `B'`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  0 < b â†’\\n    ContinuousOn f (Set.Ici a) â†’ (f =O[Filter.atTop] fun x => rexp (-b * x)) â†’ MeasureTheory.IntegrableOn f (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is continuous on `[a, âˆ)`, and is `O (exp (-b * x))` at `âˆ` for some `b > 0`, then\\n`f` is integrable on `(a, âˆ)`. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\\n  a â‰¤ b â†’\\n    IntervalIntegrable f Î¼ a b â†’\\n      IntervalIntegrable g Î¼ a b â†’\\n        f â‰¤á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b))] g â†’\\n          â†‘â†‘(MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b)) {x | f x < g x} â‰  0 â†’\\n            âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are two functions that are interval integrable on `a..b`, `a â‰¤ b`,\\n`f x â‰¤ g x` for a.e. `x âˆˆ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\\nof nonzero measure, then `âˆ« x in a..b, f x âˆ‚Î¼ < âˆ« x in a..b, g x âˆ‚Î¼`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’ ContinuousAt f b â†’ HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) (f b) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\\ncontinuous at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `f b` at `b`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {E : Type u_1} [inst : NormedAddCommGroup E] {f : â„ â†’ E} {f' : â„ â†’ â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„),\\n        x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope (norm âˆ˜ f) x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        â€–f aâ€– â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f xâ€– = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `â€–f aâ€– â‰¤ B a`;\\n* `B` has right derivative at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(â€–f zâ€– - â€–f xâ€–) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `â€–f xâ€– = B x`.\\n\\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\": \"âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), 0 < deriv f x) â†’ StrictMono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is positive, then\\n`f` is a strictly monotone function.\\nNote that we don't require differentiability explicitly as it already implied by the derivative\\nbeing strictly positive. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\\n        ContinuousWithinAt f t b â†’\\n          autoParam (UniqueDiffWithinAt â„ s b) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in a..u, f x) s b = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` is continuous\\non the right or on the left at `b`, then the right (resp., left) derivative of\\n`u â†¦ âˆ« x in a..u, f x` at `b` equals `f b`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\\n  {a b : â„},\\n  a â‰¤ b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\\n`âˆ« y in a..b, f' y` equals `f b - f a`. \"}]\n",
    "prompt_cons": "/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x â‰¤ B' x` on `[a, b)`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\n  ContinuousAt g a â†’\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\n  ContinuousAt g a â†’\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x :=\n\n/-- Change of variables, general form. If `f` is continuous on `[a, b]` and has\nright-derivative `f'` in `(a, b)`, `g` is continuous on `f '' (a, b)` and integrable on\n`f '' [a, b]`, and `f' x â€¢ (g âˆ˜ f) x` is integrable on `[a, b]`,\nthen we can substitute `u = f x` to get `âˆ« x in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« u in f a..f b, g u`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\n  {f f' : â„ â†’ â„} {g : â„ â†’ E},\n  ContinuousOn f (Set.uIcc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo (min a b) (max a b) â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) â†’\n      ContinuousOn g (f '' Set.Ioo (min a b) (max a b)) â†’\n        MeasureTheory.IntegrableOn g (f '' Set.uIcc a b) â†’\n          MeasureTheory.IntegrableOn (fun x => f' x â€¢ (g âˆ˜ f) x) (Set.uIcc a b) â†’\n            âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by `B'`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    âˆ€ {B B' : â„ â†’ â„},\n      f a â‰¤ B a â†’\n        ContinuousOn B (Set.Icc a b) â†’\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n            (âˆ€ (x : â„),\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f` is continuous on `[a, âˆ)`, and is `O (exp (-b * x))` at `âˆ` for some `b > 0`, then\n`f` is integrable on `(a, âˆ)`. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  0 < b â†’\n    ContinuousOn f (Set.Ici a) â†’ (f =O[Filter.atTop] fun x => rexp (-b * x)) â†’ MeasureTheory.IntegrableOn f (Set.Ioi a) :=\n\n/-- If `f` and `g` are two functions that are interval integrable on `a..b`, `a â‰¤ b`,\n`f x â‰¤ g x` for a.e. `x âˆˆ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `âˆ« x in a..b, f x âˆ‚Î¼ < âˆ« x in a..b, g x âˆ‚Î¼`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\n  a â‰¤ b â†’\n    IntervalIntegrable f Î¼ a b â†’\n      IntervalIntegrable g Î¼ a b â†’\n        f â‰¤á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b))] g â†’\n          â†‘â†‘(MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b)) {x | f x < g x} â‰  0 â†’\n            âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼ :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\ncontinuous at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `f b` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’ ContinuousAt f b â†’ HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) (f b) b :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `â€–f aâ€– â‰¤ B a`;\n* `B` has right derivative at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(â€–f zâ€– - â€–f xâ€–) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `â€–f xâ€– = B x`.\n\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {a b : â„} {E : Type u_1} [inst : NormedAddCommGroup E] {f : â„ â†’ E} {f' : â„ â†’ â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„),\n        x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope (norm âˆ˜ f) x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        â€–f aâ€– â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f xâ€– = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is positive, then\n`f` is a strictly monotone function.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. -/\ntheorem âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), 0 < deriv f x) â†’ StrictMono f :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` is continuous\non the right or on the left at `b`, then the right (resp., left) derivative of\n`u â†¦ âˆ« x in a..u, f x` at `b` equals `f b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\n        ContinuousWithinAt f t b â†’\n          autoParam (UniqueDiffWithinAt â„ s b) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in a..u, f x) s b = f b :=\n\n/-- Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\n`âˆ« y in a..b, f' y` equals `f b - f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\n  {a b : â„},\n  a â‰¤ b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a :=\n\n/-- Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$. -/\ntheorem",
    "choices": [
      "forall {f : â„ â†’ â„} {a b : â„}, a < b â†’\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (deriv f x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n        let g ",
      "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’ StrictMono f ",
      "forall {f : â„ â†’ â„} {a b : â„},\n  (a < b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n      (âˆƒ g, StrictMono g âˆ§ âˆ€ y, a < y âˆ§ y < b â†’ g (f y) = y) ",
      "forall {f : â„ â†’ â„} {a b : â„},\n  (a < b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n      StrictMono f âˆ§ âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’\n        âˆƒ g, (âˆ€á¶  (y : â„) in nhds x, f (g y) = y) âˆ§\n          ContinuousAt g (f x) âˆ§ HasDerivAt g (1 / deriv f x) (f x) ",
      "forall {f : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      âˆ€ {f' : â„ â†’ â„},\n        (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n          (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n            let g ",
      "forall {f : â„ â†’ â„}, (âˆ€ (x : â„), a < x â†’ x < b â†’ 0 < deriv f x) â†’\n  (StrictMonoOn f (Set.Ioo a b) âˆ§\n    âˆ€ {g : â„ â†’ â„}, (âˆ€ (x : â„), a < x â†’ x < b â†’ g (f x) = x) â†’\n      âˆ€ (x : â„), a < x â†’ x < b â†’\n        deriv g (f x) = deriv f xâ»Â¹) ",
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n      strict_mono_on f (Set.Ioo a b) âˆ§\n        âˆ€ (x : â„),\n          x âˆˆ Set.Ioo a b â†’\n            âˆƒ (g' : â„), HasDerivAt (inverse (Set.restrict f (Set.Ioo a b))) g' (f x) âˆ§ g' = (f' x)â»Â¹ ",
      "âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n  let g ",
      "forall {f : â„ â†’ â„}, (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n  (strict_mono_on f (Set.Ioo a b) âˆ§\n   âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’\n     âˆ€ (g : â„ â†’ â„), (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ g (f y) = y) â†’\n       has_deriv_at g (1 / (deriv f (g x))) x) ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n    StrictMono f â†’\n      let g "
    ]
  },
  {
    "docString": "If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\\nvaries over the `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„š),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complex `n`-th roots of unity are exactly the\\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.cyclotomic' n K =\\n        (Polynomial.X ^ n - 1) /â‚˜ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`cyclotomic' n K = (X ^ k - 1) /â‚˜ (âˆ i in Nat.properDivisors k, cyclotomic' i K)`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  IsPrimitiveRoot Î¶ n â†’\\n    âˆƒ P,\\n      Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' n K âˆ§\\n        Polynomial.degree P = Polynomial.degree (Polynomial.cyclotomic' n K) âˆ§ Polynomial.Monic P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\\nmonic polynomial with integer coefficients. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] {n : â„•}, 1 < n â†’ Polynomial.coeff (Polynomial.cyclotomic n R) 0 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The constant term of `cyclotomic n R` is `1` if `2 â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] [inst_2 : CharZero K] {Î¶ : K} {n : â„•+},\\n  IsPrimitiveRoot Î¶ â†‘n â†’ âˆƒ! P, Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' (â†‘n) K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\\n    1 â‰¤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  IsPrimitiveRoot Î¶ n â†’\\n    Polynomial.cyclotomic n K = Finset.prod (primitiveRoots n K) fun Î¼ => Polynomial.X - â†‘Polynomial.C Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`cyclotomic n K = âˆ Î¼ in primitiveRoots n K, (X - C Î¼)`. In particular,\\n`cyclotomic n K = cyclotomic' n K` \"}]\n",
    "prompt_cons": "/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\nvaries over the `n`-th roots of unity. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶ :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1 :=\n\n/-- For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem âˆ€ (p : Polynomial â„š),\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\n      Finset.card\n        (Equiv.Perm.support\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe)))) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1 :=\n\n/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. -/\ntheorem âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /â‚˜ (âˆ i in Nat.properDivisors k, cyclotomic' i K)`. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.cyclotomic' n K =\n        (Polynomial.X ^ n - 1) /â‚˜ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K :=\n\n/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\nmonic polynomial with integer coefficients. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  IsPrimitiveRoot Î¶ n â†’\n    âˆƒ P,\n      Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' n K âˆ§\n        Polynomial.degree P = Polynomial.degree (Polynomial.cyclotomic' n K) âˆ§ Polynomial.Monic P :=\n\n/-- The constant term of `cyclotomic n R` is `1` if `2 â‰¤ n`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] {n : â„•}, 1 < n â†’ Polynomial.coeff (Polynomial.cyclotomic n R) 0 = 1 :=\n\n/-- If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] [inst_2 : CharZero K] {Î¶ : K} {n : â„•+},\n  IsPrimitiveRoot Î¶ â†‘n â†’ âˆƒ! P, Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' (â†‘n) K :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\n    1 â‰¤ b :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1 :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic n K = âˆ Î¼ in primitiveRoots n K, (X - C Î¼)`. In particular,\n`cyclotomic n K = cyclotomic' n K` -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  IsPrimitiveRoot Î¶ n â†’\n    Polynomial.cyclotomic n K = Finset.prod (primitiveRoots n K) fun Î¼ => Polynomial.X - â†‘Polynomial.C Î¼ :=\n\n/-- If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1. -/\ntheorem",
    "choices": [
      "âˆ€ (C : â„• â†’ â„),\n  (âˆ‘ (n : â„•) in Finset.range (Nat.succ n), C n / (â†‘n + 1)) = 0 â†’\n    âˆƒ xâ‚€ : â„, xâ‚€ âˆˆ Set.Ioo 0 1 âˆ§ Polynomial.eval xâ‚€ (Finset.sum (Finset.range (Nat.succ n)) fun i => C i â€¢ Polynomial.X ^ i) = 0 ",
      "âˆ€ (C : Finâ‚“ (n + 1) â†’ â„),\n  (âˆ‘ i : Finâ‚“ (n + 1), C i * (â†‘i / (â†‘i + 1))) = 0 â†’\n    âˆƒ x, 0 < x âˆ§ x < 1 âˆ§ (âˆ‘ i : Finâ‚“ (n + 1), C i * x ^ â†‘i) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ i in Finset.range (n + 1), C i / (i + 1)) = 0 â†’\n    âˆƒ x âˆˆ Set.Icc (0 : â„) 1, (Finset.sum (Finset.range (n + 1)) fun i => C i * x ^ i) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ i in Finset.range (n + 2), C i / (i + 1)) = 0 â†’\n    âˆƒ xâ‚€, 0 < xâ‚€ âˆ§ xâ‚€ < 1 âˆ§ Polynomial.eval xâ‚€ (Finset.sum (Finset.range (n + 1)) fun i => Polynomial.C (C i) * Polynomial.X ^ i) = 0 ",
      "âˆ€ (C : â„• â†’ â„),\n  (âˆ‘ (i : â„•) in Finset.range (n + 1), C i / (â†‘i + 1)) = 0 â†’\n  âˆƒ x, ((0 : â„) < x âˆ§ x < 1) âˆ§ âˆ‘ (i : â„•) in Finset.range (n + 1), C i * x ^ i = 0 ",
      "âˆ€ (C : â„• â†’ â„),\n  (âˆ‘ (i : â„•) in Finset.range (Nat.succ (Nat.succ 0)), C i / (i + 1)) = 0 â†’\n    âˆƒ x, 0 < x âˆ§ x < 1 âˆ§ (âˆ‘ (i : â„•) in Finset.range (Nat.succ (Nat.succ 0)), C i * x ^ i) = 0 ",
      "âˆƒ (xâ‚€ : â„) (hxâ‚€ : 0 â‰¤ xâ‚€ âˆ§ xâ‚€ â‰¤ 1),\n  âˆ€ {C : â„• â†’ â„},\n    (âˆ€ n : â„•, C n = 0) â†’\n      âˆ‘ n in Finset.range (Nat.succ n), C n * (xâ‚€ ^ n) / (â†‘n + 1) = 0 â†’ (âˆ‘ n in Finset.range (Nat.succ n), C n * xâ‚€ ^ n) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ i in Finset.range (n + 1), C i / (i + 1)) = 0 â†’\n  âˆƒ x âˆˆ set.Icc (0 : â„) 1, (Finset.sum (Finset.range (n + 1)) fun i => C i * x ^ i) = 0 ",
      "âˆ€ (C : â„• â†’ â„),\n  (âˆ‘ i in Finset.range (n + 1), C i / (â†‘i + 1)) = 0 â†’\n  âˆƒ x : â„, 0 < x âˆ§ x < 1 âˆ§ (Finset.sum (Finset.range (n + 1)) fun i => C i * x ^ i) = 0 ",
      "âˆ€ (C : â„• â†’ â„),\n  (âˆ‘ (n : â„•) in Finset.range (Nat.succ (Finset.card (Multiset.toFinset (Polynomial.roots (Polynomial.of_finsupp C))))), C n / (â†‘n + 1)) = 0 â†’\n    âˆƒ (x : â„) (H : 0 < x âˆ§ x < 1), Polynomial.eval x (Polynomial.of_finsupp C) = 0 "
    ]
  },
  {
    "docString": "Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\\n  (âˆ€ (Z : C) (g : Z âŸ¶ X), CategoryTheory.CategoryStruct.comp g f = 0 â†’ g = 0) â†’ CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g â‰« f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv f x) â†’ MonotoneOn f D\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\\n`f` is a monotone function on `D`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\\n  (âˆ€ (Z : C) (g : Y âŸ¶ Z), CategoryTheory.CategoryStruct.comp f g = 0 â†’ g = 0) â†’ CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f â‰« g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\\n  ContinuousAt g a â†’\\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {Î² : Type u_1} [inst_1 : Preorder Î²] {f g : Î± â†’ Î²},\\n  Monotone f â†’ Antitone g â†’ f â‰¤ g â†’ âˆ€ (m n : Î±), f m â‰¤ g n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is monotone, `g` is antitone, and `f â‰¤ g`, then for all `a`, `b` we have `f a â‰¤ g b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\\n  ContinuousAt g a â†’\\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\\nin the strict sense.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\\ninverse function. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’ âˆ€ {f : â„ â†’ â„}, ContinuousOn f D â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 < deriv f x) â†’ StrictMonoOn f D\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is positive, then\\n`f` is a strictly monotone function on `D`.\\nNote that we don't require differentiability explicitly as it already implied by the derivative\\nbeing strictly positive. \"}]\n",
    "prompt_cons": "/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `g â‰« f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\n  (âˆ€ (Z : C) (g : Z âŸ¶ X), CategoryTheory.CategoryStruct.comp g f = 0 â†’ g = 0) â†’ CategoryTheory.Mono f :=\n\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\n`f` is a monotone function on `D`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv f x) â†’ MonotoneOn f D :=\n\n/-- If `f â‰« g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\n  (âˆ€ (Z : C) (g : Y âŸ¶ Z), CategoryTheory.CategoryStruct.comp f g = 0 â†’ g = 0) â†’ CategoryTheory.Epi f :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\n  ContinuousAt g a â†’\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- If `f` is monotone, `g` is antitone, and `f â‰¤ g`, then for all `a`, `b` we have `f a â‰¤ g b`. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {Î² : Type u_1} [inst_1 : Preorder Î²] {f g : Î± â†’ Î²},\n  Monotone f â†’ Antitone g â†’ f â‰¤ g â†’ âˆ€ (m n : Î±), f m â‰¤ g n :=\n\n/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼ :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\n  ContinuousAt g a â†’\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is positive, then\n`f` is a strictly monotone function on `D`.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’ âˆ€ {f : â„ â†’ â„}, ContinuousOn f D â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 < deriv f x) â†’ StrictMonoOn f D :=\n\n/-- Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing. -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n  DifferentiableOn â„ f (Set.Ioi 0) â†’\n  f 0 = 0 â†’\n  Monotone (deriv f) â†’\n  Monotone (Î» x, f x / x) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n  DifferentiableOn â„ f (Set.Ioi 0) â†’\n  f 0 = 0 â†’\n  MonotoneOn (deriv f) (Set.Ioi 0) â†’\n  âˆ€ x y : â„,\n    x âˆˆ Set.Ioi 0 â†’ y âˆˆ Set.Ioi 0 â†’ x < y â†’ (f x) / x < (f y) / y ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’ MonotoneOn (Î» x, f x / x) (Set.Ioi 0) ",
      "forall {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        Monotone (deriv f) â†’\n          StrictMonoOn (fun x => f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          âˆ€ (x y : â„), 0 < x â†’ x < y â†’ (f x) / x < (f y) / y ",
      "forall {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’ MonotoneOn (Î» x, f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ x, 0 â‰¤ x â†’ ContinuousAt f x) â†’\n  (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’\n  f 0 = 0 â†’\n  Monotone (deriv f) â†’\n  âˆ€ â¦ƒx y : â„â¦„, 0 < x â†’ x < y â†’ f x / x < f y / y ",
      "{g : â„ â†’ â„} {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioi 0 â†’\n          0 < deriv f x) â†’\n          StrictMono (deriv f) â†’ StrictMono g ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          StrictMonoOn (Î» x, f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        Monotone (deriv f) â†’\n          âˆ€ (x y : â„), 0 < x â†’ x < y â†’ (f x) / x < (f y) / y "
    ]
  },
  {
    "docString": "Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\\nthen `f` is convex on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' a â‰¤ m â‰¤ f' b`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x â‰¤ B' x` on `[a, b)`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} (f g : Î± â†’ ENNReal),\\n  âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼ â‰¤ âˆ«â» (a : Î±), f a + g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a < m â†’ m < f' b â†’ m âˆˆ f' '' Set.Ioo a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' a < m < f' b`, then `f' c = m` for some\\n`c âˆˆ (a, b)`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\\n  Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact â„) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Riemann-Lebesgue lemma for functions on `â„`, formulated via `Real.fourierIntegral`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\\ntends to `0`, then `f` tends to `1`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonpositive on `â„`,\\nthen `f` is concave on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {f : Î± â†’ â„} {s : Set Î±},\\n  LocallyBoundedVariationOn f s â†’ âˆƒ p q, MonotoneOn p s âˆ§ MonotoneOn q s âˆ§ f = p - q\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real valued function has bounded variation on a set, then it is a difference of monotone\\nfunctions there. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    âˆ€ {B B' : â„ â†’ â„},\\n      f a â‰¤ B a â†’\\n        ContinuousOn B (Set.Icc a b) â†’\\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n            (âˆ€ (x : â„),\\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by `B'`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},\\n  m â‰¤ m0 â†’\\n    âˆ€ {f g : Î± â†’ â„},\\n      MeasureTheory.StronglyMeasurable f â†’\\n        MeasureTheory.IntegrableOn f s â†’\\n          MeasureTheory.StronglyMeasurable g â†’\\n            MeasureTheory.IntegrableOn g s â†’\\n              (âˆ€ (t : Set Î±), MeasurableSet t â†’ â†‘â†‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) â†’\\n                MeasurableSet s â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, â€–f xâ€– âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `m` be a sub-Ïƒ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\\nThen `âˆ« x in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼` on all `m`-measurable sets with finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p : â„} {f g : Î± â†’ ENNReal},\\n  AEMeasurable f â†’\\n    AEMeasurable g â†’\\n      1 â‰¤ p â†’\\n        (âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤\\n          (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Minkowski's inequality for functions `Î± â†’ â„â‰¥0âˆ`: the `â„’p` seminorm of the sum of two\\nfunctions is bounded by the sum of their `â„’p` seminorms. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. \"}]\n",
    "prompt_cons": "/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\nthen `f` is convex on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' a â‰¤ m â‰¤ f' b`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x â‰¤ B' x` on `[a, b)`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} (f g : Î± â†’ ENNReal),\n  âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼ â‰¤ âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' a < m < f' b`, then `f' c = m` for some\n`c âˆˆ (a, b)`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a < m â†’ m < f' b â†’ m âˆˆ f' '' Set.Ioo a b :=\n\n/-- The Riemann-Lebesgue lemma for functions on `â„`, formulated via `Real.fourierIntegral`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\n  Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact â„) (nhds 0) :=\n\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 1) :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonpositive on `â„`,\nthen `f` is concave on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ Set.univ f :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If a real valued function has bounded variation on a set, then it is a difference of monotone\nfunctions there. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {f : Î± â†’ â„} {s : Set Î±},\n  LocallyBoundedVariationOn f s â†’ âˆƒ p q, MonotoneOn p s âˆ§ MonotoneOn q s âˆ§ f = p - q :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by `B'`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    âˆ€ {B B' : â„ â†’ â„},\n      f a â‰¤ B a â†’\n        ContinuousOn B (Set.Icc a b) â†’\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n            (âˆ€ (x : â„),\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Let `m` be a sub-Ïƒ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `âˆ« x in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼` on all `m`-measurable sets with finite measure. -/\ntheorem âˆ€ {Î± : Type u_1} {m m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},\n  m â‰¤ m0 â†’\n    âˆ€ {f g : Î± â†’ â„},\n      MeasureTheory.StronglyMeasurable f â†’\n        MeasureTheory.IntegrableOn f s â†’\n          MeasureTheory.StronglyMeasurable g â†’\n            MeasureTheory.IntegrableOn g s â†’\n              (âˆ€ (t : Set Î±), MeasurableSet t â†’ â†‘â†‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) â†’\n                MeasurableSet s â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, â€–f xâ€– âˆ‚Î¼ :=\n\n/-- Minkowski's inequality for functions `Î± â†’ â„â‰¥0âˆ`: the `â„’p` seminorm of the sum of two\nfunctions is bounded by the sum of their `â„’p` seminorms. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p : â„} {f g : Î± â†’ ENNReal},\n  AEMeasurable f â†’\n    AEMeasurable g â†’\n      1 â‰¤ p â†’\n        (âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤\n          (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$ -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      âˆ€ {a Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n  âˆ€ {M0 M1 M2 a : â„},\n    (âˆ€ x, a < x â†’ abs (f x) â‰¤ M0) â†’\n    (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ M1) â†’\n    (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ M2) â†’ M1^2 â‰¤ 4 * M0 * M2 ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ (deriv f) â†’\n    (âˆ€ (x : â„), a < x â†’ DifferentiableAt â„ f x) â†’\n      âˆ€ (Mâ‚€ Mâ‚ Mâ‚‚ : â„),\n        (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ (deriv f) â†’\n    âˆ€ {a Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n      (âˆ€ (x : â„), x > a â†’ abs (f x) â‰¤ Mâ‚€) â†’\n        (âˆ€ (x : â„), x > a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n          (âˆ€ (x : â„), x > a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆƒ (Mâ‚€ Mâ‚ Mâ‚‚ a : â„),\n        (âˆ€ (x : â„), x > a â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), x > a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), x > a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚) ",
      "forall {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  a âˆˆ â„ â†’\n    Differentiable â„ f â†’\n      Differentiable â„ (deriv f) â†’\n        âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n          (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n            (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n              (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆƒ a : â„, Differentiable â„ (Set.Ioi a) f âˆ§ Differentiable â„ (Set.Ioi a) (deriv f)) â†’\n    âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n      (âˆ€ (x : â„), x > a â†’ abs (f x) â‰¤ Mâ‚€) â†’\n        (âˆ€ (x : â„), x > a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n          (âˆ€ (x : â„), x > a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      âˆ€ {a Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚^2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} (a : â„),\n  (âˆ€ (x : â„), a < x â†’ DifferentiableAt â„ f x) â†’\n    (âˆ€ (x : â„), a < x â†’ DifferentiableAt â„ (deriv f) x) â†’\n      âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ "
    ]
  },
  {
    "docString": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [inst_1 : DiscreteTopology â†‘s] {x : Î±},\\n  x âˆˆ s â†’ âˆƒ U, U âˆˆ nhdsWithin x {x}á¶œ âˆ§ Disjoint U s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For point `x` in a discrete subset `s` of a topological space, there is a set `U`\\nsuch that\\n1. `U` is a punctured neighborhood of `x` (ie. `U âˆª {x}` is a neighbourhood of `x`),\\n2. `U` is disjoint from `s`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"}]\n",
    "prompt_cons": "/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x} :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U âˆª {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [inst_1 : DiscreteTopology â†‘s] {x : Î±},\n  x âˆˆ s â†’ âˆƒ U, U âˆˆ nhdsWithin x {x}á¶œ âˆ§ Disjoint U s :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V) :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.snd :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U : Set X, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A "
    ]
  },
  {
    "docString": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\\n  (F : Î¹ â†’ C(Î±, Î²)),\\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\\n  ContinuousMap.compactOpen =\\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²],\\n  Inducing (â†‘UniformFun.ofFun âˆ˜ FunLike.coe)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\\n  TopologicalSpace.IsTopologicalBasis s â†’\\n    âˆ€ {t : Set (Set Î²)},\\n      TopologicalSpace.IsTopologicalBasis t â†’\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module ğ•œ E] [inst_3 : Nonempty Î¹] [inst_4 : Countable Î¹] {p : SeminormFamily ğ•œ E Î¹}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p â†’ TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ âˆ€ {s : Set Î±}, IsCompact s â†’ Set.Finite {i | Set.Nonempty (f i âˆ© s)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a compact set in a topological space `Î±` and `f : Î¹ â†’ Set Î±` is a locally finite\\nfamily of sets, then `f i âˆ© s` is nonempty only for a finitely many `i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\n  (F : Î¹ â†’ C(Î±, Î²)),\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  ContinuousMap.compactOpen =\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²],\n  Inducing (â†‘UniformFun.ofFun âˆ˜ FunLike.coe) :=\n\n/-- In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    âˆ€ {t : Set (Set Î²)},\n      TopologicalSpace.IsTopologicalBasis t â†’\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t) :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ğ•œ E] [inst_3 : Nonempty Î¹] [inst_4 : Countable Î¹] {p : SeminormFamily ğ•œ E Î¹}\n  [inst_5 : TopologicalSpace E], WithSeminorms p â†’ TopologicalSpace.FirstCountableTopology E :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- If `s` is a compact set in a topological space `Î±` and `f : Î¹ â†’ Set Î±` is a locally finite\nfamily of sets, then `f i âˆ© s` is nonempty only for a finitely many `i`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ âˆ€ {s : Set Î±}, IsCompact s â†’ Set.Finite {i | Set.Nonempty (f i âˆ© s)} :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î¹ : Type v} {T : Î¹ â†’ TopologicalSpace Î±},\n  (âˆ€ (i : Î¹), TopologicalSpace Î±) â†’ TopologicalSpace Î± ",
      "âˆ€ {Î± : Type u} {X : Type u_1} (T : Î± â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace Î±),\n  TopologicalSpace (Subtype.mk (Set.Interâ‚“ fun i => (T i).to_preorder.to_order_dual) (_ : TopologicalSpace.to_preorder (Set.Interâ‚“ fun i => (T i).to_preorder.to_order_dual) = TopologicalSpace.OrderDual.to_preorder (Set.Interâ‚“ fun i => (T i).to_preorder.to_order_dual))) ",
      "âˆ€ {Î± : Type u} {X : Type u_1} {Î¹ : Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : TopologicalSpace X] (f : (i : Î¹) â†’ X â†’ Î± i) (T : Î¹ â†’ Set (Set X)),\n  (âˆ€ i, T i = TopologicalSpace.generateFrom (Set.Image (f i) (Set.Preimage (Î» x => f i x âˆˆ Set.Univ)))) â†’\n    TopologicalSpace.IsTopologicalBasis (â‹‚ i, T i) ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} {t : Î¹ â†’ TopologicalSpace Î±},\n  TopologicalSpace.generateFrom (â‹‚ (i : Î¹), (t i).is_open) = â¨… (i : Î¹), t i ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : Nonempty Î¹] (T : Î¹ â†’ TopologicalSpace Î±),\n  is_topological_space (â¨… (i : Î¹), T i) ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace Î±],\n  TopologicalSpace Î± ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} {t : Î¹ â†’ TopologicalSpace Î±},\n  TopologicalSpace Î± ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {t : Î¹ â†’ TopologicalSpace Î±}, TopologicalSpace (infi t) ",
      "âˆ€ {Î± : Type u} {X : Type u_1} {Î¹ : Type u_2} {t : Î¹ â†’ TopologicalSpace X},\n  TopologicalSpace X "
    ]
  },
  {
    "docString": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\\n  ContinuousMap.compactOpen =\\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\\n  (F : Î¹ â†’ C(Î±, Î²)),\\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module ğ•œ E] [inst_3 : Nonempty Î¹] [inst_4 : Countable Î¹] {p : SeminormFamily ğ•œ E Î¹}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p â†’ TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ s âˆ© â‹‚ (i : Î¹), Z i = âˆ… â†’ âˆƒ t, s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i = âˆ…\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every family of closed sets whose intersection avoids a compact set,\\nthere exists a finite subfamily whose intersection avoids this compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} [hÎ¹ : Nonempty Î¹],\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ s âˆ© â‹‚ (i : Î¹), Z i = âˆ… â†’ Directed (fun x x_1 => x âŠ‡ x_1) Z â†’ âˆƒ i, s âˆ© Z i = âˆ…\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every directed family of closed sets whose intersection avoids a compact set,\\nthere exists a single element of the family which itself avoids this compact set. \"}]\n",
    "prompt_cons": "/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  ContinuousMap.compactOpen =\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\n  (F : Î¹ â†’ C(Î±, Î²)),\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ğ•œ E] [inst_3 : Nonempty Î¹] [inst_4 : Countable Î¹] {p : SeminormFamily ğ•œ E Î¹}\n  [inst_5 : TopologicalSpace E], WithSeminorms p â†’ TopologicalSpace.FirstCountableTopology E :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- For every family of closed sets whose intersection avoids a compact set,\nthere exists a finite subfamily whose intersection avoids this compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ s âˆ© â‹‚ (i : Î¹), Z i = âˆ… â†’ âˆƒ t, s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i = âˆ… :=\n\n/-- For every directed family of closed sets whose intersection avoids a compact set,\nthere exists a single element of the family which itself avoids this compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} [hÎ¹ : Nonempty Î¹],\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ s âˆ© â‹‚ (i : Î¹), Z i = âˆ… â†’ Directed (fun x x_1 => x âŠ‡ x_1) Z â†’ âˆƒ i, s âˆ© Z i = âˆ… :=\n\n/-- Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! result : TopologicalSpace X, âˆ€ (i : Î¹), T i â‰¤ result ",
      "âˆ€ {Î± : Type u_1} {X : Type u_2} {Î¹ : Type u_3} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (t : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ t ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ Tâ‚€, TopologicalSpace.IsTopologicalBasis (â‹ƒâ‚€ ((fun Î± => TopologicalSpace.IsTopologicalBasis.basis_set (T Î±)) '' Set.univ)) âˆ§\n    (âˆ€ T', TopologicalSpace.IsTopologicalBasis (â‹ƒâ‚€ ((fun Î± => TopologicalSpace.IsTopologicalBasis.basis_set (T' Î±)) '' Set.univ)) â†’ Tâ‚€ â‰¤ T') ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ",
      "âˆ€ {Î± : Type u} {Î¹ : Type v} (T : Î¹ â†’ TopologicalSpace Î±),\n  âˆƒ (T' : TopologicalSpace Î±), (âˆ€ (i : Î¹), T' â‰¤ T i) âˆ§ âˆ€ (T'' : TopologicalSpace Î±), (âˆ€ (i : Î¹), T'' â‰¤ T i) â†’ T'' â‰¤ T' ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [t : Î¹ â†’ TopologicalSpace Î±],\n  âˆƒ (T : TopologicalSpace Î±), T = â¨… (i : Î¹), t i ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace Î±),\n  âˆƒ! t : TopologicalSpace Î±, (âˆ€ (i : Î¹), T i â‰¤ t) âˆ§ âˆ€ (y : TopologicalSpace Î±), (âˆ€ (i : Î¹), T i â‰¤ y) â†’ t â‰¤ y ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {_inst : (i : Î¹) â†’ TopologicalSpace Î±}, âˆƒ! (T : TopologicalSpace Î±), âˆ€ (i : Î¹), _inst i â‰¤ T ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! T', (âˆ€ (i : Î¹), T i â‰¤ T') âˆ§ âˆ€ (T'' : TopologicalSpace X), (âˆ€ (i : Î¹), T i â‰¤ T'') â†’ T' â‰¤ T'' ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)],\n  âˆƒ! (T : TopologicalSpace Î±), âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (SetOf (TopologicalSpace.generateOpen.T T (TopologicalSpace.generateOpen.T (Î± i)))) "
    ]
  },
  {
    "docString": "Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\\n  TopologicalSpace.IsTopologicalBasis s â†’\\n    âˆ€ {t : Set (Set Î²)},\\n      TopologicalSpace.IsTopologicalBasis t â†’\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  Inducing f â†’ tÎ± = TopologicalSpace.induced f tÎ²\",\n  \"isProp\": true,\n  \"docString\": \"The topology on the domain is equal to the induced topology. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²],\\n  ContinuousMap.compactOpen = ContinuousMap.compactConvergenceTopology\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology is equal to the compact-convergence topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\\nit is a finite union of some elements in the basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"One of the most useful consequences of Baire theorem: if a countable union of closed sets\\ncovers the space, then one of the sets has nonempty interior. \"}]\n",
    "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    âˆ€ {t : Set (Set Î²)},\n      TopologicalSpace.IsTopologicalBasis t â†’\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t) :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The topology on the domain is equal to the induced topology. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Inducing f â†’ tÎ± = TopologicalSpace.induced f tÎ² :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n) :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- The compact-open topology is equal to the compact-convergence topology. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²],\n  ContinuousMap.compactOpen = ContinuousMap.compactConvergenceTopology :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼)) :=\n\n/-- If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i :=\n\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s)) :=\n\n/-- Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)), TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† t} ",
      "forall {X : Type u} {A : Set (Set X)} (tÎ± : TopologicalSpace X),\n  TopologicalSpace.IsTopologicalBasis A â†’ tÎ± = Inf {t : TopologicalSpace X | A âŠ† t.sets} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† t.opens} ",
      "âˆ€ {Î± : Type u} (s : Set (Set Î±)),\n  TopologicalSpace.IsTopologicalBasis s â†’\n    TopologicalSpace.generateFrom s = â‹‚â‚€ {t : TopologicalSpace Î± | s âŠ† t.opens} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.sets} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {t | (âˆ€ (s : Set Î±), s âˆˆ A â†’ TopologicalSpace.IsOpen t s)} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.IsTopologicalBasis A â†’\n  TopologicalSpace.generateFrom A = â‹‚â‚€ {B : TopologicalSpace Î± | A âŠ† B.collectingOpens} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {Ï„ : TopologicalSpace Î± | âˆ€ s, s âˆˆ A â†’ TopologicalSpace.IsOpen Ï„ s} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â‹‚â‚€ {t : TopologicalSpace Î± | A âŠ† t.sets} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.istopologicalbasis} "
    ]
  },
  {
    "docString": "Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is\\ntotally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L â†’ T2Space (L â‰ƒâ‚[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic extension, then the Krull topology on `L â‰ƒâ‚[K] L` is Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E], UniformSpace.toTopologicalSpace â‰¤ WeakDual.instTopologicalSpace\",\n  \"isProp\": true,\n  \"docString\":\n  \"The weak-star topology is coarser than the dual-norm topology. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L], TopologicalGroup (L â‰ƒâ‚[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a field extension `L/K`, the Krull topology on `L â‰ƒâ‚[K] L` makes it a topological group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  âˆƒ f, Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Tâ‚ƒ topological space with second countable topology can be embedded into `l^âˆ = â„• â†’áµ‡ â„`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  IsOpen s â†’ IsLowerSet s\",\n  \"isProp\": true,\n  \"docString\": \"Every set open in the lower topology is a lower set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\\n  IsUpperSet â†‘ğ’œ â†’ IsLowerSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\\n  IsLowerSet â†‘ğ’œ â†’ IsUpperSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Harris-Kleitman inequality**: Lower sets and upper sets of finsets anticorrelate. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x y : Î±},\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : LowerTopology Î±], T0Space Î±\",\n  \"isProp\": true,\n  \"docString\": \"The lower topology on a partial order is Tâ‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {J : Type w}\\n  [inst_2 : CategoryTheory.Category J] (K : CategoryTheory.Functor J C) (F : CategoryTheory.Functor C D)\\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp K F)]\\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `F` creates the limit of `K` and `K â‹™ F` has a limit, then `K` has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\\n  IsClosed s â†’ âˆ€ [inst_2 : DiscreteTopology â†‘s], Cardinal.continuum â‰¤ Cardinal.mk â†‘s â†’ Â¬NormalSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\\nhas cardinality at least continuum, then the ambient space is not a normal space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : âˆ€ (j : J), Nonempty â†‘(F.obj j)]\\n  [inst_3 : âˆ€ (j : J), CompactSpace â†‘(F.obj j)] [inst_4 : âˆ€ (j : J), T2Space â†‘(F.obj j)],\\n  Nonempty â†‘(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"}]\n",
    "prompt_cons": "/-- If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is\ntotally disconnected. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ IsTotallyDisconnected Set.univ :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If `L/K` is an algebraic extension, then the Krull topology on `L â‰ƒâ‚[K] L` is Hausdorff. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ T2Space (L â‰ƒâ‚[K] L) :=\n\n/-- The weak-star topology is coarser than the dual-norm topology. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], UniformSpace.toTopologicalSpace â‰¤ WeakDual.instTopologicalSpace :=\n\n/-- For a field extension `L/K`, the Krull topology on `L â‰ƒâ‚[K] L` makes it a topological group. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L], TopologicalGroup (L â‰ƒâ‚[K] L) :=\n\n/-- Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\n  IsClosed (Set.Ici a) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- A Tâ‚ƒ topological space with second countable topology can be embedded into `l^âˆ = â„• â†’áµ‡ â„`. -/\ntheorem âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  âˆƒ f, Embedding f :=\n\n/-- Every set open in the lower topology is a lower set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  IsOpen s â†’ IsLowerSet s :=\n\n/-- **Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\n  IsUpperSet â†‘ğ’œ â†’ IsLowerSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬ :=\n\n/-- **Harris-Kleitman inequality**: Lower sets and upper sets of finsets anticorrelate. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\n  IsLowerSet â†‘ğ’œ â†’ IsUpperSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬ :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x y : Î±},\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- The lower topology on a partial order is Tâ‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : LowerTopology Î±], T0Space Î± :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- If `F` creates the limit of `K` and `K â‹™ F` has a limit, then `K` has a limit. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (K : CategoryTheory.Functor J C) (F : CategoryTheory.Functor C D)\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp K F)]\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K :=\n\n/-- Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\nhas cardinality at least continuum, then the ambient space is not a normal space. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\n  IsClosed s â†’ âˆ€ [inst_2 : DiscreteTopology â†‘s], Cardinal.continuum â‰¤ Cardinal.mk â†‘s â†’ Â¬NormalSpace X :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : âˆ€ (j : J), Nonempty â†‘(F.obj j)]\n  [inst_3 : âˆ€ (j : J), CompactSpace â†‘(F.obj j)] [inst_4 : âˆ€ (j : J), T2Space â†‘(F.obj j)],\n  Nonempty â†‘(TopCat.limitCone F).pt :=\n\n/-- Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable. -/\ntheorem",
    "choices": [
      "âˆ€ (K : Real) (l : â„), TopologicalSpace.lLimit < TopologicalSpace.KTopology K l â†’ TopologicalSpace.KTopology K l < TopologicalSpace.lLimit ",
      "not_comparable_lower_K_topology : Â¬(TopologicalSpace.generateFrom Lower.topologicalBasis â‰¤ TopologicalSpace.generateFrom K.topologicalBasis) âˆ§\n  Â¬(TopologicalSpace.generateFrom K.topologicalBasis â‰¤ TopologicalSpace.generateFrom Lower.topologicalBasis) ",
      "not_comparable_lower_k_topology :\n  Â¬(LowerTopology â„ â‰¤ KTopology â„) âˆ§ Â¬(KTopology â„ â‰¤ LowerTopology â„) ",
      "LowerLimitTopology.not_le_K_topology : Not (LowerLimitTopology â‰¤ KTopology) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderClosedTopology Î±],\n  Â¬(TopologicalSpace.lower Î± â‰¤ TopologicalSpace.K_topology Î±) âˆ§\n  Â¬(TopologicalSpace.K_topology Î± â‰¤ TopologicalSpace.lower Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±]\n  [inst_3 : KTTopology Î±], Â¬(UniformSpace.toTopologicalSpace â‰¤ LowerTopology.toTopologicalSpace) âˆ§\n    Â¬(LowerTopology.toTopologicalSpace â‰¤ KTTopology.toTopologicalSpace) ",
      "not_comparable : Â¬UniformSpace.toTopologicalSpace â‰¤ LowerTopology â„ âˆ§ Â¬UniformSpace.toTopologicalSpace â‰¤ TopologicalSpace.generateFrom (SetOf (Set.Ioo_kmeasurable)) ",
      "forall {K : Type u_1} [inst : Field K] {L : Type u_2} [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ LowerLimitTopology â„ â‰  KTopology â„ ",
      "{R_l : Type u_1} [inst : TopologicalSpace R_l] [inst_1 : LowerTopology R_l] [inst_2 : KTopology R_l],\n  Â¬(TopologicalSpace.toTopologicalSpace R_l â‰¤ TopologicalSpace.toTopologicalSpace KTopology) âˆ§\n  Â¬(TopologicalSpace.toTopologicalSpace KTopology â‰¤ TopologicalSpace.toTopologicalSpace R_l) ",
      "not_comparable_lower_and_K_topology : \n  Â¬(Topology.Lower.toTopologicalSpace â‰¤ Topology.K.toTopologicalSpace) âˆ§\n  Â¬(Topology.K.toTopologicalSpace â‰¤ Topology.Lower.toTopologicalSpace) "
    ]
  },
  {
    "docString": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\\n  Algebra.discr K â†‘b â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V) id\",\n  \"isProp\": true,\n  \"docString\": \"Open elements of `ğ“¤ Î±` form a basis of `ğ“¤ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Filter Î±) [inst : Filter.IsCountablyGenerated f], âˆƒ x, Filter.HasAntitoneBasis f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A countably generated filter admits a basis formed by an antitone sequence of sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : NoMaxOrder Î±] {a : Î±},\\n  0 < a â†’ Filter.HasBasis (nhds a) (fun Îµ => 0 < Îµ âˆ§ Îµ â‰¤ a) fun Îµ => Set.Ioo (a - Îµ) (a + Îµ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : Filter Î±} {a : Î±} {s : Set Î±},\\n  a âˆˆ s â†’ IsOpen s â†’ Filter.principal s â‰¤ f â†’ nhds a â‰¤ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\\nthe principal filter of some open set `s` containing `a`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {Î“â‚€ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€),\\n  RingSubgroupsBasis fun Î³ => Valuation.ltAddSubgroup v Î³\",\n  \"isProp\": true,\n  \"docString\":\n  \"The basis of open subgroups for the topology on a ring determined by a valuation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\\n  IsUnit (Algebra.discr K â†‘b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {f : Î² â†’ Î±},\\n  Metric.Bounded (Set.range f) â†” âˆƒ C, âˆ€ (x y : Î²), dist (f x) (f y) â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of the boundedness of the range of a function \"}]\n",
    "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼)) :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b â‰  0`. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\n  Algebra.discr K â†‘b â‰  0 :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Open elements of `ğ“¤ Î±` form a basis of `ğ“¤ Î±`. -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V) id :=\n\n/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/\ntheorem âˆ€ {Î± : Type u_1} (f : Filter Î±) [inst : Filter.IsCountablyGenerated f], âˆƒ x, Filter.HasAntitoneBasis f x :=\n\n/-- If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : NoMaxOrder Î±] {a : Î±},\n  0 < a â†’ Filter.HasBasis (nhds a) (fun Îµ => 0 < Îµ âˆ§ Îµ â‰¤ a) fun Îµ => Set.Ioo (a - Îµ) (a + Îµ) :=\n\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : Filter Î±} {a : Î±} {s : Set Î±},\n  a âˆˆ s â†’ IsOpen s â†’ Filter.principal s â‰¤ f â†’ nhds a â‰¤ f :=\n\n/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {Î“â‚€ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€),\n  RingSubgroupsBasis fun Î³ => Valuation.ltAddSubgroup v Î³ :=\n\n/-- Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\n  IsClosed (Set.Ici a) :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\n  IsUnit (Algebra.discr K â†‘b) :=\n\n/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n) :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s :=\n\n/-- Characterization of the boundedness of the range of a function -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {f : Î² â†’ Î±},\n  Metric.Bounded (Set.range f) â†” âˆƒ C, âˆ€ (x y : Î²), dist (f x) (f y) â‰¤ C :=\n\n/-- Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±],\n  TopologicalSpace.IsTopologicalBasis {s : Set Î± | âˆƒ (l u : Î±) (h : l < u) (hl : l.isRational) (hu : u.isRational), s = Set.Ioo l u} âˆ§\n  TopologicalSpace.generateFrom \n    {s : Set Î± | âˆƒ (l u : Î±) (h : l < u) (hl : l.isRational) (hu : u.isRational), s = Set.Ioo l u} â‰  inst_1 ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [inst_2 : OrderTopology Î±],\n  âˆ€ {s : Set Î±} {a : Î±}, a âˆˆ s â†’ IsOpen s â†’ (âˆƒ l u : â„š, a < â†‘u âˆ§ (Set.Ioo (â†‘l) (â†‘u) âŠ† s)) â†’\n    t = TopologicalSpace.generateFrom {s_1 : Set Î± | âˆƒ l u : â„š, s_1 = Set.Ioo (â†‘l) (â†‘u)} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [inst_2 : OrderTopology Î±],\n  TopologicalSpace.IsTopologicalBasis ((fun a b => Set.Ioo a b) '' SetOf fun p : Î± Ã— Î± => p.1 < p.2 âˆ§ âˆ€ x y, x < y â†’ âˆƒ q, x < q âˆ§ q < y) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : NoMinOrder Î±] {a : Î±},\n  0 < a â†’ Filter.HasBasis (nhds a) (fun Îµ => 0 < Îµ âˆ§ Îµ < a) (fun Îµ => Set.Ioo (a - Îµ) (a + Îµ)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [inst_2 : OrderTopology Î±] [inst_3 : FloorRing Î±] [inst_4 : TopologicalSpace.SecondCountableTopology Î±],\n  Â¬TopologicalSpace.IsTopologicalBasis âˆ˜ Set.Range (Î» (ab : Î± Ã— Î±), Set.Ioo ab.1 ab.2) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [order_topology : OrderTopology Î±] [floor_ring : FloorRing Î±],\n  TopologicalSpace.generateFrom {s : Set Î± | âˆƒ (a b : â„š), a < b âˆ§ s = Set.Ioo (a : Î±) (b : Î±)} â‰  LowerTopology Î± ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : FloorRing Î±],\n  TopologicalSpace.IsTopologicalBasis ((fun p => Set.Ioo (coe p.1) (coe p.2)) '' SetOf (fun p => p.1 < p.2 âˆ§ âˆ€ x, x â‰  coe p.1 âˆ§ x â‰¤ coe p.2))\n  âˆ§ TopologicalSpace.generateFrom ((fun p => Set.Ioo (coe p.1) (coe p.2)) '' SetOf (fun p => p.1 < p.2 âˆ§ âˆ€ x, x â‰  coe p.1 âˆ§ x â‰¤ coe p.2)) â‰  LowerTopology Î± ",
      "forall {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : FloorRing Î±],\n  TopologicalSpace.generateFrom (SetOf fun s => âˆƒ a b : â„š, a < b âˆ§ s = Set.Ioo (â†‘a : Î±) â†‘b) â‰  LowerTopology Î± ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : FloorRing Î±], TopologicalSpace.IsTopologicalBasis {Iio (r : Î±) | âˆƒ x : â„š, r = â†‘x} â†’ False ",
      "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] [inst_4 : NoMinOrder Î±],\n  t â‰  TopologicalSpace.generateFrom {s : Set Î± | âˆƒ (a : Î±), s = Set.Ioi a âˆ§ âˆ€ (b : Î±), b < a â†’ âˆƒ c, b < c âˆ§ c < a} "
    ]
  },
  {
    "docString": "A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\\nhomotopic to `ContinuousMap.pi fâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace E] {f : E â†’ F} {f' : E â†’ E â‰ƒL[ğ•œ] F},\\n  (âˆ€ (x : E), HasStrictFDerivAt f (â†‘(f' x)) x) â†’ IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has an invertible strict derivative at all points, then it is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective â†‘f â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\\nopen. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {f f' : ğ•œ â†’ ğ•œ},\\n  (âˆ€ (x : ğ•œ), HasStrictDerivAt f (f' x) x) â†’ (âˆ€ (x : ğ•œ), f' x â‰  0) â†’ IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a non-zero strict derivative at all points, then it is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\\n  OpenEmbedding â†‘f â†’\\n    OpenEmbedding â†‘g â†’\\n      OpenEmbedding\\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\": \"âˆ€ {X Y : Profinite} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of profinite spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\\n  IsClosedMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact topological space, then `Prod.snd : X Ã— Y â†’ Y` is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²] {f : X â†’ Y}\\n  [inst : TopologicalSpace.SecondCountableTopology â†‘(Set.range f)],\\n  Measurable f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable (Set.restrict (Set.range f) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a Borel measurable map from a Polish space to a topological space with second\\ncountable topology, then for any measurable space `Î²` and `g : Y â†’ Î²`, the composition `g âˆ˜ f` is\\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {n : â„•âˆ}\\n  {E' : Type u_1} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace ğ•œ E'] {F' : Type u_3}\\n  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace ğ•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'},\\n  ContDiffOn ğ•œ n f s â†’ ContDiffOn ğ•œ n g t â†’ ContDiffOn ğ•œ n (Prod.map f g) (s Ã—Ë¢ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product map of two `C^n` functions on a set is `C^n` on the product set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\nhomotopic to `ContinuousMap.pi fâ‚`. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚) :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.snd :=\n\n/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace E] {f : E â†’ F} {f' : E â†’ E â‰ƒL[ğ•œ] F},\n  (âˆ€ (x : E), HasStrictFDerivAt f (â†‘(f' x)) x) â†’ IsOpenMap f :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst :=\n\n/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective â†‘f â†’ IsOpenMap â†‘f :=\n\n/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {f f' : ğ•œ â†’ ğ•œ},\n  (âˆ€ (x : ğ•œ), HasStrictDerivAt f (f' x) x) â†’ (âˆ€ (x : ğ•œ), f' x â‰  0) â†’ IsOpenMap f :=\n\n/-- If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. -/\ntheorem âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\n  OpenEmbedding â†‘f â†’\n    OpenEmbedding â†‘g â†’\n      OpenEmbedding\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem âˆ€ {X Y : Profinite} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- If `X` is a compact topological space, then `Prod.snd : X Ã— Y â†’ Y` is a closed map. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\n  IsClosedMap Prod.snd :=\n\n/-- If `f : X â†’ Y` is a Borel measurable map from a Polish space to a topological space with second\ncountable topology, then for any measurable space `Î²` and `g : Y â†’ Î²`, the composition `g âˆ˜ f` is\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²] {f : X â†’ Y}\n  [inst : TopologicalSpace.SecondCountableTopology â†‘(Set.range f)],\n  Measurable f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable (Set.restrict (Set.range f) g) :=\n\n/-- The product map of two `C^n` functions on a set is `C^n` on the product set. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {n : â„•âˆ}\n  {E' : Type u_1} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace ğ•œ E'] {F' : Type u_3}\n  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace ğ•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'},\n  ContDiffOn ğ•œ n f s â†’ ContDiffOn ğ•œ n g t â†’ ContDiffOn ğ•œ n (Prod.map f g) (s Ã—Ë¢ t) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "forall {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "forall {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst "
    ]
  },
  {
    "docString": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x y : Î±},\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U Z : Set Î±},\\n  IsPreirreducible Z â†’ Set.Nonempty U â†’ IsOpen U â†’ U âŠ† S â†’ S âŠ† Z â†’ IsIrreducible S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `âˆ… â‰  U âŠ† S âŠ† Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"}]\n",
    "prompt_cons": "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\ t) :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x y : Î±},\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If `âˆ… â‰  U âŠ† S âŠ† Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U Z : Set Î±},\n  IsPreirreducible Z â†’ Set.Nonempty U â†’ IsOpen U â†’ U âŠ† S â†’ S âŠ† Z â†’ IsIrreducible S :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {A U : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±}, IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) "
    ]
  },
  {
    "docString": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X â†’ Y}\\n  {s : Set X}, HolderOnWith C r f s â†’ 0 < r â†’ UniformContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\": \"A HÃ¶lder continuous function is uniformly continuous \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] {s : Set Î²},\\n  IsCompact s â†’ Set.Nonempty s â†’ âˆ€ {f : Î² â†’ Î±}, ContinuousOn f s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **extreme value theorem**: a continuous function realizes its minimum on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²}, Monotone f â†’ Function.Surjective f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monotone surjective function with a densely ordered codomain is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LE Î²] {f g : Î± â†’ Î²} {a : Î±},\\n  f â‰¤á¶ [nhds a] g â†’ âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\\n`f x â‰¤ g x` in a neighbourhood of `y`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\\n  ContinuousAt g a â†’\\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\\n  [inst_6 : OrderClosedTopology Î´] {s : Set Î±} [hs : Set.OrdConnected s] {f : Î± â†’ Î´},\\n  ContinuousOn f s â†’ âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.SurjOn f s (Set.uIcc (f a) (f b))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"}]\n",
    "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A HÃ¶lder continuous function is uniformly continuous -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X â†’ Y}\n  {s : Set X}, HolderOnWith C r f s â†’ 0 < r â†’ UniformContinuousOn f s :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- The **extreme value theorem**: a continuous function realizes its minimum on a compact set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {s : Set Î²},\n  IsCompact s â†’ Set.Nonempty s â†’ âˆ€ {f : Î² â†’ Î±}, ContinuousOn f s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- A monotone surjective function with a densely ordered codomain is continuous. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²}, Monotone f â†’ Function.Surjective f â†’ Continuous f :=\n\n/-- If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x â‰¤ g x` in a neighbourhood of `y`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LE Î²] {f g : Î± â†’ Î²} {a : Î±},\n  f â‰¤á¶ [nhds a] g â†’ âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\n  ContinuousAt g a â†’\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a :=\n\n/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\n  [inst_6 : OrderClosedTopology Î´] {s : Set Î±} [hs : Set.OrdConnected s] {f : Î± â†’ Î´},\n  ContinuousOn f s â†’ âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.SurjOn f s (Set.uIcc (f a) (f b)) :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y] [inst_3 : OrderTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous (fun x => min (f x) (g x)) ",
      "âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {f g : X â†’ Î±}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y] [inst_3 : OrderClosedTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y] [inst_3 : OrderTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous (fun x => min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : LinearOrder Î²]\n  [inst_3 : OrderClosedTopology Î²] {f g : Î± â†’ Î²}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LinearOrder Î²] [inst_3 : OrderTopology Î²] {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²]\n  {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => LinearOrder.min (f x) (g x) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y] [inst_3 : OrderTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : TopologicalSpace Î²]\n  [inst_3 : OrderTopology Î²] {f g : Î± â†’ Î²},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => LinearOrder.min (f x) (g x) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²]\n  {f g : Î± â†’ Î²}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) "
    ]
  },
  {
    "docString": "Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : Filter Î¹} {c : Î²},\\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ âŠ¤) (nhds c) â†” TendstoUniformly F (fun x => c) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence to a constant function is equivalent to convergence in `p Ã—Ë¢ âŠ¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\\n    Filter.Tendsto x l f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence converges if every subsequence has a convergent subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g\",\n  \"isProp\": true,\n  \"docString\": \"Convergence in Lp implies convergence in measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : Finite Î¹]\\n  [inst_2 : âˆ€ (i : Î¹), DiscreteTopology (Ï€ i)], DiscreteTopology ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"A finite product of discrete spaces is discrete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {ğ•œ : Type u_2} {ğ”¸ : Type u_3} [inst : NormedField ğ•œ] [inst_1 : NormedAddCommGroup ğ”¸]\\n  [inst_2 : NormedSpace ğ•œ ğ”¸] {l : Filter Î¹} {Îµ : Î¹ â†’ ğ•œ} {f : Î¹ â†’ ğ”¸},\\n  Filter.Tendsto Îµ l (nhds 0) â†’\\n    Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) l (norm âˆ˜ f) â†’ Filter.Tendsto (Îµ â€¢ f) l (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The (scalar) product of a sequence that tends to zero with a bounded one also tends to zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence a.e. implies convergence in measure in a finite measure space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\\n`p Ã—Ë¢ ğ“Ÿ s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\\nall `x âˆˆ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"}]\n",
    "prompt_cons": "/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- Uniform convergence to a constant function is equivalent to convergence in `p Ã—Ë¢ âŠ¤`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ âŠ¤) (nhds c) â†” TendstoUniformly F (fun x => c) p :=\n\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\n    Filter.Tendsto x l f :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)} :=\n\n/-- Convergence in Lp implies convergence in measure. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g :=\n\n/-- A finite product of discrete spaces is discrete. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : Finite Î¹]\n  [inst_2 : âˆ€ (i : Î¹), DiscreteTopology (Ï€ i)], DiscreteTopology ((i : Î¹) â†’ Ï€ i) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- The (scalar) product of a sequence that tends to zero with a bounded one also tends to zero. -/\ntheorem âˆ€ {Î¹ : Type u_1} {ğ•œ : Type u_2} {ğ”¸ : Type u_3} [inst : NormedField ğ•œ] [inst_1 : NormedAddCommGroup ğ”¸]\n  [inst_2 : NormedSpace ğ•œ ğ”¸] {l : Filter Î¹} {Îµ : Î¹ â†’ ğ•œ} {f : Î¹ â†’ ğ”¸},\n  Filter.Tendsto Îµ l (nhds 0) â†’\n    Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) l (norm âˆ˜ f) â†’ Filter.Tendsto (Îµ â€¢ f) l (nhds 0) :=\n\n/-- Convergence a.e. implies convergence in measure in a finite measure space. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g :=\n\n/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p Ã—Ë¢ ğ“Ÿ s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s :=\n\n/-- If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\nall `x âˆˆ Î±`. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i} {l : Filter â„•},\n  Filter.Tendsto x l (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x n i) l (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {l : Filter â„•} {x : (i : Î¹) â†’ Ï€ i} {x_i : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x_i l (nhds x) â†” âˆ€ i, Filter.Tendsto (fun n => x_i n i) l (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [_inst_1 : (i : Î¹) â†’ TopologicalSpace (X i)] {x : Î  x, X x} {u : â„• â†’ Î  x, X x},\n  Filter.Tendsto u Filter.atTop (nhds x) â†” (âˆ€ (i : Î¹), Filter.Tendsto (fun n => u n i) Filter.atTop (nhds (x i))) ",
      "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i} {u : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto u Filter.atTop (nhds x) â†” âˆ€ i : Î¹, Filter.Tendsto (fun n => u n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i} {l : Filter â„•} {g : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto g l (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => g n i) l (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : â„• â†’ (i : Î¹) â†’ Ï€ i} {l : (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x Filter.atTop (nhds l) â†” âˆ€ (i : Î¹), Filter.Tendsto (Î» n, x n i) Filter.atTop (nhds (l i)) ",
      "âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i} {x_i : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ i : Î¹, Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  {F : â„• â†’ (i : Î¹) â†’ Ï€ i} {x : (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto F Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => F n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : â„• â†’ (i : Î¹) â†’ Ï€ i} {y : (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x Filter.atTop (nhds y) â†” âˆ€ i, Filter.Tendsto (Î» n, x n i) Filter.atTop (nhds (y i)) ",
      "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {l : Filter â„•} {x : (i : Î¹) â†’ Ï€ i}\n  {F : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto F l (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => F n i) l (nhds (x i)) "
    ]
  },
  {
    "docString": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\\n    MeasureTheory.Integrable â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±} {x : Î±}, Monotone f â†’ x â‰¤ f x â†’ Monotone fun n => f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone map and `x â‰¤ f x` at some point `x`, then the iterates `f^[n] x` form\\na monotone sequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"âˆ€ (f : C(â†‘unitInterval, â„)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Bernstein approximations\\n```\\nâˆ‘ k : Fin (n+1), f (k/n : â„) * n.choose k * x^k * (1-x)^(n-k)\\n```\\nfor a continuous function `f : C([0,1], â„)` converge uniformly to `f` as `n` tends to infinity.\\n\\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], Â§7D,\\nand reproduced on wikipedia.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’\\n        (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), HasFDerivAt (fun y => âˆ‘' (n : Î±), f n y) (âˆ‘' (n : Î±), f' n x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series is differentiable and its derivative is the sum of the derivatives. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â†’L[ğ•œ] F} {x : E} {s : Set E},\\n  HasFDerivWithinAt f f' s x â†’\\n    âˆ€ {Î± : Type u_4} (l : Filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E},\\n      (âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) â†’\\n        Filter.Tendsto (fun n => â€–c nâ€–) l Filter.atTop â†’\\n          Filter.Tendsto (fun n => c n â€¢ d n) l (nhds v) â†’\\n            Filter.Tendsto (fun n => c n â€¢ (f (x + d n) - f x)) l (nhds (â†‘f' v))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\\ntangent cone related discussions. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±} {x : Î±}, StrictMono f â†’ x < f x â†’ StrictMono fun n => f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\\nform a strictly monotone sequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}\\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\\n  {I' : ModelWithCorners ğ•œ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M â†’ M'} {x : M} {n : â„•},\\n  ContMDiffAt I I' (â†‘n) f x â†” âˆ€á¶  (x' : M) in nhds x, ContMDiffAt I I' (â†‘n) f x'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsFixedPt f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\\n  {f : Î± â†’ G}, Summable f â†’ Filter.Tendsto f Filter.cofinite (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\\n`cofinite`. \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} [hT : Fact (0 < T)] {f : C(AddCircle T, â„‚)},\\n  Summable (fourierCoeff â†‘f) â†’ HasSum (fun i => fourierCoeff (â†‘f) i â€¢ fourier i) f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence of Fourier coefficients of `f` is summable, then the Fourier series converges\\nuniformly to `f`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ Differentiable ğ•œ fun y => âˆ‘' (n : Î±), f n y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If all functions in the series are differentiable\\nwith a summable bound on the derivatives, then the series is differentiable.\\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\\nconvergence then the series is zero everywhere so the result still holds. \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} [hT : Fact (0 < T)] {f : C(AddCircle T, â„‚)},\\n  Summable (fourierCoeff â†‘f) â†’ âˆ€ (x : AddCircle T), HasSum (fun i => fourierCoeff (â†‘f) i â€¢ â†‘(fourier i) x) (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence of Fourier coefficients of `f` is summable, then the Fourier series of `f`\\nconverges everywhere pointwise to `f`. \"}]\n",
    "prompt_cons": "/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If $x â‰¤ f x$ for all $x$ (we write this as `id â‰¤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±}, id â‰¤ f â†’ âˆ€ (n : â„•), id â‰¤ f^[n] :=\n\n/-- If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\n    MeasureTheory.Integrable â†‘f :=\n\n/-- If `f` is a monotone map and `x â‰¤ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±} {x : Î±}, Monotone f â†’ x â‰¤ f x â†’ Monotone fun n => f^[n] x :=\n\n/-- If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- The Bernstein approximations\n```\nâˆ‘ k : Fin (n+1), f (k/n : â„) * n.choose k * x^k * (1-x)^(n-k)\n```\nfor a continuous function `f : C([0,1], â„)` converge uniformly to `f` as `n` tends to infinity.\n\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], Â§7D,\nand reproduced on wikipedia. -/\ntheorem âˆ€ (f : C(â†‘unitInterval, â„)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series is differentiable and its derivative is the sum of the derivatives. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’\n        (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), HasFDerivAt (fun y => âˆ‘' (n : Î±), f n y) (âˆ‘' (n : Î±), f' n x) x :=\n\n/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â†’L[ğ•œ] F} {x : E} {s : Set E},\n  HasFDerivWithinAt f f' s x â†’\n    âˆ€ {Î± : Type u_4} (l : Filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E},\n      (âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) â†’\n        Filter.Tendsto (fun n => â€–c nâ€–) l Filter.atTop â†’\n          Filter.Tendsto (fun n => c n â€¢ d n) l (nhds v) â†’\n            Filter.Tendsto (fun n => c n â€¢ (f (x + d n) - f x)) l (nhds (â†‘f' v)) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\nform a strictly monotone sequence. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±} {x : Î±}, StrictMono f â†’ x < f x â†’ StrictMono fun n => f^[n] x :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners ğ•œ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M â†’ M'} {x : M} {n : â„•},\n  ContMDiffAt I I' (â†‘n) f x â†” âˆ€á¶  (x' : M) in nhds x, ContMDiffAt I I' (â†‘n) f x' :=\n\n/-- If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. -/\ntheorem âˆ€ {Î± : Type u} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsFixedPt f^[n] x :=\n\n/-- Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\n`cofinite`. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\n  {f : Î± â†’ G}, Summable f â†’ Filter.Tendsto f Filter.cofinite (nhds 0) :=\n\n/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series converges\nuniformly to `f`. -/\ntheorem âˆ€ {T : â„} [hT : Fact (0 < T)] {f : C(AddCircle T, â„‚)},\n  Summable (fourierCoeff â†‘f) â†’ HasSum (fun i => fourierCoeff (â†‘f) i â€¢ fourier i) f :=\n\n/-- An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. -/\ntheorem âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If all functions in the series are differentiable\nwith a summable bound on the derivatives, then the series is differentiable.\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\nconvergence then the series is zero everywhere so the result still holds. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ Differentiable ğ•œ fun y => âˆ‘' (n : Î±), f n y :=\n\n/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series of `f`\nconverges everywhere pointwise to `f`. -/\ntheorem âˆ€ {T : â„} [hT : Fact (0 < T)] {f : C(AddCircle T, â„‚)},\n  Summable (fourierCoeff â†‘f) â†’ âˆ€ (x : AddCircle T), HasSum (fun i => fourierCoeff (â†‘f) i â€¢ â†‘(fourier i) x) (â†‘f x) :=\n\n/-- Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$. -/\ntheorem",
    "choices": [
      "âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (Î» (n : â„•), x^n) Filter.atTop (nhds (ite (x = 1) 1 0)) ",
      "âˆ€ (x : â„) (hx : x âˆˆ Icc (0 : â„) 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (ite (x < 1) 0 1)) ",
      "âˆ€ (x : â„) (hx : 0 â‰¤ x) (hx' : x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "âˆ€ (x : â„) (hx : x âˆˆ Set.Icc 0 1), Filter.Tendsto (Î» n => x ^ n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "forall (x : â„) (hx : 0 â‰¤ x) (hx' : x â‰¤ 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "âˆ€ {x : â„}, x âˆˆ Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "âˆ€ (x : â„) (hx : 0 â‰¤ x âˆ§ x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (ite (x < 1) 0 1)) ",
      "âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„) (hx : x âˆˆ Icc (0 : â„) 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (ite (x = 1) 1 0)) "
    ]
  },
  {
    "docString": "Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  ContinuousAt f x â†’\\n    Filter.Tendsto g p (nhds x) â†’\\n      (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gâ‚™` tends to `x`, then `Fâ‚™ (gâ‚™)` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [inst_2 : CompactSpace Î±],\\n  Filter.Tendsto F p (nhds f) â†” TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence in the compact-open topology is the same as uniform convergence for sequences of\\ncontinuous functions on a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  ContinuousWithinAt f s x â†’\\n    Filter.Tendsto g p (nhdsWithin x s) â†’\\n      (âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\\nwhich is continuous at `x` within `s `, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ (gâ‚™)` tends\\nto `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {l : Filter Î¹} {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ]\\n  [inst_2 : NormedSpace ğ•œ E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] {f : Î¹ â†’ E â†’ G}\\n  {g : E â†’ G} {f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G} {g' : E â†’ E â†’L[ğ•œ] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) â†’\\n    (âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) â†’\\n      (âˆ€á¶  (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) â†’\\n        TendstoUniformlyOnFilter (fun n y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\\n  UniformContinuous g â†’ TendstoUniformly F f p â†’ TendstoUniformly (fun i => g âˆ˜ F i) (g âˆ˜ f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing on the left by a uniformly continuous function preserves uniform convergence \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)}, TendstoLocallyUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’ Filter.Tendsto F p (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Locally uniform convergence implies convergence in the compact-open topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] {Î¹ : Type u_1} [inst_1 : PseudoMetricSpace Î²] (b : â„ â†’ â„),\\n  Filter.Tendsto b (nhds 0) (nhds 0) â†’\\n    âˆ€ (F : Î¹ â†’ Î² â†’ Î±), (âˆ€ (x y : Î²) (i : Î¹), dist (F i x) (F i y) â‰¤ b (dist x y)) â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n y = F y` in a neighbourhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±}\\n  {p : Filter Î¹} [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\\n  UniformContinuous g â†’ TendstoUniformlyOn F f p s â†’ TendstoUniformlyOn (fun i => g âˆ˜ F i) (g âˆ˜ f) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform convergence on a set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  1 â‰¤ p â†’\\n    p â‰  âŠ¤ â†’\\n      (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n        MeasureTheory.Memâ„’p g p â†’\\n          MeasureTheory.UnifIntegrable f p Î¼ â†’\\n            MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\\n              Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\\nconverge in Lp to `g`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹}\\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s â†’ x âˆˆ s â†’ Cauchy (Filter.map (fun i => F i x) p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\\na Cauchy sequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {A : Set (Î² â†’ Î±)},\\n  Set.UniformEquicontinuous A â†’ Set.UniformEquicontinuous (closure A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of functions is uniformly equicontinuous, its closure for the product topology is also\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  1 â‰¤ p â†’\\n    p â‰  âŠ¤ â†’\\n      (âˆ€ (n : â„•), MeasureTheory.Memâ„’p (f n) p) â†’\\n        MeasureTheory.Memâ„’p g p â†’\\n          (MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g âˆ§ MeasureTheory.UnifIntegrable f p Î¼ â†”\\n            Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali's convergence theorem**: A sequence of functions `f` converges to `g` in Lp if and\\nonly if it is uniformly integrable and converges to `g` in measure. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If `Fâ‚™` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gâ‚™` tends to `x`, then `Fâ‚™ (gâ‚™)` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  ContinuousAt f x â†’\n    Filter.Tendsto g p (nhds x) â†’\n      (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [inst_2 : CompactSpace Î±],\n  Filter.Tendsto F p (nhds f) â†” TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If `Fâ‚™` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ (gâ‚™)` tends\nto `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  ContinuousWithinAt f s x â†’\n    Filter.Tendsto g p (nhdsWithin x s) â†’\n      (âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` -/\ntheorem âˆ€ {Î¹ : Type u_3} {l : Filter Î¹} {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ]\n  [inst_2 : NormedSpace ğ•œ E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] {f : Î¹ â†’ E â†’ G}\n  {g : E â†’ G} {f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G} {g' : E â†’ E â†’L[ğ•œ] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) â†’\n    (âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) â†’\n      (âˆ€á¶  (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) â†’\n        TendstoUniformlyOnFilter (fun n y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l\n          (nhds x) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\n  UniformContinuous g â†’ TendstoUniformly F f p â†’ TendstoUniformly (fun i => g âˆ˜ F i) (g âˆ˜ f) p :=\n\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)}, TendstoLocallyUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’ Filter.Tendsto F p (nhds f) :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] {Î¹ : Type u_1} [inst_1 : PseudoMetricSpace Î²] (b : â„ â†’ â„),\n  Filter.Tendsto b (nhds 0) (nhds 0) â†’\n    âˆ€ (F : Î¹ â†’ Î² â†’ Î±), (âˆ€ (x y : Î²) (i : Î¹), dist (F i x) (F i y) â‰¤ b (dist x y)) â†’ UniformEquicontinuous F :=\n\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. -/\ntheorem âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y :=\n\n/-- Composing on the left by a uniformly continuous function preserves\nuniform convergence on a set -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±}\n  {p : Filter Î¹} [inst_1 : UniformSpace Î³] {g : Î² â†’ Î³},\n  UniformContinuous g â†’ TendstoUniformlyOn F f p s â†’ TendstoUniformlyOn (fun i => g âˆ˜ F i) (g âˆ˜ f) p s :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\nconverge in Lp to `g`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  1 â‰¤ p â†’\n    p â‰  âŠ¤ â†’\n      (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n        MeasureTheory.Memâ„’p g p â†’\n          MeasureTheory.UnifIntegrable f p Î¼ â†’\n            MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\n              Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0) :=\n\n/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹}\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s â†’ x âˆˆ s â†’ Cauchy (Filter.map (fun i => F i x) p) :=\n\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {A : Set (Î² â†’ Î±)},\n  Set.UniformEquicontinuous A â†’ Set.UniformEquicontinuous (closure A) :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousAt f x :=\n\n/-- **Vitali's convergence theorem**: A sequence of functions `f` converges to `g` in Lp if and\nonly if it is uniformly integrable and converges to `g` in measure. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  1 â‰¤ p â†’\n    p â‰  âŠ¤ â†’\n      (âˆ€ (n : â„•), MeasureTheory.Memâ„’p (f n) p) â†’\n        MeasureTheory.Memâ„’p g p â†’\n          (MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g âˆ§ MeasureTheory.UnifIntegrable f p Î¼ â†”\n            Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0)) :=\n\n/-- Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {f : â„• â†’ Î± â†’ Î²} {x : â„• â†’ Î±} {xâ‚€ : Î±} {fâ‚€ : Î± â†’ Î²},\n  Filter.Tendsto x Filter.atTop (nhds xâ‚€) â†’\n    TendstoUniformly f fâ‚€ Filter.atTop â†’\n      (âˆ€ (n : â„•), Continuous (f n)) â†’ Continuous fâ‚€ â†’ Filter.Tendsto (fun n => f n (x n)) Filter.atTop (nhds (fâ‚€ xâ‚€)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  ContinuousAt f x â†’\n    Filter.Tendsto g p (nhds x) â†’\n      TendstoUniformly F f p â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {f : Î¹ â†’ C(Î±, Î²)} {x : Î±}\n  {p : Filter Î¹} {F : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²},\n  TendstoUniformly (fun i => â†‘(f i)) g p â†’ Filter.Tendsto F p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] {X : Î± â†’ Î²} [inst_1 : MetricSpace Î²] {F : Î¹ â†’ Î± â†’ Î²}\n  {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  Filter.Tendsto g p (nhds x) â†’\n    TendstoUniformly F f p â†’\n      Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²}\n  {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto g p (nhds x) â†’\n      (âˆ€ (i : Î¹), Continuous (F i)) â†’ Continuous f â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±] {g : Î¹ â†’ Î±},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {f : Î¹ â†’ Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±},\n  TendstoUniformly f x p â†’\n    Filter.Tendsto g p (nhds x) â†’\n      Filter.Tendsto (fun n => f n (g n)) p (nhds (x x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] (g : Î± â†’ Î²) {F : Î¹ â†’ Î± â†’ Î²} {x : Î±}\n  {p : Filter Î¹} {p' : Filter Î±} [inst_2 : Filter.NeBot p],\n  TendstoUniformly F g p â†’\n    Filter.Tendsto x p' (nhds x) â†’\n      âˆ€á¶  (y : Î¹) in p, Filter.Tendsto (fun n => F n (x n)) (Filter.map x p') (nhds (g y)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±},\n  Continuous f â†’\n    Filter.Tendsto g p (nhds x) â†’\n      TendstoUniformly F f p â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : TopologicalSpace Î±] [inst_1 : MetricSpace Î²] {f : Î¹ â†’ Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î± â†’ Î²} {x_n : Î¹ â†’ Î±},\n  Continuous f â†’\n    Filter.Tendsto x_n p (nhds x) â†’\n      TendstoUniformly f g p â†’ Filter.Tendsto (fun n => f n (x_n n)) p (nhds (g x)) "
    ]
  },
  {
    "docString": "If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\":\n  \"âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\\n  {s : Set ((n : â„•) â†’ E n)},\\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a retraction onto this\\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. \"},\n {\"theorem\":\n  \"âˆ€ (Râ‚ : Type u_2) {A : Type u_1} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : Algebra Râ‚ A] (I : Ideal A),\\n  Function.Surjective â†‘(Ideal.Quotient.mkâ‚ Râ‚ I)\",\n  \"isProp\": true,\n  \"docString\": \"The canonical morphism `A â†’â‚[Râ‚] I.quotient` is surjective. \"},\n {\"theorem\": \"âˆ€ {Î± : Sort u} {Î² : Sort v}, Function.Injective fun e => â†‘e\",\n  \"isProp\": true,\n  \"docString\": \"The map `(r â‰ƒ s) â†’ (r â†’ s)` is injective. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (r : Setoid Î±), EqvGen.Setoid Setoid.r = r\",\n  \"isProp\": true,\n  \"docString\": \"The equivalence closure of an equivalence relation r is r. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X Y : C},\\n  IsEquiv (X âŸ¶ Y) r\",\n  \"isProp\": true,\n  \"docString\": \"`r` is an equivalence on every hom-set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (self : Î± â‰ƒâ‚œ Î²),\\n  Continuous self.invFun\",\n  \"isProp\": true,\n  \"docString\": \"The inverse map of a homeomorphism is a continuous function. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\": \"âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\\nthen `R â†’ R[X]/P` is an integral map. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Î“ T]\\n  [inst_6 : ProperlyDiscontinuousSMul Î“ T], T2Space (Quotient (MulAction.orbitRel Î“ T))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by a discontinuous group action of a locally compact t2 space is t2. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f g : Con.Quotient c â†’* P),\\n  (âˆ€ (a : M), â†‘f â†‘a = â†‘g â†‘a) â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\\nare equal on elements that are coercions from the monoid. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} {f : Î± â†’ Î²} (h : Setoid.ker f â‰¤ r) (hf : Function.Surjective f),\\n  Setoid.map r f = Setoid.mapOfSurjective r f h hf\",\n  \"isProp\": true,\n  \"docString\":\n  \"A special case of the equivalence closure of an equivalence relation r equalling r. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P A : Type u} [inst_1 : CommRing A] [inst_2 : Algebra R A] [inst_3 : CommRing P]\\n  [inst_4 : Algebra R P] (f : P â†’â‚[R] A),\\n  Function.Surjective â†‘f â†’\\n    âˆ€ [inst_5 : Algebra.FormallySmooth R P],\\n      Algebra.FormallySmooth R A â†” âˆƒ g, AlgHom.comp (AlgHom.kerSquareLift f) g = AlgHom.id R A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P â†’â‚[R] A` be a surjection with kernel `J`, and `P` a formally smooth `R`-algebra,\\nthen `A` is formally smooth over `R` iff the surjection `P â§¸ J ^ 2 â†’â‚[R] A` has a section.\\n\\nGeometric intuition: we require that a first-order thickening of `Spec A` inside `Spec P` admits\\na retraction. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\\n  {S : CategoryTheory.Functor C D} {T : D} [inst_2 : CategoryTheory.Limits.HasColimits C]\\n  [inst_3 : CategoryTheory.Limits.PreservesColimits S] {A : CategoryTheory.CostructuredArrow S T}\\n  (P : CategoryTheory.Subobject (Opposite.op A))\\n  {q :\\n    S.obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.CostructuredArrow.projectQuotient P)).unop âŸ¶\\n      (CategoryTheory.Functor.fromPUnit T).obj A.right}\\n  (hq :\\n    CategoryTheory.CategoryStruct.comp\\n        (S.map (CategoryTheory.Subobject.arrow (CategoryTheory.CostructuredArrow.projectQuotient P)).unop) q =\\n      A.hom),\\n  CategoryTheory.CostructuredArrow.liftQuotient (CategoryTheory.CostructuredArrow.projectQuotient P) hq = P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Projecting and then lifting a quotient recovers the original quotient, because there is at most\\none morphism making the projected quotient into a costructured arrow. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\\n  ContinuousOn f s â†’ TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a map is continuous on a separable set `s`, then the image of `s` is also separable. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r :=\n\n/-- Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. -/\ntheorem âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\n  {s : Set ((n : â„•) â†’ E n)},\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ Continuous f :=\n\n/-- The canonical morphism `A â†’â‚[Râ‚] I.quotient` is surjective. -/\ntheorem âˆ€ (Râ‚ : Type u_2) {A : Type u_1} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : Algebra Râ‚ A] (I : Ideal A),\n  Function.Surjective â†‘(Ideal.Quotient.mkâ‚ Râ‚ I) :=\n\n/-- The map `(r â‰ƒ s) â†’ (r â†’ s)` is injective. -/\ntheorem âˆ€ {Î± : Sort u} {Î² : Sort v}, Function.Injective fun e => â†‘e :=\n\n/-- The equivalence closure of an equivalence relation r is r. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Setoid Î±), EqvGen.Setoid Setoid.r = r :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- `r` is an equivalence on every hom-set. -/\ntheorem âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X Y : C},\n  IsEquiv (X âŸ¶ Y) r :=\n\n/-- The inverse map of a homeomorphism is a continuous function. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (self : Î± â‰ƒâ‚œ Î²),\n  Continuous self.invFun :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c) :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\nthen `R â†’ R[X]/P` is an integral map. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C) :=\n\n/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Î“ T]\n  [inst_6 : ProperlyDiscontinuousSMul Î“ T], T2Space (Quotient (MulAction.orbitRel Î“ T)) :=\n\n/-- Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\nare equal on elements that are coercions from the monoid. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f g : Con.Quotient c â†’* P),\n  (âˆ€ (a : M), â†‘f â†‘a = â†‘g â†‘a) â†’ f = g :=\n\n/-- A special case of the equivalence closure of an equivalence relation r equalling r. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} {f : Î± â†’ Î²} (h : Setoid.ker f â‰¤ r) (hf : Function.Surjective f),\n  Setoid.map r f = Setoid.mapOfSurjective r f h hf :=\n\n/-- Let `P â†’â‚[R] A` be a surjection with kernel `J`, and `P` a formally smooth `R`-algebra,\nthen `A` is formally smooth over `R` iff the surjection `P â§¸ J ^ 2 â†’â‚[R] A` has a section.\n\nGeometric intuition: we require that a first-order thickening of `Spec A` inside `Spec P` admits\na retraction. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P A : Type u} [inst_1 : CommRing A] [inst_2 : Algebra R A] [inst_3 : CommRing P]\n  [inst_4 : Algebra R P] (f : P â†’â‚[R] A),\n  Function.Surjective â†‘f â†’\n    âˆ€ [inst_5 : Algebra.FormallySmooth R P],\n      Algebra.FormallySmooth R A â†” âˆƒ g, AlgHom.comp (AlgHom.kerSquareLift f) g = AlgHom.id R A :=\n\n/-- Projecting and then lifting a quotient recovers the original quotient, because there is at most\none morphism making the projected quotient into a costructured arrow. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\n  {S : CategoryTheory.Functor C D} {T : D} [inst_2 : CategoryTheory.Limits.HasColimits C]\n  [inst_3 : CategoryTheory.Limits.PreservesColimits S] {A : CategoryTheory.CostructuredArrow S T}\n  (P : CategoryTheory.Subobject (Opposite.op A))\n  {q :\n    S.obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.CostructuredArrow.projectQuotient P)).unop âŸ¶\n      (CategoryTheory.Functor.fromPUnit T).obj A.right}\n  (hq :\n    CategoryTheory.CategoryStruct.comp\n        (S.map (CategoryTheory.Subobject.arrow (CategoryTheory.CostructuredArrow.projectQuotient P)).unop) q =\n      A.hom),\n  CategoryTheory.CostructuredArrow.liftQuotient (CategoryTheory.CostructuredArrow.projectQuotient P) hq = P :=\n\n/-- If a map is continuous on a separable set `s`, then the image of `s` is also separable. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  ContinuousOn f s â†’ TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f '' s) :=\n\n/-- If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {A : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace A] {r : Î± â†’ A},\n  Continuous r â†’ IsRetraction A r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {A : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace A] {r : Î± â†’ A},\n  (âˆ€ (a : A), r a = a) â†’ Continuous r â†’ QuotientMap r ",
      "forall {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {A : Set Î±},\n  Continuous f â†’ (âˆ€ (a : Î±), a âˆˆ A â†’ f a = a) â†’ Set.range f = A â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  Continuous r âˆ§ Set.range r âŠ† A âˆ§ (âˆ€ x : Î±, x âˆˆ A â†’ r x = x) â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  IsRetraction A r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  IsRetraction A r â†’ Continuous r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {f : Î± â†’ Î²},\n  Continuous f â†’ Set.range f = s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ f x = x) â†’ QuotientMap f ",
      "forall {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  Continuous r â†’ (âˆ€ a âˆˆ A, r a = a) â†’ Set.range r = A â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  Continuous f â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ f x = x) â†’ Set.range f = s â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  IsClosed s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ f x = x) â†’ Continuous f â†’ Set.range f = s â†’ QuotientMap f "
    ]
  },
  {
    "docString": "Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\\n    Pairwise (Disjoint on s) â†’\\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsClopen (s i)) â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"}]\n",
    "prompt_cons": "/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\n    Pairwise (Disjoint on s) â†’\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹ :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsClopen (s i)) â†’ Subsingleton Î¹ :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- A nonempty convex set is path connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s :=\n\n/-- Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] {A : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} [Preorder Î¹] {A : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsConnected (A i)) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (A i âˆ© A (i + 1))) â†’ IsConnected (â‹ƒ (i : Î¹), A i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [inst_1 : LinearOrder Î¹] [inst_2 : SuccOrder Î¹] [inst_3 : IsPreirreducibleOrder Î¹]\n  {Z : Î¹ â†’ Set Î±} (H : âˆ€ (i : Î¹), IsConnected (Z i)) (K : âˆ€ (i : Î¹), Set.Nonempty (Z i âˆ© Z (SuccOrder.succ i))),\n  IsConnected (â‹ƒ (i : Î¹), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) "
    ]
  },
  {
    "docString": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite type with cofinite topology is an irreducible topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that definability is closed under finite projections. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] [inst_5 : T2Space E] {s : Set E},\\n  Set.Finite s â†’ IsClosed (â†‘(convexHull â„) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  Â¬Continuous â†‘CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"}]\n",
    "prompt_cons": "/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- An infinite type with cofinite topology is an irreducible topological space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Shows that definability is closed under finite projections. -/\ntheorem âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s) :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Convex hull of a finite set is closed. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] [inst_5 : T2Space E] {s : Set E},\n  Set.Finite s â†’ IsClosed (â†‘(convexHull â„) s) :=\n\n/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  Â¬Continuous â†‘CofiniteTopology.of.symm :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s) :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Show that if $X$ is an infinite set, it is connected in the finite complement topology. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Infinite Î±] [inst_2 : CofiniteTopology Î±],\n  IsConnected Set.univ ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], IsConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  IsConnected (CofiniteTopology X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : CofiniteTopology X],\n  IsConnected Set.univ ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], IsConnected (Set.Univ : Set (CofiniteTopology X)) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Infinite Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±],\n  IsConnected Set.univ ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], IsConnected (CofiniteTopology X) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], TopologicalSpace.ConnectedSpace (CofiniteTopology Î±) "
    ]
  },
  {
    "docString": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category C]\\n  [inst_1 : âˆ€ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\\n  CategoryTheory.Limits.HasBinaryCoproducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} (x : Î±),\\n  (âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any point of a set is joined to a fixed point by a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±) (c : Set (Set Î±)),\\n  (âˆ€ (s : Set Î±), s âˆˆ c â†’ x âˆˆ s) â†’ (âˆ€ (s : Set Î±), s âˆˆ c â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A union of a family of preconnected sets with a common point is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±},\\n  IsConnected s â†’ âˆ€ (f : Î± â†’ Î²), ContinuousOn f s â†’ IsConnected (f '' s)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\\n  OpenEmbedding â†‘f â†’\\n    OpenEmbedding â†‘g â†’\\n      OpenEmbedding\\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B}\\n  (f : CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y),\\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X â†’ X = Y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\\nthe arrows. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"}]\n",
    "prompt_cons": "/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem âˆ€ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 : âˆ€ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.Limits.HasBinaryCoproducts C :=\n\n/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} (x : Î±),\n  (âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s :=\n\n/-- A union of a family of preconnected sets with a common point is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±) (c : Set (Set Î±)),\n  (âˆ€ (s : Set Î±), s âˆˆ c â†’ x âˆˆ s) â†’ (âˆ€ (s : Set Î±), s âˆˆ c â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ c) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The image of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±},\n  IsConnected s â†’ âˆ€ (f : Î± â†’ Î²), ContinuousOn f s â†’ IsConnected (f '' s) :=\n\n/-- If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. -/\ntheorem âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\n  OpenEmbedding â†‘f â†’\n    OpenEmbedding â†‘g â†’\n      OpenEmbedding\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x} :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X â†’ X = Y :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ â†’ IsProperSubset B Set.univ â†’ IsConnected X â†’ IsConnected Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {B : Set Î²} {X Y : Set Î±},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {X Y : Set Î±} {A B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  {A : Set Î±} {B : Set Î²} {X : Set Î±} {Y : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’\n    IsConnected ((X Ã—Ë¢ Y) - (A Ã—Ë¢ B)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ â†’\n    IsProperSubset B Set.univ â†’\n      ConnectedSpace X â†’\n        ConnectedSpace Y â†’ IsConnected (Set.prod Set.univ Set.univ - Set.prod A B) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ â†’ IsProperSubset B Set.univ â†’ IsConnected X â†’ IsConnected Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {B : Set Î²} {X : Set Î±} {Y : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X Ã— Y) - (A Ã— B)) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ â†’ IsProperSubset B Set.univ â†’ IsConnected X â†’ IsConnected Y â†’ IsConnected (Set.diff (X Ã—â‚“ Y) (A Ã—â‚“ B)) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ â†’\n  IsProperSubset B Set.univ â†’\n  ConnectedSpace X â†’\n  ConnectedSpace Y â†’\n  IsConnected (Set.Product (Set.univ - A) (Set.univ - B)) ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (A : Set X) (B : Set Y),\n  IsProperSubset A Set.univ â†’\n    IsProperSubset B Set.univ â†’\n      IsConnected X â†’\n        IsConnected Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) "
    ]
  },
  {
    "docString": "Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x\",\n  \"isProp\": true,\n  \"docString\": \"The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’ Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ Set.EqOn f g S âˆ¨ Set.EqOn f (-g) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\\n`S`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\\n  [inst_3 : Module â„ E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  0 âˆˆ s â†’ Convex â„ s â†’ IsOpen s â†’ âˆ€ {xâ‚€ : E}, Â¬xâ‚€ âˆˆ s â†’ âˆƒ f, â†‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â†‘f x < 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\\nall of `s` to values strictly below `1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚) (s : Set â„‚),\\n  Set.Countable s â†’\\n    ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n      (âˆ€ (x : â„‚),\\n          x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) \\\\ s â†’\\n            HasFDerivAt f (f' x) x) â†’\\n        MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\\n            (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n          (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) -\\n                  âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\\n                Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\\n            âˆ« (x : â„) in z.re..w.re,\\n              âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\\n`z w : â„‚`, is *real* differentiable at all but countably many points of the corresponding open\\nrectangle, and $\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the\\nintegral of `f` over the boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictAnti (deriv f) â†’ StrictConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly antitone on `â„` then `f` is strictly\\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict antitonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]\\n  [inst_2 : InnerProductSpace â„ E] [inst_3 : InnerProductSpace â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F},\\n  HasFDerivAt f f' x â†’\\n    ConformalAt f x â†’ âˆ€ (u v : E), InnerProductGeometry.angle (â†‘f' u) (â†‘f' v) = InnerProductGeometry.angle u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real differentiable map `f` is conformal at a point `x`,\\nthen it preserves the angles at that point. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} {E : Type u_1} {F : Type u_2} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚] (x : E),\\n  LipschitzWith â€–xâ€–â‚Š fun f => â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Evaluation of a continuous linear map `f` at a point is Lipschitz continuous in `f`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚),\\n  ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n    (âˆ€ (x : â„‚),\\n        x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) â†’\\n          HasFDerivAt f (f' x) x) â†’\\n      MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\\n          (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n        (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\\n            Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\\n          âˆ« (x : â„) in z.re..w.re,\\n            âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\\n`z w : â„‚`, is *real* differentiable on the corresponding open rectangle, and\\n$\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the integral of `f` over\\nthe boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : Î± â†’ Real.Angle} {s : Set Î±} {x y : Î±},\\n  IsConnected s â†’\\n    ContinuousOn f s â†’\\n      (âˆ€ (z : Î±), z âˆˆ s â†’ f z â‰  0 âˆ§ f z â‰  â†‘Real.pi) â†’ x âˆˆ s â†’ y âˆˆ s â†’ Real.Angle.sign (f y) = Real.Angle.sign (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose a function to angles is continuous on a connected set and never takes the values `0`\\nor `Ï€` on that set. Then the values of the function on that set all have the same sign. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : DecidableEq Î¹] (i : Î¹),\\n  Continuous fun f => Function.update f.fst i f.snd\",\n  \"isProp\": true,\n  \"docString\": \"`Function.update f i x` is continuous in `(f, x)`. \"}]\n",
    "prompt_cons": "/-- If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. -/\ntheorem âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’ Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ Set.EqOn f g S âˆ¨ Set.EqOn f (-g) S :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\n  [inst_3 : Module â„ E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  0 âˆˆ s â†’ Convex â„ s â†’ IsOpen s â†’ âˆ€ {xâ‚€ : E}, Â¬xâ‚€ âˆˆ s â†’ âˆƒ f, â†‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â†‘f x < 1 :=\n\n/-- Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\n`z w : â„‚`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚) (s : Set â„‚),\n  Set.Countable s â†’\n    ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n      (âˆ€ (x : â„‚),\n          x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) \\ s â†’\n            HasFDerivAt f (f' x) x) â†’\n        MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\n            (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n          (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) -\n                  âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n                Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n            âˆ« (x : â„) in z.re..w.re,\n              âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I :=\n\n/-- If a function `f` is continuous and `f'` is strictly antitone on `â„` then `f` is strictly\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict antitonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictAnti (deriv f) â†’ StrictConcaveOn â„ Set.univ f :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If a real differentiable map `f` is conformal at a point `x`,\nthen it preserves the angles at that point. -/\ntheorem âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]\n  [inst_2 : InnerProductSpace â„ E] [inst_3 : InnerProductSpace â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F},\n  HasFDerivAt f f' x â†’\n    ConformalAt f x â†’ âˆ€ (u v : E), InnerProductGeometry.angle (â†‘f' u) (â†‘f' v) = InnerProductGeometry.angle u v :=\n\n/-- Evaluation of a continuous linear map `f` at a point is Lipschitz continuous in `f`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} {E : Type u_1} {F : Type u_2} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚] (x : E),\n  LipschitzWith â€–xâ€–â‚Š fun f => â†‘f x :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\n`z w : â„‚`, is *real* differentiable on the corresponding open rectangle, and\n$\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the integral of `f` over\nthe boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚),\n  ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n    (âˆ€ (x : â„‚),\n        x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) â†’\n          HasFDerivAt f (f' x) x) â†’\n      MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\n          (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n        (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n            Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n          âˆ« (x : â„) in z.re..w.re,\n            âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- Suppose a function to angles is continuous on a connected set and never takes the values `0`\nor `Ï€` on that set. Then the values of the function on that set all have the same sign. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : Î± â†’ Real.Angle} {s : Set Î±} {x y : Î±},\n  IsConnected s â†’\n    ContinuousOn f s â†’\n      (âˆ€ (z : Î±), z âˆˆ s â†’ f z â‰  0 âˆ§ f z â‰  â†‘Real.pi) â†’ x âˆˆ s â†’ y âˆˆ s â†’ Real.Angle.sign (f y) = Real.Angle.sign (f x) :=\n\n/-- `Function.update f i x` is continuous in `(f, x)`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] [inst_1 : DecidableEq Î¹] (i : Î¹),\n  Continuous fun f => Function.update f.fst i f.snd :=\n\n/-- Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$. -/\ntheorem",
    "choices": [
      "âˆ€ (f : Circle â†’ â„), Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f ",
      "âˆ€ (f : â†¥circle â„), Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ (f : Circle â†’ â„), Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ (f : CircleD1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = â†‘f (-x) ",
      "âˆ€ (f : Circle â†’ â„), Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ (f : Circle â†’ â„), Continuous f â†’ âˆƒ x : Circle, f x = f (-x) ",
      "âˆ€ (f : Circle â†’ â„), Continuous f â†’ âˆƒ x : Circle, f x = f (-x) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E], (âˆ€ (x : E), x âˆˆ Circle â†’ âˆƒ z, x = circleMap z)\n  â†’ âˆƒ (x : E) (z : â„), x âˆˆ Circle âˆ§ x = circleMap z âˆ§ f x = f (-x) ",
      "âˆ€ {f : Circle â†’ â„}, Continuous f â†’ âˆƒ x, f x = f (-x) "
    ]
  },
  {
    "docString": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (pâ‚ pâ‚‚ : Path x y),\\n  Path.Homotopic pâ‚ pâ‚‚\",\n  \"isProp\": true,\n  \"docString\": \"In a simply connected space, any two paths are homotopic \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U W : Set X},\\n  IsPathConnected W â†’ W âŠ† U â†’ IsPathConnected (Subtype.val â»Â¹' W)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\\nambient type `U` (when `U` contains `W`). \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally connected charts, then the space itself is\\nlocally connected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y],\\n  SimplyConnectedSpace Y â†” PathConnectedSpace Y âˆ§ âˆ€ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is simply connected iff it is path connected, and there is at most one path\\nup to homotopy between any two points. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)}, TendstoLocallyUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’ Filter.Tendsto F p (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Locally uniform convergence implies convergence in the compact-open topology. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : TopologicalSpace.SecondCountableTopology X],\\n  MeasureTheory.LocallyIntegrable f â†’\\n    âˆƒ u, (âˆ€ (n : â„•), IsOpen (u n)) âˆ§ â‹ƒ (n : â„•), u n = Set.univ âˆ§ âˆ€ (n : â„•), MeasureTheory.IntegrableOn f (u n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally integrable in a second countable topological space,\\nthen there exists a sequence of open sets covering the space on which it is integrable. \"}]\n",
    "prompt_cons": "/-- A nonempty convex set is path connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î± :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- In a simply connected space, any two paths are homotopic -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (pâ‚ pâ‚‚ : Path x y),\n  Path.Homotopic pâ‚ pâ‚‚ :=\n\n/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U W : Set X},\n  IsPathConnected W â†’ W âŠ† U â†’ IsPathConnected (Subtype.val â»Â¹' W) :=\n\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- A space is simply connected iff it is path connected, and there is at most one path\nup to homotopy between any two points. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y],\n  SimplyConnectedSpace Y â†” PathConnectedSpace Y âˆ§ âˆ€ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y) :=\n\n/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)}, TendstoLocallyUniformly (fun i a => â†‘(F i) a) (â†‘f) p â†’ Filter.Tendsto F p (nhds f) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If a function is locally integrable in a second countable topological space,\nthen there exists a sequence of open sets covering the space on which it is integrable. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : TopologicalSpace.SecondCountableTopology X],\n  MeasureTheory.LocallyIntegrable f â†’\n    âˆƒ u, (âˆ€ (n : â„•), IsOpen (u n)) âˆ§ â‹ƒ (n : â„•), u n = Set.univ âˆ§ âˆ€ (n : â„•), MeasureTheory.IntegrableOn f (u n) :=\n\n/-- Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] (U : Set X),\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] (U : Set X),\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X}, IsOpen U â†’ IsConnected U â†’ IsPathConnected U "
    ]
  },
  {
    "docString": "Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  Metric.Bounded s â†’ IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"}]\n",
    "prompt_cons": "/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- The **Heineâ€“Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V) :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  Metric.Bounded s â†’ IsCompact (closure s) :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  {A : Set (Set Î±)} (hA : DirectedOn (âŠ†) A) (h2A : âˆ€ a âˆˆ A, IsClosed a âˆ§ IsConnected a),\n  IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {A : Set (Set Î±)}, \n  (âˆ€ (a : Set Î±), a âˆˆ A â†’ IsClosed a) â†’ (âˆ€ (a : Set Î±), a âˆˆ A â†’ IsConnected a) â†’ âˆ€ {aâ‚ aâ‚‚ : Set Î±},\n  aâ‚ âˆˆ A â†’ aâ‚‚ âˆˆ A â†’ aâ‚ âŠ† aâ‚‚ âˆ¨ aâ‚‚ âŠ† aâ‚ â†’ IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {A : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), HasMem.Mem s A â†’ IsClosed s âˆ§ IsConnected s) â†’\n  Zorn.Chain HasSubset.Subset A â†’ IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  {A : Set (Set Î±)}, (âˆ€ (a : Set Î±), a âˆˆ A â†’ IsClosed a âˆ§ IsConnected a)\n  â†’ Zorn.Chain HasSubset.Subset A â†’ âˆƒ Y, Y âŠ† A âˆ§ IsConnected Y ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±] {A : Set (Set Î±)},\n  DirectedOn (âŠ†) A â†’ (âˆ€ a âˆˆ A, IsConnected a) â†’ (âˆ€ a âˆˆ A, IsClosed a) â†’ IsConnected (â‹‚â‚€ A) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  {A : Set (Set Î±)}, (âˆ€ (s : Set Î±), HasMem.Mem s A â†’ IsClosed s âˆ§ IsConnected s) â†’ Zorn.Chain HasSubset.Subset A â†’\n  IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X] {A : Set (Set X)},\n  Set.SimplyOrdered A â†’ (âˆ€ a âˆˆ A, IsConnected a) â†’ IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  {A : Set (Set X)}, PairwiseDisjoint A â†’ (âˆ€ U âˆˆ A, IsConnected U) â†’ (âˆ€ U âˆˆ A, IsClosed U) â†’\n  âˆ€ {U V : Set X}, IsDirectedOn HasSubset.Subset A â†’ IsOpen U â†’ IsOpen V â†’ (âˆ©â‚€ A âŠ† U âˆª V) â†’\n  (âˆ©â‚€ A âˆ© U â‰  âˆ… â†’ âˆ©â‚€ A âˆ© V â‰  âˆ… â†’ âˆ©â‚€ A âˆ© (U âˆ© V) â‰  âˆ…) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  âˆ€ {A : Set (Set Î±)}, âˆ€ (hA : âˆ€ (s : Set Î±), s âˆˆ A â†’ IsConnected s âˆ§ IsClosed s),\n  âˆ€ (hA_mono : âˆ€ (s t : Set Î±), s âˆˆ A â†’ t âˆˆ A â†’ s âŠ† t âˆ¨ t âŠ† s),\n  IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X] {A : Set (Set X)},\n  (âˆ€ s âˆˆ A, IsClosed s âˆ§ IsConnected s) â†’ Zorn.Chain HasSubset.Subset A â†’\n  IsConnected (â‹‚â‚€ A) "
    ]
  },
  {
    "docString": "Show that a connected metric space having more than one point is uncountable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\\n  IsOpenMap Quotient.mk' â†’ TopologicalSpace.SecondCountableTopology (Quotient S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open quotient of a second countable space is second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\\nspace from countably many data. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} {x : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasurableSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.AEStronglyMeasurable f Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies ae strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A proper pseudo metric space is sigma compact, and therefore second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] [inst_1 : Countable Î¹]\\n  [inst_2 : âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology (E i)],\\n  TopologicalSpace.SecondCountableTopology ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A countable disjoint union of second countable spaces is second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\\n  Monotone f â†’\\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\\n      Set.Countable {x | Â¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where a monotone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î±], Set.Countable {x | nhdsWithin x (Set.Iio x) = âŠ¥}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points which are isolated on the left is countable when the space is\\nsecond-countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"}]\n",
    "prompt_cons": "/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- An open quotient of a second countable space is second countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\n  IsOpenMap Quotient.mk' â†’ TopologicalSpace.SecondCountableTopology (Quotient S) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\nspace from countably many data. -/\ntheorem âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- In a space with second countable topology, measurable implies ae strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} {x : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasurableSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.AEStronglyMeasurable f Î¼ :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- A proper pseudo metric space is sigma compact, and therefore second countable. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- A countable disjoint union of second countable spaces is second countable. -/\ntheorem âˆ€ {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] [inst_1 : Countable Î¹]\n  [inst_2 : âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology (E i)],\n  TopologicalSpace.SecondCountableTopology ((i : Î¹) Ã— E i) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- In a second countable space, the set of points where a monotone function is not continuous\nis at most countable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\n  Monotone f â†’\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\n      Set.Countable {x | Â¬ContinuousAt f x} :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î±], Set.Countable {x | nhdsWithin x (Set.Iio x) = âŠ¥} :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- Show that a connected metric space having more than one point is uncountable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±],\n  (âˆ€ (x : Î±), âˆƒ (y : Î±), x â‰  y) â†’ Â¬Set.Countable (Set.Univ : Set Î±) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±],\n  (âˆƒ x y : Î±, x â‰  y) â†’ Â¬Set.Countable (Set.Univ : Set Î±) ",
      "forall {X : Type u} [inst : MetricSpace X] [inst_1 : TopologicalSpace.ConnectedSpace X], 2 â‰¤ cardinal.mk X â†’ Â¬Set.Countable X ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Set.Countable Î± â†’ Nonempty Î± â†’ âˆƒ x y, x â‰  y ",
      "forall {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], 2 â‰¤ Cardinal.mk Î± â†’ Â¬Set.Countable Î± ",
      "forall {Î± : Type u} [inst : MetricSpace Î±] [self : ConnectedSpace Î±],\n  (âˆƒ x y, x â‰  y) â†’ Â¬Set.Countable (Set.Univ : Set Î±) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Nontrivial Î± â†’ Â¬(Set.Countable Î±) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± â†’ (âˆƒ x y : Î±, x â‰  y) â†’ Â¬Set.Countable Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Nonempty Î± â†’ (Exists (x y : Î±), x â‰  y) â†’ Â¬Set.Countable Î± ",
      "forall {Î± : Type u} [mÎ± : MetricSpace Î±] [inst : ConnectedSpace Î±], Nonempty Î± â†’\n  (âˆƒ (x y : Î±), x â‰  y) â†’ Â¬Set.Countable (Set.Univ Î±) "
    ]
  },
  {
    "docString": "Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  IsSeqCompact s â†’ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `â„•`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Nonempty s â†’ (Set.Countable s â†” âˆƒ f, Function.Surjective f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A non-empty set is countable iff there exists a surjection from the\\nnatural numbers onto the subtype induced by the set.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the type of nonempty compact subsets is second countable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  IsSeqCompact s â†’ IsCompact s :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `â„•`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- A non-empty set is countable iff there exists a surjection from the\nnatural numbers onto the subtype induced by the set. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Nonempty s â†’ (Set.Countable s â†” âˆƒ f, Function.Surjective f) :=\n\n/-- In a second countable space, the type of nonempty compact subsets is second countable -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (Z i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’\n          (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X â†”\n    âˆ€ (C : â„• â†’ Set X),\n      (âˆ€ (i : â„•), IsClosed (C i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (C i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’\n          (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (A : â„• â†’ Set Î±), (âˆ€ (n : â„•), IsClosed (A n)) â†’ (âˆ€ (n : â„•), Set.Nonempty (A n)) â†’\n      (âˆ€ (n : â„•), A (n + 1) âŠ† A n) â†’ Set.Nonempty (â‹‚ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (C i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’\n          (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’\n            Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (Z i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’\n          (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’\n        (âˆ€ (i : â„•), IsClosed (Z i)) â†’\n          (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) "
    ]
  },
  {
    "docString": "Show that the rationals $\\mathbb{Q}$ are not locally compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Non-Denumerability of the Continuum**: The reals are not countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\\n  Disjoint (nhds x) (Filter.cocompact Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Î“ T]\\n  [inst_6 : ProperlyDiscontinuousSMul Î“ T], T2Space (Quotient (MulAction.orbitRel Î“ T))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by a discontinuous group action of a locally compact t2 space is t2. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second theorem states that locally compact spaces are Baire. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R}, a â‰  0 â†’ IsRegular a\",\n  \"isProp\": true,\n  \"docString\": \"Non-zero elements of an integral domain are regular. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], Â¬IsField R\",\n  \"isProp\": true,\n  \"docString\": \"A discrete valuation ring `R` is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstVAdd Î“ T]\\n  [inst_6 : ProperlyDiscontinuousVAdd Î“ T], T2Space (Quotient (AddAction.orbitRel Î“ T))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by a discontinuous group action of a locally compact t2\\nspace is t2.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (m : M), 0 â‰¤ â€–â†‘(QuotientAddGroup.mk' S) mâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The quotient norm is nonnegative. \"}]\n",
    "prompt_cons": "/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ :=\n\n/-- **Non-Denumerability of the Continuum**: The reals are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\n  Disjoint (nhds x) (Filter.cocompact Î±) :=\n\n/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Î“ T]\n  [inst_6 : ProperlyDiscontinuousSMul Î“ T], T2Space (Quotient (MulAction.orbitRel Î“ T)) :=\n\n/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- The second theorem states that locally compact spaces are Baire. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î± :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- Non-zero elements of an integral domain are regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R}, a â‰  0 â†’ IsRegular a :=\n\n/-- A discrete valuation ring `R` is not a field. -/\ntheorem âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], Â¬IsField R :=\n\n/-- The quotient by a discontinuous group action of a locally compact t2\nspace is t2. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstVAdd Î“ T]\n  [inst_6 : ProperlyDiscontinuousVAdd Î“ T], T2Space (Quotient (AddAction.orbitRel Î“ T)) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast :=\n\n/-- The quotient norm is nonnegative. -/\ntheorem âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (m : M), 0 â‰¤ â€–â†‘(QuotientAddGroup.mk' S) mâ€– :=\n\n/-- Show that the rationals $\\mathbb{Q}$ are not locally compact. -/\ntheorem",
    "choices": [
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„ ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„ ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„ ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š "
    ]
  },
  {
    "docString": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second theorem states that locally compact spaces are Baire. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\\n  [inst_3 : LocallyCompactSpace G] {U : Set G}, U âˆˆ nhds 1 â†’ âˆƒ K, IsCompact K âˆ§ IsClosed K âˆ§ K âŠ† U âˆ§ 1 âˆˆ interior K\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact group, any neighborhood of the identity contains a compact closed\\nneighborhood of the identity, even without separation assumptions on the space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"}]\n",
    "prompt_cons": "/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- The second theorem states that locally compact spaces are Baire. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î± :=\n\n/-- In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V) :=\n\n/-- The **Heineâ€“Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î± :=\n\n/-- In a locally compact group, any neighborhood of the identity contains a compact closed\nneighborhood of the identity, even without separation assumptions on the space. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\n  [inst_3 : LocallyCompactSpace G] {U : Set G}, U âˆˆ nhds 1 â†’ âˆƒ K, IsCompact K âˆ§ IsClosed K âˆ§ K âŠ† U âˆ§ 1 âˆˆ interior K :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, IsOpen V âˆ§ V âŠ† U âˆ§ x âˆˆ V âˆ§ IsCompact (closure V) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  U âˆˆ nhds x â†’ âˆƒ V, IsOpen V âˆ§ x âˆˆ V âˆ§ V âŠ† U âˆ§ IsCompact (closure V) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±),\n  (âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ âˆ€ (U : Set Î±), U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ (âˆƒ V, IsOpen V âˆ§ x âˆˆ V âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [hÎ± : LocallyCompactSpace Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) (U : Set Î±),\n  U âˆˆ nhds x â†’ LocallyCompactSpace Î± â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  U âˆˆ nhds x â†’ âˆƒ V, IsOpen V âˆ§ x âˆˆ V âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U "
    ]
  },
  {
    "docString": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen t â†’ Dense (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a dense set with an open dense set is a dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen s â†’ Dense (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of an open dense set with a dense set is a dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  s âˆˆ residual Î± â†”\\n    âˆƒ S, (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsOpen t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ Dense t) âˆ§ Set.Countable S âˆ§ â‹‚â‚€ S âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is residual iff it includes a countable intersection of dense open sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {t : Set Î¹} {s : Set Î±},\\n  IsGÎ´ s â†’\\n    Dense s â†’\\n      Set.Countable t â†’\\n        âˆ€ {f : Î¹ â†’ Set Î±},\\n          (âˆ€ (i : Î¹), i âˆˆ t â†’ IsClosed (f i)) â†’\\n            s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), f i â†’ Dense (â‹ƒ (i : Î¹) (_ : i âˆˆ t), interior (f i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors\\nis dense. Formulated here with a union over a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is an encodable type. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- There exists a countable dense set. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen t â†’ Dense (s âˆ© t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen s â†’ Dense (s âˆ© t) :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h) :=\n\n/-- A set is residual iff it includes a countable intersection of dense open sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±},\n  s âˆˆ residual Î± â†”\n    âˆƒ S, (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsOpen t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ Dense t) âˆ§ Set.Countable S âˆ§ â‹‚â‚€ S âŠ† s :=\n\n/-- If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors\nis dense. Formulated here with a union over a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {t : Set Î¹} {s : Set Î±},\n  IsGÎ´ s â†’\n    Dense s â†’\n      Set.Countable t â†’\n        âˆ€ {f : Î¹ â†’ Set Î±},\n          (âˆ€ (i : Î¹), i âˆˆ t â†’ IsClosed (f i)) â†’\n            s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), f i â†’ Dense (â‹ƒ (i : Î¹) (_ : i âˆˆ t), interior (f i)) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²), interior (f s)) :=\n\n/-- Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  Set.PairwiseDisjoint (Set.Range s) s â†’\n    (âˆ€ (i : Î¹), IsOpen (s i)) â†’ (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Set.Countable (Set.Range s) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  Set.PairwiseDisjoint (range s) (Î» x y, Disjoint x y) â†’\n    (âˆ€ (i : Î¹), IsOpen (s i)) â†’ (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Set.Countable (Set.Range s) ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  LocallyFinite s â†’ Set.PairwiseDisjoint s â†’ Set.Countable (Function.Support s) ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  Set.PairwiseDisjoint (Set.Range s) id â†’ (âˆ€ (i : Î¹), IsOpen (s i)) â†’ (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Set.Countable (Set.Range s) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i j : Î¹), i â‰  j â†’ Disjoint (s i) (s j)) â†’\n    (âˆ€ (i : Î¹), IsOpen (s i)) â†’ Set.Countable (Set.Range s) ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a "
    ]
  },
  {
    "docString": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” closure s = closure t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two sets are at zero Hausdorff distance if and only if they have the same closures \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T25Space Î±] â¦ƒx y : Î±â¦„,\\n  x â‰  y â†’ Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a Tâ‚‚.â‚… space, their filters of closed neighborhoods are\\ndisjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±}, EMetric.hausdorffEdist s t = 0 â†” closure s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two sets are at zero Hausdorff edistance if and only if they have the same closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T5Space Î±] â¦ƒs t : Set Î±â¦„,\\n  Disjoint (closure s) t â†’ Disjoint s (closure t) â†’ Disjoint (nhdsSet s) (nhdsSet t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\\nadmit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ (EMetric.hausdorffEdist s t = 0 â†” s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.hausdorffDist s (closure s) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance between a set and its closure vanish \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"}]\n",
    "prompt_cons": "/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Two sets are at zero Hausdorff distance if and only if they have the same closures -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” closure s = closure t) :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- Given two distinct points in a Tâ‚‚.â‚… space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T25Space Î±] â¦ƒx y : Î±â¦„,\n  x â‰  y â†’ Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t) :=\n\n/-- Two sets are at zero Hausdorff edistance if and only if they have the same closure -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±}, EMetric.hausdorffEdist s t = 0 â†” closure s = closure t :=\n\n/-- If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\nadmit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T5Space Î±] â¦ƒs t : Set Î±â¦„,\n  Disjoint (closure s) t â†’ Disjoint s (closure t) â†’ Disjoint (nhdsSet s) (nhdsSet t) :=\n\n/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ (EMetric.hausdorffEdist s t = 0 â†” s = t) :=\n\n/-- The Hausdorff distance between a set and its closure vanish -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.hausdorffDist s (closure s) = 0 :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedClosures s t ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ s âŠ† U âˆ§ t âŠ† V âˆ§ Disjoint (closure U) (closure V) "
    ]
  },
  {
    "docString": "Show that a closed subspace of a normal space is normal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œâ‚ : Type u_1} {ğ•œâ‚‚ : Type u_2} [inst : NontriviallyNormedField ğ•œâ‚] [inst_1 : NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚}\\n  {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst_2 : SeminormedAddCommGroup Mâ‚] [inst_3 : AddCommGroup Mâ‚‚]\\n  [inst_4 : NormedSpace ğ•œâ‚ Mâ‚] [inst_5 : Module ğ•œâ‚‚ Mâ‚‚] [inst_6 : UniformSpace Mâ‚‚] [inst_7 : UniformAddGroup Mâ‚‚]\\n  [inst_8 : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [inst_9 : T2Space Mâ‚‚] [inst_10 : CompleteSpace Mâ‚‚],\\n  IsClosed {f | IsCompactOperator â†‘f}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsOpen (u i)) â†’\\n    (âˆ€ (x : X), Set.Finite {i | x âˆˆ u i}) â†’\\n      â‹ƒ (i : Î¹), u i = Set.univ â†’\\n        âˆƒ v, Set.iUnion v = Set.univ âˆ§ (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \\\"shrunk\\\"\\nto a new open cover so that the closure of each new open set is contained in the corresponding\\noriginal open set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two orthogonal subspaces equals the subspace orthogonal\\nto the sup. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- Affine subspaces are convex. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem âˆ€ {ğ•œâ‚ : Type u_1} {ğ•œâ‚‚ : Type u_2} [inst : NontriviallyNormedField ğ•œâ‚] [inst_1 : NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚}\n  {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst_2 : SeminormedAddCommGroup Mâ‚] [inst_3 : AddCommGroup Mâ‚‚]\n  [inst_4 : NormedSpace ğ•œâ‚ Mâ‚] [inst_5 : Module ğ•œâ‚‚ Mâ‚‚] [inst_6 : UniformSpace Mâ‚‚] [inst_7 : UniformAddGroup Mâ‚‚]\n  [inst_8 : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [inst_9 : T2Space Mâ‚‚] [inst_10 : CompleteSpace Mâ‚‚],\n  IsClosed {f | IsCompactOperator â†‘f} :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new open cover so that the closure of each new open set is contained in the corresponding\noriginal open set. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsOpen (u i)) â†’\n    (âˆ€ (x : X), Set.Finite {i | x âˆˆ u i}) â†’\n      â‹ƒ (i : Î¹), u i = Set.univ â†’\n        âˆƒ v, Set.iUnion v = Set.univ âˆ§ (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i :=\n\n/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—® :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s) :=\n\n/-- Show that a closed subspace of a normal space is normal. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {A : Set Î±},\n  IsClosed A â†’ NormalSpace {x // x âˆˆ A} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s : Set Î±}, IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Submodule Î±),\n  IsClosed â†‘s â†’ NormalSpace { x // x âˆˆ s } ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {S : Set Î±},\n  IsClosed S â†’ NormalSpace { x // x âˆˆ S } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace (Projectivization.Subspace Î± s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {S : Set Î±},\n  IsClosed S â†’ NormalSpace { x // x âˆˆ S } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Submodule Î±),\n  IsClosed â†‘s â†’ NormalSpace { x // x âˆˆ s } "
    ]
  },
  {
    "docString": "Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a â†’ IsSMulRegular M s â†’ IsSMulRegular M (a â€¢ s)\",\n  \"isProp\": true,\n  \"docString\": \"The product of `M`-regular elements is `M`-regular. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Multiset Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Multiset Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a â†” a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a non-trivial integral domain, an element is regular iff it is non-zero. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Array Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Array Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Mul Î±] [inst_2 : ContinuousMul Î±], ContinuousMul Î±áµáµ’áµ–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them\\nare nonzero. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Finset Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Finset Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsLeftRegular a â†’ IsLeftRegular b â†’ IsLeftRegular (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a semigroup, the product of left-regular elements is left-regular. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a : R} (b : R), IsLeftRegular a â†’ (IsLeftRegular (a * b) â†” IsLeftRegular b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element is left-regular if and only if multiplying it on the left by a left-regular element\\nis left-regular. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {a : R} [inst : Monoid R] (n : â„•), IsLeftRegular a â†’ IsLeftRegular (a ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Any power of a left-regular element is left-regular. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} {a b : R} [inst : SMul R M] [inst_1 : Mul R] [inst_2 : IsScalarTower R R M],\\n  IsSMulRegular M (a * b) âˆ§ IsSMulRegular M (b * a) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are `M`-regular if and only if both products `a * b` and `b * a`\\nare `M`-regular. \"}]\n",
    "prompt_cons": "/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b :=\n\n/-- The product of `M`-regular elements is `M`-regular. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a â†’ IsSMulRegular M s â†’ IsSMulRegular M (a â€¢ s) :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s } :=\n\n/-- If `Î±` is countable, then so is `Multiset Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Multiset Î±) :=\n\n/-- Finite product of finite sets is finite -/\ntheorem âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t) :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- In a non-trivial integral domain, an element is regular iff it is non-zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a â†” a â‰  0 :=\n\n/-- If `Î±` is countable, then so is `Array Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Array Î±) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Mul Î±] [inst_2 : ContinuousMul Î±], ContinuousMul Î±áµáµ’áµ– :=\n\n/-- If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0 :=\n\n/-- If `Î±` is countable, then so is `Finset Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Finset Î±) :=\n\n/-- In a semigroup, the product of left-regular elements is left-regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsLeftRegular a â†’ IsLeftRegular b â†’ IsLeftRegular (a * b) :=\n\n/-- An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a : R} (b : R), IsLeftRegular a â†’ (IsLeftRegular (a * b) â†” IsLeftRegular b) :=\n\n/-- Any power of a left-regular element is left-regular. -/\ntheorem âˆ€ {R : Type u_1} {a : R} [inst : Monoid R] (n : â„•), IsLeftRegular a â†’ IsLeftRegular (a ^ n) :=\n\n/-- Two elements `a` and `b` are `M`-regular if and only if both products `a * b` and `b * a`\nare `M`-regular. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} {a b : R} [inst : SMul R M] [inst_1 : Mul R] [inst_2 : IsScalarTower R R M],\n  IsSMulRegular M (a * b) âˆ§ IsSMulRegular M (b * a) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b :=\n\n/-- Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem",
    "choices": [
      "âˆ€ {Î¹ : Type u} {X : Î¹ â†’ Type v} [inst : (i : Î¹) â†’ Nonempty (X i)] [inst_1 : (i : Î¹) â†’ RegularSpace (X i)],\n  RegularSpace (Î  (i : Î¹), X i) â†’ âˆ€ i, RegularSpace (X i) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Semigroup (Î± i)]\n  [inst_1 : (i : Î¹) â†’ Nonempty (Î± i)] {p : (i : Î¹) â†’ Prop},\n  (âˆ€ i, p (Î± i)) â†’ (âˆ€ i a b, p (Î± i) â†’ p (Î± i) â†’ p (Î± i)) â†’\n  p (Î  (i : Î¹), Î± i) â†’ (âˆ€ i, p (Î± i)) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : (i : Î¹) â†’ Nonempty (X i)]\n  [inst_2 : âˆ€ (i : Î¹), T2Space (X i)] [inst_3 : TopologicalSpace (Î  (i : Î¹), X i)] [inst_4 : T2Space (Î  (i : Î¹), X i)]\n  (hprod : T2Space (Î  (i : Î¹), X i)), (âˆ€ (i : Î¹), T2Space (X i)) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [Î  i, TopologicalSpace (X i)] [Î  i, T2Space (X i)] [Î  i, Nonempty (X i)]\n  [inst : TopologicalSpace (Î  (i : Î¹), X i)] [inst_1 : T2Space (Î  (i : Î¹), X i)] [inst_2 : TopologicalSpace.RegularSpace (Î  (i : Î¹), X i)],\n  âˆ€ i, TopologicalSpace.RegularSpace (X i) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} (_inst : âˆ€ (i : Î¹), Nonempty (Î± i))\n  [inst_1 : (i : Î¹) â†’ Mul (Î± i)] [inst_2 : (i : Î¹) â†’ IsSMulRegular (Î± i) (Î± i)],\n  IsSMulRegular ((i : Î¹) â†’ Î± i) ((i : Î¹) â†’ Î± i) â†’ (i : Î¹) â†’ IsSMulRegular (Î± i) (Î± i) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (Î± i)]\n  [inst_2 : âˆ€ (i : Î¹), T2Space (Î± i)] [inst_3 : (âˆ€ (i : Î¹), RegularSpace (Î± i))]\n  (inst_4 : RegularSpace (Î  (i : Î¹), Î± i)) (i : Î¹), RegularSpace (Î± i) ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_5} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ AddCommGroup (X i)] [inst_1 : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_2 : âˆ€ (i : Î¹), TopologicalAddGroup (X i)] [inst_3 : T2Space (Î  (i : Î¹), X i)]\n  (h : âˆ€ (i : Î¹), Nonempty (X i)) (R : (Î  (i : Î¹), X i) â†’ (Î  (i : Î¹), X i) â†’ Prop)\n  (hr : IsEquivalence R) (hreg : âˆ€ (x y : Î  (i : Î¹), X i), R x y â†’ (x = y âˆ¨ IsRegular x âˆ§ IsRegular y)),\n  âˆ€ (i : Î¹), âˆ€ (x y : X i), R (Function.update (Î» (_x : Î¹), Classical.choice (h _x)) i x)\n    (Function.update (Î» (_x : Î¹), Classical.choice (h _x)) i y) â†’ (x = y âˆ¨ IsRegular x âˆ§ IsRegular y) ",
      "âˆ€ {Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Î¹ â†’ Type u_3} {X : Î¹' â†’ Type u_4} [inst : (i : Î¹) â†’ MulZeroClass (Î± i)]\n  [inst_1 : (i : Î¹') â†’ MulZeroClass (X i)] [inst_2 : (i : Î¹) â†’ NoZeroDivisors (Î± i)] [inst_3 : (i : Î¹') â†’ NoZeroDivisors (X i)]\n  (f : (i : Î¹) â†’ Î± i) (g : (i : Î¹') â†’ X i) (h : âˆ€ (i : Î¹), Nonempty (Î± i)) (h' : âˆ€ (i : Î¹'), Nonempty (X i)),\n  IsRegular (âˆá¶  (i : Î¹) (x : Î± i), f i * âˆá¶  (i : Î¹') (x : X i), g i) â†’\n  (âˆ€ (j : Î¹), IsRegular (f j)) âˆ§ âˆ€ (j : Î¹'), IsRegular (g j) ",
      "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : Nonempty Î¹] [inst_2 : âˆ€ i, Nonempty (Î± i)]\n  {f : Î  (i : Î¹), Set (Î± i)}, (âˆ€ (i : Î¹), IsCompact (f i)) â†’ IsCompact (Set.Pi Set.univ f) â†’ (âˆ€ (i : Î¹), IsCompact (f i)) ",
      "âˆ€ {Î¹ : Type u} {Î± : Î¹ â†’ Type v} [inst : (i : Î¹) â†’ TopologicalSpace (Î± i)] [inst_1 : (i : Î¹) â†’ Nonempty (Î± i)]\n  [inst_2 : T2Space (Î  (i : Î¹), Î± i)] [inst_3 : âˆ€ (i : Î¹), RegularSpace (Î± i)],\n  RegularSpace (Î  (i : Î¹), Î± i) "
    ]
  },
  {
    "docString": "Show that every locally compact Hausdorff space is regular.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\\n  MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second theorem states that locally compact spaces are Baire. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"}]\n",
    "prompt_cons": "/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\n  MeasureTheory.Measure.Regular Î¼ :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- The second theorem states that locally compact spaces are Baire. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î± :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î± :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Show that every locally compact Hausdorff space is regular. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± "
    ]
  },
  {
    "docString": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\\n    p âˆ… â†’\\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\\\ U)) â†’\\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a measure is inner regular (using closed or compact sets), then every measurable set of\\nfinite measure can by approximated by a (closed or compact) subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\\nthen there exists a continuous function `f : X â†’ â„` such that\\n\\n* `f` equals zero on `s`;\\n* `f` equals one on `t`;\\n* `0 â‰¤ f x â‰¤ 1` for all `x`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` continuous on a compact set `K` is integrable on this set with respect to any\\nlocally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"}]\n",
    "prompt_cons": "/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0 :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- If a measure is inner regular (using closed or compact sets), then every measurable set of\nfinite measure can by approximated by a (closed or compact) subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\n    p âˆ… â†’\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\ U)) â†’\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X â†’ â„` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 â‰¤ f x â‰¤ 1` for all `x`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any\nlocally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : TotallyDisconnectedSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] [inst_2 : NormalSpace Î±] {A B : Set Î±},\n  IsCompact A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : Î±), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : IsCompactSeparated X] {A B : Set X},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n    âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : CompletelyRegularSpace X]\n  {A B : Set X}, IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n    âˆƒ f : X â†’â‚€ â„, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : UniformSpace X] [inst_2 : CompletelyRegularSpace X]\n  {A B : Set X}, IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ (f : X â†’ â„), Continuous f âˆ§ Set.EqOn f 0 A âˆ§ Set.EqOn f 1 B âˆ§ âˆ€ (x : X), f x âˆˆ Set.Icc 0 1 "
    ]
  },
  {
    "docString": "Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-ÄŒech compactification of $X$ is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\\n  {n k â„“ Î¼ : â„•},\\n  SimpleGraph.IsSRGWith G n k â„“ Î¼ â†’ SimpleGraph.IsSRGWith Gá¶œ n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a strongly regular graph is strongly regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : RË£), IsSMulRegular M â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"Any element in `RË£` is `M`-regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\\n  MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (A : Subalgebra â„ C(X, â„)),\\n  Subalgebra.SeparatesPoints A â†’ Subalgebra.topologicalClosure A = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Stone-Weierstrass Approximation Theorem**,\\nthat a subalgebra `A` of `C(X, â„)`, where `X` is a compact topological space,\\nis dense if it separates points.\\n\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"}]\n",
    "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\n  {n k â„“ Î¼ : â„•},\n  SimpleGraph.IsSRGWith G n k â„“ Î¼ â†’ SimpleGraph.IsSRGWith Gá¶œ n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“)) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- Any element in `RË£` is `M`-regular. -/\ntheorem âˆ€ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : RË£), IsSMulRegular M â†‘a :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î± :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\n  MeasureTheory.Measure.Regular Î¼ :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- The **Stone-Weierstrass Approximation Theorem**,\nthat a subalgebra `A` of `C(X, â„)`, where `X` is a compact topological space,\nis dense if it separates points. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (A : Subalgebra â„ C(X, â„)),\n  Subalgebra.SeparatesPoints A â†’ Subalgebra.topologicalClosure A = âŠ¤ :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s) :=\n\n/-- A nonempty convex set is path connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-ÄŒech compactification of $X$ is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : SeparationSpace Î±] [inst_2 : CompletelyRegularSpace Î±] [inst_3 : T0Space Î±],\n  ConnectedSpace Î± â†” ConnectedSpace (StoneCech Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] [inst_2 : CompletelyRegularSpace Î±],\n  ConnectedSpace Î± â†” ConnectedSpace (StoneCechCompactification Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] [inst_2 : PreconnectedSpace Î±] [inst_3 : CompletelyRegularSpace Î±],\n  ConnectedSpace (StoneCech Î±) â†” ConnectedSpace Î± ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompletelyRegularSpace Î±],\n  ConnectedSpace Î± â†” ConnectedSpace (StoneCechCompactification Î±) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : CompletelyRegularSpace Î±] [inst_2 : T0Space Î±],\n  ConnectedSpace Î± â†” ConnectedSpace (Compactum Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompletelyRegularSpace Î±] [inst_2 : PreconnectedSpace Î±],\n  PreconnectedSpace (StoneCech Î±) â†” ConnectedSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.Separation.Î± Î±] [inst_2 : PreconnectedSpace Î±],\n  ConnectedSpace (StoneCechCompactification Î±) â†” ConnectedSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompletelyRegularSpace Î±],\n  ConnectedSpace Î± â†” ConnectedSpace (StoneCechCompactification Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompletelyRegularSpace Î±] [inst_2 : PreconnectedSpace Î±],\n  CompactSpace (StoneCech Î±) â†’ ConnectedSpace (StoneCech Î±) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompletelyRegularSpace Î±] [inst_2 : LocallyCompactSpace Î±],\n  ConnectedSpace Î± â†” ConnectedSpace (Compactum Î±) "
    ]
  },
  {
    "docString": "Prove that $-(-v) = v$ for every $v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (v : E), â†‘(reflection (Submodule.span ğ•œ {v})á—®) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\\n  Matrix.IsSymm (Matrix.circulant v) â†” âˆ€ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"A circulant of `v` is symmetric iff `v` equals its reverse. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\\n  I â‰  0 â†’\\n    Associates.count (Associates.mk v.asIdeal)\\n        (Associates.factors\\n          (Associates.mk\\n            (âˆá¶  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I))) =\\n      Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `v` in `âˆ_v v^(val_v(I))` equals `val_v(I)`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {vâ‚ vâ‚‚ : RayVector R M}, -vâ‚ â‰ˆ -vâ‚‚ â†” vâ‚ â‰ˆ vâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero vectors are equivalent, so are their negations. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R),\\n  âˆƒ Ï€, IsDedekindDomain.HeightOneSpectrum.intValuationDef v Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists `Ï€ âˆˆ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] (K : Type u_1)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R),\\n  âˆƒ Ï€, â†‘(IsDedekindDomain.HeightOneSpectrum.valuation v) Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists `Ï€ âˆˆ K` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G),\\n  ZeroHom.toFun self.toZeroHom (-r) = ZeroHom.toFun self.toZeroHom r\",\n  \"isProp\": true,\n  \"docString\": \"The seminorm is invariant under negation. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : AddGroup Î±]\\n  [inst_1 : OrderedAddCommMonoid Î²] [self : AddGroupSeminormClass F Î± Î²] (f : F) (a : Î±), â†‘f (-a) = â†‘f a\",\n  \"isProp\": true,\n  \"docString\": \"The map is invariant under negation of its argument. \"},\n {\"theorem\":\n  \"âˆ€ {v : Sat.Valuation} {a : Prop} {n : â„•}, (v n â†” a) â†’ Sat.Literal.reify v (Sat.Literal.pos n) Â¬a\",\n  \"isProp\": true,\n  \"docString\": \"The reification of a positive literal `Â¬âŸ¦aâŸ§_v â‰¡ Â¬a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : NonAssocRing Î±] [inst_1 : NonAssocRing Î²] (f : Î± â†’+* Î²) (x y : Î±),\\n  â†‘f (x - y) = â†‘f x - â†‘f y\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve subtraction. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\\n  [inst_6 : MeasureTheory.SigmaFinite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„,\\n  MeasureTheory.Integrable f â†’\\n    MeasureTheory.Integrable g â†’\\n      âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ =\\n        âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\": \"Double integrals commute with subtraction. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : SubtractionMonoid Î²] (f : Î± â†’+ Î²) (a : Î±), â†‘f (-a) = -â†‘f a\",\n  \"isProp\": true,\n  \"docString\": \"Additive group homomorphisms preserve negation.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\\n  reflection âŠ¥ = LinearIsometryEquiv.neg ğ•œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reflection through the trivial subspace {0} is just negation. \"}]\n",
    "prompt_cons": "/-- The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), â†‘(reflection (Submodule.span ğ•œ {v})á—®) v = -v :=\n\n/-- If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- A circulant of `v` is symmetric iff `v` equals its reverse. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\n  Matrix.IsSymm (Matrix.circulant v) â†” âˆ€ (i : n), v (-i) = v i :=\n\n/-- The multiplicity of `v` in `âˆ_v v^(val_v(I))` equals `val_v(I)`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\n  I â‰  0 â†’\n    Associates.count (Associates.mk v.asIdeal)\n        (Associates.factors\n          (Associates.mk\n            (âˆá¶  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I))) =\n      Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) :=\n\n/-- **Liouville's Theorem** -/\ntheorem âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x :=\n\n/-- If two nonzero vectors are equivalent, so are their negations. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {vâ‚ vâ‚‚ : RayVector R M}, -vâ‚ â‰ˆ -vâ‚‚ â†” vâ‚ â‰ˆ vâ‚‚ :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- There exists `Ï€ âˆˆ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R),\n  âˆƒ Ï€, IsDedekindDomain.HeightOneSpectrum.intValuationDef v Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1)) :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- There exists `Ï€ âˆˆ K` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] (K : Type u_1)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R),\n  âˆƒ Ï€, â†‘(IsDedekindDomain.HeightOneSpectrum.valuation v) Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1)) :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The seminorm is invariant under negation. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G),\n  ZeroHom.toFun self.toZeroHom (-r) = ZeroHom.toFun self.toZeroHom r :=\n\n/-- The map is invariant under negation of its argument. -/\ntheorem âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : AddGroup Î±]\n  [inst_1 : OrderedAddCommMonoid Î²] [self : AddGroupSeminormClass F Î± Î²] (f : F) (a : Î±), â†‘f (-a) = â†‘f a :=\n\n/-- The reification of a positive literal `Â¬âŸ¦aâŸ§_v â‰¡ Â¬a`. -/\ntheorem âˆ€ {v : Sat.Valuation} {a : Prop} {n : â„•}, (v n â†” a) â†’ Sat.Literal.reify v (Sat.Literal.pos n) Â¬a :=\n\n/-- Ring homomorphisms preserve subtraction. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : NonAssocRing Î±] [inst_1 : NonAssocRing Î²] (f : Î± â†’+* Î²) (x y : Î±),\n  â†‘f (x - y) = â†‘f x - â†‘f y :=\n\n/-- Double integrals commute with subtraction. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\n  [inst_6 : MeasureTheory.SigmaFinite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„,\n  MeasureTheory.Integrable f â†’\n    MeasureTheory.Integrable g â†’\n      âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ =\n        âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n\n/-- Additive group homomorphisms preserve negation. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : SubtractionMonoid Î²] (f : Î± â†’+ Î²) (a : Î±), â†‘f (-a) = -â†‘f a :=\n\n/-- Reflection through the trivial subspace {0} is just negation. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\n  reflection âŠ¥ = LinearIsometryEquiv.neg ğ•œ :=\n\n/-- Prove that $-(-v) = v$ for every $v \\in V$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E] (v : E),\n  -(-v) = v ",
      "forall {ğ•œ : Type u_2} {E : Type u_1} [inst : Ring ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E] (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : Ring ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E] (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : Ring ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E] (v : E), -(-v) = v ",
      "âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : Field ğ•œ] [inst_1 : AddGroup E] [inst_2 : Module ğ•œ E]\n  (v : E), -(-v) = v ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : Ring ğ•œ] [inst_1 : Invertible (-1 : ğ•œ)] [inst_2 : AddCommGroup E] [inst_3 : Module ğ•œ E]\n  (v : E), -(-v) = v "
    ]
  },
  {
    "docString": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under subtraction \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x : R}, x âˆˆ s â†’ -x âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under negation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x : K}, x âˆˆ s â†’ xâ»Â¹ âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under inverses. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\": \"âˆ€ {a b : Ordinal.{u_1}}, Set.Nonempty {o | a â‰¤ b + o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of subtraction is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under subtraction. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"}]\n",
    "prompt_cons": "/-- A non-unital subring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- A non-unital subring is closed under subtraction -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- A non-unital subring is closed under negation. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x : R}, x âˆˆ s â†’ -x âˆˆ s :=\n\n/-- A subsemiring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- A non-unital subring is closed under multiplication. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- A subfield is closed under inverses. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x : K}, x âˆˆ s â†’ xâ»Â¹ âˆˆ s :=\n\n/-- A subfield is closed under addition. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- The set in the definition of subtraction is nonempty. -/\ntheorem âˆ€ {a b : Ordinal.{u_1}}, Set.Nonempty {o | a â‰¤ b + o} :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- A subring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s :=\n\n/-- A subfield is closed under subtraction. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$. -/\ntheorem",
    "choices": [
      "Providing an example is beyond the scope of translating to Lean code based on the examples provided. My purpose is to translate natural language statements into Lean theorem prover code, not to provide examples or solve problems. Please provide a specific statement that you'd like me to translate into Lean code.",
      "Sorry, I am an AI language model and I am not able to provide examples of math problems. I can only help you with translating theorems into Lean code.",
      "example : âˆƒ U : Set (â„ Ã— â„), (âˆ€ uâ‚ uâ‚‚ âˆˆ U, uâ‚ + uâ‚‚ âˆˆ U) âˆ§ (âˆ€ u âˆˆ U, -u âˆˆ U) âˆ§ Â¬(âˆ€ u v âˆˆ U, u - v âˆˆ U) ",
      "Sorry, as a coding assistant, I cannot provide examples. My purpose is to translate given examples into Lean Theorem Prover code. Please provide an example, and I can help you translate it into Lean code.",
      "I cannot provide an example in the form of a theorem. However, I can describe an example: consider the subset U of â„Â² formed by the union of the x-axis and the y-axis. U is closed under addition and taking additive inverses, but it is not a subspace of â„Â² because it is not closed under scalar multiplication.",
      "example : âˆƒ U : Set (â„ Ã— â„), (âˆ€ uâ‚ uâ‚‚ âˆˆ U, uâ‚ + uâ‚‚ âˆˆ U) âˆ§ (âˆ€ u âˆˆ U, -u âˆˆ U) âˆ§ Â¬(âˆƒ V : Subspace â„ (â„ Ã— â„), U = â†‘V) ",
      "example : âˆƒ U : Set (â„ Ã— â„), (âˆ€ uâ‚ uâ‚‚ âˆˆ U, uâ‚ + uâ‚‚ âˆˆ U) âˆ§ (âˆ€ u âˆˆ U, -u âˆˆ U) âˆ§ Â¬Subspace â„ U ",
      "example : âˆƒ U : Set (â„ Ã— â„), (âˆ€ x y âˆˆ U, x + y âˆˆ U) âˆ§ (âˆ€ x âˆˆ U, -x âˆˆ U) âˆ§ Â¬(âˆ€ x y âˆˆ U, x - y âˆˆ U) ",
      "Sorry, I cannot provide an example in this format. Please try asking in natural language without the Lean Theorem Prover context.",
      "This is not a theorem, but I can provide an example of such a set:\n\nExample: Consider the set U = {(x, y) âˆˆ â„Â² | x â‰¥ 0 âˆ§ y â‰¥ 0}. This set is closed under addition, because if (xâ‚, yâ‚) âˆˆ U and (xâ‚‚, yâ‚‚) âˆˆ U, then (xâ‚ + xâ‚‚, yâ‚ + yâ‚‚) âˆˆ U as both xâ‚ + xâ‚‚ and yâ‚ + yâ‚‚ are non-negative. The set is also closed under taking additive inverses, because if (x, y) âˆˆ U, then its additive inverse is (-x, -y), and since x and y are non-negative, -x and -y are non-positive, so (-x, -y) âˆˆ U.\n\nHowever, U is not a subspace of â„Â² because it does not contain the zero vector (0, 0)."
    ]
  },
  {
    "docString": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two affine subspaces, coerced to a set, is the intersection of the two sets of\\npoints. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V},\\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points in projective space is contained in a subspace, and that subspace is\\ncontained in the span of the set of points, then the span of the set of points is equal to\\nthe subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P},\\n  p âˆˆ sâ‚ â†’ p âˆˆ sâ‚‚ â†’ (sâ‚ = sâ‚‚ â†” AffineSubspace.direction sâ‚ = AffineSubspace.direction sâ‚‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with nonempty intersection are equal if and only if their directions are\\nequal. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Function.Injective SetLike.coe\",\n  \"isProp\": true,\n  \"docString\": \"Two affine subspaces are equal if they have the same points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t â†’ s âŠ† t â†’ Monoid.Closure s âŠ† t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submonoid generated by a set is contained in any submonoid that contains the set. \"}]\n",
    "prompt_cons": "/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- Affine subspaces are convex. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—® :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- The inf of two affine subspaces, coerced to a set, is the intersection of the two sets of\npoints. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2 :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- If a set of points in projective space is contained in a subspace, and that subspace is\ncontained in the span of the set of points, then the span of the set of points is equal to\nthe subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V},\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Two affine subspaces with nonempty intersection are equal if and only if their directions are\nequal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P},\n  p âˆˆ sâ‚ â†’ p âˆˆ sâ‚‚ â†’ (sâ‚ = sâ‚‚ â†” AffineSubspace.direction sâ‚ = AffineSubspace.direction sâ‚‚) :=\n\n/-- Two affine subspaces are equal if they have the same points. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Function.Injective SetLike.coe :=\n\n/-- In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S) :=\n\n/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t â†’ s âŠ† t â†’ Monoid.Closure s âŠ† t :=\n\n/-- Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u} {V : Type u_1} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (S : Set (Submodule ğ•œ V)),\n  IsSubmodule (â‹‚â‚€ S) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Projectivization.Subspace K V), IsSubspace (â‹‚ (i : Î¹), â†‘(s i)) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type*}\n  (s : Î¹ â†’ Projectivization.Subspace K V), IsSubspace (â‹‚ (i : Î¹), â†‘(s i)) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {Î¹ : Type u_3} (s : Î¹ â†’ Submodule K V),\n  IsSubmodule (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (S : Î¹ â†’ Submodule K V), IsSubmodule (â‹‚ (i : Î¹), S i) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Submodule K V),\n  IsSubmodule (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (S : Î¹ â†’ Submodule K V),\n  Submodule K V (â‹‚ (i : Î¹), S i) ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {s : Set (Projectivization.Subspace K V)},\n  IsSubspace (â‹‚â‚€ s) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w} (S : Î¹ â†’ Submodule K V),\n  IsSubmodule (â‹‚ (i : Î¹), S i) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (S : Î¹ â†’ Projectivization.Subspace K V), IsSubspace (â‹‚ i, â†‘(S i)) "
    ]
  },
  {
    "docString": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] {f : M â†’ Mâ‚‚}, IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x\",\n  \"isProp\": true,\n  \"docString\": \"A linear map preserves scalar multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†’ g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, if linear maps are inverse to each other on one side then they\\nare also inverse to each other on the other side. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 â€¢ x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†” g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\\nthey are inverse to each other on the other side. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†” Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ğ•œ : Type u_1} [inst_1 : Field ğ•œ] [inst_2 : Module ğ•œ M] (f : M â†’â‚—[ğ•œ] M),\\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ğ•œ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the tensor product of a scalar linear map and of an element of a normed space\\nis the product of the norms. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Mâ‚‚ : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid Mâ‚‚] {R : Type u_3} {S : Type u_4}\\n  [inst_2 : Semiring S] [inst_3 : SMul R M] [inst_4 : Module S M] [inst_5 : SMul R Mâ‚‚] [inst_6 : Module S Mâ‚‚]\\n  [self : LinearMap.CompatibleSMul M Mâ‚‚ R S] (fâ‚— : M â†’â‚—[S] Mâ‚‚) (c : R) (x : M), â†‘fâ‚— (c â€¢ x) = c â€¢ â†‘fâ‚— x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication by `R` of `M` can be moved through linear maps. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {f : Module.End K V}\\n  {Î¼ : K} {n : â„•}, Submodule.map f (Module.End.generalizedEigenrange f Î¼ n) â‰¤ Module.End.generalizedEigenrange f Î¼ n\",\n  \"isProp\": true,\n  \"docString\": \"A linear map maps a generalized eigenrange into itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type v} {Mâ‚‚ : Type w} [inst : Semiring R]\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)] [inst_2 : AddCommMonoid Mâ‚‚] [inst_3 : (i : Î¹) â†’ Module R (Mâ‚ i)]\\n  [inst_4 : Module R Mâ‚‚] (self : MultilinearMap R Mâ‚ Mâ‚‚) [inst_5 : DecidableEq Î¹] (m : (i : Î¹) â†’ Mâ‚ i) (i : Î¹) (c : R)\\n  (x : Mâ‚ i),\\n  MultilinearMap.toFun self (Function.update m i (c â€¢ x)) = c â€¢ MultilinearMap.toFun self (Function.update m i x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A multilinear map is compatible with scalar multiplication in every argument. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  (b : Basis Î¹ R M) {Râ‚ : Type u_2} [inst_3 : Semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Mâ‚ : Type u_4} [inst_4 : AddCommMonoid Mâ‚]\\n  [inst_5 : Module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â†’â‚›â‚—[Ïƒ] Mâ‚}, (âˆ€ (i : Î¹), â†‘fâ‚ (â†‘b i) = â†‘fâ‚‚ (â†‘b i)) â†’ fâ‚ = fâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear maps are equal if they are equal on basis vectors. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : InnerProductSpace ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E') (x y : E),\\n  inner (â†‘f x) (â†‘f y) = inner x y\",\n  \"isProp\": true,\n  \"docString\": \"A linear isometry preserves the inner product. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.range b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite family of vectors is linearly independent if and only if\\nits cardinality equals the dimension of its span. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- A linear map preserves scalar multiplication. -/\ntheorem âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] {f : M â†’ Mâ‚‚}, IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x :=\n\n/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†’ g * f = 1 :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 â€¢ x = x :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†” g * f = 1 :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F) :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–) :=\n\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†” Function.Surjective â†‘f :=\n\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ğ•œ : Type u_1} [inst_1 : Field ğ•œ] [inst_2 : Module ğ•œ M] (f : M â†’â‚—[ğ•œ] M),\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ğ•œ M :=\n\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€– :=\n\n/-- Scalar multiplication by `R` of `M` can be moved through linear maps. -/\ntheorem âˆ€ {M : Type u_1} {Mâ‚‚ : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid Mâ‚‚] {R : Type u_3} {S : Type u_4}\n  [inst_2 : Semiring S] [inst_3 : SMul R M] [inst_4 : Module S M] [inst_5 : SMul R Mâ‚‚] [inst_6 : Module S Mâ‚‚]\n  [self : LinearMap.CompatibleSMul M Mâ‚‚ R S] (fâ‚— : M â†’â‚—[S] Mâ‚‚) (c : R) (x : M), â†‘fâ‚— (c â€¢ x) = c â€¢ â†‘fâ‚— x :=\n\n/-- A linear map maps a generalized eigenrange into itself. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {f : Module.End K V}\n  {Î¼ : K} {n : â„•}, Submodule.map f (Module.End.generalizedEigenrange f Î¼ n) â‰¤ Module.End.generalizedEigenrange f Î¼ n :=\n\n/-- A multilinear map is compatible with scalar multiplication in every argument. -/\ntheorem âˆ€ {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type v} {Mâ‚‚ : Type w} [inst : Semiring R]\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)] [inst_2 : AddCommMonoid Mâ‚‚] [inst_3 : (i : Î¹) â†’ Module R (Mâ‚ i)]\n  [inst_4 : Module R Mâ‚‚] (self : MultilinearMap R Mâ‚ Mâ‚‚) [inst_5 : DecidableEq Î¹] (m : (i : Î¹) â†’ Mâ‚ i) (i : Î¹) (c : R)\n  (x : Mâ‚ i),\n  MultilinearMap.toFun self (Function.update m i (c â€¢ x)) = c â€¢ MultilinearMap.toFun self (Function.update m i x) :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v :=\n\n/-- Two linear maps are equal if they are equal on basis vectors. -/\ntheorem âˆ€ {Î¹ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Î¹ R M) {Râ‚ : Type u_2} [inst_3 : Semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Mâ‚ : Type u_4} [inst_4 : AddCommMonoid Mâ‚]\n  [inst_5 : Module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â†’â‚›â‚—[Ïƒ] Mâ‚}, (âˆ€ (i : Î¹), â†‘fâ‚ (â†‘b i) = â†‘fâ‚‚ (â†‘b i)) â†’ fâ‚ = fâ‚‚ :=\n\n/-- A linear isometry preserves the inner product. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : InnerProductSpace ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E') (x y : E),\n  inner (â†‘f x) (â†‘f y) = inner x y :=\n\n/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.range b) :=\n\n/-- Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : V â†’â‚—[K] V),\n  Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V â†’â‚—[K] V},\n  Module.rank K V = 1 â†’ âˆƒ a, âˆ€ v, T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (h_dim : Module.rank K V = 1) (T : V â†’â‚—[K] V),\n  âˆƒ a : K, âˆ€ (v : V), â†‘T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {f : V â†’â‚—[K] V},\n  Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {f : V â†’â‚—[K] V},\n  Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 1 â†’ âˆ€ (f : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {f : V â†’â‚—[K] V},\n  Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {f : V â†’â‚—[K] V}, Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v "
    ]
  },
  {
    "docString": "Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card\\n        (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p)) \\\\ Multiset.toFinset (Polynomial.roots p)) +\\n      1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial `p` is at most the number of roots of its derivative\\nthat are not roots of `p` plus one. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ p` are the same. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m = 1 â†” Â¬â†‘p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\\nhas `Î¼ ^ m` as root. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•}, Nat.coprime m n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ m` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} [inst : Field K] {P : Polynomial K},\\n  Polynomial.Monic P â†’\\n    Polynomial.Splits (RingHom.id K) P â†’\\n      Polynomial.coeff P 0 = (-1) ^ Polynomial.natDegree P * Multiset.prod (Polynomial.roots P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ (m : â„•+) (p : Nat.Primes) (k : â„•), Pow.pow (â†‘p) k âˆ£ m â†” k â‰¤ Multiset.count p (PNat.factorMultiset m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of occurrences of p in the factor multiset of m\\nis the same as the p-adic valuation of m. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\\n  â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p â†’\\n    â†‘Polynomial.C (Polynomial.leadingCoeff p) *\\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - â†‘Polynomial.C a) (Polynomial.roots p)) =\\n      p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial `p` that has as many roots as its degree\\ncan be written `p = p.leadingCoeff * âˆ(X - a)`, for `a` in `p.roots`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"}]\n",
    "prompt_cons": "/-- The number of roots of a real polynomial `p` is at most the number of roots of its derivative\nthat are not roots of `p` plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card\n        (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p)) \\ Multiset.toFinset (Polynomial.roots p)) +\n      1 :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ p` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1 :=\n\n/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m = 1 â†” Â¬â†‘p âˆ£ m :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1 :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1 :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\nhas `Î¼ ^ m` as root. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m) :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ m` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•}, Nat.coprime m n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m) :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. -/\ntheorem âˆ€ {K : Type v} [inst : Field K] {P : Polynomial K},\n  Polynomial.Monic P â†’\n    Polynomial.Splits (RingHom.id K) P â†’\n      Polynomial.coeff P 0 = (-1) ^ Polynomial.natDegree P * Multiset.prod (Polynomial.roots P) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The number of occurrences of p in the factor multiset of m\nis the same as the p-adic valuation of m. -/\ntheorem âˆ€ (m : â„•+) (p : Nat.Primes) (k : â„•), Pow.pow (â†‘p) k âˆ£ m â†” k â‰¤ Multiset.count p (PNat.factorMultiset m) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leadingCoeff * âˆ(X - a)`, for `a` in `p.roots`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p â†’\n    â†‘Polynomial.C (Polynomial.leadingCoeff p) *\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - â†‘Polynomial.C a) (Polynomial.roots p)) =\n      p :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u_1} [inst : Field K] {p : Polynomial K},\n  Polynomial.Monic p â†’\n    (âˆ€ a : K, Polynomial.rootMultiplicity a p â‰¤ 1) â†”\n      âˆ€ a : K, Â¬Polynomial.IsRoot (gcd p (â†‘Polynomial.derivative p)) a ",
      "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] {p : Polynomial K},\n  (Polynomial.natDegree p = Fintype.card (Polynomial.rootSet p K) âˆ§\n  âˆ€ a : K, a âˆ‰ Polynomial.rootSet p K â†’ Polynomial.rootMultiplicity a p = 0) â†”\n    âˆ€ x : K, Â¬(Polynomial.IsRoot p x âˆ§ Polynomial.IsRoot (Polynomial.derivative p) x) ",
      "âˆ€ {K : Type u_1} [inst : Field K] [inst_1 : Algebra K â„‚] {p : Polynomial K},\n  Polynomial.natDegree p = Fintype.card â†‘(Polynomial.rootSet p â„‚) â†”\n    Â¬HasSubset.Subset (Polynomial.rootSet (â†‘Polynomial.derivative p) â„‚) (Polynomial.rootSet p â„‚) ",
      "âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.natDegree p = Fintype.card (Polynomial.rootSet p K) â†’\n  (âˆ€ a : K, Â¬(Polynomial.IsRoot p a âˆ§ Polynomial.IsRoot (Polynomial.derivative p) a)) â†”\n    p â‰  0 âˆ§ âˆ€ {a : K}, Polynomial.IsRoot p a â†’ Polynomial.rootMultiplicity a p = 1 ",
      "âˆ€ {F : Type u_1} [inst : Field F] {p : Polynomial F},\n  Polynomial.degree p = â†‘(Polynomial.natDegree p) â†’\n    (Finset.card (Multiset.toFinset (Polynomial.roots p)) = Polynomial.natDegree p â†”\n     Multiset.disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p))) ",
      "âˆ€ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  Polynomial.natDegree p = Fintype.card â†‘(Polynomial.rootSet p F) â†”\n    âˆ€ (x : F), Â¬(Polynomial.IsRoot p x âˆ§ Polynomial.IsRoot p.derivative x) ",
      "âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.degree p = Polynomial.degree (â†‘Polynomial.derivative p) + 1 â†”\n    âˆ€ (a : K), Â¬Polynomial.IsRoot p a âˆ¨ Â¬Polynomial.IsRoot (â†‘Polynomial.derivative p) a ",
      "âˆ€ {K : Type v} [inst : Field K] [inst_1 : CharZero K] {p : Polynomial K},\n  Polynomial.degree p = Polynomial.degree (Polynomial.derivative p) + 1 â†’\n    (Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (Polynomial.derivative p)) â†”\n      â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p) ",
      "âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.degree p = â†‘(Polynomial.natDegree p) â†’\n    (p * â†‘Polynomial.derivative p = 0 â†” âˆ€ (a : K), Multiset.count a (Polynomial.roots p) â‰¤ 1) ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Algebra F â„‚] (p : Polynomial F),\n  Polynomial.degree p = â†‘(Polynomial.natDegree p) â†”\n    (âˆ€ (x : â„‚), Polynomial.IsRoot (Polynomial.map (algebraMap F â„‚) p) x â†’ Â¬Polynomial.IsRoot (Polynomial.map (algebraMap F â„‚) (Polynomial.derivative p)) x) "
    ]
  },
  {
    "docString": "Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under addition. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\\nthen `t â€¢ x âˆˆ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\\n    âˆ€ (f : V'' â†’â‚—[R] V),\\n      Function.Injective â†‘f â†’\\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\\n * the function `f' : V'' â†’ V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h + g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} (f : Î± â†’ G),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹},\\n      (âˆ€á¶  (i : Î¹) in l, MeasureTheory.Integrable (F i)) â†’\\n        Filter.Tendsto (fun i => âˆ«â» (x : Î±), â†‘â€–F i x - f xâ€–â‚Š âˆ‚Î¼) l (nhds 0) â†’\\n          Filter.Tendsto (fun i => âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] {E : Type u_1} [inst_1 : Field E] [inst_2 : Algebra F E] (S T : Set E),\\n  IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F S } T) =\\n    IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F T } S)\",\n  \"isProp\": true,\n  \"docString\": \"`F[S][T] = F[T][S]` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s t : Set Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : NormedSpace â„ E],\\n  MeasureTheory.NullMeasurableSet t â†’\\n    s âŠ† t â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ t \\\\ s â†’ f x = 0) â†’ âˆ« (x : Î±) in t, f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function vanishes almost everywhere on `t \\\\ s` with `s âŠ† t`, then its integrals on `s`\\nand `t` coincide if `t` is null-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T â‰¤ S â†’\\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\\n      [inst_5 : Fintype (M â§¸ T)],\\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (self : GroupSeminorm G) (x : G),\\n  GroupSeminorm.toFun self xâ»Â¹ = GroupSeminorm.toFun self x\",\n  \"isProp\": true,\n  \"docString\": \"The seminorm is invariant under inversion. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (g : M â†’â‚—[R] M)\\n  (f : (M â†’â‚—[R] M)Ë£), â†‘(LinearMap.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â†‘(LinearMap.trace R M) g\",\n  \"isProp\": true,\n  \"docString\": \"The trace of an endomorphism is invariant under conjugation \"},\n {\"theorem\":\n  \"âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {p : Submodule R M} (hfp : âˆ€ (x : M), x âˆˆ p â†’ â†‘f x âˆˆ p) {Î¼ : R},\\n  Disjoint (Module.End.eigenspace f Î¼) p â†’ Module.End.eigenspace (LinearMap.restrict f hfp) Î¼ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an invariant subspace `p` of an endomorphism `f` is disjoint from the `Î¼`-eigenspace of `f`,\\nthen the restriction of `f` to `p` has trivial `Î¼`-eigenspace. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Algebra.adjoin R' s â†’ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ adjoin R' s`,\\nthen `t â€¢ x âˆˆ adjoin R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] {E : Type u_1} [inst_1 : Field E] [inst_2 : Algebra F E] (S T : Set E),\\n  IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F S } T) =\\n    IntermediateField.adjoin F (S âˆª T)\",\n  \"isProp\": true,\n  \"docString\": \"`F[S][T] = F[S âˆª T]` \"},\n {\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"}]\n",
    "prompt_cons": "/-- If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S)) :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼ :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\nthen `t â€¢ x âˆˆ span R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\n * the function `f' : V'' â†’ V'` doesn't need to be injective -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\n    âˆ€ (f : V'' â†’â‚—[R] V),\n      Function.Injective â†‘f â†’\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b) :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h + g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddRightInvariant Î¼ :=\n\n/-- If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. -/\ntheorem âˆ€ {Î± : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} (f : Î± â†’ G),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹},\n      (âˆ€á¶  (i : Î¹) in l, MeasureTheory.Integrable (F i)) â†’\n        Filter.Tendsto (fun i => âˆ«â» (x : Î±), â†‘â€–F i x - f xâ€–â‚Š âˆ‚Î¼) l (nhds 0) â†’\n          Filter.Tendsto (fun i => âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼)) :=\n\n/-- `F[S][T] = F[T][S]` -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] {E : Type u_1} [inst_1 : Field E] [inst_2 : Algebra F E] (S T : Set E),\n  IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F S } T) =\n    IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F T } S) :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If a function vanishes almost everywhere on `t \\ s` with `s âŠ† t`, then its integrals on `s`\nand `t` coincide if `t` is null-measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s t : Set Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : NormedSpace â„ E],\n  MeasureTheory.NullMeasurableSet t â†’\n    s âŠ† t â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ t \\ s â†’ f x = 0) â†’ âˆ« (x : Î±) in t, f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼ :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T â‰¤ S â†’\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\n      [inst_5 : Fintype (M â§¸ T)],\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T) :=\n\n/-- The seminorm is invariant under inversion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (self : GroupSeminorm G) (x : G),\n  GroupSeminorm.toFun self xâ»Â¹ = GroupSeminorm.toFun self x :=\n\n/-- The trace of an endomorphism is invariant under conjugation -/\ntheorem âˆ€ (R : Type u) [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (g : M â†’â‚—[R] M)\n  (f : (M â†’â‚—[R] M)Ë£), â†‘(LinearMap.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â†‘(LinearMap.trace R M) g :=\n\n/-- If an invariant subspace `p` of an endomorphism `f` is disjoint from the `Î¼`-eigenspace of `f`,\nthen the restriction of `f` to `p` has trivial `Î¼`-eigenspace. -/\ntheorem âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {p : Submodule R M} (hfp : âˆ€ (x : M), x âˆˆ p â†’ â†‘f x âˆˆ p) {Î¼ : R},\n  Disjoint (Module.End.eigenspace f Î¼) p â†’ Module.End.eigenspace (LinearMap.restrict f hfp) Î¼ = âŠ¥ :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ adjoin R' s`,\nthen `t â€¢ x âˆˆ adjoin R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Algebra.adjoin R' s â†’ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s :=\n\n/-- `F[S][T] = F[S âˆª T]` -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] {E : Type u_1} [inst_1 : Field E] [inst_2 : Algebra F E] (S T : Set E),\n  IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F S } T) =\n    IntermediateField.adjoin F (S âˆª T) :=\n\n/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$. -/\ntheorem",
    "choices": [
      "forall {K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] (S T : LinearMap K V) (hST : S.comp T = T.comp S) (Î» : K),\n  Submodule.map S (LinearMap.ker (T - LinearMap.smul_right LinearMap.id Î»)) â‰¤ LinearMap.ker (T - LinearMap.smul_right LinearMap.id Î») ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : LinearMap K V) (Î» : K),\n  LinearMap.comp S T = LinearMap.comp T S â†’\n    âˆ€ (x : V), x âˆˆ LinearMap.ker (LinearMap.sub T (coeFn (LinearMap.smulRight LinearMap.id Î») x)) â†’\n      coeFn S x âˆˆ LinearMap.ker (LinearMap.sub T (coeFn (LinearMap.smulRight LinearMap.id Î») x)) ",
      "forall {K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] (S T : LinearMap K V) (hST : S.comp T = T.comp S)\n  (Î» : K), Submodule.map S (LinearMap.ker (T - Î» â€¢ LinearMap.id)) â‰¤ LinearMap.ker (T - Î» â€¢ LinearMap.id) ",
      "âˆ€ {K : Type u} [inst : Field K] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T S : End K V},\n  S * T = T * S â†’\n    âˆ€ (Î» : K), LinearMap.ker ((T - LinearMap.smulRight LinearMap.id Î») : V â†’â‚—[K] V) â‰¤\n      LinearMap.ker ((S * (T - LinearMap.smulRight LinearMap.id Î»)) : V â†’â‚—[K] V) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module R V] {S T : Module.End R V} {Î¼ : R},\n  S.comp T = T.comp S â†’\n    âˆ€ (x : V), x âˆˆ (Module.End.eigenspace T Î¼) â†’ S x âˆˆ Module.End.eigenspace T Î¼ ",
      "forall {K : Type u} [Field K] {V : Type v} [AddCommGroup V] [Module K V] {S T : End K V} (hST : S * T = T * S) (Î» : K),\n  Submodule.map S (Module.End.eigenspace T Î») â‰¤ Module.End.eigenspace T Î» ",
      "âˆ€ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {S T : Module.End R M} (hST : S * T = T * S),\n  âˆ€ (Î» : R), Submodule.map S (Module.End.eigenspace T Î») â‰¤ Module.End.eigenspace T Î» ",
      "âˆ€ {K : Type u} [inst : Field K] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Module.End K V),\n  S * T = T * S â†’ âˆ€ (Î» : K), Submodule.map S (Module.End.eigenspace T Î») â‰¤ Module.End.eigenspace T Î» ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Module.End K V),\n  S.comp T = T.comp S â†’ âˆ€ (Î» : K), Submodule.map S (Module.End.eigenspace T Î») â‰¤ Module.End.eigenspace T Î» ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : End K V) (h : S.comp T = T.comp S) (Î» : K),\n  âˆ€ (x : V), x âˆˆ Submodule.comap T (Submodule.map (LinearMap.id - LinearMap.smulRight T Î») (Submodule.span K {x})) â†’\n    (S x) âˆˆ Submodule.comap T (Submodule.map (LinearMap.id - LinearMap.smulRight T Î») (Submodule.span K {x})) "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (a b : M),\\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b)\",\n  \"isProp\": true,\n  \"docString\": \"The symmetric product of vectors is a scalar \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\\n  â¨† (Î¼ : K) (k : â„•), â†‘(Module.End.generalizedEigenspace f Î¼) k = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\\n  (âˆ€ (r : R),\\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), âˆƒ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 â€¢ x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (n : ZMod 2) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q n â†’ Prop},\\n  (âˆ€ (v : CliffordAlgebra Q) (h : v âˆˆ LinearMap.range (CliffordAlgebra.Î¹ Q) ^ ZMod.val n),\\n      P v (_ : v âˆˆ â¨† (i : { n_1 // â†‘n_1 = n }), LinearMap.range (CliffordAlgebra.Î¹ Q) ^ â†‘i)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n} {hy : y âˆˆ CliffordAlgebra.evenOdd Q n},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q n), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even or odd part, it suffices to show it is true on the\\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\\nof vectors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), â†‘f (r â€¢ a) = r â€¢ â†‘f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a â‹†-algebra equivalence commutes with the action of scalars. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–) :=\n\n/-- The symmetric product of vectors is a scalar -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (a b : M),\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b) :=\n\n/-- The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\n  â¨† (Î¼ : K) (k : â„•), â†‘(Module.End.generalizedEigenspace f Î¼) k = âŠ¤ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\n  (âˆ€ (r : R),\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), âˆƒ c, Module.End.HasEigenvalue f c :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 â€¢ x = x :=\n\n/-- To show a property is true on the even or odd part, it suffices to show it is true on the\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\nof vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (n : ZMod 2) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q n â†’ Prop},\n  (âˆ€ (v : CliffordAlgebra Q) (h : v âˆˆ LinearMap.range (CliffordAlgebra.Î¹ Q) ^ ZMod.val n),\n      P v (_ : v âˆˆ â¨† (i : { n_1 // â†‘n_1 = n }), LinearMap.range (CliffordAlgebra.Î¹ Q) ^ â†‘i)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n} {hy : y âˆˆ CliffordAlgebra.evenOdd Q n},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q n), P x hx :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- By definition, a â‹†-algebra equivalence commutes with the action of scalars. -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), â†‘f (r â€¢ a) = r â€¢ â†‘f a :=\n\n/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), âˆƒ (c : K), v â‰  0 â†’ Module.End.HasEigenvector T c v) â†’ âˆƒ (c : K), T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ Î¼, Module.End.HasEigenvector T Î¼ v) â†’ âˆƒ Î¼, T = Î¼ â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (Î¼ : K), Module.End.HasEigenvector T Î¼ v) â†’ âˆƒ (c : K), T = c â€¢ LinearMap.id ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (T : V â†’â‚—[ğ•œ] V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : ğ•œ), T v = c â€¢ v) â†’ âˆƒ (c : ğ•œ), T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V) (hv : v â‰  0), âˆƒ c, T v = c â€¢ v) â†’ âˆƒ c, T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h : âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, Module.End.HasEigenvector T c v),\n  âˆƒ c, T = c â€¢ Module.End.id K V ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), âˆƒ (Î¼ : K), Module.End.HasEigenvector T Î¼ v) â†’ âˆƒ (Î¼ : K), T = Î¼ â€¢ 1 ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, T v = c â€¢ v) â†’ âˆƒ (c : K), T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (Î¼ : K) (w : V), w â‰  0 âˆ§ w = v âˆ§ T w = Î¼ â€¢ w) â†’ âˆƒ (c : K), T = c â€¢ 1 ",
      "âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), âˆƒ (c : K), T v = c â€¢ v) â†’ âˆƒ (c : K), âˆ€ (v : V), T v = c â€¢ v "
    ]
  },
  {
    "docString": "Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\\nthen `t â€¢ x âˆˆ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\\n  â¨† (Î¼ : K) (k : â„•), â†‘(Module.End.generalizedEigenspace f Î¼) k = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\\n  (âˆ€ (r : R),\\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T â‰¤ S â†’\\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\\n      [inst_5 : Fintype (M â§¸ T)],\\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K) {k : â„•},\\n  FiniteDimensional.finrank K V â‰¤ k â†’\\n    â†‘(Module.End.generalizedEigenspace f Î¼) k = â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'],\\n  (M â‰ƒâ‚—[R] M') â†’ Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension, a version with different\\nuniverses. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"}]\n",
    "prompt_cons": "/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\nthen `t â€¢ x âˆˆ span R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\n  â¨† (Î¼ : K) (k : â„•), â†‘(Module.End.generalizedEigenspace f Î¼) k = âŠ¤ :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\n  (âˆ€ (r : R),\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T â‰¤ S â†’\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\n      [inst_5 : Fintype (M â§¸ T)],\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T) :=\n\n/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K) {k : â„•},\n  FiniteDimensional.finrank K V â‰¤ k â†’\n    â†‘(Module.End.generalizedEigenspace f Î¼) k = â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V) :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'],\n  (M â‰ƒâ‚—[R] M') â†’ Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M') :=\n\n/-- If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S)) :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥ :=\n\n/-- Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$. -/\ntheorem",
    "choices": [
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] [inst_3 : FiniteDimensional ğ•œ E] (T S : E â†’â‚—[ğ•œ] E),\n  LinearMap.IsSymmetric T â†’\n  (âˆƒ (s : Finset ğ•œ), Finset.card s = FiniteDimensional.finrank ğ•œ E âˆ§ âˆ€ (Î¼ : ğ•œ), Î¼ âˆˆ s â†’ Module.End.eigenspace T Î¼ â‰  âŠ¥) â†’\n  (âˆ€ (Î¼ : ğ•œ), Module.End.eigenvectors T Î¼ = Module.End.eigenvectors S Î¼) â†’ T.comp S = S.comp T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T S : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E],\n  (âˆ€ (Î¼ : ğ•œ), FiniteDimensional.finrank ğ•œ (Module.End.eigenspace T Î¼) = 1) â†’\n    (âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ Module.End.eigenspace T Î¼ â†’ (â†‘S v) âˆˆ Module.End.eigenspace T Î¼) â†’\n      T.comp S = S.comp T ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T S : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’\n    (forall Î¼ : ğ•œ, Module.End.eigenspace T Î¼ = Module.End.eigenspace S Î¼) â†’\n      [FiniteDimensional ğ•œ E] â†’ T * S = S * T ",
      "âˆ€ {ğ•œ : Type u} [inst : Field ğ•œ] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {T S : Module.End ğ•œ V}\n  [inst_3 : FiniteDimensional ğ•œ V],\n  (âˆ€ (Î¼ : ğ•œ), Module.End.HasEigenvalue T Î¼ â†’ âˆ€ (v : V), v âˆˆ Module.End.eigenspace T Î¼ â†’ S v âˆˆ Module.End.eigenspace T Î¼) â†’\n  LinearMap.commute T S ",
      "forall {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T S : E â†’â‚—[ğ•œ] E},\n  (LinearMap.IsSymmetric T) â†’\n  (Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank ğ•œ E) â†’\n  (âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ Module.End.eigenspace T Î¼ â†’ v âˆˆ Module.End.eigenspace S Î¼) â†’\n  T * S = S * T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T S : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E],\n  LinearMap.IsSymmetric T â†’\n  (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼) = âŠ¤ â†’\n  (âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ Module.End.eigenspace T Î¼ â†’ v âˆˆ Module.End.eigenspace S Î¼) â†’ T * S = S * T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T S : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E],\n  (LinearMap.eigenvectors T).card = FiniteDimensional.finrank ğ•œ E â†’\n    (âˆ€ (v : E), v âˆˆ LinearMap.eigenvectors T â†” v âˆˆ LinearMap.eigenvectors S) â†’ T.comp S = S.comp T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : VectorSpace ğ•œ E]\n  {T S : E â†’â‚—[ğ•œ] E}, \n  (âˆ€ Î¼ : ğ•œ, Module.End.has_eigenvalue T Î¼ â†’ Module.End.has_eigenvalue S Î¼) â†’\n  (âˆ€ (v : E) (Î¼ : ğ•œ), v âˆˆ Module.End.eigenspace T Î¼ â†’ v âˆˆ Module.End.eigenspace S Î¼) â†’\n  LinearMap.commute T S ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {T S : Module.End ğ•œ V}\n  [inst_3 : FiniteDimensional ğ•œ V],\n  (âˆ€ (Î¼ : ğ•œ), Module.End.HasEigenvalue T Î¼ â†’\n     âˆ€ (x : V), Module.End.HasEigenvector T (Î¼, x) â†’ Module.End.HasEigenvector S (Module.End.eigenvalue T S x, x)) â†’\n  Module.rank ğ•œ V = (Fintype.card ğ•œ) â†’ T.comp S = S.comp T ",
      "forall {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  {T S : Module.End ğ•œ V} (hT : LinearMap.HasDistinctEigenvectors T) (hS : LinearMap.HasSameEigenvectorsAs T S),\n  T * S = S * T "
    ]
  },
  {
    "docString": "Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (v : E), â†‘(orthogonalProjection (Submodule.span ğ•œ {v})á—®) v = 0\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection onto `(ğ•œ âˆ™ v)á—®` of `v` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\\nfunction `a` which tends to `0`, then `f` tends to `0`.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\\n  InnerProductGeometry.angle x y = 0 â†’ inner x y = â€–xâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between two vectors is 0, the inner product equals the product of the norms. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {u v : E}, v âˆˆ (Submodule.span ğ•œ {u})á—® â†” inner u v = 0\",\n  \"isProp\": true,\n  \"docString\": \"A vector is in `(ğ•œ âˆ™ u)á—®` iff it is orthogonal to `u`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\\ntends to `0`, then `f` tends to `1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (self : UniformSpace.Core Î±), (Filter.lift' self.uniformity fun s => compRel s s) â‰¤ self.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set `u âˆˆ uniformity`, there exists `v âˆˆ uniformity` such that `v â—‹ v âŠ† u`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {u v : E}, v âˆˆ (Submodule.span ğ•œ {u})á—® â†” inner v u = 0\",\n  \"isProp\": true,\n  \"docString\": \"A vector in `(ğ•œ âˆ™ u)á—®` is orthogonal to `u`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : Fintype Î¹] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : (i : Î¹) â†’ NormedAddCommGroup (E i)] [inst_3 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)] [inst_4 : NormedAddCommGroup G]\\n  [inst_5 : NormedSpace ğ•œ G] (f : ContinuousMultilinearMap ğ•œ E G), â€–fâ€– = 0 â†” f = 0\",\n  \"isProp\": true,\n  \"docString\": \"A continuous linear map is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V},\\n  â€–xâ€– = â€–yâ€– â†’ (x = y â†” Orientation.oangle o x y = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vectors with equal norms are equal if and only if they have zero angle between them. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"}]\n",
    "prompt_cons": "/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V :=\n\n/-- The orthogonal projection onto `(ğ•œ âˆ™ v)á—®` of `v` is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), â†‘(orthogonalProjection (Submodule.span ğ•œ {v})á—®) v = 0 :=\n\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 0) :=\n\n/-- If the angle between two vectors is 0, the inner product equals the product of the norms. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\n  InnerProductGeometry.angle x y = 0 â†’ inner x y = â€–xâ€– * â€–yâ€– :=\n\n/-- A vector is in `(ğ•œ âˆ™ u)á—®` iff it is orthogonal to `u`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {u v : E}, v âˆˆ (Submodule.span ğ•œ {u})á—® â†” inner u v = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 1) :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- For every set `u âˆˆ uniformity`, there exists `v âˆˆ uniformity` such that `v â—‹ v âŠ† u`. -/\ntheorem âˆ€ {Î± : Type u} (self : UniformSpace.Core Î±), (Filter.lift' self.uniformity fun s => compRel s s) â‰¤ self.uniformity :=\n\n/-- A vector in `(ğ•œ âˆ™ u)á—®` is orthogonal to `u`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {u v : E}, v âˆˆ (Submodule.span ğ•œ {u})á—® â†” inner v u = 0 :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- A continuous linear map is zero iff its norm vanishes. -/\ntheorem âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : Fintype Î¹] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : (i : Î¹) â†’ NormedAddCommGroup (E i)] [inst_3 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace ğ•œ G] (f : ContinuousMultilinearMap ğ•œ E G), â€–fâ€– = 0 â†” f = 0 :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M :=\n\n/-- Two vectors with equal norms are equal if and only if they have zero angle between them. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V},\n  â€–xâ€– = â€–yâ€– â†’ (x = y â†” Orientation.oangle o x y = 0) :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {u v : V},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {u v : V} (a : ğ•œ), inner u v = 0 â†” âˆ€ a, âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {u v : V},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {u v : V},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), â€–uâ€– â‰¤ â€–u + a â€¢ vâ€– ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {u v : V},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), â€–uâ€– â‰¤ â€–u + a â€¢ vâ€– ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {u v : V},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a * vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {u v : V},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  (u v : V), inner u v = 0 â†” (âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ "
    ]
  },
  {
    "docString": "Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner x y * inner x y â‰¤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchyâ€“Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : V), â†‘f (â†‘(Orientation.rotation o Î¸) x) = â†‘(Real.Angle.expMapCircle Î¸) * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\\ncomplex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : V), Orientation.oangle o x y = â†‘(Complex.arg (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\\nterms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\\n  [inst_6 : FiniteDimensional â„ V],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-inner v w))) â€¢ f v)\\n    (Filter.cocompact V) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\\nevaluated in terms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.kahler o) x) y = â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F), |inner x y / (â€–xâ€– * â€–yâ€–)| â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real inner product of two vectors, divided by the product of their\\nnorms, has absolute value at most 1. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`âŸªT v, vâŸ«_â„‚` is real for all v.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  |inner x y / (â€–xâ€– * â€–yâ€–)| = 1 â†” x â‰  0 âˆ§ âˆƒ r, r â‰  0 âˆ§ y = r â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors, divided by the product of their\\nnorms, has absolute value 1 if and only if they are nonzero and one is\\na multiple of the other. One form of equality case for Cauchy-Schwarz. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {F : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : AddCommGroup F] [inst_2 : Module ğ•œ F]\\n  (self : InnerProductSpace.Core ğ•œ F) (x : F), inner x x = 0 â†’ x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The inner product is positive definite. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V),\\n  inner x y = â€–xâ€– * â€–yâ€– * Real.Angle.cos (Orientation.oangle o x y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors is the product of the norms and the cosine of the oriented\\nangle between the vectors. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [self : InnerProductSpace ğ•œ E]\\n  (x : E), â€–xâ€– ^ 2 = â†‘IsROrC.re (inner x x)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product induces the norm. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [self : InnerProductSpace ğ•œ E]\\n  (x y : E) (r : ğ•œ), inner (r â€¢ x) y = â†‘(starRingEnd ğ•œ) r * inner x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product is conjugate linear in the first coordinate. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner x y / (â€–xâ€– * â€–yâ€–) = 1 â†” x â‰  0 âˆ§ âˆƒ r, 0 < r âˆ§ y = r â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors, divided by the product of their\\nnorms, has value 1 if and only if they are nonzero and one is\\na positive multiple of the other. \"}]\n",
    "prompt_cons": "/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im :=\n\n/-- Cauchyâ€“Schwarz inequality for real inner products. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner x y * inner x y â‰¤ inner x x * inner y y :=\n\n/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : V), â†‘f (â†‘(Orientation.rotation o Î¸) x) = â†‘(Real.Angle.expMapCircle Î¸) * â†‘f x :=\n\n/-- The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\nterms of a complex-number representation of the space. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : V), Orientation.oangle o x y = â†‘(Complex.arg (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y)) :=\n\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\n  [inst_6 : FiniteDimensional â„ V],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-inner v w))) â€¢ f v)\n    (Filter.cocompact V) (nhds 0) :=\n\n/-- The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\nevaluated in terms of a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x :=\n\n/-- The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.kahler o) x) y = â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y :=\n\n/-- The real inner product of two vectors, divided by the product of their\nnorms, has absolute value at most 1. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F), |inner x y / (â€–xâ€– * â€–yâ€–)| â‰¤ 1 :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  |inner x y / (â€–xâ€– * â€–yâ€–)| = 1 â†” x â‰  0 âˆ§ âˆƒ r, r â‰  0 âˆ§ y = r â€¢ x :=\n\n/-- The inner product is positive definite. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {F : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : AddCommGroup F] [inst_2 : Module ğ•œ F]\n  (self : InnerProductSpace.Core ğ•œ F) (x : F), inner x x = 0 â†’ x = 0 :=\n\n/-- The inner product of two vectors is the product of the norms and the cosine of the oriented\nangle between the vectors. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V),\n  inner x y = â€–xâ€– * â€–yâ€– * Real.Angle.cos (Orientation.oangle o x y) :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0 :=\n\n/-- The inner product induces the norm. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [self : InnerProductSpace ğ•œ E]\n  (x : E), â€–xâ€– ^ 2 = â†‘IsROrC.re (inner x x) :=\n\n/-- The inner product is conjugate linear in the first coordinate. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [self : InnerProductSpace ğ•œ E]\n  (x y : E) (r : ğ•œ), inner (r â€¢ x) y = â†‘(starRingEnd ğ•œ) r * inner x y :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0) :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- The inner product of two vectors, divided by the product of their\nnorms, has value 1 if and only if they are nonzero and one is\na positive multiple of the other. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner x y / (â€–xâ€– * â€–yâ€–) = 1 â†” x â‰  0 âˆ§ âˆƒ r, 0 < r âˆ§ y = r â€¢ x :=\n\n/-- Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$. -/\ntheorem",
    "choices": [
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v =\n    (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + (â€–u + Complex.i â€¢ vâ€– ^ 2 - â€–u - Complex.i â€¢ vâ€– ^ 2) * Complex.i) / 4 ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  (u v : V), inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + ((â€–u + (IsROrC.i * v)â€– ^ 2 - â€–u - (IsROrC.i * v)â€– ^ 2) * IsROrC.i)) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€–^2 - â€–u - vâ€–^2 + (â€–u + Complex.i â€¢ vâ€–^2 - â€–u - Complex.i â€¢ vâ€–^2) * Complex.i) / 4 ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  (u v : V), inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + â€–u + I * vâ€– ^ 2 * I - â€–u - I * vâ€– ^ 2 * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + (â€–u + Complex.i â€¢ vâ€– ^ 2 - â€–u - Complex.i â€¢ vâ€– ^ 2) * Complex.i) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + (â€–u + (I * v)â€– ^ 2 - â€–u - (I * v)â€– ^ 2) * I) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + (â€–u + Complex.i â€¢ vâ€– ^ 2 - â€–u - Complex.i â€¢ vâ€– ^ 2) * Complex.i) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + â€–u + (Complex.i * v)â€– ^ 2 * Complex.i - â€–u - (Complex.i * v)â€– ^ 2 * Complex.i) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + (â€–u + Complex.I * vâ€– ^ 2 - â€–u - Complex.I * vâ€– ^ 2) * Complex.I) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– ^ 2 - â€–u - vâ€– ^ 2 + (â€–u + Complex.i â€¢ vâ€– ^ 2 - â€–u - Complex.i â€¢ vâ€– ^ 2) * Complex.i) / 4 "
    ]
  },
  {
    "docString": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from an orthogonal submodule `V` is the zero map. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\\n  dist p â†‘(â†‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance to a point's orthogonal projection is 0 iff it lies in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, â†‘(â†‘(orthogonalProjection K) v) = v â†” v âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point equals its orthogonal projection if and only if it lies in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two orthogonal subspaces equals the subspace orthogonal\\nto the sup. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] (p : P),\\n  â†‘(EuclideanGeometry.reflection s) p = p â†” p âˆˆ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is its own reflection if and only if it is in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\\n  orthogonalProjection âŠ¥ = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto the trivial submodule is the zero map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\\n  reflection âŠ¥ = LinearIsometryEquiv.neg ğ•œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reflection through the trivial subspace {0} is just negation. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"}]\n",
    "prompt_cons": "/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V :=\n\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- The distance to a point's orthogonal projection is 0 iff it lies in the subspace. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\n  dist p â†‘(â†‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- A point equals its orthogonal projection if and only if it lies in the subspace. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K] {v : E}, â†‘(â†‘(orthogonalProjection K) v) = v â†” v âˆˆ K :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, W âŠ” Projectivization.Subspace.span S = Projectivization.Subspace.span (â†‘W âˆª S) :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—® :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—® :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- A point is its own reflection if and only if it is in the subspace. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] (p : P),\n  â†‘(EuclideanGeometry.reflection s) p = p â†” p âˆˆ s :=\n\n/-- The orthogonal projection onto the trivial submodule is the zero map. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\n  orthogonalProjection âŠ¥ = 0 :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- Reflection through the trivial subspace {0} is just negation. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\n  reflection âŠ¥ = LinearIsometryEquiv.neg ğ•œ :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$ -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (U V : Submodule ğ•œ E),\n  Uá—® = âŠ¥ â†” U = V "
    ]
  },
  {
    "docString": "Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (W : Submodule R M),\\n  LinearMap.range (LinearMap.dualMap (Submodule.mkQ W)) = Submodule.dualAnnihilator W\",\n  \"isProp\": true,\n  \"docString\":\n  \"That $\\\\operatorname{im}(q^* : (V/W)^* \\\\to V^*) = \\\\operatorname{ann}(W)$. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\": \"âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two continuous functions to a t2-space that agree on the dense range of a function are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}\\n  (P : (Î± â†’ E) â†’ Prop),\\n  (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\\n    (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\\n        Disjoint (Function.support f) (Function.support g) â†’\\n          MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’ P f â†’ P g â†’ P (f + g)) â†’\\n      IsClosed {f | P â†‘â†‘f} â†’\\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Integrable f â†’ P f â†’ P g) â†’\\n          âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Integrable f â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary integrable function in a normed group,\\nit suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : T3Space Î±],\\n  NormalSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Tâ‚ƒ topological space with second countable topology is a normal space.\\nThis lemma is not an instance to avoid a loop. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_2} {A : Type u_3} {B : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A]\\n  [inst_2 : CompleteSpace A] [inst_3 : StarRing A] [inst_4 : CstarRing A] [inst_5 : NormedRing B]\\n  [inst_6 : NormedAlgebra â„‚ B] [inst_7 : CompleteSpace B] [inst_8 : StarRing B] [inst_9 : CstarRing B]\\n  [hF : StarAlgHomClass F â„‚ A B] (Ï† : F) (a : A), â€–â†‘Ï† aâ€– â‰¤ â€–aâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"A star algebra homomorphism of complex Câ‹†-algebras is norm contractive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\": \"âˆ€ {d : â„¤}, MonoidHom.mker Zsqrtd.normMonoidHom = unitary (â„¤âˆšd)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the norm map on `â„¤âˆšd` equals the submonoid of unitary elements. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {t : TopologicalSpace ğ•œ},\\n  TopologicalAddGroup ğ•œ â†’ ContinuousSMul ğ•œ ğ•œ â†’ T2Space ğ•œ â†’ t = UniformSpace.toTopologicalSpace\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ•œ` is a nontrivially normed field, any T2 topology on `ğ•œ` which makes it a topological\\nvector space over itself (with the norm topology) is *equal* to the norm topology. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the tensor product of a scalar linear map and of an element of a normed space\\nis the product of the norms. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NonUnitalNormedRing E] [inst_1 : StarRing E] [inst_2 : CstarRing E], NormedStarGroup E\",\n  \"isProp\": true,\n  \"docString\": \"In a C*-ring, star preserves the norm. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional ğ•œ E] [inst_14 : FiniteDimensional ğ•œ F],\\n  Nonempty (E â‰ƒL[ğ•œ] F) â†” FiniteDimensional.finrank ğ•œ E = FiniteDimensional.finrank ğ•œ F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"}]\n",
    "prompt_cons": "/-- That $\\operatorname{im}(q^* : (V/W)^* \\to V^*) = \\operatorname{ann}(W)$. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (W : Submodule R M),\n  LinearMap.range (LinearMap.dualMap (Submodule.mkQ W)) = Submodule.dualAnnihilator W :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- **Liouville's Theorem** -/\ntheorem âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u)) :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h :=\n\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}\n  (P : (Î± â†’ E) â†’ Prop),\n  (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\n    (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\n        Disjoint (Function.support f) (Function.support g) â†’\n          MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’ P f â†’ P g â†’ P (f + g)) â†’\n      IsClosed {f | P â†‘â†‘f} â†’\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Integrable f â†’ P f â†’ P g) â†’\n          âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Integrable f â†’ P f :=\n\n/-- A Tâ‚ƒ topological space with second countable topology is a normal space.\nThis lemma is not an instance to avoid a loop. -/\ntheorem âˆ€ (Î± : Type u) [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : T3Space Î±],\n  NormalSpace Î± :=\n\n/-- A star algebra homomorphism of complex Câ‹†-algebras is norm contractive. -/\ntheorem âˆ€ {F : Type u_2} {A : Type u_3} {B : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A]\n  [inst_2 : CompleteSpace A] [inst_3 : StarRing A] [inst_4 : CstarRing A] [inst_5 : NormedRing B]\n  [inst_6 : NormedAlgebra â„‚ B] [inst_7 : CompleteSpace B] [inst_8 : StarRing B] [inst_9 : CstarRing B]\n  [hF : StarAlgHomClass F â„‚ A B] (Ï† : F) (a : A), â€–â†‘Ï† aâ€– â‰¤ â€–aâ€– :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- The kernel of the norm map on `â„¤âˆšd` equals the submonoid of unitary elements. -/\ntheorem âˆ€ {d : â„¤}, MonoidHom.mker Zsqrtd.normMonoidHom = unitary (â„¤âˆšd) :=\n\n/-- If `ğ•œ` is a nontrivially normed field, any T2 topology on `ğ•œ` which makes it a topological\nvector space over itself (with the norm topology) is *equal* to the norm topology. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {t : TopologicalSpace ğ•œ},\n  TopologicalAddGroup ğ•œ â†’ ContinuousSMul ğ•œ ğ•œ â†’ T2Space ğ•œ â†’ t = UniformSpace.toTopologicalSpace :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0) :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€– :=\n\n/-- In a C*-ring, star preserves the norm. -/\ntheorem âˆ€ {E : Type u_1} [inst : NonUnitalNormedRing E] [inst_1 : StarRing E] [inst_2 : CstarRing E], NormedStarGroup E :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional ğ•œ E] [inst_14 : FiniteDimensional ğ•œ F],\n  Nonempty (E â‰ƒL[ğ•œ] F) â†” FiniteDimensional.finrank ğ•œ E = FiniteDimensional.finrank ğ•œ F :=\n\n/-- Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$ -/\ntheorem",
    "choices": [
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] (T : V â†’â‚—[ğ•œ] V),\n  T.IsNormal â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : StarModule ğ•œ V] (T : ğ•œ â†’+* V â†’â‚—[RingHom.id ğ•œ] V),\n  LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (starLinearMapOf T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : StarModule ğ•œ V] (T : V â†’â‚—[ğ•œ] V), @IsNormal ğ•œ V _ _ _ T â†’ LinearMap.range T = LinearMap.range (LinearMap.star T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : StarAddMonoid V]\n  {T : V â†’â‚—[ğ•œ] V}, LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] (T : V â†’â‚—[ğ•œ] V),\n  LinearMap.IsNormal T â†” LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] (T : V â†’â‚—[ğ•œ] V),\n  @LinearMap.IsNormal ğ•œ V V _ _ _ _ T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : StarModule ğ•œ V] {T : V â†’â‚›â‚—[RingHom.id ğ•œ] V},\n  LinearMap.isNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : InnerProductSpace ğ•œ V] (T : V â†’â‚—[ğ•œ] V), LinearMap.innerProductSpaceIsometry T â†’\n    LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : StarModule ğ•œ V] (T : V â†’SL[RingHom.id ğ•œ] V),\n  LinearMap.IsNormal T â†’ LinearMap.range T = (LinearMap.range (coeFn star T)).star ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  (T : V â†’â‚—[ğ•œ] V) [is_R_or_C : IsROrC ğ•œ] [hT : LinearMap.IsNormal T], LinearMap.range T = LinearMap.range (T.adjoint) "
    ]
  },
  {
    "docString": "Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] (U : Submodule ğ•œ E) [inst_4 : CompleteSpace { x // x âˆˆ U }],\\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U))\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection is self-adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (T : E â†’â‚—[ğ•œ] E), LinearMap.IsSymmetric T â†” LinearMap.IsSelfAdjoint sesqFormOfInner T\",\n  \"isProp\": true,\n  \"docString\":\n  \"An operator `T` on an inner product space is symmetric if and only if it is\\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a\",\n  \"isProp\": true,\n  \"docString\": \"The spectrum of a selfadjoint is real \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`âŸªT v, vâŸ«_â„‚` is real for all v.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a Tâ‚€ space are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î¼ : ğ•œ),\\n  Module.End.eigenspace\\n      (LinearMap.restrict T\\n        (_ : âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®))\\n      Î¼ =\\n    âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space has no eigenvalues. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\\nevaluated in terms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner x y * inner x y â‰¤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchyâ€“Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"}]\n",
    "prompt_cons": "/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- The orthogonal projection is self-adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] (U : Submodule ğ•œ E) [inst_4 : CompleteSpace { x // x âˆˆ U }],\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U)) :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥ :=\n\n/-- An operator `T` on an inner product space is symmetric if and only if it is\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (T : E â†’â‚—[ğ•œ] E), LinearMap.IsSymmetric T â†” LinearMap.IsSelfAdjoint sesqFormOfInner T :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v :=\n\n/-- Two inseparable points in a Tâ‚€ space are equal. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î¼ : ğ•œ),\n  Module.End.eigenspace\n      (LinearMap.restrict T\n        (_ : âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®))\n      Î¼ =\n    âŠ¥ :=\n\n/-- The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\nevaluated in terms of a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x :=\n\n/-- Cauchyâ€“Schwarz inequality for real inner products. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner x y * inner x y â‰¤ inner x x * inner y y :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re :=\n\n/-- Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsNormal T â†’ (T ^ 9) = (T ^ 8) â†’ IsSelfAdjoint T âˆ§ (T ^ 2) = T ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  IsNormalOperator T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSymmetric T âˆ§ T ^ 2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSymmetric T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsNormal T â†’\n  T ^ 9 = T ^ 8 â†’\n  LinearMap.IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSymmetric T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSymmetric T âˆ§ T ^ 2 = T ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [IsROrC ğ•œ] [NormedAddCommGroup V] [InnerProductSpace ğ•œ V]\n  (T : V â†’â‚—[ğ•œ] V), LinearMap.IsNormal T â†’ T^9 = T^8 â†’ IsSelfAdjoint T âˆ§ T^2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T^9 = T^8 â†’ LinearMap.IsSymmetric T âˆ§ T^2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSymmetric T âˆ§ T ^ 2 = T "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsLocalExtrOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(ContinuousLinearMap.rayleighQuotient T xâ‚€)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\\ncentred at the origin is an eigenvector of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a\",\n  \"isProp\": true,\n  \"docString\": \"The spectrum of a selfadjoint is real \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), âˆƒ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨… (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] (U : Submodule ğ•œ E) [inst_4 : CompleteSpace { x // x âˆˆ U }],\\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U))\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection is self-adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X) {Îµ : NNReal},\\n  0 < Îµ â†’ âˆƒ f, (âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x) âˆ§ â†‘Î› f < rieszContentAux Î› K + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Riesz content can be approximated arbitrarily well by evaluating the positive linear\\nfunctional on test functions: for any `Îµ > 0`, there exists a bounded continuous nonnegative\\nfunction f on X such that `f â‰¥ 1` on K and such that `Î»(K) â‰¤ Î› f < Î»(K) + Îµ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : Module.End K V} {k : â„•} {Î¼ : K},\\n  Module.End.HasEigenvalue f Î¼ â†’\\n    0 < k â†’ 0 < FiniteDimensional.finrank K { x // x âˆˆ â†‘(Module.End.generalizedEigenspace f Î¼) k }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generalized eigenspace of an eigenvalue has positive dimension for positive exponents. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {v : â„ â†’ E â†’ E}\\n  {tMin tâ‚€ tMax : â„} (xâ‚€ : E) {C R : â„} {L : NNReal},\\n  IsPicardLindelof v tMin tâ‚€ tMax xâ‚€ L R C â†’\\n    âˆƒ f, f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ Set.Icc tMin tMax â†’ HasDerivWithinAt f (v t (f t)) (Set.Icc tMin tMax) t\",\n  \"isProp\": true,\n  \"docString\": \"Picard-LindelÃ¶f (Cauchy-Lipschitz) theorem. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"}]\n",
    "prompt_cons": "/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\ncentred at the origin is an eigenvector of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsLocalExtrOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(ContinuousLinearMap.rayleighQuotient T xâ‚€)) xâ‚€ :=\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a :=\n\n/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), âˆƒ c, Module.End.HasEigenvalue f c :=\n\n/-- The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨… (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- The orthogonal projection is self-adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] (U : Submodule ğ•œ E) [inst_4 : CompleteSpace { x // x âˆˆ U }],\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U)) :=\n\n/-- For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re :=\n\n/-- The Riesz content can be approximated arbitrarily well by evaluating the positive linear\nfunctional on test functions: for any `Îµ > 0`, there exists a bounded continuous nonnegative\nfunction f on X such that `f â‰¥ 1` on K and such that `Î»(K) â‰¤ Î› f < Î»(K) + Îµ`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X) {Îµ : NNReal},\n  0 < Îµ â†’ âˆƒ f, (âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x) âˆ§ â†‘Î› f < rieszContentAux Î› K + Îµ :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- The generalized eigenspace of an eigenvalue has positive dimension for positive exponents. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : Module.End K V} {k : â„•} {Î¼ : K},\n  Module.End.HasEigenvalue f Î¼ â†’\n    0 < k â†’ 0 < FiniteDimensional.finrank K { x // x âˆˆ â†‘(Module.End.generalizedEigenspace f Î¼) k } :=\n\n/-- Picard-LindelÃ¶f (Cauchy-Lipschitz) theorem. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {v : â„ â†’ E â†’ E}\n  {tMin tâ‚€ tMax : â„} (xâ‚€ : E) {C R : â„} {L : NNReal},\n  IsPicardLindelof v tMin tâ‚€ tMax xâ‚€ L R C â†’\n    âˆƒ f, f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ Set.Icc tMin tMax â†’ HasDerivWithinAt f (v t (f t)) (Set.Icc tMin tMax) t :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ {Î¼ : ğ•œ} {v : E}, âˆ¥vâˆ¥ = 1 â†’ âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆ¥T v - Î¼ â€¢ vâˆ¥ < Îµ â†’\n      âˆƒ Î¼' : ğ•œ, Module.End.HasEigenvalue T Î¼' âˆ§ abs (Î¼ - Î¼') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) {Î» : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆƒ (v : E), âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n      âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue T Î»' âˆ§ âˆ¥Î» - Î»'âˆ¥ < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} {Î» : ğ•œ} {Îµ : â„},\n  LinearMap.IsSymmetric T â†’\n    0 < Îµ â†’\n    âˆƒ v, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ â†’\n      âˆƒ Î»', Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) {Î» : ğ•œ} {Îµ : â„} (hÎµ : 0 < Îµ) {v : E},\n  (âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’ âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ {Î» : ğ•œ} {Îµ : â„},\n      0 < Îµ â†’\n        âˆ€ {v : E},\n          âˆ¥vâˆ¥ = 1 â†’ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ â†’\n            âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) {Î» : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n      âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} {Î» : ğ•œ} {Îµ : â„},\n  LinearMap.IsSymmetric T â†’\n    0 < Îµ â†’\n      (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» vâˆ¥ < Îµ) â†’\n        âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) {Î» : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n      âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n      (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n        âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {Î» : ğ•œ} {Îµ : â„} {v : E},\n      0 < Îµ â†’\n        âˆ¥vâˆ¥ = 1 â†’\n          âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ â†’\n            âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue (â†‘T) Î»' âˆ§ abs (Î» - Î»') < Îµ "
    ]
  },
  {
    "docString": "For all odd $n$ show that $8 \\mid n^{2}-1$.",
    "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"âˆ€ {n a : â„•}, Even a â†’ (Odd (n % a) â†” Odd n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {n a : â„•}, Odd n â†’ Even a â†’ Odd (n % a)\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8)\",\n  \"isProp\": true,\n  \"docString\": \"The value of `Ï‡â‚ˆ n`, for `n : â„¤`, depends only on `n % 8`. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    Odd p â†’\\n      âˆ€ {x y : â„¤},\\n        â†‘p âˆ£ x - y â†’\\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `Ï‡â‚„ n = 1`. \"},\n {\"theorem\": \"âˆ€ {n a : â„•}, Even a â†’ (Even (n % a) â†” Even n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"theorem\": \"âˆ€ (n : â„•), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8)\",\n  \"isProp\": true,\n  \"docString\": \"The value of `Ï‡â‚ˆ n`, for `n : â„•`, depends only on `n % 8`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd m â†’ Odd n â†’ qrSign m n ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `m` and `n` are odd, then the square of `qrSign m n` is `1`. \"}]\n",
    "prompt_cons": "/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If `a` is even, then `n` is odd iff `n % a` is odd. -/\ntheorem âˆ€ {n a : â„•}, Even a â†’ (Odd (n % a) â†” Odd n) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `n` is odd and `a` is even, then `n % a` is odd. -/\ntheorem âˆ€ {n a : â„•}, Odd n â†’ Even a â†’ Odd (n % a) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The value of `Ï‡â‚ˆ n`, for `n : â„¤`, depends only on `n % 8`. -/\ntheorem âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8) :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    Odd p â†’\n      âˆ€ {x y : â„¤},\n        â†‘p âˆ£ x - y â†’\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. -/\ntheorem âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1 :=\n\n/-- If `n % 4 = 1`, then `Ï‡â‚„ n = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = 1 :=\n\n/-- If `a` is even, then `n` is even iff `n % a` is even. -/\ntheorem âˆ€ {n a : â„•}, Even a â†’ (Even (n % a) â†” Even n) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡ :=\n\n/-- The value of `Ï‡â‚ˆ n`, for `n : â„•`, depends only on `n % 8`. -/\ntheorem âˆ€ (n : â„•), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- When `m` and `n` are odd, then the square of `qrSign m n` is `1`. -/\ntheorem âˆ€ {m n : â„•}, Odd m â†’ Odd n â†’ qrSign m n ^ 2 = 1 :=\n\n/-- For all odd $n$ show that $8 \\mid n^{2}-1$. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•}, Odd n â†’ (8 âˆ£ n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall_odd_n_eight_divides_n_squared_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n^2 - 1 ",
      "âˆ€ {n : â„•}, Odd n â†’ (8 âˆ£ n ^ 2 - 1) ",
      "forall_odd_n_eight_divides_n_squared_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall_odd_n_eight_divides_n_squared_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall_odd_nat_mul_eight_diff_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 "
    ]
  },
  {
    "docString": "Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A â‰ƒ+* B â†’ NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},\\n  2 â‰¤ k â†’\\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {n : â„•} (self : Fin n), â†‘self < n\",\n  \"isProp\": true,\n  \"docString\": \"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\\n  IsPrimitiveRoot Î¶ (2 ^ k) â†’\\n    2 â‰¤ k â†’\\n      âˆ€ [H : IsCyclotomicExtension {2 ^ k} K L],\\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (Î¶ - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\\nthen the norm of `Î¶ - 1` is `2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\\n  (i : CategoryTheory.Functor D C) [inst_2 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_3 : CategoryTheory.CartesianClosed C],\\n  (âˆ€ (B : D) (A : C), (A âŸ¹ i.obj B) âˆˆ CategoryTheory.Functor.essImage i) â†’ CategoryTheory.ExponentialIdeal i\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show `i` is an exponential ideal it suffices to show that `A âŸ¹ iB` is \\\"in\\\" `D` for any `A` in\\n`C` and `B` in `D`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\": \"âˆ€ (z : UpperHalfPlane), âˆƒ g, g â€¢ z âˆˆ ModularGroup.fd\",\n  \"isProp\": true,\n  \"docString\": \"Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)`  \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\\n  IsPrimitiveRoot Î¶ (2 ^ (k + 1)) â†’\\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ (k + 1)} K L],\\n      Irreducible (Polynomial.cyclotomic (2 ^ (k + 1)) K) â†’ â†‘(Algebra.norm K) (Î¶ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ (k + 1)) K)` (in particular for `K = â„š`), then the norm of\\n`Î¶ ^ (2 ^ k) - 1` is `(-2) ^ (2 ^ k)`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"}]\n",
    "prompt_cons": "/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A â‰ƒ+* B â†’ NoZeroDivisors A :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. -/\ntheorem âˆ€ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},\n  2 â‰¤ k â†’\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. -/\ntheorem âˆ€ {n : â„•} (self : Fin n), â†‘self < n :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\nthen the norm of `Î¶ - 1` is `2`. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\n  IsPrimitiveRoot Î¶ (2 ^ k) â†’\n    2 â‰¤ k â†’\n      âˆ€ [H : IsCyclotomicExtension {2 ^ k} K L],\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (Î¶ - 1) = 2 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5 :=\n\n/-- To show `i` is an exponential ideal it suffices to show that `A âŸ¹ iB` is \"in\" `D` for any `A` in\n`C` and `B` in `D`. -/\ntheorem âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\n  (i : CategoryTheory.Functor D C) [inst_2 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_3 : CategoryTheory.CartesianClosed C],\n  (âˆ€ (B : D) (A : C), (A âŸ¹ i.obj B) âˆˆ CategoryTheory.Functor.essImage i) â†’ CategoryTheory.ExponentialIdeal i :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)` -/\ntheorem âˆ€ (z : UpperHalfPlane), âˆƒ g, g â€¢ z âˆˆ ModularGroup.fd :=\n\n/-- If `Irreducible (cyclotomic (2 ^ (k + 1)) K)` (in particular for `K = â„š`), then the norm of\n`Î¶ ^ (2 ^ k) - 1` is `(-2) ^ (2 ^ k)`. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\n  IsPrimitiveRoot Î¶ (2 ^ (k + 1)) â†’\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ (k + 1)} K L],\n      Irreducible (Polynomial.cyclotomic (2 ^ (k + 1)) K) â†’ â†‘(Algebra.norm K) (Î¶ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k :=\n\n/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$. -/\ntheorem",
    "choices": [
      "(1 + Complex.I) ^ 2 = 2 * Complex.I * Complex.I ",
      "(1 + Complex.I) ^ 2 = 2 * Complex.I * -Complex.I ",
      "âˆƒ (z : â„¤[i]), 2 = (1 + 1 * Complex.I) ^ 2 * z ",
      "IsUnit (Complex.I * (1 + Complex.I) ^ 2 - 2) ",
      "divisible_by_2 : â„¤[i] ",
      "2_divisible_by_one_plus_i_sq : (1 + Complex.I) ^ 2 âˆ£ 2 ",
      "IsUnit (1 + Complex.I) â†’ (2 : â„¤[i]) âˆ£ (1 + Complex.I) ^ 2 ",
      "Exists.intro (1 + Complex.i) (Eq.symm (Eq.trans (Eq.trans (Eq.trans (Eq.symm (Complex.I_mul_I)) ((fun [Mul â„‚] á¾° á¾°_1 e_2 á¾°_2 á¾°_3 e_3 => congr (congr_argâ‚“ HMul.hMul e_2) e_3) (1 + Complex.i) (1 + Complex.i) rfl (1 + Complex.i) (1 + Complex.i) rfl)) (mul_addâ‚“ (1 + Complex.i) 1 Complex.i)) ((fun [Add â„‚] á¾° á¾°_1 e_2 á¾°_2 á¾°_3 e_3 => congr (congr_argâ‚“ HAdd.hAdd e_2) e_3) ((1 + Complex.i) * 1) (1 + Complex.i) (mul_oneâ‚“ (1 + Complex.i)) ((1 + Complex.i) * Complex.i) (-1 + 2 * Complex.i) (Eq.trans (Eq.trans (Eq.trans (add_mulâ‚“ 1 Complex.i Complex.i) ((fun [Add â„‚] á¾° á¾°_1 e_2 á¾°_2 á¾°_3 e_3 => congr (congr_argâ‚“ HAdd.hAdd e_2) e_3) (1 * Complex.i) Complex.i (one_mulâ‚“ Complex.i) (Complex.i * Complex.i) (-1) (Complex.I_mul_I))) (add_commâ‚“ Complex.i (-1))) (add_right_commâ‚“ (-1) 1 (2 * Complex.i)))))",
      "(1 + Complex.I) ^ 2 = 2 ",
      "IsUnit (Complex.i * (1 + Complex.i) ^ 2 - 2) "
    ]
  },
  {
    "docString": "Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {p n r b : â„•},\\n  Nat.Prime p â†’ Nat.log p n < b â†’ (p ^ r âˆ£ Nat.factorial n â†” r â‰¤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` \"},\n {\"theorem\":\n  \"âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2`  \"},\n {\"theorem\": \"âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"âˆ€ {p n b : â„•} [hp : Fact (Nat.Prime p)],\\n  Nat.log p n < b â†’ padicValNat p (Nat.factorial n) = Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Legendre's Theorem**\\n\\nThe `p`-adic valuation of `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ {n d : â„•}, d âˆ£ n â†’ Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `d âˆ£ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {n b : â„•}, Nat.log p n < b â†’ multiplicity p (Nat.factorial n) = â†‘(Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Legendre's Theorem**\\n\\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  p â‰  2 â†’\\n    â†‘a â‰  0 â†’\\n      legendreSym p a =\\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (â†‘a * â†‘x)) (Finset.Ico 1 (Nat.succ (p / 2))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\\nthan `p/2` such that `(a * x) % p > p / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [inst_1 : UniqueFactorizationMonoid Î±]\\n  [inst_2 : NormalizationMonoid Î±] [inst_3 : DecidableEq Î±] {x : Î±} {n : â„•}, factorization (x ^ n) = n â€¢ factorization x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"âˆ€ {p n k : â„•}, â†‘(Nat.factorization (Nat.choose n k)) p â‰¤ Nat.log p n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. \"},\n {\"theorem\":\n  \"âˆ€ (n p : â„•), Finset.card (Finset.filter (fun x => p âˆ£ x) (Finset.Ioc 0 n)) = n / p\",\n  \"isProp\": true,\n  \"docString\": \"Exactly `n / p` naturals in `(0, n]` are multiples of `p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSingletonClass Î±] {a : Î± â†’ ENNReal},\\n  Measurable a â†’\\n    âˆ€ {c : ENNReal},\\n      âˆ‘' (i : Î±), a i â‰¤ c â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ Îµ â‰  âŠ¤ â†’ â†‘â†‘MeasureTheory.Measure.count {i | Îµ â‰¤ a i} â‰¤ c / Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Markov's inequality for the counting measure with hypothesis using `tsum` in `â„â‰¥0âˆ`. \"},\n {\"theorem\": \"âˆ€ {n : â„•} (p : â„•), n â‰  0 â†’ â†‘(Nat.factorization n) p < n\",\n  \"isProp\": true,\n  \"docString\": \"A crude upper bound on `n.factorization p` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSingletonClass Î±] {a : Î± â†’ NNReal},\\n  Measurable a â†’\\n    Summable a â†’\\n      âˆ€ {c : NNReal},\\n        âˆ‘' (i : Î±), a i â‰¤ c â†’ âˆ€ {Îµ : NNReal}, Îµ â‰  0 â†’ â†‘â†‘MeasureTheory.Measure.count {i | Îµ â‰¤ a i} â‰¤ â†‘c / â†‘Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Markov's inequality for counting measure with hypothesis using `tsum` in `â„â‰¥0`. \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` -/\ntheorem âˆ€ {p n r b : â„•},\n  Nat.Prime p â†’ Nat.log p n < b â†’ (p ^ r âˆ£ Nat.factorial n â†” r â‰¤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i) :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2` -/\ntheorem âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n :=\n\n/-- **Legendre's Theorem**\n\nThe `p`-adic valuation of `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem âˆ€ {p n b : â„•} [hp : Fact (Nat.Prime p)],\n  Nat.log p n < b â†’ padicValNat p (Nat.factorial n) = Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- For `d âˆ£ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` -/\ntheorem âˆ€ {n d : â„•}, d âˆ£ n â†’ Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n)) :=\n\n/-- **Legendre's Theorem**\n\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {n b : â„•}, Nat.log p n < b â†’ multiplicity p (Nat.factorial n) = â†‘(Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i) :=\n\n/-- Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\nthan `p/2` such that `(a * x) % p > p / 2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  p â‰  2 â†’\n    â†‘a â‰  0 â†’\n      legendreSym p a =\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (â†‘a * â†‘x)) (Finset.Ico 1 (Nat.succ (p / 2)))) :=\n\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [inst_1 : UniqueFactorizationMonoid Î±]\n  [inst_2 : NormalizationMonoid Î±] [inst_3 : DecidableEq Î±] {x : Î±} {n : â„•}, factorization (x ^ n) = n â€¢ factorization x :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. -/\ntheorem âˆ€ {p n k : â„•}, â†‘(Nat.factorization (Nat.choose n k)) p â‰¤ Nat.log p n :=\n\n/-- The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹)) :=\n\n/-- Exactly `n / p` naturals in `(0, n]` are multiples of `p`. -/\ntheorem âˆ€ (n p : â„•), Finset.card (Finset.filter (fun x => p âˆ£ x) (Finset.Ioc 0 n)) = n / p :=\n\n/-- Markov's inequality for the counting measure with hypothesis using `tsum` in `â„â‰¥0âˆ`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSingletonClass Î±] {a : Î± â†’ ENNReal},\n  Measurable a â†’\n    âˆ€ {c : ENNReal},\n      âˆ‘' (i : Î±), a i â‰¤ c â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ Îµ â‰  âŠ¤ â†’ â†‘â†‘MeasureTheory.Measure.count {i | Îµ â‰¤ a i} â‰¤ c / Îµ :=\n\n/-- A crude upper bound on `n.factorization p` -/\ntheorem âˆ€ {n : â„•} (p : â„•), n â‰  0 â†’ â†‘(Nat.factorization n) p < n :=\n\n/-- Markov's inequality for counting measure with hypothesis using `tsum` in `â„â‰¥0`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSingletonClass Î±] {a : Î± â†’ NNReal},\n  Measurable a â†’\n    Summable a â†’\n      âˆ€ {c : NNReal},\n        âˆ‘' (i : Î±), a i â‰¤ c â†’ âˆ€ {Îµ : NNReal}, Îµ â‰  0 â†’ â†‘â†‘MeasureTheory.Measure.count {i | Îµ â‰¤ a i} â‰¤ â†‘c / â†‘Îµ :=\n\n/-- Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$. -/\ntheorem",
    "choices": [
      "âˆ€ {p n : â„•},\n  Nat.Prime p â†’\n    ((âˆƒ k, n = p ^ k) â†”\n      Finset.sum (Finset.filter (fun d => d âˆ£ n) (Finset.range (Nat.succ n))) (fun d => Î¼ (n / d) * Nat.log d) = Nat.log p) ",
      "âˆ€ {p n : â„•},\n  Nat.Prime p â†’\n    n â‰  0 â†’\n      (Finset.sum (Finset.Ico 1 (Nat.succ (Nat.log p n))) fun k => moebiusMu (n / p ^ k) * Nat.log (p ^ k)) =\n        if n % p = 0 âˆ§ n / p % p â‰  0 then Nat.log p else 0 ",
      "âˆ€ {n p : â„•},\n  Nat.Prime p â†’\n    (n â‰  0 â†’\n      Finset.sum (Finset.attach (Nat.divisors n))\n        (fun d => (Î¼ (n / d.val) * (Nat.log d.val))) =\n          if n % p = 0 âˆ§ p ^ Nat.log p n = n then Nat.log p else 0) ",
      "âˆ€ {p n : â„•}, Nat.Prime p â†’ (n = p ^ Nat.factorization n p â†” âˆ‘ (d : â„•) in Finset.divisors n, Î¼ (n / d) * Nat.log d = Nat.log p) ",
      "âˆ€ {p n : â„•},\n  Nat.Prime p â†’\n    (PowerSeries.mk fun d => Finset.sum (Finset.filter (fun x => x âˆ£ n) (Finset.range (n + 1))) fun A => moebiusFun n / A * Real.log d) =\n      (PowerSeries.mk fun d => if Nat.Prime.pow n p then Real.log p else 0) ",
      "forall {n d : â„•}, Nat.gcd n d = 1 â†’ (Finset.sum (Finset.filter (fun A => A âˆ£ n) (Finset.range (n + 1))) fun A => moebius n * Nat.log d) = ite (n = 1) (Nat.log d) 0 ",
      "âˆ€ {n : â„•}, n â‰  0 â†’ Finset.sum (Finset.divisors n) (fun d => Î¼ (n / d) * Nat.log d) = ite (Nat.succ (Nat.log (Nat.minFac n) n) = n) (Nat.log (Nat.minFac n)) 0 ",
      "âˆ€ {n p : â„•} [hp : Fact (Nat.Prime p)],\n  (Finset.sum (Finset.filter (fun d => n % d = 0) (Finset.range (Nat.succ n))) fun d => â†‘(Moebius.moebius) (n / d) * Real.log â†‘d) =\n    if h : âˆƒ (k : â„•), n = p ^ k then Real.log (â†‘p) else 0 ",
      "âˆ€ {n : â„•}, n â‰  0 â†’\n  (Finset.sum (Finset.divisors n) fun d => Î¼ (n / d) * Real.log d) = (dite (Nat.Prime (Nat.minFac n)) (Î» h => Real.log (Nat.minFac n)) (Î» h => 0)) ",
      "âˆ€ {p n : â„•},\n  Nat.Prime p â†’\n    (n = p ^ padicValNat p n â†”\n       Finset.sum (Finset.divisors n) (Î» (d : â„•), Î¼ (n / d) * Real.log (â†‘d)) = Real.log (â†‘p)) "
    ]
  },
  {
    "docString": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•} (n : â„•), k â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there exists an arbitrarily large prime `p` such that\\n`p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) (n : â„¤) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve integer powers. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"}]\n",
    "prompt_cons": "/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- For any positive `k : â„•` there exists an arbitrarily large prime `p` such that\n`p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•} (n : â„•), k â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k] :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Multiplicative congruence relations preserve integer powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) (n : â„¤) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- Show that there are infinitely many primes congruent to $-1$ modulo 6 . -/\ntheorem",
    "choices": [
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD k]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} "
    ]
  },
  {
    "docString": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Disjoint (LinearMap.range (ExteriorAlgebra.Î¹ R)) 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generators of the exterior algebra are disjoint from its scalars. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ (self : â„š), self.den â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The denominator is nonzero. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R},\\n  Polynomial.Monic q â†’\\n    Polynomial.degree q â‰¤ Polynomial.degree p â†’ Polynomial.leadingCoeff (p /â‚˜ q) = Polynomial.leadingCoeff p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Division by a monic polynomial doesn't change the leading coefficient. \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- The generators of the exterior algebra are disjoint from its scalars. -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Disjoint (LinearMap.range (ExteriorAlgebra.Î¹ R)) 1 :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) } :=\n\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- The denominator is nonzero. -/\ntheorem âˆ€ (self : â„š), self.den â‰  0 :=\n\n/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- Division by a monic polynomial doesn't change the leading coefficient. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R},\n  Polynomial.Monic q â†’\n    Polynomial.degree q â‰¤ Polynomial.degree p â†’ Polynomial.leadingCoeff (p /â‚˜ q) = Polynomial.leadingCoeff p :=\n\n/-- Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers. -/\ntheorem",
    "choices": [
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "no_solution_7x3_plus_2_eq_y3 : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "h : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "Â¬âˆƒ (x y : â„¤), 7 * x ^ 3 + 2 = y ^ 3 ",
      "âˆ€x y : â„¤, 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "no_int_solution : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "Â¬âˆƒ x y : â„¤, 7 * x^3 + 2 = y^3 "
    ]
  },
  {
    "docString": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {n p k : â„•}, n â‰  0 â†’ Nat.factorization n = Finsupp.single p k â†’ n = p ^ k\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the factorization of `n` contains just one number `p` then `n` is a power of `p` \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem âˆ€ {n p k : â„•}, n â‰  0 â†’ Nat.factorization n = Finsupp.single p k â†’ n = p ^ k :=\n\n/-- Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$. -/\ntheorem",
    "choices": [
      "âˆ€ {p q : â„•} (n : â„•) [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  q â†’ p âˆ£ q - 1 â†’ Nat.Coprime n (p * q) â†’ (â†‘n ^ (q - 1) â‰¡ 1) [ZMOD (â†‘p * â†‘q)] ",
      "âˆ€ {p q n : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (â†‘n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)]) ",
      "âˆ€ {p q n : â„•}, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ (q - 1) % (p - 1) = 0 â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (â†‘n ^ (q - 1)) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "forall {p q n : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)],\n  p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (n ^ (q - 1)) â‰¡ 1 [ZMOD (p * q)] ",
      "forall {p q n : â„•} [Fact (Nat.Prime p)] [Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] "
    ]
  },
  {
    "docString": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)],\\n  p â‰  2 â†’ âˆ€ (a : â„¤), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = â†‘a})) = legendreSym p a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of square roots of `a` modulo `p` is determined by the Legendre symbol. \"}]\n",
    "prompt_cons": "/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1 :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)],\n  p â‰  2 â†’ âˆ€ (a : â„¤), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = â†‘a})) = legendreSym p a + 1 :=\n\n/-- Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$. -/\ntheorem",
    "choices": [
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ (a : ZMod p), IsPrimitiveRoot a â†‘p â†” orderOf (-a) = (p - 1) / 2 ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p},\n  p % 4 = 3 â†’ (IsPrimitiveRoot a p â†” (orderOf (-a) = (p - 1) / 2)) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p},\n  p % 4 = 3 â†’ (IsPrimitiveRoot a (p - 1) â†” orderOf (-a) = (p - 1) / 2) ",
      "âˆ€ {a : â„•} {p : â„•} [inst : Fact (Nat.Prime p)],\n  p % 4 = 3 â†’ ((IsPrimitiveRoot a p) â†” (orderOf (-a) = (p - 1) / 2)) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p},\n  p % 4 = 3 â†’ (IsPrimitiveRoot a â†‘p â†” IsPrimitiveRoot (-a) ((p - 1) / 2)) ",
      "âˆ€ {a : â„•} {p : â„•} [inst : Fact (Nat.Prime p)],\n  p % 4 = 3 â†’ (IsPrimitiveRoot â†‘a p â†” orderOf (-a) = (p - 1) / 2) ",
      "forall {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’\n  âˆ€ (a : ZMod p), IsPrimitiveRoot a â†‘p â†” (orderOf (-a)) = (p - 1) / 2 ",
      "âˆ€ {a p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ (IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a) ((p - 1) / 2)) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : ZMod p), p % 4 = 3 â†’ IsPrimitiveRoot a p â†” orderOf (-a) = (p - 1) / 2 ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {t : â„•} {a : ZMod p},\n  p = 4 * t + 3 â†’ (IsPrimitiveRoot a (p - 1) â†” orderOf (-a) = (p - 1) / 2) "
    ]
  },
  {
    "docString": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p â†’ (p âˆ£ List.prod L â†” âˆƒ a, a âˆˆ L âˆ§ p âˆ£ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L` \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’\\n    âˆ€ {p : â„•} [inst_2 : Fact (Nat.Prime p)],\\n      p â‰  2 â†’ (IsSquare â†‘p â†” â†‘(quadraticChar (ZMod p)) (â†‘(â†‘ZMod.Ï‡â‚„ â†‘(Fintype.card F)) * â†‘(Fintype.card F)) â‰  -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An odd prime `p` is a square in `F` iff the quadratic character of `ZMod p` does not\\ntake the value `-1` on `Ï‡â‚„#F * #F`. \"},\n {\"theorem\":\n  \"âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"}]\n",
    "prompt_cons": "/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L` -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p â†’ (p âˆ£ List.prod L â†” âˆƒ a, a âˆˆ L âˆ§ p âˆ£ a) :=\n\n/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- An odd prime `p` is a square in `F` iff the quadratic character of `ZMod p` does not\ntake the value `-1` on `Ï‡â‚„#F * #F`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’\n    âˆ€ {p : â„•} [inst_2 : Fact (Nat.Prime p)],\n      p â‰  2 â†’ (IsSquare â†‘p â†” â†‘(quadraticChar (ZMod p)) (â†‘(â†‘ZMod.Ï‡â‚„ â†‘(Fintype.card F)) * â†‘(Fintype.card F)) â‰  -1) :=\n\n/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`. -/\ntheorem âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1) :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a : ZMod p}, (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” IsPrimitiveRoot a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, Nat.Prime p â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” IsPrimitiveRoot a p ",
      "âˆ€ {p : â„•} (a : ZMod p) [inst : Fact (Nat.Prime p)], IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, a âˆˆ (Zmod.prime_field p).primitive_roots â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ Â¬IsUnit (coe (a ^ ((p - 1) / q) - 1))) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p â‰  2 â†’ âˆ€ (a : ZMod p), IsPrimitiveRoot a p â†” âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ Â¬a ^ ((p - 1) / q) = 1 ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : ZMod p), Nat.Prime p â†’ p â‰  2 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” primitiveRoot a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a : (ZMod p)Ë£},\n  (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” a âˆˆ primitiveRoots p ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„•), (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” IsPrimitiveRoot a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” IsPrimitiveRoot a p ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : ZMod p), (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ IsPrimitiveRoot a (p - 1) "
    ]
  },
  {
    "docString": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-1) â†” Fintype.card F % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `F` iff `#F` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w / y) (x / z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 0 R = 1\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth modified cyclotomic polyomial is `1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"}]\n",
    "prompt_cons": "/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1 :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- `-1` is a square in `F` iff `#F` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-1) â†” Fintype.card F % 4 â‰  3 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- Multiplicative congruence relations preserve division. -/\ntheorem âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w / y) (x / z) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- The zeroth modified cyclotomic polyomial is `1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 0 R = 1 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1) :=\n\n/-- Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 . -/\ntheorem",
    "choices": [
      "âˆ€ {x p : â„•} [inst : Fact (Nat.Prime p)], p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {p x : â„•} [inst : Fact (Nat.Prime p)], p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ Nat.Prime p â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•} [inst : Fact (Nat.Prime p)], p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {p x : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {p x : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•} (hp : Nat.Prime p), p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 "
    ]
  },
  {
    "docString": "Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"}]\n",
    "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3 :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2) :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1 :=\n\n/-- Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$. -/\ntheorem",
    "choices": [
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬p âˆ£ a â†’ Â¬q âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬(â†‘p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % (4 * a) = q â†’ Â¬â†‘p âˆ£ a â†’ legendreSym a p = legendreSym a q ",
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % (4 * -a) = q â†’ Â¬(â†‘p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {p q a : â„¤},\n  a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ Â¬(p âˆ£ a) â†’ legendreSym a p = legendreSym a q ",
      "âˆ€ {a p q : â„¤} [inst : Fact (Int.Prime p)] [inst_1 : Fact (Int.Prime q)],\n  a < 0 â†’ p % (4 * a) = q â†’ p âˆ£ a â†’ legendreSym a p = legendreSym a q ",
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % 4 = q % 4 â†’ Â¬p âˆ£ a â†’ Â¬q âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % (4 * -1) â‰¡ q % (4 * -1) â†’ Â¬p âˆ£ -1 â†’ legendreSym (-1) â†‘p = legendreSym (-1) â†‘q ",
      "âˆ€ {p q : â„•} (a : â„¤) [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ Â¬(p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {p q a : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ p âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q "
    ]
  },
  {
    "docString": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\\n    1 â‰¤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"},\n {\"theorem\": \"âˆ€ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"theorem\":\n  \"âˆ€ {x y z : â„¤},\\n  PythagoreanTriple x y z â†’\\n    (PythagoreanTriple x y z â†”\\n      âˆƒ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\":\n  \"âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚„ â†‘n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1\",\n  \"isProp\": true,\n  \"docString\": \"An explicit description of `Ï‡â‚„` on integers / naturals \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\n    1 â‰¤ b :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem âˆ€ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a :=\n\n/-- **Formula for Pythagorean Triples** -/\ntheorem âˆ€ {x y z : â„¤},\n  PythagoreanTriple x y z â†’\n    (PythagoreanTriple x y z â†”\n      âˆƒ k m n,\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- An explicit description of `Ï‡â‚„` on integers / naturals -/\ntheorem âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚„ â†‘n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 :=\n\n/-- The sum of two finite adÃ¨les is a finite adÃ¨le. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways. -/\ntheorem",
    "choices": [
      "Int.min_fac_eq 1729 ",
      "finite_1729 : âˆƒ a0 b0 a1 b1 : â„¤, a0 â‰  a1 âˆ§ a0^3 + b0^3 = 1729 âˆ§ a1^3 + b1^3 = 1729 ",
      "/r-/\nexample : âˆƒ (n : â„•), n = 1729 âˆ§ âˆƒ (a b c d : â„¤), a â‰  b âˆ§ c â‰  d âˆ§ a ^ 3 + b ^ 3 = n âˆ§ c ^ 3 + d ^ 3 = n ",
      "âˆƒ (n : â„•), n = 1729 âˆ§ (âˆƒ (aâ‚ aâ‚‚ bâ‚ bâ‚‚ : â„¤), aâ‚ â‰  aâ‚‚ âˆ§ bâ‚ â‰  bâ‚‚ âˆ§ aâ‚ ^ 3 + bâ‚ ^ 3 = n âˆ§ aâ‚‚ ^ 3 + bâ‚‚ ^ 3 = n) ",
      "Ramanujan1729 : âˆƒ a b c d : â„•, a â‰  b âˆ§ c â‰  d âˆ§ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ a ^ 3 + b ^ 3 = 1729 ",
      "â„• â†’ âˆƒ x y z w, x ^ 3 + y ^ 3 = z ^ 3 + w ^ 3 âˆ§ x â‰  z ",
      "â„• â†’ âˆƒ (x y z w : â„•), x â‰  y âˆ§ z â‰  w âˆ§ x^3 + y^3 = z^3 + w^3 ",
      "âˆƒ x1 y1 x2 y2 : â„•, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ âˆƒ (n : â„•), n = x1 ^ 3 + y1 ^ 3 âˆ§ n = x2 ^ 3 + y2 ^ 3 âˆ§ (âˆ€ (m : â„•), m < n â†’ Â¬(âˆƒ a b c d : â„•, a â‰  c âˆ§ b â‰  d âˆ§ m = a ^ 3 + b ^ 3 âˆ§ m = c ^ 3 + d ^ 3)) ",
      "âˆƒ x1 y1 x2 y2 : â„•, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ x1 ^ 3 + y1 ^ 3 = 1729 ",
      "â„•.smallest_1729 "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\\n  {s : Set E} {x y : E},\\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero FrÃ©chet derivative at every point of a convex set,\\nthen it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : Î± â†’ Î²},\\n  MeasureTheory.Memâ„’p f p â†’\\n    MeasureTheory.StronglyMeasurable f â†’\\n      âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ M, 0 < M âˆ§ MeasureTheory.snorm (Set.indicator {x | M â‰¤ â†‘â€–f xâ€–â‚Š} f) p Î¼ â‰¤ ENNReal.ofReal Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma implies that a single function is uniformly integrable (in the probability sense). \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"}]\n",
    "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\nfor some value `v`. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- If a function has zero FrÃ©chet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\n  {s : Set E} {x y : E},\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€) :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : Î± â†’ Î²},\n  MeasureTheory.Memâ„’p f p â†’\n    MeasureTheory.StronglyMeasurable f â†’\n      âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ M, 0 < M âˆ§ MeasureTheory.snorm (Set.indicator {x | M â‰¤ â†‘â€–f xâ€–â‚Š} f) p Î¼ â‰¤ ENNReal.ofReal Îµ :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t :=\n\n/-- A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€) :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ (âˆ€ x âˆˆ U, (f x).re = (f x).re) â†’ âˆ€ x y âˆˆ U, f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {U : Set E},\n  AnalyticOn â„‚ g U â†’\n    IsOpen U â†’ (âˆ€ a b : E, a âˆˆ U â†’ b âˆˆ U â†’ (g a).re = (g b).re) â†’ âˆ€ a b : E, a âˆˆ U â†’ b âˆˆ U â†’ g a = g b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {â„¦ : Set E} {f : E â†’ â„‚},\n  AnalyticOn â„‚ f â„¦ â†’ (âˆ€ (x y : E), x âˆˆ â„¦ â†’ y âˆˆ â„¦ â†’ (f x).re = (f y).re) â†’ âˆ€ (x y : E), x âˆˆ â„¦ â†’ y âˆˆ â„¦ â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {U : Set M} {f : M â†’ â„‚},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ (âˆ€ x âˆˆ U, Complex.re (f x) = 0) â†’ âˆ€ x y âˆˆ U, f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {U : Set E},\n  AnalyticOn â„‚ g U â†’\n    IsOpen U â†’ (âˆ€ (x : E), x âˆˆ U â†’ Real.const (g x).re = (g x).re) â†’ âˆ€ (x y : E), x âˆˆ U â†’ y âˆˆ U â†’ g x = g y ",
      "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {U : Set E},\n  IsOpen U â†’ DifferentiableOn â„‚ f U â†’ (âˆ€ (x : E), x âˆˆ U â†’ (f x).re = (f x).re) â†’ âˆ€ (x y : E), x âˆˆ U â†’ y âˆˆ U â†’ f x = f y ",
      "âˆ€ {E: Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ IsPreconnected U â†’\n      (âˆ€ (x : M), x âˆˆ U â†’ complex.re (f x) = complex.re (f (classical.arbitrary M))) â†’\n        âˆ€ (x : M), x âˆˆ U â†’ f x = f (classical.arbitrary M) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsOpen U â†’\n      (âˆ€ (z : E), z âˆˆ U â†’ (g z).re = (g (Classical.arbitrary E)).re) â†’\n        âˆ€ (z w : E), z âˆˆ U â†’ w âˆˆ U â†’ g z = g w ",
      "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ (âˆ€ (x : M), x âˆˆ U â†’ (f x).re = 0) â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F} {U : Set E},\n  MDifferentiableOn â„‚ f U â†’\n    IsOpen U â†’ (âˆ€ (x : E), x âˆˆ U â†’ âˆ€ (y : E), y âˆˆ U â†’ Complex.re (f x) = Complex.re (f y)) â†’\n      âˆ€ (x : E), x âˆˆ U â†’ âˆ€ (y : E), y âˆˆ U â†’ f x = f y "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\\n  {s : Set E} {x y : E},\\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero FrÃ©chet derivative at every point of a convex set,\\nthen it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {f : X â†’ Y},\\n  IsLocallyConstant f â†’ âˆ€ {s : Set X}, IsPreconnected s â†’ âˆ€ {x y : X}, x âˆˆ s â†’ y âˆˆ s â†’ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally constant function is constant on any preconnected set. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : Î± â†’ Î²},\\n  MeasureTheory.Memâ„’p f p â†’\\n    MeasureTheory.StronglyMeasurable f â†’\\n      âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ M, 0 < M âˆ§ MeasureTheory.snorm (Set.indicator {x | M â‰¤ â†‘â€–f xâ€–â‚Š} f) p Î¼ â‰¤ ENNReal.ofReal Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma implies that a single function is uniformly integrable (in the probability sense). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\\n  âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ Î´, Î´ > 0 âˆ§ âˆ€ (s : Set Î±), â†‘â†‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\\nto zero as `Î¼ s` tends to zero. This lemma states states this fact in terms of `Îµ` and `Î´`. \"}]\n",
    "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\nfor some value `v`. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y :=\n\n/-- If a function has zero FrÃ©chet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\n  {s : Set E} {x y : E},\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- A locally constant function is constant on any preconnected set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {f : X â†’ Y},\n  IsLocallyConstant f â†’ âˆ€ {s : Set X}, IsPreconnected s â†’ âˆ€ {x y : X}, x âˆˆ s â†’ y âˆˆ s â†’ f x = f y :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : Î± â†’ Î²},\n  MeasureTheory.Memâ„’p f p â†’\n    MeasureTheory.StronglyMeasurable f â†’\n      âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ M, 0 < M âˆ§ MeasureTheory.snorm (Set.indicator {x | M â‰¤ â†‘â€–f xâ€–â‚Š} f) p Î¼ â‰¤ ENNReal.ofReal Îµ :=\n\n/-- If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. This lemma states states this fact in terms of `Îµ` and `Î´`. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\n  âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ Î´, Î´ > 0 âˆ§ âˆ€ (s : Set Î±), â†‘â†‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsOpen U â†’ (âˆ€ (x : M), x âˆˆ U â†’ Complex.abs (f x) = Complex.abs (f (Classical.arbitrary M))) â†’ âˆ€ (a b : M), a âˆˆ U â†’ b âˆˆ U â†’ f a = f b ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {Î© : Set M},\n  AnalyticOn â„‚ f Î© â†’ âˆ€ (x y : M), x âˆˆ Î© â†’ y âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f y) â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {U : Set E},\n  AnalyticOn â„‚ g U â†’\n    (âˆ€ x âˆˆ U, Complex.abs (g x) = Complex.abs (g 0)) â†’ âˆ€ (x y : E), x âˆˆ U â†’ y âˆˆ U â†’ g x = g y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {U : Set E},\n  IsOpen U â†’ MDifferentiableOn â„‚ f U â†’ (âˆ€ (x : E), x âˆˆ U â†’ Complex.abs (f x) = Complex.abs (f 0)) â†’ âˆ€ (x : E), x âˆˆ U â†’ f x = f 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {U : Set E},\n  DifferentiableOn â„‚ f U â†’\n  IsOpen U â†’\n  (âˆ€ x âˆˆ U, Complex.abs (f x) = Complex.abs (f (Classical.choice U.nonempty))) â†’\n  âˆ€ x y âˆˆ U, f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f U â†’\n    (âˆ€ x âˆˆ U, Complex.abs (f x) = Complex.abs (f (Classical.arbitrary E))) â†’ âˆ€ x y âˆˆ U, f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E]\n  {f : E â†’ â„‚}, AnalyticOn â„‚ f set.univ â†’ (âˆ€ (x : E), Complex.abs (f x) = Complex.abs (f 0)) â†’ f = Function.const E (f 0) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {U : Set E},\n  AnalyticOn â„‚ g U â†’\n    IsOpen U â†’ ContinuousOn (Complex.abs âˆ˜ g) U â†’ Function.IsConstOn g U (Function.const_on_abs_is_const g U) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {G : Type u_3} [inst_4 : TopologicalSpace G] {I : ModelWithCorners â„‚ E G}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace G M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} (h : MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U),\n  IsOpen U â†’ (âˆ€ (x : M), x âˆˆ U â†’ Complex.abs (f x) = 1) â†’ Function.const M 1 = f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {Î© : Set E},\n  AnalyticOn â„‚ f Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f 0)) â†’ âˆ€ (x : E), x âˆˆ Î© â†’ f x = f 0 "
    ]
  },
  {
    "docString": "Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    â†‘r' < r â†’\\n      âˆƒ a,\\n        a âˆˆ Set.Ioo 0 1 âˆ§\\n          âˆƒ C,\\n            C > 0 âˆ§\\n              âˆ€ (y : E),\\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernelâ‚` is convergent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\\n`Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\\ndisc `Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p q : FormalMultilinearSeries ğ•œ E F),\\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) â‰¤ FormalMultilinearSeries.radius (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The radius of the sum of two formal series is at least the minimum of their two radii. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries ğ•œ E F),\\n  0 < FormalMultilinearSeries.radius p â†’\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"}]\n",
    "prompt_cons": "/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    â†‘r' < r â†’\n      âˆƒ a,\n        a âˆˆ Set.Ioo 0 1 âˆ§\n          âˆƒ C,\n            C > 0 âˆ§\n              âˆ€ (y : E),\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n :=\n\n/-- The sum defining `zetaKernelâ‚` is convergent. -/\ntheorem âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\n`Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p q : FormalMultilinearSeries ğ•œ E F),\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) â‰¤ FormalMultilinearSeries.radius (p + q) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries ğ•œ E F),\n  0 < FormalMultilinearSeries.radius p â†’\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ},\n  âˆ¥zâˆ¥ = 1 â†’ Summable (Î» (n : â„•), z ^ n / (â†‘n + 1) ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E]\n  {z : E}, â†‘(âˆ¥zâˆ¥) < 1 â†’ Summable fun n => z ^ n / (â†‘n ^ 2 : ğ•œ) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ},\n  Complex.abs â†‘z = 1 â†’ Summable fun n => (â†‘z ^ n) / (â†‘n ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ},\n  Â¬IsUnit z â†’ 1 < âˆ¥zâˆ¥ â†’ Summable fun n => (z ^ n) / (â†‘n ^ 2 : ğ•œ) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {R : â„}, 0 < R â†’\n  âˆ€ z : ğ•œ, â†‘Complex.abs z = R â†’ Summable fun n => z ^ n / (â†‘n + 1) ^ 2 ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedSpace ğ•œ ğ•œ] (z : ğ•œ), âˆ¥zâˆ¥ = 1 â†’ Summable (Î» n => z ^ n / (n ^ 2 : â„)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {z : ğ•œ},\n  HasUnitNorm z â†’ Summable fun n => z ^ n / (â†‘n + 1) ^ 2 ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedSpace ğ•œ ğ•œ] (z : ğ•œ),\n  (HasNorm z âˆ§ âˆ¥zâˆ¥ = 1) â†’ Summable (Î» (n : â„•), z ^ n / (â†‘n + 1) ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup ğ•œ] {z : ğ•œ},\n  Complex.abs z = 1 â†’ Summable (Î» n, z ^ n / (â†‘n * â†‘n)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NondiscreteNormedField ğ•œ] {R : â„} (z : ğ•œ), R = 1 â†’ Complex.abs z = R â†’ Summable (Î» n => z ^ n / (n + 1) ^ 2) "
    ]
  },
  {
    "docString": "Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚) (s : Set â„‚),\\n  Set.Countable s â†’\\n    ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n      (âˆ€ (x : â„‚),\\n          x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) \\\\ s â†’\\n            HasFDerivAt f (f' x) x) â†’\\n        MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\\n            (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n          (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) -\\n                  âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\\n                Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\\n            âˆ« (x : â„) in z.re..w.re,\\n              âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\\n`z w : â„‚`, is *real* differentiable at all but countably many points of the corresponding open\\nrectangle, and $\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the\\nintegral of `f` over the boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  x âˆˆ s â†’\\n    (âˆ€ (u : Set (Î² Ã— Î²)),\\n        u âˆˆ uniformity Î² â†’\\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚),\\n  ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n    (âˆ€ (x : â„‚),\\n        x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) â†’\\n          HasFDerivAt f (f' x) x) â†’\\n      MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\\n          (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n        (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\\n            Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\\n          âˆ« (x : â„) in z.re..w.re,\\n            âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\\n`z w : â„‚`, is *real* differentiable on the corresponding open rectangle, and\\n$\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the integral of `f` over\\nthe boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"}]\n",
    "prompt_cons": "/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\n`z w : â„‚`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚) (s : Set â„‚),\n  Set.Countable s â†’\n    ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n      (âˆ€ (x : â„‚),\n          x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) \\ s â†’\n            HasFDerivAt f (f' x) x) â†’\n        MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\n            (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n          (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) -\n                  âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n                Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n            âˆ« (x : â„) in z.re..w.re,\n              âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousAt f x :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ Equicontinuous F :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  x âˆˆ s â†’\n    (âˆ€ (u : Set (Î² Ã— Î²)),\n        u âˆˆ uniformity Î² â†’\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n      ContinuousWithinAt f s x :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\n`z w : â„‚`, is *real* differentiable on the corresponding open rectangle, and\n$\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the integral of `f` over\nthe boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚),\n  ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n    (âˆ€ (x : â„‚),\n        x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) â†’\n          HasFDerivAt f (f' x) x) â†’\n      MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\n          (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n        (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n            Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n          âˆ« (x : â„) in z.re..w.re,\n            âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²]\n  [inst_3 : MeasurableSpace Î±] [inst_4 : BorelSpace Î±] [inst_5 : AddCommGroup Î²] [inst_6 : BorelSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} {f g F G : Î± â†’ Î²}, MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’\n    Continuous F â†’ Continuous G â†’ (âˆ€ (x : Î±), MeasureTheory.integral (MeasureTheory.Measure.restrict Î¼ (Set.Iic x)) f = F x) â†’\n      (âˆ€ (x : Î±), MeasureTheory.integral (MeasureTheory.Measure.restrict Î¼ (Set.Iic x)) g = G x) â†’ F = G ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f Fâ‚ Fâ‚‚ : X â†’ â„},\n  Continuous f â†’ (âˆ€ (x : X), HasDerivAt Fâ‚ (f x) x) â†’ (âˆ€ (x : X), HasDerivAt Fâ‚‚ (f x) x) â†’ Fâ‚ - Fâ‚‚ = Function.const X (Fâ‚ 0 - Fâ‚‚ 0) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y] {Î© : Set X}\n  [inst_3 : IsConnected Î©] {f g F G : X â†’ Y}, ContinuousOn f Î© â†’ ContinuousOn g Î© â†’\n    (âˆ€ x âˆˆ Î©, derivWithin F Î© x = f x) â†’ (âˆ€ x âˆˆ Î©, derivWithin G Î© x = g x) â†’\n      (âˆƒ c : Y, âˆ€ x âˆˆ Î©, F x = G x + c) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {Î© : Set Î±}\n  {f F G : Î± â†’ Î²},\n  ContinuousOn f Î© â†’\n  (âˆ€ (x : Î±), x âˆˆ Î© â†’ HasDerivWithinAt F (f x) Î© x) â†’\n  (âˆ€ (x : Î±), x âˆˆ Î© â†’ HasDerivWithinAt G (f x) Î© x) â†’\n  âˆ€ (x : Î±), x âˆˆ Î© â†’ âˆƒ (C : Î²), âˆ€ (y : Î±), y âˆˆ Î© â†’ F y = G y + C ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : AddGroup Î²]\n  [inst_3 : TopologicalAddGroup Î²] {Î¼ : MeasureTheory.Measure Î±} {f F G : Î± â†’ Î²},\n  Continuous f â†’ Measurable F â†’ Measurable G â†’ (âˆ€ (x : Î±), âˆ« (t : Î±) in x..x, f t = 0) â†’\n    MeasureTheory.Integrable f â†’\n      MeasureTheory.Integrable F â†’ MeasureTheory.Integrable G â†’\n        (âˆ€ (x : Î±), âˆ« (t : Î±) in x..x, F t = âˆ« (t : Î±) in x..x, G t) â†’\n          âˆƒ (c : Î²), âˆ€ (x : Î±), F x = G x + c ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±]\n  {Î© : Set Î±} {f F G : Î± â†’ Î²}, ContinuousOn f Î© â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt F (f x) Î© x) â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt G (f x) Î© x) â†’\n  (âˆƒ C : Î², âˆ€ x âˆˆ Î©, F x - G x = C) ",
      "âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : TopologicalSpace F]\n  [inst_3 : TopologicalSpace E] {f Fâ‚€ Fâ‚ : F â†’ E} {Î© : Set F},\n  ContinuousOn f Î© â†’ HasPrimitiveOn Fâ‚€ f Î© â†’ HasPrimitiveOn Fâ‚ f Î© â†’ âˆƒ c : E, âˆ€ x âˆˆ Î©, Fâ‚€ x = Fâ‚ x + c ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : AddCommGroup Î²]\n  {f : Î± â†’ Î²} {Fâ‚ Fâ‚‚ : Î± â†’ Î²},\n  Continuous f â†’\n    (âˆ€ (x : Î±), HasDeriv Fâ‚ f x) â†’ (âˆ€ (x : Î±), HasDeriv Fâ‚‚ f x) â†’ âˆƒ (C : Î²), âˆ€ (x : Î±), Fâ‚ x = Fâ‚‚ x + C ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±]\n  {s : Set Î²} [inst_3 : LocallyConnectedSpace (Î± â†’ Î²)] (f g F G : Î± â†’ Î²),\n  ContinuousOn f s â†’ ContinuousOn g s â†’\n    (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ (t : Set Î±), IsOpen t âˆ§ x âˆˆ t âˆ§ Set.EqOn f g t) â†’\n    (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ (t : Set Î±), IsOpen t âˆ§ x âˆˆ t âˆ§ Set.EqOn F G t) â†’\n      âˆƒ (C : Î²), âˆ€ (x : Î±), x âˆˆ s â†’ F x = G x + C ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î²] {Î© : Set Î±}\n  {f Fâ‚ Fâ‚‚ : Î± â†’ Î²},\n  ContinuousOn f Î© â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt Fâ‚ (f x) Î© x) â†’ (âˆ€ x âˆˆ Î©, HasDerivWithinAt Fâ‚‚ (f x) Î© x) â†’\n    âˆƒ C : Î², âˆ€ x âˆˆ Î©, Fâ‚ x = Fâ‚‚ x + C "
    ]
  },
  {
    "docString": "Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the first quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\\n  [inst_7 : ContinuousSMul R M] (f : M â†’L[R] R), f â‰  0 â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero continuous linear functional is open. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the first quadrant.\\n\\nThen `f` is equal to zero on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : Î± â†’ Î²},\\n  MeasureTheory.Memâ„’p f p â†’\\n    MeasureTheory.StronglyMeasurable f â†’\\n      âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ M, 0 < M âˆ§ MeasureTheory.snorm (Set.indicator {x | M â‰¤ â†‘â€–f xâ€–â‚Š} f) p Î¼ â‰¤ ENNReal.ofReal Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma implies that a single function is uniformly integrable (in the probability sense). \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : Fintype Î¹] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : (i : Î¹) â†’ NormedAddCommGroup (E i)] [inst_3 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)] [inst_4 : NormedAddCommGroup G]\\n  [inst_5 : NormedSpace ğ•œ G] (f : ContinuousMultilinearMap ğ•œ E G), â€–fâ€– = 0 â†” f = 0\",\n  \"isProp\": true,\n  \"docString\": \"A continuous linear map is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the second quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the second quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed second quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {p : FormalMultilinearSeries ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ},\\n  HasFPowerSeriesAt f p x â†’ f =á¶ [nhds x] 0 â†’ p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A one-dimensional formal multilinear series representing a locally zero function is zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the second quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the second quadrant.\\n\\nThen `f` is equal to zero on the closed second quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ğ•œ] F),\\n  Continuous â†‘e â†’ Continuous â†‘(LinearEquiv.symm e)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] (p : Subspace â„ E)\\n  (f : { x // x âˆˆ p } â†’L[â„] â„), âˆƒ g, (âˆ€ (x : { x // x âˆˆ p }), â†‘g â†‘x = â†‘f x) âˆ§ â€–gâ€– = â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Hahn-Banach theorem for continuous linear functions over `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {F : Type u_5} {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚] {Î¹ : Type u_1}\\n  [inst_7 : CompleteSpace E] {g : Î¹ â†’ E â†’SL[Ïƒâ‚â‚‚] F},\\n  (âˆ€ (x : E), âˆƒ C, âˆ€ (i : Î¹), â€–â†‘(g i) xâ€– â‰¤ C) â†’ âˆƒ C', âˆ€ (i : Î¹), â€–g iâ€– â‰¤ C'\",\n  \"isProp\": true,\n  \"docString\":\n  \"This is the standard Banach-Steinhaus theorem, or Uniform Boundedness Principle.\\nIf a family of continuous linear maps from a Banach space into a normed space is pointwise\\nbounded, then the norms of these linear maps are uniformly bounded. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : T2Space Î²] [inst_2 : MeasurableSpace Î²] [inst_3 : BorelSpace Î²] {f : Î³ â†’ Î²},\\n  Continuous f â†’ Function.Injective f â†’ MeasurableSet (Set.range f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\\nspace is Borel-measurable. \"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C :=\n\n/-- A nonzero continuous linear functional is open. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\n  [inst_7 : ContinuousSMul R M] (f : M â†’L[R] R), f â‰  0 â†’ IsOpenMap â†‘f :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im} :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : Î± â†’ Î²},\n  MeasureTheory.Memâ„’p f p â†’\n    MeasureTheory.StronglyMeasurable f â†’\n      âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ M, 0 < M âˆ§ MeasureTheory.snorm (Set.indicator {x | M â‰¤ â†‘â€–f xâ€–â‚Š} f) p Î¼ â‰¤ ENNReal.ofReal Îµ :=\n\n/-- A continuous linear map is zero iff its norm vanishes. -/\ntheorem âˆ€ {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [inst : Fintype Î¹] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : (i : Î¹) â†’ NormedAddCommGroup (E i)] [inst_3 : (i : Î¹) â†’ NormedSpace ğ•œ (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace ğ•œ G] (f : ContinuousMultilinearMap ğ•œ E G), â€–fâ€– = 0 â†” f = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the second quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the second quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed second quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€) :=\n\n/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {p : FormalMultilinearSeries ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ},\n  HasFPowerSeriesAt f p x â†’ f =á¶ [nhds x] 0 â†’ p = 0 :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the second quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the second quadrant.\n\nThen `f` is equal to zero on the closed second quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im} :=\n\n/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ğ•œ] F),\n  Continuous â†‘e â†’ Continuous â†‘(LinearEquiv.symm e) :=\n\n/-- Hahn-Banach theorem for continuous linear functions over `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] (p : Subspace â„ E)\n  (f : { x // x âˆˆ p } â†’L[â„] â„), âˆƒ g, (âˆ€ (x : { x // x âˆˆ p }), â†‘g â†‘x = â†‘f x) âˆ§ â€–gâ€– = â€–fâ€– :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C :=\n\n/-- This is the standard Banach-Steinhaus theorem, or Uniform Boundedness Principle.\nIf a family of continuous linear maps from a Banach space into a normed space is pointwise\nbounded, then the norms of these linear maps are uniformly bounded. -/\ntheorem âˆ€ {E : Type u_2} {F : Type u_5} {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚] {Î¹ : Type u_1}\n  [inst_7 : CompleteSpace E] {g : Î¹ â†’ E â†’SL[Ïƒâ‚â‚‚] F},\n  (âˆ€ (x : E), âˆƒ C, âˆ€ (i : Î¹), â€–â†‘(g i) xâ€– â‰¤ C) â†’ âˆƒ C', âˆ€ (i : Î¹), â€–g iâ€– â‰¤ C' :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem âˆ€ {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : T2Space Î²] [inst_2 : MeasurableSpace Î²] [inst_3 : BorelSpace Î²] {f : Î³ â†’ Î²},\n  Continuous f â†’ Function.Injective f â†’ MeasurableSet (Set.range f) :=\n\n/-- Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {Ï• : E â†’ E} {zâ‚€ : E},\n  IsOpen Î© â†’\n    Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ deriv ğ•œ Ï• zâ‚€ = 1 â†’\n          âˆ€ (z : E), z âˆˆ Î© â†’ Ï• z = zâ‚€ + z - zâ‚€ ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set â„‚},\n  IsOpen Î© â†’\n    Bounded Î© â†’\n      âˆ€ {Ï† : â„‚ â†’ â„‚},\n        MDifferentiableOn â„‚ Ï† Î© â†’\n          ContinuousOn Ï† (Closure Î©) â†’\n            âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’\n              Ï† zâ‚€ = zâ‚€ â†’\n                deriv Ï† zâ‚€ = 1 â†’ (âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï† z = zâ‚€ + (z - zâ‚€)) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {Î© : Set â„‚} [inst_4 : BorelSpace F] {Ï† : E â†’ F},\n  IsOpen Î© â†’ Bounded Î© â†’ AnalyticOn â„‚ Ï† Î© â†’\n    (âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï† zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï† 1 zâ‚€) â†’\n      (âˆ€ z, z âˆˆ Î© â†’ Ï† z = z + (Ï† zâ‚€ - zâ‚€)) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {â„¦ : Set â„‚} {Ï† : â„‚ â†’ â„‚},\n  IsOpen â„¦ â†’ Metric.Bounded â„¦ â†’ ContinuousOn Ï† â„¦ â†’ DifferentiableOn â„‚ Ï† â„¦ â†’\n    (âˆ€ (z : â„‚), z âˆˆ â„¦ â†’ Ï† z âˆˆ â„¦) â†’\n      (âˆƒ zâ‚€, zâ‚€ âˆˆ â„¦ âˆ§ Ï† zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï† 1 zâ‚€) â†’ âˆƒ c : â„‚, âˆ€ (z : â„‚), z âˆˆ â„¦ â†’ Ï† z = z + c ",
      "âˆ€ {â„‚ : Type u_1} [inst : NormedAddCommGroup â„‚] [inst_1 : NormedSpace â„‚ â„‚] {Î© : Set â„‚},\n  IsOpen Î© â†’\n    (âˆƒ R,\n        Metric.Bounded Î© âˆ§\n          âˆ€ (z : â„‚), z âˆˆ Î© â†’ Metric.ClosedBall z R âŠ† Î©) â†’\n      âˆ€ {f : â„‚ â†’ â„‚},\n        MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f â†’\n          âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ f zâ‚€ = zâ‚€ â†’ (deriv I (modelWithCornersSelf â„‚ â„‚) f zâ‚€).re = 1 â†’ IsLinearMap â„‚ f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set â„‚} (hÎ© : IsOpen Î©) {Ï† : â„‚ â†’ â„‚},\n  MDifferentiableOn â„‚ Ï† Î© â†’\n    IsLinearMap â„‚ Ï† â†’\n      (âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï† zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï† 1 zâ‚€) â†’ âˆ€ z : â„‚, z âˆˆ Î© â†’ (LinearMap.mk Ï† (is_linear_map.mk' Ï† _) z = Ï† z) ",
      "forall {â„‚ : Type u_1} [inst : NontriviallyNormedField â„‚] [inst_1 : NormedAddCommGroup â„‚] [inst_2 : NormedSpace â„‚ â„‚]\n  {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚}, Convex â„‚ Î© â†’ IsOpen Î© â†’ DifferentiableOn â„‚ Ï• Î© â†’\n    (âˆ€ (z : â„‚), HasMem.Mem z Î© â†’ HasMem.Mem (Ï• z) Î©) â†’\n      (âˆƒ zâ‚€, HasMem.Mem zâ‚€ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ deriv Ï• zâ‚€ = 1) â†’\n        (âˆƒ a b, âˆ€ (z : â„‚), HasMem.Mem z Î© â†’ Ï• z = a * z + b) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (Î© : Set E)\n  [inst_3 : IsOpen Î©] [inst_4 : Metric.Bounded Î©] {Ï† : E â†’ E} {zâ‚€ : E},\n  AnalyticAt â„‚ Ï† zâ‚€ â†’ Ï† zâ‚€ = zâ‚€ â†’ deriv (Ï† : E â†’ â„‚) zâ‚€ = 1 â†’\n    (âˆ€ x âˆˆ Î©, Ï† x âˆˆ Î©) â†’ LinearIsometryEquiv.toContinuousLinearEquiv (Ï† : E â‰ƒâ‚—áµ¢[â„‚] E) = Ï† ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M]\n  [inst_7 : ChartedSpace H M] [inst_8 : SmoothManifoldWithCorners I M] {Î© : Set M} {Ï† : M â†’ M},\n  IsOpen Î© â†’ âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï† zâ‚€ = zâ‚€ âˆ§ MDifferentiableAt I (modelWithCornersSelf â„‚ F) Ï† zâ‚€ âˆ§\n    â‡‘(mfderiv I (modelWithCornersSelf â„‚ F) Ï† zâ‚€) = linearIsometryEquiv.refl â„‚ F â†’\n      âˆ€á¶  (z : M) in nhds_within zâ‚€ Î©, Ï† z = z + (z - zâ‚€) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E}\n  [inst_2 : IsOpen Î©] {Î¦ : E â†’ E} (hÎ¦ : Î¦ âˆˆ HolomorphicOn â„‚ Î©) {zâ‚€ : E} (hzâ‚€ : zâ‚€ âˆˆ Î©) (hzâ‚€' : Î¦ zâ‚€ = zâ‚€),\n  HasDerivAt Î¦ 1 zâ‚€ â†’ âˆ€ (z : E), z âˆˆ Î© â†’ Î¦ z = zâ‚€ + (z - zâ‚€) "
    ]
  },
  {
    "docString": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, âˆ)`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iic a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-âˆ, a]. \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iio a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-âˆ, a). \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, a < -1 â†’ âˆ€ {c : â„}, 0 < c â†’ MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `0 < c`, then `(Î» t : â„, t ^ a)` is integrable on `(c, âˆ)` for all `a < -1`. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„},\\n  a â‰¤ 0 â†’\\n    âˆ€ {z : â„‚},\\n      |z.im| â‰¤ b â†’\\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_4} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace ğ•œ H] {F : H â†’ Î± â†’ E}\\n  {F' : Î± â†’ H â†’L[ğ•œ] E} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„},\\n  0 < Îµ â†’\\n    (âˆ€á¶  (x : H) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\\n      MeasureTheory.Integrable (F xâ‚€) â†’\\n        MeasureTheory.AEStronglyMeasurable F' Î¼ â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, LipschitzOnWith (â†‘Real.nnabs (bound a)) (fun x => F x a) (Metric.ball xâ‚€ Îµ)) â†’\\n            MeasureTheory.Integrable bound â†’\\n              (âˆ€áµ (a : Î±) âˆ‚Î¼, HasFDerivAt (fun x => F x a) (F' a) xâ‚€) â†’\\n                MeasureTheory.Integrable F' âˆ§ HasFDerivAt (fun x => âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"Differentiation under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€`, assuming\\n`F xâ‚€` is integrable, `x â†¦ F x a` is locally Lipschitz on a ball around `xâ‚€` for ae `a`\\n(with a ball radius independent of `a`) with integrable Lipschitz bound, and `F x` is ae-measurable\\nfor `x` in a possibly smaller neighborhood of `xâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’\\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\\nfinite limit `c` almost surely at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-c` at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] (a : Î±) [inst_4 : NoMinOrder Î±], closure (Set.Iio a) = Set.Iic a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closure of the interval `(-âˆ, a)` is the interval `(-âˆ, a]`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_4} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace ğ•œ H] {F : H â†’ Î± â†’ E}\\n  {F' : H â†’ Î± â†’ H â†’L[ğ•œ] E} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„},\\n  0 < Îµ â†’\\n    (âˆ€á¶  (x : H) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\\n      MeasureTheory.Integrable (F xâ‚€) â†’\\n        MeasureTheory.AEStronglyMeasurable (F' xâ‚€) Î¼ â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ Metric.ball xâ‚€ Îµ â†’ â€–F' x aâ€– â‰¤ bound a) â†’\\n            MeasureTheory.Integrable bound â†’\\n              (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ Metric.ball xâ‚€ Îµ â†’ HasFDerivAt (fun x => F x a) (F' x a) x) â†’\\n                HasFDerivAt (fun x => âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"Differentiation under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€`, assuming\\n`F xâ‚€` is integrable, `x â†¦ F x a` is differentiable on a ball around `xâ‚€` for ae `a` with\\nderivative norm uniformly bounded by an integrable function (the ball radius is independent of `a`),\\nand `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `xâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} [hT : Fact (0 < T)] {E : Type} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : AddCircle T â†’ E)\\n  (n : â„¤) (a : â„), fourierCoeff f n = (1 / T) â€¢ âˆ« (x : â„) in a..a + T, â†‘(fourier (-n)) â†‘x â€¢ f â†‘x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Fourier coefficients of a function on `AddCircle T` can be computed as an integral\\nover `[a, a + T]`, for any real `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` is continuous\\nat `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-f a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\\ncontinuous at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-f a` at `a`. \"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. -/\ntheorem âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1) :=\n\n/-- `exp (-b * x)` is integrable on `(a, âˆ)`. -/\ntheorem âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- The cardinality of the interval (-âˆ, a]. -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iic a) = Cardinal.continuum :=\n\n/-- The cardinality of the interval (-âˆ, a). -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iio a) = Cardinal.continuum :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `0 < c`, then `(Î» t : â„, t ^ a)` is integrable on `(c, âˆ)` for all `a < -1`. -/\ntheorem âˆ€ {a : â„}, a < -1 â†’ âˆ€ {c : â„}, 0 < c â†’ MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c) :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I :=\n\n/-- A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem âˆ€ {a b : â„},\n  a â‰¤ 0 â†’\n    âˆ€ {z : â„‚},\n      |z.im| â‰¤ b â†’\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- Differentiation under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€`, assuming\n`F xâ‚€` is integrable, `x â†¦ F x a` is locally Lipschitz on a ball around `xâ‚€` for ae `a`\n(with a ball radius independent of `a`) with integrable Lipschitz bound, and `F x` is ae-measurable\nfor `x` in a possibly smaller neighborhood of `xâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_4} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace ğ•œ H] {F : H â†’ Î± â†’ E}\n  {F' : Î± â†’ H â†’L[ğ•œ] E} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆ€á¶  (x : H) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\n      MeasureTheory.Integrable (F xâ‚€) â†’\n        MeasureTheory.AEStronglyMeasurable F' Î¼ â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, LipschitzOnWith (â†‘Real.nnabs (bound a)) (fun x => F x a) (Metric.ball xâ‚€ Îµ)) â†’\n            MeasureTheory.Integrable bound â†’\n              (âˆ€áµ (a : Î±) âˆ‚Î¼, HasFDerivAt (fun x => F x a) (F' a) xâ‚€) â†’\n                MeasureTheory.Integrable F' âˆ§ HasFDerivAt (fun x => âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€ :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\nfinite limit `c` almost surely at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-c` at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) a :=\n\n/-- The closure of the interval `(-âˆ, a)` is the interval `(-âˆ, a]`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] (a : Î±) [inst_4 : NoMinOrder Î±], closure (Set.Iio a) = Set.Iic a :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- Differentiation under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€`, assuming\n`F xâ‚€` is integrable, `x â†¦ F x a` is differentiable on a ball around `xâ‚€` for ae `a` with\nderivative norm uniformly bounded by an integrable function (the ball radius is independent of `a`),\nand `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `xâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_4} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace ğ•œ H] {F : H â†’ Î± â†’ E}\n  {F' : H â†’ Î± â†’ H â†’L[ğ•œ] E} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆ€á¶  (x : H) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\n      MeasureTheory.Integrable (F xâ‚€) â†’\n        MeasureTheory.AEStronglyMeasurable (F' xâ‚€) Î¼ â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ Metric.ball xâ‚€ Îµ â†’ â€–F' x aâ€– â‰¤ bound a) â†’\n            MeasureTheory.Integrable bound â†’\n              (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ Metric.ball xâ‚€ Îµ â†’ HasFDerivAt (fun x => F x a) (F' x a) x) â†’\n                HasFDerivAt (fun x => âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€ :=\n\n/-- The Fourier coefficients of a function on `AddCircle T` can be computed as an integral\nover `[a, a + T]`, for any real `a`. -/\ntheorem âˆ€ {T : â„} [hT : Fact (0 < T)] {E : Type} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : AddCircle T â†’ E)\n  (n : â„¤) (a : â„), fourierCoeff f n = (1 / T) â€¢ âˆ« (x : â„) in a..a + T, â†‘(fourier (-n)) â†‘x â€¢ f â†‘x :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` is continuous\nat `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -f a :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\ncontinuous at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-f a` at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-f a) a :=\n\n/-- Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$. -/\ntheorem",
    "choices": [
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (â†‘Real.cos x) / (x ^ 2 + a ^ 2) = â†‘Real.pi * (rexp (-a) / a) ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ .. âˆ, (Real.cos x) / (x^2 + a^2) = Real.pi * (Real.exp (-a) / a) ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (Real.cos x) / (x ^ 2 + a ^ 2) = Real.pi * (Real.exp (-a) / a) ",
      "forall (a : â„), 0 < a â†’ âˆ« (x : â„) in Real.Inf ..Real.Sup, (Real.cos x) / (x^2 + a^2) = Real.pi * (Real.exp (-a)) / a ",
      "âˆ€ (a : â„), 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (Real.cos x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (Real.cos x) / (x ^ 2 + a ^ 2) = Real.pi * (Real.exp (-a) / a) ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (Real.cos x / (x ^ 2 + a ^ 2)) = Real.pi * (rexp (-a) / a) ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, (Real.cos x) / (x^2 + a^2) = Real.pi * rexp (-a) / a ",
      "âˆ€ (a : â„), 0 < a â†’ (âˆ« (x : â„) in â„..â„, Real.cos x / (x ^ 2 + a ^ 2)) = Real.pi * rexp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in â„, (Complex.cos x) / (x ^ 2 + a ^ 2) = Real.pi * (rexp (-a) / a) "
    ]
  },
  {
    "docString": "Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„), Real.cos x â‰  0 â†’ deriv (fun y => Real.tan y - y) x = â†‘1 / Real.cos x ^ 2 - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 < x â†’ Real.sin x < x\",\n  \"isProp\": true,\n  \"docString\": \"For 0 < x, we have sin x < x. \"},\n {\"theorem\": \"âˆ€ (x : â„), 0 < x â†’ x â‰¤ 1 â†’ |Real.log x * x| < 1\",\n  \"isProp\": true,\n  \"docString\": \"Bound for `|log x * x|` in the interval `(0, 1]`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 < x â†’ x < Real.pi / 2 â†’ x < Real.tan x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `0 < x < Ï€/2` we have `x < tan x`.\\n\\nThis is proved by checking that the function `tan x - x` vanishes\\nat zero and has non-negative derivative. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.cos x ^ (n + 2) =\\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.cos x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `cos x ^ n` for any natural `n â‰¥ 2`. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. \"},\n {\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 6` is `1 / 2`. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 3` is `âˆš3 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {s t a b : â„},\\n  0 < s â†’ 0 < t â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ Real.Gamma (a * s + b * t) â‰¤ Real.Gamma s ^ a * Real.Gamma t ^ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Log-convexity of the Gamma function on the positive reals (stated in multiplicative form),\\nproved using the HÃ¶lder inequality applied to Euler's integral. \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 3` is `1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\\n  Real.cos (InnerProductGeometry.angle x y) = -1 â†” InnerProductGeometry.angle x y = Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cosine of the angle between two vectors is -1 if and only if the angle is Ï€. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 6` is `âˆš3 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (z : â„‚),\\n  Filter.Tendsto (fun n => â†‘Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (â†‘Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x)) :=\n\n/-- The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. -/\ntheorem âˆ€ (x : â„), Real.cos x â‰  0 â†’ deriv (fun y => Real.tan y - y) x = â†‘1 / Real.cos x ^ 2 - 1 :=\n\n/-- The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n :=\n\n/-- For 0 < x, we have sin x < x. -/\ntheorem âˆ€ {x : â„}, 0 < x â†’ Real.sin x < x :=\n\n/-- Bound for `|log x * x|` in the interval `(0, 1]`. -/\ntheorem âˆ€ (x : â„), 0 < x â†’ x â‰¤ 1 â†’ |Real.log x * x| < 1 :=\n\n/-- For all `0 < x < Ï€/2` we have `x < tan x`.\n\nThis is proved by checking that the function `tan x - x` vanishes\nat zero and has non-negative derivative. -/\ntheorem âˆ€ {x : â„}, 0 < x â†’ x < Real.pi / 2 â†’ x < Real.tan x :=\n\n/-- The reduction formula for the integral of `cos x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.cos x ^ (n + 2) =\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.cos x ^ n :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I :=\n\n/-- Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹)) :=\n\n/-- The sine of `Ï€ / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- The sine of `Ï€ / 3` is `âˆš3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- Log-convexity of the Gamma function on the positive reals (stated in multiplicative form),\nproved using the HÃ¶lder inequality applied to Euler's integral. -/\ntheorem âˆ€ {s t a b : â„},\n  0 < s â†’ 0 < t â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ Real.Gamma (a * s + b * t) â‰¤ Real.Gamma s ^ a * Real.Gamma t ^ b :=\n\n/-- The cosine of `Ï€ / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- The cosine of the angle between two vectors is -1 if and only if the angle is Ï€. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] {x y : V},\n  Real.cos (InnerProductGeometry.angle x y) = -1 â†” InnerProductGeometry.angle x y = Real.pi :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem âˆ€ (x : â„),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- The cosine of `Ï€ / 6` is `âˆš3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem âˆ€ (z : â„‚),\n  Filter.Tendsto (fun n => â†‘Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (â†‘Real.pi * z))) :=\n\n/-- Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$. -/\ntheorem",
    "choices": [
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = - Real.log 2 ",
      "integral_log_sin_pi (x : â„) (hx : 0 < x) (hx' : x < 1) :\n  âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 ",
      "integral_log_sin_pi ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 "
    ]
  },
  {
    "docString": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\\n  0 â‰¤ R â†’\\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\\n      Set.Countable s â†’\\n        ContinuousOn f (Metric.closedBall c R) â†’\\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the first quadrant.\\n\\nThen `f` is equal to zero on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {p : FormalMultilinearSeries ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ},\\n  HasFPowerSeriesAt f p x â†’ f =á¶ [nhds x] 0 â†’ p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A one-dimensional formal multilinear series representing a locally zero function is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. \"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\n  0 â‰¤ R â†’\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\n      Set.Countable s â†’\n        ContinuousOn f (Metric.closedBall c R) â†’\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0 :=\n\n/-- Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0 :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im} :=\n\n/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f)) :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\nfor some value `v`. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v :=\n\n/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {p : FormalMultilinearSeries ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ},\n  HasFPowerSeriesAt f p x â†’ f =á¶ [nhds x] 0 â†’ p = 0 :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z :=\n\n/-- Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$. -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„‚ â†’ â„‚},\n  DiffContOnCl â„‚ f (Metric.closedBall 0 1) â†’\n    Set.EqOn f (fun z => zâ»Â¹) (Metric.sphere 0 1) â†’ False ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’\n    ContinuousOn f (Set.Icc (-1) 1 Ã—â„‚ Set.Icc (-1) 1) â†’\n      (âˆ€ (x : â„), 1 = f (â†‘x / (â†‘x.sq_abs) * Complex.I)) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DifferentiableOn â„‚ f (Metric.ball 0 1) â†’\n    ContinuousOn f (Metric.closedBall 0 1) â†’\n      (âˆ€ (z : â„‚), â†‘Complex.abs z = 1 â†’ f z = zâ»Â¹) â†’ False ",
      "âˆ€ {f : â„‚ â†’ â„‚},\n  ContinuousOn f (Metric.closedBall 0 1) â†’\n    Set.EqOn f (Î» (z : â„‚), zâ»Â¹) (Metric.sphere 0 1) â†’\n      Â¬DifferentiableOn â„‚ f (Metric.ball 0 1) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DifferentiableOn â„‚ f (Metric.ball 0 1) â†’\n    ContinuousOn f (Metric.closedBall 0 1) â†’\n      Set.EqOn f (fun z => 1 / z) (Metric.sphere 0 1) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  (âˆƒ p : FormalMultilinearSeries â„‚ â„‚ E, HasFPowerSeriesOnBall f p 0 1) â†’\n    ContinuousOn f (Metric.sphere 0 1) â†’\n      (âˆ€ z âˆˆ Metric.sphere 0 1, f z = zâ»Â¹) â†’ False ",
      "âˆ€ {f : â„‚ â†’ â„‚},\n  DifferentiableOn â„‚ f (Metric.ball 0 1) â†’\n    Set.EqOn f (Î» z, zâ»Â¹) (Metric.sphere 0 1) â†’ ContinuousOn f (Metric.closedBall 0 1) â†’ False ",
      "forall {f : â„‚ â†’ â„‚} {z : â„‚},\n  DifferentiableOn â„‚ f (Metric.ball 0 1) â†’\n    ContinuousOn f (Metric.closedBall 0 1) â†’\n      Set.EqOn f (Î» z, 1 / z) (Metric.sphere 0 1) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {x : E},\n  Â¬(âˆƒ f : Disk x 1 â†’ E,\n      MDifferentiable (modelWithCornersSelf â„‚ E) (â‡‘f) âˆ§\n        ContinuousOn (â‡‘f) (Frontier (Metric.ClosedBall x 1)) âˆ§ âˆ€ z : E, x â‰  z â†’ â†‘Complex.abs (z - x) = 1 â†’ f z = (z - x)â»Â¹) ",
      "Â¬âˆƒ (f : â„‚ â†’ â„‚),\n    DifferentiableOn â„‚ f (Metric.ball 0 1) âˆ§\n      ContinuousOn f (Metric.closedBall 0 1) âˆ§\n        âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = zâ»Â¹ "
    ]
  },
  {
    "docString": "For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$",
    "prompts": "[{\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), riemannZeta (-2 * (â†‘n + 1)) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The trivial zeroes of the zeta function. \"},\n {\"theorem\": \"Cardinal.mk â†‘Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, a % 4 = 3 â†’ b % 4 = 3 â†’ jacobiSym (â†‘a) b = -jacobiSym (â†‘b) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„š),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {Râ‚ : Type u_3} {Râ‚‚ : Type u_4} (Mâ‚ : Type u_1) (Mâ‚‚ : Type u_5) [inst : CommSemiring R]\\n  [inst_1 : CommSemiring Râ‚] [inst_2 : AddCommMonoid Mâ‚] [inst_3 : Module Râ‚ Mâ‚] [inst_4 : CommSemiring Râ‚‚]\\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : Module Râ‚‚ Mâ‚‚] (Iâ‚ : Râ‚ â†’+* R) (Iâ‚‚ : Râ‚‚ â†’+* R) [inst_7 : Nontrivial Mâ‚],\\n  Â¬LinearMap.SeparatingLeft 0\",\n  \"isProp\": true,\n  \"docString\": \"In a non-trivial module, zero is not non-degenerate. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (u v w : Fin 3 â†’ R),\\n  â†‘(â†‘crossProduct u) (â†‘(â†‘crossProduct v) w) + â†‘(â†‘crossProduct v) (â†‘(â†‘crossProduct w) u) +\\n      â†‘(â†‘crossProduct w) (â†‘(â†‘crossProduct u) v) =\\n    0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Jacobi identity: For a cross product of three vectors,\\ntheir sum over the three even permutations is equal to the zero vector. \"},\n {\"theorem\":\n  \"âˆ€ (Mâ‚€ : Type u_1) [inst : MulZeroOneClass Mâ‚€] [inst_1 : Nontrivial Mâ‚€], NeZero 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nontrivial monoid with zero, zero and one are different. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 â‰¤ x â†’ âˆ€ (y z : â„), x ^ y * x ^ z â‰¤ x ^ (y + z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `0 â‰¤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\\nThe inequality is always true, though, and given in this lemma. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} (self : ComplexShape Î¹) {i i' j : Î¹}, ComplexShape.Rel self i j â†’ ComplexShape.Rel self i' j â†’ i = i'\",\n  \"isProp\": true,\n  \"docString\": \"There is at most one nonzero differential to `X j`. \"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- The trivial zeroes of the zeta function. -/\ntheorem âˆ€ (n : â„•), riemannZeta (-2 * (â†‘n + 1)) = 0 :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk â†‘Set.univ = Cardinal.continuum :=\n\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. -/\ntheorem âˆ€ {a b : â„•}, a % 4 = 3 â†’ b % 4 = 3 â†’ jacobiSym (â†‘a) b = -jacobiSym (â†‘b) a :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem âˆ€ (p : Polynomial â„š),\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\n      Finset.card\n        (Equiv.Perm.support\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe)))) :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem âˆ€ {R : Type u_2} {Râ‚ : Type u_3} {Râ‚‚ : Type u_4} (Mâ‚ : Type u_1) (Mâ‚‚ : Type u_5) [inst : CommSemiring R]\n  [inst_1 : CommSemiring Râ‚] [inst_2 : AddCommMonoid Mâ‚] [inst_3 : Module Râ‚ Mâ‚] [inst_4 : CommSemiring Râ‚‚]\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : Module Râ‚‚ Mâ‚‚] (Iâ‚ : Râ‚ â†’+* R) (Iâ‚‚ : Râ‚‚ â†’+* R) [inst_7 : Nontrivial Mâ‚],\n  Â¬LinearMap.SeparatingLeft 0 :=\n\n/-- Jacobi identity: For a cross product of three vectors,\ntheir sum over the three even permutations is equal to the zero vector. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (u v w : Fin 3 â†’ R),\n  â†‘(â†‘crossProduct u) (â†‘(â†‘crossProduct v) w) + â†‘(â†‘crossProduct v) (â†‘(â†‘crossProduct w) u) +\n      â†‘(â†‘crossProduct w) (â†‘(â†‘crossProduct u) v) =\n    0 :=\n\n/-- In a nontrivial monoid with zero, zero and one are different. -/\ntheorem âˆ€ (Mâ‚€ : Type u_1) [inst : MulZeroOneClass Mâ‚€] [inst_1 : Nontrivial Mâ‚€], NeZero 1 :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- For `0 â‰¤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\nThe inequality is always true, though, and given in this lemma. -/\ntheorem âˆ€ {x : â„}, 0 â‰¤ x â†’ âˆ€ (y z : â„), x ^ y * x ^ z â‰¤ x ^ (y + z) :=\n\n/-- There is at most one nonzero differential to `X j`. -/\ntheorem âˆ€ {Î¹ : Type u_1} (self : ComplexShape Î¹) {i i' j : Î¹}, ComplexShape.Rel self i j â†’ ComplexShape.Rel self i' j â†’ i = i' :=\n\n/-- For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$ -/\ntheorem",
    "choices": [
      "âˆ€ (z1 z2 z3 z4 : â„‚),\n  Complex.abs z1 = 1 â†’ z1 â‰  1 â†’\n  Complex.abs z2 = 1 â†’ z2 â‰  1 â†’\n  Complex.abs z3 = 1 â†’ z3 â‰  1 â†’\n  Complex.abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, â†‘Complex.normSq z1 = 1 â†’ â†‘Complex.normSq z2 = 1 â†’ â†‘Complex.normSq z3 = 1 â†’ â†‘Complex.normSq z4 = 1 â†’ z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ (z1 z2 z3 z4 : â„‚),\n  Complex.abs z1 = 1 â†’\n    Complex.abs z2 = 1 â†’\n      Complex.abs z3 = 1 â†’\n        Complex.abs z4 = 1 â†’\n          z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "forall (z1 z2 z3 z4 : â„‚), Complex.abs z1 = 1 â†’ Complex.abs z2 = 1 â†’ Complex.abs z3 = 1 â†’ Complex.abs z4 = 1 â†’\n  z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "forall (z : Fin 4 â†’ â„‚), (âˆ€ j, complex.normSq (z j) = 1 âˆ§ z j â‰  1) â†’ 3 - z 0 - z 1 - z 2 - z 3 + z 0 * z 1 * z 2 * z 3 â‰  0 ",
      "âˆ€ (z1 z2 z3 z4 : â„‚),\n  Complex.abs z1 = 1 â†’\n  Complex.abs z2 = 1 â†’\n  Complex.abs z3 = 1 â†’\n  Complex.abs z4 = 1 â†’\n  z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ (z1 z2 z3 z4 : â„‚),\n  Complex.abs z1 = 1 â†’ z1 â‰  1 â†’\n  Complex.abs z2 = 1 â†’ z2 â‰  1 â†’\n  Complex.abs z3 = 1 â†’ z3 â‰  1 â†’\n  Complex.abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ (z : Fin 4 â†’ â„‚), (âˆ€ (j : Fin 4), Complex.abs (z j) = 1 âˆ§ z j â‰  1) â†’ 3 - z 0 - z 1 - z 2 - z 3 + z 0 * z 1 * z 2 * z 3 â‰  0 ",
      "forall (z : Fin 4 â†’ â„‚) (hzâ‚ : âˆ€ j, Complex.abs (z j) = 1) (hzâ‚‚ : âˆ€ j, z j â‰  1),\n  3 - (z 0 + z 1 + z 2 + z 3) + z 0 * z 1 * z 2 * z 3 â‰  0 ",
      "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚}, Complex.abs zâ‚ = 1 â†’ Complex.abs zâ‚‚ = 1 â†’ Complex.abs zâ‚ƒ = 1 â†’ Complex.abs zâ‚„ = 1 â†’\n  zâ‚ â‰  1 â†’ zâ‚‚ â‰  1 â†’ zâ‚ƒ â‰  1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 "
    ]
  },
  {
    "docString": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\\n  0 â‰¤ R â†’\\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\\n      Set.Countable s â†’\\n        ContinuousOn f (Metric.closedBall c R) â†’\\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤} {c w : â„‚} {R : â„}, n < 0 â†’ w âˆˆ Metric.sphere c |R| â†’ (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\\ncenter `c` and radius `|R|`, so the integral `âˆ® z in C(c, R), (z - w) ^ n` is equal to zero. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"`zeta n A B` is a primitive `n`-th root of unity. \"},\n {\"theorem\": \"âˆ€ (n : â„•), riemannZeta (-2 * (â†‘n + 1)) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The trivial zeroes of the zeta function. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complex `n`-th roots of unity are exactly the\\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  IsPrimitiveRoot Î¶ n â†’\\n    âˆƒ P,\\n      Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' n K âˆ§\\n        Polynomial.degree P = Polynomial.degree (Polynomial.cyclotomic' n K) âˆ§ Polynomial.Monic P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\\nmonic polynomial with integer coefficients. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„},\\n  0 < R â†’\\n    ContinuousOn f (Metric.sphere c R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ â€–f zâ€– â‰¤ C) â†’\\n        (âˆƒ z, z âˆˆ Metric.sphere c R âˆ§ â€–f zâ€– < C) â†’ â€–âˆ® (z : â„‚) in C(c, R), f zâ€– < 2 * Real.pi * R * C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is continuous on the circle `|z - c| = R`, `R > 0`, the `â€–f zâ€–` is less than or equal to\\n`C : â„` on this circle, and this norm is strictly less than `C` at some point `z` of the circle,\\nthen `â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C`. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R|\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\\nvaries over the `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball c R) â†’\\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) â†’ f c = c â†’ 0 < R â†’ â†‘Complex.abs (deriv f c) â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk of positive radius to itself and the\\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\\nthis disk is at most `1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\\n  ConvexOn â„ (Set.Ioi 0) f â†’\\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ 2 â‰¤ n â†’ 0 < x â†’ f â†‘n + x * Real.log (â†‘n - 1) â‰¤ f (â†‘n + x)\",\n  \"isProp\": true,\n  \"docString\": \"Linear lower bound for `f (x + n)` on unit interval \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), WittVector.IsPoly p fun R _Rcr x => x * â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by `n` is a polynomial function. \"}]\n",
    "prompt_cons": "/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\n  0 â‰¤ R â†’\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\n      Set.Countable s â†’\n        ContinuousOn f (Metric.closedBall c R) â†’\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0 :=\n\n/-- For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n :=\n\n/-- If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `âˆ® z in C(c, R), (z - w) ^ n` is equal to zero. -/\ntheorem âˆ€ {n : â„¤} {c w : â„‚} {R : â„}, n < 0 â†’ w âˆˆ Metric.sphere c |R| â†’ (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- `zeta n A B` is a primitive `n`-th root of unity. -/\ntheorem âˆ€ (n : â„•+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) â†‘n :=\n\n/-- The trivial zeroes of the zeta function. -/\ntheorem âˆ€ (n : â„•), riemannZeta (-2 * (â†‘n + 1)) = 0 :=\n\n/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. -/\ntheorem âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\nmonic polynomial with integer coefficients. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  IsPrimitiveRoot Î¶ n â†’\n    âˆƒ P,\n      Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' n K âˆ§\n        Polynomial.degree P = Polynomial.degree (Polynomial.cyclotomic' n K) âˆ§ Polynomial.Monic P :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val :=\n\n/-- If `f` is continuous on the circle `|z - c| = R`, `R > 0`, the `â€–f zâ€–` is less than or equal to\n`C : â„` on this circle, and this norm is strictly less than `C` at some point `z` of the circle,\nthen `â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„},\n  0 < R â†’\n    ContinuousOn f (Metric.sphere c R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ â€–f zâ€– â‰¤ C) â†’\n        (âˆƒ z, z âˆˆ Metric.sphere c R âˆ§ â€–f zâ€– < C) â†’ â€–âˆ® (z : â„‚) in C(c, R), f zâ€– < 2 * Real.pi * R * C :=\n\n/-- The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. -/\ntheorem âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R| :=\n\n/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\nvaries over the `n`-th roots of unity. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶ :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk of positive radius to itself and the\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\nthis disk is at most `1`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball c R) â†’\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) â†’ f c = c â†’ 0 < R â†’ â†‘Complex.abs (deriv f c) â‰¤ 1 :=\n\n/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f)) :=\n\n/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\n  ConvexOn â„ (Set.Ioi 0) f â†’\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ 2 â‰¤ n â†’ 0 < x â†’ f â†‘n + x * Real.log (â†‘n - 1) â‰¤ f (â†‘n + x) :=\n\n/-- Multiplication by `n` is a polynomial function. -/\ntheorem âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), WittVector.IsPoly p fun R _Rcr x => x * â†‘n :=\n\n/-- Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$. -/\ntheorem",
    "choices": [
      "forall {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), Complex.abs z â‰¤ 1 â†’ Complex.abs ((â†‘n : â„‚) + âˆ‘ i in Finset.range n, z ^ i) > 0 ",
      "forall {n : â„•} (hn : 0 < n) {z : â„‚} (hz : Complex.abs z â‰¤ 1), Polynomial.eval z (Finset.sum (Finset.range n) fun i => Polynomial.monomial i (â†‘(n - i))) â‰  0 ",
      "âˆ€ (n : â„•), 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.ofFinsupp (Polynomial.monomialFun (n - 1) 1 + Finset.sum (Finset.range (n - 1)) (fun k => Polynomial.monomialFun k (n - 1 - k)))) z ",
      "forall {n : â„•} (hn : 0 < n) {z : â„‚},\n  â†‘Complex.abs z â‰¤ 1 â†’\n    Polynomial.eval z (Polynomial.x ^ (n - 1) + Finset.sum (Finset.range (n - 1)) (Î» i => Polynomial.C â†‘(n - 1 - i) * Polynomial.x ^ i)) â‰  0 ",
      "âˆ€ (n : â„•), 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.isRoot (finset.univ : Finset (Finâ‚“ n)).sum (fun i => Polynomial.X ^ â†‘(i : â„•)) z ",
      "âˆ€ {n : â„•} {z : â„‚}, 0 < n â†’ Complex.abs z â‰¤ 1 â†’ Complex.abs ((finset.range n).sum (Î» i, (z ^ i) * (â†‘n - â†‘i))) < â†‘n ",
      "â„• â†’ Prop ",
      "âˆ€ {n : â„•} (hn : 0 < n), âˆ€ {z : â„‚}, â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.monomial (n - 1) 1 - âˆ‘ i in Finset.range (n - 1), Polynomial.monomial i â†‘(n - i)) z ",
      "forall {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.eval z (Polynomial.sum (Finset.range n) (Î» (i : â„•), Polynomial.monomial (n - 1 - i) (n - i))) = 0 ",
      "no_roots_in_unit_disk : âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.isRoot (finset.univ : Finset (Finâ‚“ n)).sum (Î» (i : Finâ‚“ n), Polynomial.X ^ (n - 1 - i) * â†‘(i + 1)) z "
    ]
  },
  {
    "docString": "Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\\ndisc `Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\\n`Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ âˆ€ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\\nsame power series around `x + y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] (Ï† : PowerSeries R), IsUnit Ï† â†’ IsUnit (â†‘(PowerSeries.constantCoeff R) Ï†)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a formal power series is invertible, then so is its constant coefficient.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    â†‘r' < r â†’\\n      âˆƒ a,\\n        a âˆˆ Set.Ioo 0 1 âˆ§\\n          âˆƒ C,\\n            C > 0 âˆ§\\n              âˆ€ (y : E),\\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} {r : ENNReal} {f : E â†’ F} {x : E} [inst_5 : CompleteSpace F],\\n  HasFPowerSeriesOnBall f p x r â†’\\n    HasFPowerSeriesOnBall (fderiv ğ•œ f)\\n      (ContinuousLinearMap.compFormalMultilinearSeries\\n        (â†‘(ContinuousLinearEquiv.mk (continuousMultilinearCurryFin1 ğ•œ E F).toLinearEquiv))\\n        (FormalMultilinearSeries.changeOriginSeries p 1))\\n      x r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a power series on a ball, then so does its derivative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the order of a formal power series is finite,\\nthen the coefficient indexed by the order is nonzero.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† Ïˆ : PowerSeries R},\\n  Ï† = Ïˆ â†” âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = â†‘(PowerSeries.coeff R n) Ïˆ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two formal power series are equal if all their coefficients are equal.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : Semiring R] (Ï† : MvPowerSeries Ïƒ R),\\n  IsUnit Ï† â†’ IsUnit (â†‘(MvPowerSeries.constantCoeff Ïƒ R) Ï†)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a multivariate formal power series is invertible,\\nthen so is its constant coefficient.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\\n  {f : Î± â†’ G}, Summable f â†’ Filter.Tendsto f Filter.cofinite (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\\n`cofinite`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] (Ï† : PowerSeries R),\\n  Ï† - â†‘(PowerSeries.C R) (â†‘(PowerSeries.constantCoeff R) Ï†) =\\n    (PowerSeries.mk fun p => â†‘(PowerSeries.coeff R (p + 1)) Ï†) * PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two ways of removing the constant coefficient of a power series are the same. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’ CauchySeq f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (n : â„•),\\n  â†‘n < PowerSeries.order Ï† â†’ â†‘(PowerSeries.coeff R n) Ï† = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th coefficient of a formal power series is `0` if `n` is strictly\\nsmaller than the order of the power series.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    â†‘r' < r â†’\\n      TendstoUniformlyOn (fun n y => FormalMultilinearSeries.partialSum p n (y - x)) f Filter.atTop (Metric.ball x â†‘r')\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion at `x`, then it is the uniform limit of the\\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\\nis the uniform limit of `p.partialSum n (y - x)` there. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    TendstoLocallyUniformlyOn (fun n y => FormalMultilinearSeries.partialSum p n (y - x)) f Filter.atTop\\n      (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion at `x`, then it is the locally uniform limit of\\nthe partial sums of this power series on the disk of convergence, i.e., `f y`\\nis the locally uniform limit of `p.partialSum n (y - x)` there. \"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"}]\n",
    "prompt_cons": "/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\n`Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ âˆ€ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r :=\n\n/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] (Ï† : PowerSeries R), IsUnit Ï† â†’ IsUnit (â†‘(PowerSeries.constantCoeff R) Ï†) :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    â†‘r' < r â†’\n      âˆƒ a,\n        a âˆˆ Set.Ioo 0 1 âˆ§\n          âˆƒ C,\n            C > 0 âˆ§\n              âˆ€ (y : E),\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n :=\n\n/-- If a function has a power series on a ball, then so does its derivative. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} {r : ENNReal} {f : E â†’ F} {x : E} [inst_5 : CompleteSpace F],\n  HasFPowerSeriesOnBall f p x r â†’\n    HasFPowerSeriesOnBall (fderiv ğ•œ f)\n      (ContinuousLinearMap.compFormalMultilinearSeries\n        (â†‘(ContinuousLinearEquiv.mk (continuousMultilinearCurryFin1 ğ•œ E F).toLinearEquiv))\n        (FormalMultilinearSeries.changeOriginSeries p 1))\n      x r :=\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0 :=\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† Ïˆ : PowerSeries R},\n  Ï† = Ïˆ â†” âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = â†‘(PowerSeries.coeff R n) Ïˆ :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- If a multivariate formal power series is invertible,\nthen so is its constant coefficient. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : Semiring R] (Ï† : MvPowerSeries Ïƒ R),\n  IsUnit Ï† â†’ IsUnit (â†‘(MvPowerSeries.constantCoeff Ïƒ R) Ï†) :=\n\n/-- Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\n`cofinite`. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\n  {f : Î± â†’ G}, Summable f â†’ Filter.Tendsto f Filter.cofinite (nhds 0) :=\n\n/-- Two ways of removing the constant coefficient of a power series are the same. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] (Ï† : PowerSeries R),\n  Ï† - â†‘(PowerSeries.C R) (â†‘(PowerSeries.constantCoeff R) Ï†) =\n    (PowerSeries.mk fun p => â†‘(PowerSeries.coeff R (p + 1)) Ï†) * PowerSeries.X :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’ CauchySeq f :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (n : â„•),\n  â†‘n < PowerSeries.order Ï† â†’ â†‘(PowerSeries.coeff R n) Ï† = 0 :=\n\n/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    â†‘r' < r â†’\n      TendstoUniformlyOn (fun n y => FormalMultilinearSeries.partialSum p n (y - x)) f Filter.atTop (Metric.ball x â†‘r') :=\n\n/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    TendstoLocallyUniformlyOn (fun n y => FormalMultilinearSeries.partialSum p n (y - x)) f Filter.atTop\n      (EMetric.ball x r) :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤ :=\n\n/-- Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational. -/\ntheorem",
    "choices": [
      "Sorry, I cannot prove theorems in natural language. I can only translate theorems from natural language to Lean code. Please provide a theorem in natural language, and I will translate it for you.",
      "Let f (x : â„•) ",
      "Sorry, I cannot provide a theorem for this problem as I am only able to generate Lean code for given problem statements.",
      "Let ğ•œ : Type u_1 be a field such that -3 is not a square in ğ•œ. We consider the power series f : PowerSeries ğ•œ defined as\nf(x) = âˆ‘ i=0 to âˆ c_i * x^i,\nwhere c_i âˆˆ {0, 1} for all i.\n\nLet Î± = f(2/3) and Î² = f(1/2). Since f is a power series with coefficients in {0, 1}, we have Î± = 3/2.\n\nWe claim that Î² is irrational. To show this, we will prove that Î² cannot be a root of any polynomial of the form\ng(y) = aâ‚€ + aâ‚y + aâ‚‚yÂ² + ... + a_nyâ¿,\nwhere a_j âˆˆ {0, 1} for all j, and n is a positive integer.\n\nSuppose, to the contrary, that Î² is a root of such a polynomial g(y). Then, we have\ng(Î²) = aâ‚€ + aâ‚Î² + aâ‚‚Î²Â² + ... + a_nÎ²â¿ = 0.\n\nNow consider the polynomial g(y + Î±). We expand it as follows:\ng(y + Î±) = aâ‚€ + aâ‚(y + Î±) + aâ‚‚(y + Î±)Â² + ... + a_n(y + Î±)â¿.\n\nBy substituting y = 0, we get\ng(Î±) = aâ‚€ + aâ‚Î± + aâ‚‚Î±Â² + ... + a_nÎ±â¿.\n\nHowever, we know that Î± = 3/2 and that all coefficients a_j âˆˆ {0, 1}. Therefore, all terms in the sum are either 0 or of the form (3/2)â¿ for some n. In either case, all terms are of the form 3áµ/2Ë¡ for some k, l âˆˆ â„•. Thus, g(Î±) must be of this form as well.\n\nOn the other hand, by substituting y = -Î±, we get\ng(-Î±) = aâ‚€ - aâ‚Î± + aâ‚‚Î±Â² - ... + (-1)â¿a_nÎ±â¿.\n\nNow, by our assumption, Î² is a root of g(y), so g(Î² - Î±) = 0. But Î² - Î± = -Î±, so\n0 = g",
      "âˆ€ {R : Type u_1} [inst : Semiring R],\n  let f : PowerSeries R ",
      "âˆƒ (f : â„• â†’ â„š) (H : âˆ€ n, f n = 0 âˆ¨ f n = 1),\n  (HasSum (fun n => f n * (2 / 3) ^ n) (3 / 2)) âˆ§ Â¬âˆƒ (q : â„š), HasSum (fun n => f n * (1 / 2) ^ n) q ",
      "forall {f : â„• â†’ â„}, (âˆ€ n, f n = 0 âˆ¨ f n = 1) -> f (2 / 3) = 3 / 2 -> irrational (f (1 / 2)) ",
      "Let p (n : â„•) : Prop ",
      "Let R : Type u_1, [inst : Semiring R], and let f : PowerSeries R be a power series such that âˆ€ (n : â„•), PowerSeries.coeff R n f = 0 âˆ¨ PowerSeries.coeff R n f = 1. Suppose f (2 / 3) = 3 / 2. Then f (1 / 2) is not a rational number.",
      "Let ğ•œ be â„, E be â„, F be â„, f be a function from â„ to â„, and p be a formal power series from â„ to â„ such that every coefficient of p is either 0 or 1. Suppose that f (2 / 3) = 3 / 2. We will prove that f (1 / 2) is irrational.\n\nFirst, consider the power series representation of f:\n\nf (x) = âˆ‘ (n : â„•), p_n * x^n\n\nwith p_n = â†‘(PowerSeries.coeff â„ n) p for each n, and p_n is either 0 or 1.\n\nNow, let g (x) = f (x / 2), then g (x) is also a power series:\n\ng (x) = âˆ‘ (n : â„•), p_n * (x / 2)^n\n\nNow, we have the following facts:\n\n1. g (1 / 3) = f (1 / 2)\n2. g (4 / 3) = f (2 / 3) = 3 / 2\n\nFrom fact 2, we can write:\n\ng (4 / 3) = âˆ‘ (n : â„•), p_n * (4 / 3)^n = 3 / 2\n\nSince p_n is either 0 or 1, this sum has only rational terms. Thus, g (4 / 3) is a rational number.\n\nNow, we will show that g (x) is a continuous function. Since f admits a power series expansion, it is continuous on the disk of convergence. Thus, g (x) is continuous on the disk of convergence as well.\n\nNow, let A = {x âˆˆ â„ | g (x) is rational}. Since g is continuous and g (4 / 3) is rational, there exists an open interval I around x = 4 / 3 such that for all x âˆˆ I, g (x) is rational. Thus, A is a nonempty open set.\n\nSimilarly, let B = {x âˆˆ â„ | g (x) is irrational}. Note that g (1 / 3) = f (1 / 2) âˆˆ B. Therefore, B is a nonempty open set.\n\nSince A and B are both nonempty and open, and A âˆ© B = âˆ…, this means that g cannot be a continuous"
    ]
  },
  {
    "docString": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b â‰¥ 2 \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {b : â„•} {l : List â„•}, (âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) â†’ Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b + 2 is less than (b + 2)^n \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    Odd p â†’\\n      âˆ€ {x y : â„¤},\\n        â†‘p âˆ£ x - y â†’\\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ (x : â„•), x âˆˆ l â†’ x < b) â†’ Nat.ofDigits b l < b ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b is less than b^n if b > 1 \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} (q : â„•) {p : â„•},\\n  Nat.Prime p â†’\\n    p â‰¤ 2 * q â†’ (n < q â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n) â†’ n < p â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\\ndescending list of primes, each no more than twice the next, such that the list contains a witness\\nfor each number â‰¤ n.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- The digits in the base b expansion of n are all less than b, if b â‰¥ 2 -/\ntheorem âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem âˆ€ {b : â„•} {l : List â„•}, (âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) â†’ Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    Odd p â†’\n      âˆ€ {x y : â„¤},\n        â†‘p âˆ£ x - y â†’\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- an n-digit number in base b is less than b^n if b > 1 -/\ntheorem âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ (x : â„•), x âˆˆ l â†’ x < b) â†’ Nat.ofDigits b l < b ^ List.length l :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\ndescending list of primes, each no more than twice the next, such that the list contains a witness\nfor each number â‰¤ n. -/\ntheorem âˆ€ {n : â„•} (q : â„•) {p : â„•},\n  Nat.Prime p â†’\n    p â‰¤ 2 * q â†’ (n < q â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n) â†’ n < p â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime. -/\ntheorem",
    "choices": [
      "forall (n : â„•), n > 0 -> Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ {n : â„•}, 0 < n â†’ Â¬(Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1)) ",
      "forall (n : â„•), n > 0 â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ {n : â„•}, 0 < n â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10^n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬(Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1)) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) "
    ]
  },
  {
    "docString": "Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\": \"âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\": \"âˆ€ {n x y : â„¤}, n = x ^ 2 + y ^ 2 â†’ IsCoprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integer `n` is a sum of two squares of coprime integers,\\nthen `-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1) :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„¤}, n = x ^ 2 + y ^ 2 â†’ IsCoprime x y â†’ IsSquare (-1) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p :=\n\n/-- Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers. -/\ntheorem",
    "choices": [
      "âˆƒ f : â„• â†’ â„•, âˆ€ n, (âˆƒ a b, f n = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, f n + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e g, f n + 2 = e ^ 2 + g ^ 2) ",
      "âˆƒf : â„• â†’ â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„•, âˆ€ (n : â„•), (f n).1 ^ 2 + (f n).2 ^ 2 = n âˆ§ (f n).3 ^ 2 + (f n).4 ^ 2 = n + 1 âˆ§ (f n).5 ^ 2 + (f n).6 ^ 2 = n + 2 ",
      "âˆƒ (f : â„• â†’ â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„•),\n  âˆ€ (n : â„•), f n = (f n).1 ^ 2 + (f n).2 ^ 2 âˆ§\n              n + 1 = (f n).3 ^ 2 + (f n).4 ^ 2 âˆ§\n              n + 2 = (f n).5 ^ 2 + (f n).6 ^ 2 + (f n).7 ^ 2 + (f n).8 ^ 2 ",
      "âˆ€ {N : â„•}, âˆƒ n : â„•, N â‰¤ n âˆ§ (âˆƒ xâ‚ yâ‚ xâ‚‚ yâ‚‚ xâ‚ƒ yâ‚ƒ, n = xâ‚ ^ 2 + yâ‚ ^ 2 âˆ§ n + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2 âˆ§ n + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
      "âˆ€ {n : â„•}, âˆƒ m, (âˆƒ a b, m = a ^ 2 + b ^ 2) âˆ§ (âˆƒ x y, m + 1 = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, m + 2 = u ^ 2 + v ^ 2) ",
      "âˆ€ (n : â„•), âˆƒ (k : â„•), (âˆƒ aâ‚ bâ‚, (n + k) = aâ‚ ^ 2 + bâ‚ ^ 2) âˆ§ (âˆƒ aâ‚‚ bâ‚‚, (n + k + 1) = aâ‚‚ ^ 2 + bâ‚‚ ^ 2) âˆ§ (âˆƒ aâ‚ƒ bâ‚ƒ, (n + k + 2) = aâ‚ƒ ^ 2 + bâ‚ƒ ^ 2) ",
      "âˆ€ (N : â„•), âˆƒ n : â„•, n â‰¥ N âˆ§ (âˆƒ a b, n = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, n + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, n + 2 = e ^ 2 + f ^ 2) ",
      "âˆƒ s : â„• â†’ â„•, StrictMono s âˆ§ âˆ€ (n : â„•), (âˆƒ a b c d e f, s n = a ^ 2 + b ^ 2 âˆ§ s n + 1 = c ^ 2 + d ^ 2 âˆ§ s n + 2 = e ^ 2 + f ^ 2) ",
      "âˆ€ N, âˆƒ n, N â‰¤ n âˆ§ (âˆƒ a b c d e f g h, n = a ^ 2 + b ^ 2 âˆ§ n + 1 = c ^ 2 + d ^ 2 âˆ§ n + 2 = e ^ 2 + f ^ 2 âˆ§ n + 3 = g ^ 2 + h ^ 2) ",
      "âˆƒ f : â„• â†’ â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„• Ã— â„•, âˆ€ n, (f n).1 ^ 2 + (f n).2 ^ 2 = n âˆ§\n  (f n).3 ^ 2 + (f n).4 ^ 2 = n + 1 âˆ§ (f n).5 ^ 2 + (f n).6 ^ 2 = n + 2 "
    ]
  },
  {
    "docString": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\\n  DifferentiableOn â„ f s â†’\\n    ContinuousWithinAt f s a â†’\\n      s âˆˆ nhdsWithin a (Set.Ioi a) â†’\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the right of a point `a : â„`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\\n  DifferentiableOn â„ f s â†’\\n    ContinuousWithinAt f s a â†’\\n      s âˆˆ nhdsWithin a (Set.Iio a) â†’\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the left of a point `a : â„`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the left at `a`. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f g : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      DiffContOnCl â„‚ g (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n        (âˆƒ c,\\n            c < 2 âˆ§\\n              âˆƒ B,\\n                g =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n                  rexp (B * â†‘Complex.abs z ^ c)) â†’\\n          (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) â†’\\n            (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = g (â†‘x * Complex.I)) â†’ Set.EqOn f g {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f g : â„‚ â†’ E` be functions such that\\n\\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\\n* `â€–f zâ€–` and `â€–g zâ€–` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\\n  quadrant for some `A`, `B`, and `c < 2`;\\n* `f` is equal to `g` on the boundary of the third quadrant.\\n\\nThen `f` is equal to `g` on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â†’L[ğ•œ] F} {a : E},\\n  HasStrictFDerivAt f f' a â†’ âˆ€ {c : NNReal}, Subsingleton E âˆ¨ 0 < c â†’ âˆƒ s, s âˆˆ nhds a âˆ§ ApproximatesLinearOn f f' s c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\\nwith constant `c` on some neighborhood of `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\\n  [inst_5 : MeasurableSpace E] [inst_6 : BorelSpace E] [inst_7 : TopologicalSpace.SecondCountableTopology F] (f : E â†’ F)\\n  (s : Set E) (f' : E â†’ E â†’L[â„] F),\\n  (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\\n    âˆ€ (r : (E â†’L[â„] F) â†’ NNReal),\\n      (âˆ€ (A : E â†’L[â„] F), r A â‰  0) â†’\\n        âˆƒ t A,\\n          Pairwise (Disjoint on t) âˆ§\\n            (âˆ€ (n : â„•), MeasurableSet (t n)) âˆ§\\n              s âŠ† â‹ƒ (n : â„•), t n âˆ§\\n                (âˆ€ (n : â„•), ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§\\n                  (Set.Nonempty s â†’ âˆ€ (n : â„•), âˆƒ y, y âˆˆ s âˆ§ A n = f' y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that a function `f` has a derivative at every point of a set `s`. Then one may\\npartition `s` into countably many disjoint relatively measurable sets (i.e., intersections\\nof `s` with measurable sets `t n`) on which `f` is well approximated by linear maps `A n`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {a : â„}\\n  {s : Set â„},\\n  (âˆ€ (x : â„), x âˆˆ s â†’ IntervalIntegrable f MeasureTheory.volume a x) â†’\\n    Continuous f â†’ DifferentiableOn â„ (fun u => âˆ« (x : â„) in a..u, f x) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The integral of a continuous function is differentiable on a real set `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\\n  [inst_5 : TopologicalSpace.SecondCountableTopology F] (f : E â†’ F) (s : Set E) (f' : E â†’ E â†’L[â„] F),\\n  (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\\n    âˆ€ (r : (E â†’L[â„] F) â†’ NNReal),\\n      (âˆ€ (A : E â†’L[â„] F), r A â‰  0) â†’\\n        âˆƒ t A,\\n          (âˆ€ (n : â„•), IsClosed (t n)) âˆ§\\n            s âŠ† â‹ƒ (n : â„•), t n âˆ§\\n              (âˆ€ (n : â„•), ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§\\n                (Set.Nonempty s â†’ âˆ€ (n : â„•), âˆƒ y, y âˆˆ s âˆ§ A n = f' y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that a function `f` has a derivative at every point of a set `s`. Then one may cover `s`\\nwith countably many closed sets `t n` on which `f` is well approximated by linear maps `A n`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\\n      closure (f '' s) âˆˆ nhdsWithin (f a) (Set.Iic (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is monotone on a left neighborhood of `a` and\\nthe closure of the image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is\\ncontinuous at `a` from the left \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\\ncontinuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T1Space Î²] {f : Î± â†’ Î²}\\n  {a : Î±} {b : Î²}, Filter.Tendsto f (nhds a) (nhds b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\\n`f` admits *some* limit at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  ConvexOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is convex iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  StrictConcaveOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is strictly concave iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"}]\n",
    "prompt_cons": "/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- If a function is differentiable on the right of a point `a : â„`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\n  DifferentiableOn â„ f s â†’\n    ContinuousWithinAt f s a â†’\n      s âˆˆ nhdsWithin a (Set.Ioi a) â†’\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Ici a) a :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ z.re â‰¤ 0 â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C :=\n\n/-- If a function is differentiable on the left of a point `a : â„`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the left at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\n  DifferentiableOn â„ f s â†’\n    ContinuousWithinAt f s a â†’\n      s âˆˆ nhdsWithin a (Set.Iio a) â†’\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Iic a) a :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f g : â„‚ â†’ E` be functions such that\n\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\n* `â€–f zâ€–` and `â€–g zâ€–` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the third quadrant.\n\nThen `f` is equal to `g` on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f g : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      DiffContOnCl â„‚ g (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n        (âˆƒ c,\n            c < 2 âˆ§\n              âˆƒ B,\n                g =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n                  rexp (B * â†‘Complex.abs z ^ c)) â†’\n          (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) â†’\n            (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = g (â†‘x * Complex.I)) â†’ Set.EqOn f g {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a :=\n\n/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â†’L[ğ•œ] F} {a : E},\n  HasStrictFDerivAt f f' a â†’ âˆ€ {c : NNReal}, Subsingleton E âˆ¨ 0 < c â†’ âˆƒ s, s âˆˆ nhds a âˆ§ ApproximatesLinearOn f f' s c :=\n\n/-- Assume that a function `f` has a derivative at every point of a set `s`. Then one may\npartition `s` into countably many disjoint relatively measurable sets (i.e., intersections\nof `s` with measurable sets `t n`) on which `f` is well approximated by linear maps `A n`. -/\ntheorem âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\n  [inst_5 : MeasurableSpace E] [inst_6 : BorelSpace E] [inst_7 : TopologicalSpace.SecondCountableTopology F] (f : E â†’ F)\n  (s : Set E) (f' : E â†’ E â†’L[â„] F),\n  (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\n    âˆ€ (r : (E â†’L[â„] F) â†’ NNReal),\n      (âˆ€ (A : E â†’L[â„] F), r A â‰  0) â†’\n        âˆƒ t A,\n          Pairwise (Disjoint on t) âˆ§\n            (âˆ€ (n : â„•), MeasurableSet (t n)) âˆ§\n              s âŠ† â‹ƒ (n : â„•), t n âˆ§\n                (âˆ€ (n : â„•), ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§\n                  (Set.Nonempty s â†’ âˆ€ (n : â„•), âˆƒ y, y âˆˆ s âˆ§ A n = f' y) :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- The integral of a continuous function is differentiable on a real set `s`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {a : â„}\n  {s : Set â„},\n  (âˆ€ (x : â„), x âˆˆ s â†’ IntervalIntegrable f MeasureTheory.volume a x) â†’\n    Continuous f â†’ DifferentiableOn â„ (fun u => âˆ« (x : â„) in a..u, f x) s :=\n\n/-- Assume that a function `f` has a derivative at every point of a set `s`. Then one may cover `s`\nwith countably many closed sets `t n` on which `f` is well approximated by linear maps `A n`. -/\ntheorem âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\n  [inst_5 : TopologicalSpace.SecondCountableTopology F] (f : E â†’ F) (s : Set E) (f' : E â†’ E â†’L[â„] F),\n  (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\n    âˆ€ (r : (E â†’L[â„] F) â†’ NNReal),\n      (âˆ€ (A : E â†’L[â„] F), r A â‰  0) â†’\n        âˆƒ t A,\n          (âˆ€ (n : â„•), IsClosed (t n)) âˆ§\n            s âŠ† â‹ƒ (n : â„•), t n âˆ§\n              (âˆ€ (n : â„•), ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§\n                (Set.Nonempty s â†’ âˆ€ (n : â„•), âˆƒ y, y âˆˆ s âˆ§ A n = f' y) :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If a function `f` with a densely ordered codomain is monotone on a left neighborhood of `a` and\nthe closure of the image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is\ncontinuous at `a` from the left -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\n      closure (f '' s) âˆˆ nhdsWithin (f a) (Set.Iic (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\ncontinuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\n`f` admits *some* limit at `a`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T1Space Î²] {f : Î± â†’ Î²}\n  {a : Î±} {b : Î²}, Filter.Tendsto f (nhds a) (nhds b) â†’ ContinuousAt f a :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is convex iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  ConvexOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y) :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  StrictConcaveOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Differentiable â„ (deriv (deriv f)) â†’\n    (âˆƒ (a : â„), deriv (deriv f) a = 0) ",
      "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {x : â„},\n  (Differentiable â„^[3] f) â†’ âˆƒ a, (deriv^[3] f) a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E},\n  Differentiable â„ [3] f â†’ âˆƒ a, f a = (1 / 2) â€¢ (f a - f a) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Differentiable â„ (deriv^[2] f) â†’ Continuous (deriv^[3] f) â†’ âˆƒ a, deriv^[3] f a = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E},\n  Differentiable â„[3] f â†’\n    âˆƒ a, (deriv^[3] f) a = -6 * (deriv^[2] f) a ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  (ğ“[Set.Ioi 0] 0).HasBasis (fun f => 0 < f) (fun f => Set.Ioo 0 f) â†’\n    Continuous (deriv^[3] f) â†’\n      âˆƒ a, HasDerivAt (deriv^[2] f) (deriv^[3] f a) a âˆ§\n            HasDerivAt (deriv^[1] f) ((deriv^[2] f) a) a âˆ§\n              HasDerivAt f ((deriv^[1] f) a) a ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E},\n  Differentiable â„^[3] f â†’\n    âˆƒ a, (âˆƒ x, f x = a) âˆ§\n      (âˆƒ x, deriv (deriv (deriv f)) x = a) âˆ§\n        (âˆƒ x, deriv (deriv f) x = a) âˆ§\n          (âˆƒ x, deriv f x = a) âˆ§\n            (âˆƒ x, f x = a) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E},\n  Differentiable â„^[3] f â†’ âˆƒ a, (âˆ« x in a..a + 1, (âˆ« t in a..x, f'' t)) = 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {fp : â„ â†’ E} {fpp : â„ â†’ E} {fppp : â„ â†’ E},\n  (âˆ€ x, HasDerivAt f (fp x) x) â†’\n    (âˆ€ x, HasDerivAt fp (fpp x) x) â†’\n      (âˆ€ x, HasDerivAt fpp (fppp x) x) â†’\n        Continuous fppp â†’ âˆƒ a b c, (âˆ€ x, f x = a * x^3 / 6 + b * x^2 / 2 + c * x) âˆ§ fppp = fun x => a ",
      "âˆ€ {f : â„ â†’ â„} {x : â„}, ContinuousOn (deriv^[3]) f â„ â†’ âˆƒ a, deriv f a * deriv f x = deriv f (a * x) "
    ]
  },
  {
    "docString": "Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\\n  Function.Injective â†‘(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrder Î±] {f : Fin n â†’ Î±}, Tuple.sort f = Equiv.refl (Fin n) â†” Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The permutation that sorts `f` is the identity if and only if `f` is monotone. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f f},\\n  CategoryTheory.Limits.IsLimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Î¹ c)\",\n  \"isProp\": true,\n  \"docString\": \"Every equalizer of `(f, f)` is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {n : â„•}, 0 < n â†’ Function.Injective â†‘(Polynomial.expand R n)\",\n  \"isProp\": true,\n  \"docString\": \"Expansion is injective. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Cofork f f},\\n  CategoryTheory.Limits.IsColimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.Ï€ c)\",\n  \"isProp\": true,\n  \"docString\": \"Every coequalizer of `(f, f)` is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} [inst : MeasurableSpace Î±] {E : Type u_2} [inst_1 : MeasurableSpace E] [inst_2 : NormedAddCommGroup E]\\n  [inst_3 : BorelSpace E] [inst_4 : TopologicalSpace.SecondCountableTopology E] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_5 : MeasureTheory.IsFiniteMeasure Î¼] {Î¹ : Type u_1} {f : Î¹ â†’ Î± â†’ E} {j : Î¹} {p : ENNReal},\\n  1 â‰¤ p â†’\\n    p â‰  âŠ¤ â†’\\n      MeasureTheory.Memâ„’p (f j) p â†’\\n        (âˆ€ (i : Î¹), ProbabilityTheory.IdentDistrib (f i) (f j)) â†’ MeasureTheory.UniformIntegrable f p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence of identically distributed Láµ– functions is p-uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î¹ : Type u_1} {m : MeasurableSpace Î±} [inst : TopologicalSpace Î²]\\n  [inst_1 : TopologicalSpace.PseudoMetrizableSpace Î²] (u : Filter Î¹) [inst_2 : Filter.NeBot u]\\n  [inst_3 : Filter.IsCountablyGenerated u] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²},\\n  (âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)) â†’ Filter.Tendsto f u (nhds g) â†’ MeasureTheory.StronglyMeasurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequential limit of strongly measurable functions is strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {f : Î¹ â†’ Î± â†’ Î²} [inst_1 : Finite Î¹],\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UniformIntegrable f p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite sequence of Lp functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : LinearOrderedRing Î±] {Ïƒ : Equiv.Perm Î¹} {f g : Î¹ â†’ Î±} [inst_1 : Fintype Î¹],\\n  Antivary f g â†’\\n    (((Finset.sum Finset.univ fun i => f (â†‘Ïƒ i) * g i) = Finset.sum Finset.univ fun i => f i * g i) â†”\\n      Antivary (f âˆ˜ â†‘Ïƒ) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\\nwhich antivary together, is unchanged by a permutation if and only if `f âˆ˜ Ïƒ` and `g` antivary\\ntogether. Stated by permuting the entries of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} [inst_1 : Finite Î¹],\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ âˆ€ {f : Î¹ â†’ Î± â†’ Î²}, (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UnifIntegrable f p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A finite sequence of Lp functions is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) [inst : IsTrichotomous Î± r] [inst : IsIrrefl Î² s]\\n  (f : Î± â†’ Î²), (âˆ€ {x y : Î±}, r x y â†’ s (f x) (f y)) â†’ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"An increasing function is injective \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y},\\n  f = g â†’\\n    âˆ€ {c : CategoryTheory.Limits.Cofork f g},\\n      CategoryTheory.Limits.IsColimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.Ï€ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : LinearOrderedRing Î±] [inst_1 : LinearOrderedAddCommGroup Î²]\\n  [inst_2 : Module Î± Î²] [inst_3 : OrderedSMul Î± Î²] {s : Finset Î¹} {Ïƒ : Equiv.Perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²},\\n  AntivaryOn f g â†‘s â†’\\n    {x | â†‘Ïƒ x â‰  x} âŠ† â†‘s â†’\\n      (((Finset.sum s fun i => f (â†‘Ïƒ i) â€¢ g i) = Finset.sum s fun i => f i â€¢ g i) â†” AntivaryOn (f âˆ˜ â†‘Ïƒ) g â†‘s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\\n`g`, which antivary together, is unchanged by a permutation if and only if `f âˆ˜ Ïƒ` and `g` antivary\\ntogether. Stated by permuting the entries of `f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n y = F y` in a neighbourhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±},\\n  TendstoUniformlyOnFilter F f p p' â†” Filter.Tendsto (fun q => (f q.snd, F q.fst q.snd)) (p Ã—Ë¢ p') (uniformity Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence of functions `Fâ‚™` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\\nfilter `p` iff the function `(n, x) â†¦ (f x, Fâ‚™ x)` converges along `p Ã—Ë¢ p'` to the uniformity.\\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : LinearOrderedRing Î±] {Ïƒ : Equiv.Perm Î¹} {f g : Î¹ â†’ Î±} [inst_1 : Fintype Î¹],\\n  Antivary f g â†’\\n    (((Finset.sum Finset.univ fun i => f i * g (â†‘Ïƒ i)) = Finset.sum Finset.univ fun i => f i * g i) â†”\\n      Antivary f (g âˆ˜ â†‘Ïƒ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\\nwhich antivary together, is unchanged by a permutation if and only if `f` and `g âˆ˜ Ïƒ` antivary\\ntogether. Stated by permuting the entries of `g`. \"}]\n",
    "prompt_cons": "/-- An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. -/\ntheorem âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\n  Function.Injective â†‘(Con.kerLift f) :=\n\n/-- The permutation that sorts `f` is the identity if and only if `f` is monotone. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrder Î±] {f : Fin n â†’ Î±}, Tuple.sort f = Equiv.refl (Fin n) â†” Monotone f :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- Every equalizer of `(f, f)` is an isomorphism. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f f},\n  CategoryTheory.Limits.IsLimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Î¹ c) :=\n\n/-- Expansion is injective. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {n : â„•}, 0 < n â†’ Function.Injective â†‘(Polynomial.expand R n) :=\n\n/-- Every coequalizer of `(f, f)` is an isomorphism. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Cofork f f},\n  CategoryTheory.Limits.IsColimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.Ï€ c) :=\n\n/-- A sequence of identically distributed Láµ– functions is p-uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_3} [inst : MeasurableSpace Î±] {E : Type u_2} [inst_1 : MeasurableSpace E] [inst_2 : NormedAddCommGroup E]\n  [inst_3 : BorelSpace E] [inst_4 : TopologicalSpace.SecondCountableTopology E] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_5 : MeasureTheory.IsFiniteMeasure Î¼] {Î¹ : Type u_1} {f : Î¹ â†’ Î± â†’ E} {j : Î¹} {p : ENNReal},\n  1 â‰¤ p â†’\n    p â‰  âŠ¤ â†’\n      MeasureTheory.Memâ„’p (f j) p â†’\n        (âˆ€ (i : Î¹), ProbabilityTheory.IdentDistrib (f i) (f j)) â†’ MeasureTheory.UniformIntegrable f p Î¼ :=\n\n/-- A sequential limit of strongly measurable functions is strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î¹ : Type u_1} {m : MeasurableSpace Î±} [inst : TopologicalSpace Î²]\n  [inst_1 : TopologicalSpace.PseudoMetrizableSpace Î²] (u : Filter Î¹) [inst_2 : Filter.NeBot u]\n  [inst_3 : Filter.IsCountablyGenerated u] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²},\n  (âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)) â†’ Filter.Tendsto f u (nhds g) â†’ MeasureTheory.StronglyMeasurable g :=\n\n/-- A finite sequence of Lp functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {f : Î¹ â†’ Î± â†’ Î²} [inst_1 : Finite Î¹],\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UniformIntegrable f p Î¼ :=\n\n/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f âˆ˜ Ïƒ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : LinearOrderedRing Î±] {Ïƒ : Equiv.Perm Î¹} {f g : Î¹ â†’ Î±} [inst_1 : Fintype Î¹],\n  Antivary f g â†’\n    (((Finset.sum Finset.univ fun i => f (â†‘Ïƒ i) * g i) = Finset.sum Finset.univ fun i => f i * g i) â†”\n      Antivary (f âˆ˜ â†‘Ïƒ) g) :=\n\n/-- A finite sequence of Lp functions is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î¹ : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} [inst_1 : Finite Î¹],\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ âˆ€ {f : Î¹ â†’ Î± â†’ Î²}, (âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p) â†’ MeasureTheory.UnifIntegrable f p Î¼ :=\n\n/-- An increasing function is injective -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) [inst : IsTrichotomous Î± r] [inst : IsIrrefl Î² s]\n  (f : Î± â†’ Î²), (âˆ€ {x y : Î±}, r x y â†’ s (f x) (f y)) â†’ Function.Injective f :=\n\n/-- Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y},\n  f = g â†’\n    âˆ€ {c : CategoryTheory.Limits.Cofork f g},\n      CategoryTheory.Limits.IsColimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.Ï€ c) :=\n\n/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f âˆ˜ Ïƒ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : LinearOrderedRing Î±] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module Î± Î²] [inst_3 : OrderedSMul Î± Î²] {s : Finset Î¹} {Ïƒ : Equiv.Perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²},\n  AntivaryOn f g â†‘s â†’\n    {x | â†‘Ïƒ x â‰  x} âŠ† â†‘s â†’\n      (((Finset.sum s fun i => f (â†‘Ïƒ i) â€¢ g i) = Finset.sum s fun i => f i â€¢ g i) â†” AntivaryOn (f âˆ˜ â†‘Ïƒ) g â†‘s) :=\n\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. -/\ntheorem âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y :=\n\n/-- A sequence of functions `Fâ‚™` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) â†¦ (f x, Fâ‚™ x)` converges along `p Ã—Ë¢ p'` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±},\n  TendstoUniformlyOnFilter F f p p' â†” Filter.Tendsto (fun q => (f q.snd, F q.fst q.snd)) (p Ã—Ë¢ p') (uniformity Î²) :=\n\n/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f` and `g âˆ˜ Ïƒ` antivary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} [inst : LinearOrderedRing Î±] {Ïƒ : Equiv.Perm Î¹} {f g : Î¹ â†’ Î±} [inst_1 : Fintype Î¹],\n  Antivary f g â†’\n    (((Finset.sum Finset.univ fun i => f i * g (â†‘Ïƒ i)) = Finset.sum Finset.univ fun i => f i * g i) â†”\n      Antivary f (g âˆ˜ â†‘Ïƒ)) :=\n\n/-- Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [_i : T1Space Î±] {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n  (âˆ€ k, q k = p (f k)) â†’\n  (âˆ€ x, Filter.Tendsto p Filter.atTop (nhds x) â†” Filter.Tendsto q Filter.atTop (nhds x)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’\n    (Filter.Tendsto p Filter.atTop (nhds (lim p)) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (lim p))) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [_i : T1Space Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’ Filter.Tendsto p Filter.atTop Filter.atTop â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds (Lim Filter.atTop p)) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (Lim Filter.atTop p)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : â„• â†’ â„•} (hf : Function.Injective f) {p : â„• â†’ Î±},\n  Filter.Tendsto p Filter.atTop (nhds (Filter.Lim Filter.atTop p)) â†”\n    Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (Filter.Lim Filter.atTop p)) ",
      "âˆ€ {Î± : Type} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {Î¹ : Type u_1} {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’ Filter.Tendsto p Filter.atTop (nhds (lim at_top p)) â†’ Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (lim at_top p)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : â„• â†’ Î±} {hf : Filter.Tendsto f Filter.atTop (nhds (f 0))}\n  {p : â„• â†’ â„•} (hp : Function.Injective p),\n  Filter.Tendsto (f âˆ˜ p) Filter.atTop (nhds (f 0)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•}, Function.Injective f â†’\n  Filter.Tendsto p Filter.atTop (nhds (a : Î±)) â†’ Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•}, Function.Injective f â†’\n  Filter.Tendsto p Filter.atTop (nhds (l : Î±)) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (p : â„• â†’ Î±) (f : â„• â†’ â„•),\n  Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds (Filter.Lim Filter.atTop p)) â†”\n      Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (Filter.Lim Filter.atTop p)) "
    ]
  },
  {
    "docString": "Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : MetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\\n  Inducing f â†’ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"A topology `Inducing` map from a Tâ‚€ space is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆ€ (x : X),\\n            âˆ€á¶  (p : ENNReal Ã— X) in nhds 0 Ã—Ë¢ nhds x, âˆ€ (i : Î¹), p.snd âˆˆ K i â†’ EMetric.closedBall p.snd p.fst âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets in an emetric space. Let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then for any point\\n`x : X`, for sufficiently small `r : â„â‰¥0âˆ` and for `y` sufficiently close to `x`, for all `i`, if\\n`y âˆˆ K i`, then `EMetric.closedBall y r âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  Metric.Bounded s â†’ IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : TopologicalSpace.SecondCountableTopology X],\\n  MeasureTheory.LocallyIntegrable f â†’\\n    âˆƒ u, (âˆ€ (n : â„•), IsOpen (u n)) âˆ§ â‹ƒ (n : â„•), u n = Set.univ âˆ§ âˆ€ (n : â„•), MeasureTheory.IntegrableOn f (u n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally integrable in a second countable topological space,\\nthen there exists a sequence of open sets covering the space on which it is integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\\n    p âˆ… â†’\\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\\\ U)) â†’\\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a measure is inner regular (using closed or compact sets), then every measurable set of\\nfinite measure can by approximated by a (closed or compact) subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\\n  Isometry f â†’ UniformInducing f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform inducing map \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Isometry â†‘Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The embedding of a metric space in its completion is an isometry. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"}]\n",
    "prompt_cons": "/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : MetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- A topology `Inducing` map from a Tâ‚€ space is injective. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\n  Inducing f â†’ Function.Injective f :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V) :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets in an emetric space. Let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then for any point\n`x : X`, for sufficiently small `r : â„â‰¥0âˆ` and for `y` sufficiently close to `x`, for all `i`, if\n`y âˆˆ K i`, then `EMetric.closedBall y r âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆ€ (x : X),\n            âˆ€á¶  (p : ENNReal Ã— X) in nhds 0 Ã—Ë¢ nhds x, âˆ€ (i : Î¹), p.snd âˆˆ K i â†’ EMetric.closedBall p.snd p.fst âŠ† U i :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  Metric.Bounded s â†’ IsCompact (closure s) :=\n\n/-- If a function is locally integrable in a second countable topological space,\nthen there exists a sequence of open sets covering the space on which it is integrable. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : TopologicalSpace.SecondCountableTopology X],\n  MeasureTheory.LocallyIntegrable f â†’\n    âˆƒ u, (âˆ€ (n : â„•), IsOpen (u n)) âˆ§ â‹ƒ (n : â„•), u n = Set.univ âˆ§ âˆ€ (n : â„•), MeasureTheory.IntegrableOn f (u n) :=\n\n/-- If a measure is inner regular (using closed or compact sets), then every measurable set of\nfinite measure can by approximated by a (closed or compact) subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\n    p âˆ… â†’\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\ U)) â†’\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤ :=\n\n/-- An isometry from a metric space is a uniform inducing map -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ UniformInducing f :=\n\n/-- Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x} :=\n\n/-- The embedding of a metric space in its completion is an isometry. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Isometry â†‘Î± :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : MetricSpace X], âˆƒ (Ï• : (Set X â†’ Prop) â‰ƒ (Set X â†’ Prop)), \n  (âˆ€ (U : Set X), IsOpen U â†” Ï• U IsClosed) âˆ§ (âˆ€ (K : Set X), IsClosed K â†” Ï•.symm K IsOpen) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set X â†’ Set X), (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (f U)) âˆ§ (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (f K)) âˆ§\n    Function.Bijective f ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set.SubsetClasses (IsOpen : Set X â†’ Prop) â‰ƒ Set.SubsetClasses (IsClosed : Set X â†’ Prop)),\n    âˆ€ (U : Set X), IsOpen U â†” IsClosed (f âŸ¨U, _âŸ©) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set (Set X)),\n    (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (f U)) âˆ§\n    (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (fâ»Â¹' K)) âˆ§\n    Function.Bijective f ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : (TopologicalSpace.Opens X) â‰ƒ (TopologicalSpace.Closeds X)),\n    âˆ€ (U : TopologicalSpace.Opens X), f U = HasCompl.compl U ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : (Set X) â†’ (Set X)), (âˆ€ U : Set X, IsOpen U â†’ IsClosed (f U)) âˆ§ (âˆ€ K : Set X, IsClosed K â†’ IsOpen (f K)) âˆ§\n    (âˆ€ U1 U2 : Set X, IsOpen U1 â†’ IsOpen U2 â†’ (f U1 = f U2 â†” U1 = U2)) âˆ§\n    (âˆ€ K1 K2 : Set X, IsClosed K1 â†’ IsClosed K2 â†’ (f K1 = f K2 â†” K1 = K2)) ",
      "âˆ€ {M : Type u} [inst : MetricSpace M], âˆƒ (f : {t : Set M // IsOpen t} â‰ƒ {s : Set M // IsClosed s}), True ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : set_of IsOpen â†’ set_of IsClosed), Function.Bijective f ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set (Set X)), (âˆ€ (s : Set X), IsOpen s â†’ IsClosed (f s)) âˆ§\n     (âˆ€ (s : Set X), IsClosed s â†’ IsOpen (f s)) âˆ§\n       (Function.LeftInverse f f) âˆ§ (Function.RightInverse f f) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set (Set X) â†’ Set (Set X)),\n    (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (f U)) âˆ§\n      (âˆ€ (K : Set X), IsClosed K â†’ IsOpen (f K)) âˆ§\n        (âˆ€ (U : Set X), IsOpen U â†’ f (f U) = U) âˆ§\n          (âˆ€ (K : Set X), IsClosed K â†’ f (f K) = K) "
    ]
  },
  {
    "docString": "Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] (B : â„),\\n  Set.Finite {x | IsIntegral â„¤ x âˆ§ âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– â‰¤ B}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\\nsmaller in norm than `B` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded below \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  Metric.Bounded s â†’ IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s â†’ TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  IsClosed s â†’ Metric.Bounded s â†’ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, a closed bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} [inst : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼] â¦ƒK : Set Î±â¦„, IsCompact K â†’ â†‘â†‘Î¼ K < âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact subset has finite measure for a measure which is finite on compacts. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded above \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\\n    p âˆ… â†’\\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\\\ U)) â†’\\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a measure is inner regular (using closed or compact sets), then every measurable set of\\nfinite measure can by approximated by a (closed or compact) subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_2 : MeasureTheory.Measure.Regular Î¼] â¦ƒU : Set Î±â¦„,\\n  IsOpen U â†’ âˆ€ {r : ENNReal}, r < â†‘â†‘Î¼ U â†’ âˆƒ K, K âŠ† U âˆ§ IsCompact K âˆ§ r < â†‘â†‘Î¼ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î¼` is a regular measure, then any open set can be approximated by a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K], â€–orthogonalProjection Kâ€– â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection has norm `â‰¤ 1`. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedSpace â„ E] [inst_4 : LinearMap.CompatibleSMul E E ğ•œ â„],\\n  StrictConvex ğ•œ (Metric.closedBall 0 1) â†’ StrictConvexSpace ğ•œ E\",\n  \"isProp\": true,\n  \"docString\":\n  \"A real normed vector space is strictly convex provided that the unit ball is strictly convex. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\\n  [inst_5 : CompleteSpace F],\\n  Function.Surjective â†‘f â†’ âˆƒ C, C â‰¥ 0 âˆ§ âˆ€ (y : F), âˆƒ x, dist (â†‘f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"First step of the proof of the Banach open mapping theorem (using completeness of `F`):\\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\\nRescaling everything, it follows that any `y âˆˆ F` is arbitrarily well approached by\\nimages of elements of norm at most `C * â€–yâ€–`.\\nFor further use, we will only need such an element whose image\\nis within distance `â€–yâ€–/2` of `y`, to apply an iterative process. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ SeminormedGroup (Ï€ i)] (f : (i : Î¹) â†’ Ï€ i),\\n  (Finset.sum Finset.univ fun i => â€–f iâ€–â‚Š) â‰¤ Fintype.card Î¹ â€¢ â€–fâ€–â‚Š\",\n  \"isProp\": true,\n  \"docString\":\n  \"The $L^1$ norm is less than the $L^\\\\infty$ norm scaled by the cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {m : â„¤}, m â‰  0 â†’ m â‰  1 â†’ StrictConvexOn â„ (Set.Ioi 0) fun x => x ^ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"`x^m`, `m : â„¤` is convex on `(0, +âˆ)` for all `m` except `0` and `1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n",
    "prompt_cons": "/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] (B : â„),\n  Set.Finite {x | IsIntegral â„¤ x âˆ§ âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– â‰¤ B} :=\n\n/-- A compact set is bounded below -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddBelow s :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  Metric.Bounded s â†’ IsCompact (closure s) :=\n\n/-- A compact set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ Metric.Bounded s :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s â†’ TotallyBounded s :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  IsClosed s â†’ Metric.Bounded s â†’ IsCompact s :=\n\n/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} [inst : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼] â¦ƒK : Set Î±â¦„, IsCompact K â†’ â†‘â†‘Î¼ K < âŠ¤ :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- A compact set is bounded above -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : Nonempty Î±] {s : Set Î±}, IsCompact s â†’ BddAbove s :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Set.Finite s â†’ IsCompact (â†‘(convexHull â„) s) :=\n\n/-- If a measure is inner regular (using closed or compact sets), then every measurable set of\nfinite measure can by approximated by a (closed or compact) subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  {p : Set Î± â†’ Prop} [inst_2 : MeasureTheory.Measure.OuterRegular Î¼],\n  MeasureTheory.Measure.InnerRegular Î¼ p IsOpen â†’\n    p âˆ… â†’\n      (âˆ€ â¦ƒs U : Set Î±â¦„, p s â†’ IsOpen U â†’ p (s \\ U)) â†’\n        MeasureTheory.Measure.InnerRegular Î¼ p fun s => MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤ :=\n\n/-- If `Î¼` is a regular measure, then any open set can be approximated by a compact subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.Measure.Regular Î¼] â¦ƒU : Set Î±â¦„,\n  IsOpen U â†’ âˆ€ {r : ENNReal}, r < â†‘â†‘Î¼ U â†’ âˆƒ K, K âŠ† U âˆ§ IsCompact K âˆ§ r < â†‘â†‘Î¼ K :=\n\n/-- The orthogonal projection has norm `â‰¤ 1`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K], â€–orthogonalProjection Kâ€– â‰¤ 1 :=\n\n/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem âˆ€ (ğ•œ : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedSpace â„ E] [inst_4 : LinearMap.CompatibleSMul E E ğ•œ â„],\n  StrictConvex ğ•œ (Metric.closedBall 0 1) â†’ StrictConvexSpace ğ•œ E :=\n\n/-- First step of the proof of the Banach open mapping theorem (using completeness of `F`):\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\nRescaling everything, it follows that any `y âˆˆ F` is arbitrarily well approached by\nimages of elements of norm at most `C * â€–yâ€–`.\nFor further use, we will only need such an element whose image\nis within distance `â€–yâ€–/2` of `y`, to apply an iterative process. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\n  [inst_5 : CompleteSpace F],\n  Function.Surjective â†‘f â†’ âˆƒ C, C â‰¥ 0 âˆ§ âˆ€ (y : F), âˆƒ x, dist (â†‘f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– :=\n\n/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ SeminormedGroup (Ï€ i)] (f : (i : Î¹) â†’ Ï€ i),\n  (Finset.sum Finset.univ fun i => â€–f iâ€–â‚Š) â‰¤ Fintype.card Î¹ â€¢ â€–fâ€–â‚Š :=\n\n/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- `x^m`, `m : â„¤` is convex on `(0, +âˆ)` for all `m` except `0` and `1`. -/\ntheorem âˆ€ {m : â„¤}, m â‰  0 â†’ m â‰  1 â†’ StrictConvexOn â„ (Set.Ioi 0) fun x => x ^ m :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact. -/\ntheorem",
    "choices": [
      "âˆ€ {m : â„•} [inst : Fintype m], IsCompact (Metric.ClosedBall (0 : â„^m) 1) ",
      "{E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] :\n  IsCompact (Metric.closedBall (0 : E) 1) ",
      "âˆ€ {E : Type u_1} [inst : NormedGroup E] [inst_1 : NondiscreteNormedField â„],\n  IsCompact (Metric.closedBall (0 : E) 1) ",
      "{m : â„•} [inst : NormedGroup â„[m]] : IsCompact (Metric.ClosedBall 0 1) ",
      "(ğ•œ : Type) [inst : NormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E]\n  (h : âˆ€ x : E, â€–xâ€– = âˆ¥xâˆ¥) : IsCompact (Metric.closedBall 0 1) ",
      "{m : â„•} [inst : NormedGroup â„[m]] : IsCompact (Metric.closedBall 0 1) ",
      "{m : â„•} [inst : NormedGroup â„[m]] :\n  IsCompact {x : â„[m] | â€–xâ€– â‰¤ 1} ",
      "{m : â„•} [inst : NormedAddCommGroup (Finâ‚“ m â†’ â„)] : IsCompact (Metric.closedBall (0 : Finâ‚“ m â†’ â„) 1) ",
      "IsCompact {x : â„^m | âˆ¥xâˆ¥ â‰¤ 1} ",
      "{m : â„•} [inst : NormedField â„] [inst_1 : NormedSpace â„ (Fin m)] :\n  IsCompact (Metric.closedBall (0 : Fin m â†’ â„) 1) "
    ]
  },
  {
    "docString": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\\n  IsClosed s â†’ âˆ€ [inst_2 : DiscreteTopology â†‘s], Cardinal.continuum â‰¤ Cardinal.mk â†‘s â†’ Â¬NormalSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\\nhas cardinality at least continuum, then the ambient space is not a normal space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : ConnectedSpace Î±] [inst_2 : Nontrivial Î±] [inst_3 : T1Space Î±]\\n  (x : Î±), Filter.NeBot (nhdsWithin x {x}á¶œ)\",\n  \"isProp\": true,\n  \"docString\": \"A non-trivial connected T1 space has no isolated points. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\\n  IsClosed s â†’ Â¬a âˆˆ s â†’ Disjoint (nhdsSet s) (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\\nneighborhoods.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  IsConnected s â†”\\n    âˆ€ (U : Finset (Set Î±)),\\n      (âˆ€ (u v : Set Î±), u âˆˆ U â†’ v âˆˆ U â†’ Set.Nonempty (s âˆ© (u âˆ© v)) â†’ u = v) â†’\\n        (âˆ€ (u : Set Î±), u âˆˆ U â†’ IsOpen u) â†’ s âŠ† â‹ƒâ‚€ â†‘U â†’ âˆƒ u, u âˆˆ U âˆ§ s âŠ† u\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set `s` is connected if and only if\\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\\nit is contained in one of the members of the collection. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  IsClosed s â†’ (IsPreconnected s â†” âˆ€ (u v : Set Î±), IsClosed u â†’ IsClosed v â†’ s âŠ† u âˆª v â†’ Disjoint u v â†’ s âŠ† u âˆ¨ s âŠ† v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A closed set `s` is preconnected if and only if for every cover by two closed sets that are\\ndisjoint, it is contained in one of the two covering sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\\n    Pairwise (Disjoint on s) â†’\\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] (H : Subgroup G),\\n  1 âˆˆ interior â†‘H â†’ IsOpen â†‘H\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a subgroup of a topological group has `1` in its interior, then it is open. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C}\\n  {S : CategoryTheory.Sieve X},\\n  CategoryTheory.GrothendieckTopology.IsClosed Jâ‚ S â†’\\n    âˆ€ {Y : C} (f : Y âŸ¶ X), CategoryTheory.GrothendieckTopology.Covers Jâ‚ S f â†” S.arrows f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is `Jâ‚`-closed, then `S` covers exactly the arrows it contains. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] [inst_2 : NormalSpace X]\\n  {s : Set X}, IsClosed s â†’ âˆ€ [inst : DiscreteTopology â†‘s], Cardinal.mk â†‘s < Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s` be a closed set in a separable normal space. If the induced topology on `s` is discrete,\\nthen `s` has cardinality less than continuum.\\n\\nThe proof follows\\nhttps://en.wikipedia.org/wiki/Moore_plane#Proof_that_the_Moore_plane_is_not_normal \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"}]\n",
    "prompt_cons": "/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\nhas cardinality at least continuum, then the ambient space is not a normal space. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\n  IsClosed s â†’ âˆ€ [inst_2 : DiscreteTopology â†‘s], Cardinal.continuum â‰¤ Cardinal.mk â†‘s â†’ Â¬NormalSpace X :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- A non-trivial connected T1 space has no isolated points. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : ConnectedSpace Î±] [inst_2 : Nontrivial Î±] [inst_3 : T1Space Î±]\n  (x : Î±), Filter.NeBot (nhdsWithin x {x}á¶œ) :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\nneighborhoods. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\n  IsClosed s â†’ Â¬a âˆˆ s â†’ Disjoint (nhdsSet s) (nhds a) :=\n\n/-- A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  IsConnected s â†”\n    âˆ€ (U : Finset (Set Î±)),\n      (âˆ€ (u v : Set Î±), u âˆˆ U â†’ v âˆˆ U â†’ Set.Nonempty (s âˆ© (u âˆ© v)) â†’ u = v) â†’\n        (âˆ€ (u : Set Î±), u âˆˆ U â†’ IsOpen u) â†’ s âŠ† â‹ƒâ‚€ â†‘U â†’ âˆƒ u, u âˆˆ U âˆ§ s âŠ† u :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x) :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x} :=\n\n/-- A closed set `s` is preconnected if and only if for every cover by two closed sets that are\ndisjoint, it is contained in one of the two covering sets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ (IsPreconnected s â†” âˆ€ (u v : Set Î±), IsClosed u â†’ IsClosed v â†’ s âŠ† u âˆª v â†’ Disjoint u v â†’ s âŠ† u âˆ¨ s âŠ† v) :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\n    Pairwise (Disjoint on s) â†’\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹ :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] (H : Subgroup G),\n  1 âˆˆ interior â†‘H â†’ IsOpen â†‘H :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- If `S` is `Jâ‚`-closed, then `S` covers exactly the arrows it contains. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C}\n  {S : CategoryTheory.Sieve X},\n  CategoryTheory.GrothendieckTopology.IsClosed Jâ‚ S â†’\n    âˆ€ {Y : C} (f : Y âŸ¶ X), CategoryTheory.GrothendieckTopology.Covers Jâ‚ S f â†” S.arrows f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Let `s` be a closed set in a separable normal space. If the induced topology on `s` is discrete,\nthen `s` has cardinality less than continuum.\n\nThe proof follows\nhttps://en.wikipedia.org/wiki/Moore_plane#Proof_that_the_Moore_plane_is_not_normal -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] [inst_2 : NormalSpace X]\n  {s : Set X}, IsClosed s â†’ âˆ€ [inst : DiscreteTopology â†‘s], Cardinal.mk â†‘s < Cardinal.continuum :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- Show that if $S$ is connected, it is not true in general that its interior is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬(IsConnected (interior s) â†” True) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ Â¬(IsConnected (interior s) â†’ IsConnected s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set Î±},\n  IsConnected S â†’ Â¬IsConnected (interior S) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬(âˆ€ {t : Set Î±}, t = interior s â†’ IsConnected t) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬IsConnected (interior s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set Î±}, IsConnected S â†’ Â¬(IsConnected (interior S) â†’ IsConnected S) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ Â¬IsConnected (interior s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ Â¬(IsConnected (interior s) â†’ IsConnected s) ",
      "{Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬IsConnected (interior s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  IsConnected s â†’ Â¬(IsConnected (interior s) â†” IsConnected s) "
    ]
  },
  {
    "docString": "Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence a.e. implies convergence in measure in a finite measure space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)],\\n  UniformContinuous Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion from `lp E p` to `âˆ€ i, E i` is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\\n  (s : Set Î²),\\n  IsCompact s â†’\\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\\n      IsClosed A â†’\\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {Î¹ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module ğ•œ E] {p : SeminormFamily ğ•œ E Î¹} [inst_3 : Nonempty Î¹] [t : TopologicalSpace E],\\n  WithSeminorms p â†’ âˆ€ (q : Seminorm ğ•œ E), Continuous â†‘q â†’ âˆƒ s C, C â‰  0 âˆ§ q â‰¤ C â€¢ Finset.sup s p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `E` be a topological vector space (over a `NontriviallyNormedField`) whose topology is\\ngenerated by some family of seminorms `p`, and let `q` be a seminorm on `E`. If `q` is continuous,\\nthen it is uniformly controlled by *finitely many* seminorms of `p`, that is there\\nis some finset `s` of the index set and some `C > 0` such that `q â‰¤ C â€¢ s.sup p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [inst : MetricSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : SemilatticeSup Î¹] [inst_2 : Nonempty Î¹] [inst_3 : Countable Î¹] {f : Î¹ â†’ Î± â†’ Î²}\\n  {g : Î± â†’ Î²} [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : Î¹), MeasureTheory.StronglyMeasurable (f n)) â†’\\n    MeasureTheory.StronglyMeasurable g â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n        âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰¤ ENNReal.ofReal Îµ âˆ§ TendstoUniformlyOn f g Filter.atTop tá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"Egorov's theorem for finite measure spaces. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\\n  IsComplete s â†’\\n    âˆ€ (hsf : Set.MapsTo f s s),\\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\\n        âˆ€ {x : Î±},\\n          x âˆˆ s â†’\\n            edist x (f x) â‰  âŠ¤ â†’\\n              âˆƒ y,\\n                y âˆˆ s âˆ§\\n                  Function.IsFixedPt f y âˆ§\\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Banach fixed-point theorem for maps contracting on a complete subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), UniformContinuous fun x => Metric.infNndist x s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\": \"âˆ€ (p : â„) [inst : Fact (0 < p)], CompactSpace (AddCircle p)\",\n  \"isProp\": true,\n  \"docString\": \"The \\\"additive circle\\\" `â„ â§¸ (â„¤ âˆ™ p)` is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, x âˆˆ s â†’ Metric.infDist x s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance of a point to a set containing it vanishes \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"}]\n",
    "prompt_cons": "/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Convergence a.e. implies convergence in measure in a finite measure space. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- The coercion from `lp E p` to `âˆ€ i, E i` is uniformly continuous. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)],\n  UniformContinuous Subtype.val :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\n  (s : Set Î²),\n  IsCompact s â†’\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\n      IsClosed A â†’\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A :=\n\n/-- Let `E` be a topological vector space (over a `NontriviallyNormedField`) whose topology is\ngenerated by some family of seminorms `p`, and let `q` be a seminorm on `E`. If `q` is continuous,\nthen it is uniformly controlled by *finitely many* seminorms of `p`, that is there\nis some finset `s` of the index set and some `C > 0` such that `q â‰¤ C â€¢ s.sup p`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {Î¹ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ğ•œ E] {p : SeminormFamily ğ•œ E Î¹} [inst_3 : Nonempty Î¹] [t : TopologicalSpace E],\n  WithSeminorms p â†’ âˆ€ (q : Seminorm ğ•œ E), Continuous â†‘q â†’ âˆƒ s C, C â‰  0 âˆ§ q â‰¤ C â€¢ Finset.sup s p :=\n\n/-- Egorov's theorem for finite measure spaces. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [inst : MetricSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : SemilatticeSup Î¹] [inst_2 : Nonempty Î¹] [inst_3 : Countable Î¹] {f : Î¹ â†’ Î± â†’ Î²}\n  {g : Î± â†’ Î²} [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : Î¹), MeasureTheory.StronglyMeasurable (f n)) â†’\n    MeasureTheory.StronglyMeasurable g â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n        âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰¤ ENNReal.ofReal Îµ âˆ§ TendstoUniformlyOn f g Filter.atTop tá¶œ :=\n\n/-- Banach fixed-point theorem for maps contracting on a complete subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\n  IsComplete s â†’\n    âˆ€ (hsf : Set.MapsTo f s s),\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\n        âˆ€ {x : Î±},\n          x âˆˆ s â†’\n            edist x (f x) â‰  âŠ¤ â†’\n              âˆƒ y,\n                y âˆˆ s âˆ§\n                  Function.IsFixedPt f y âˆ§\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K) :=\n\n/-- The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), UniformContinuous fun x => Metric.infNndist x s :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- The \"additive circle\" `â„ â§¸ (â„¤ âˆ™ p)` is compact. -/\ntheorem âˆ€ (p : â„) [inst : Fact (0 < p)], CompactSpace (AddCircle p) :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, x âˆˆ s â†’ Metric.infDist x s = 0 :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses. -/\ntheorem",
    "choices": [
      "âˆƒ (p : â„), âˆƒá¶  (x : â„) in Filter.atTop, #((fun x => x âˆˆ E) âˆ© Ico x (x + 1))á¶œ = #E ",
      "âˆ€ {E : Set â„} [inst : Set.Nonempty E] (h : Set.Countable E â†’ False),\n  âˆƒ p, Filter.Eventually (fun x => p â‰¤ x) (Filter.comap coe (Filter.atBot : Filter â„)) âˆ§\n        Filter.Eventually (fun x => x â‰¤ p) (Filter.comap coe (Filter.atTop : Filter â„)) ",
      "âˆ€ (E : Set â„), Set.Countable Eá¶œ â†’ âˆƒ p, IsCondensationPoint p E ",
      "âˆ€ {E : Set â„}, Set.Uncountable E â†’ âˆƒ p, âˆ€ Îµ, 0 < Îµ â†’ Set.Countable (E âˆ© Metric.Ball p Îµ) ",
      "âˆ€ (E : Set â„), Set.Countable Eá¶œ â†’ âˆƒ p, CondensesAt E p ",
      "âˆ€ (E : Set â„), \n  Set.Countable E â†’ \n    âˆƒ p, Filter.HasAntitoneBasis (filter.principal ((Î» x, x - p) '' E)) (Î» n : â„•, (â¨… i âˆˆ E, Ball ((Î» x, x - p) i) (1 / (n + 1)))) ",
      "âˆ€ (E : Set â„), Set.Countable Eá¶œ â†’ âˆƒ p, IsCondensationPoint p E ",
      "âˆ€ {E : Set â„} [inst : Set.Countable Eá¶œ],\n  âˆƒ p, Filter.Tendsto (id fun x => x) (Filter.principal E) (nhds p) ",
      "âˆ€ {E : Set â„}, Set.Countable Eá¶œ â†’ âˆƒ p, Filter.Tendsto (fun n => Set.card (E âˆ© Ioo (p - 1 / (n + 1)) (p + 1 / (n + 1)))) Filter.atTop Filter.atTop ",
      "âˆ€ (E : Set â„), Set.Countable Eá¶œ â†’ âˆƒ p : â„, âˆ€ Îµ > (0 : â„), (SetOf fun x => x â‰  p âˆ§ E x âˆ§ abs (x - p) < Îµ).Nonempty "
    ]
  },
  {
    "docString": "Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), Filter.Tendsto (fun x => x ^ n * rexp (-x)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x^n * exp(-x)` tends to `0` at `+âˆ`, for any natural number `n`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {v : â„• â†’ â„} {c : â„}, 0 < v 0 â†’ 1 < c â†’ (âˆ€ (n : â„•), c * v n â‰¤ v (n + 1)) â†’ Filter.Tendsto v Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence `v` of real numbers satisfies `k * v n â‰¤ v (n+1)` with `1 < k`,\\nthen it goes to +âˆ. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : InfConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsGLB s a â†’ Filter.Tendsto CoeTC.coe Filter.atBot (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ -âˆ`\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p {x} â†” Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence on a singleton is equivalent to regular convergence \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"}]\n",
    "prompt_cons": "/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- The function `x^n * exp(-x)` tends to `0` at `+âˆ`, for any natural number `n`. -/\ntheorem âˆ€ (n : â„•), Filter.Tendsto (fun x => x ^ n * rexp (-x)) Filter.atTop (nhds 0) :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- If a sequence `v` of real numbers satisfies `k * v n â‰¤ v (n+1)` with `1 < k`,\nthen it goes to +âˆ. -/\ntheorem âˆ€ {v : â„• â†’ â„} {c : â„}, 0 < v 0 â†’ 1 < c â†’ (âˆ€ (n : â„•), c * v n â‰¤ v (n + 1)) â†’ Filter.Tendsto v Filter.atTop Filter.atTop :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ -âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : InfConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsGLB s a â†’ Filter.Tendsto CoeTC.coe Filter.atBot (nhds a) :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- The theorem that $(e^X - 1) * âˆ‘ Bâ‚™(t)* X^n/n! = Xe^{tX}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (t : A),\n  (PowerSeries.mk fun n => â†‘(Polynomial.aeval t) ((1 / â†‘(Nat.factorial n)) â€¢ Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * â†‘(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Uniform convergence on a singleton is equivalent to regular convergence -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p {x} â†” Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$. -/\ntheorem",
    "choices": [
      "Filter.Tendsto (fun n => sqrt (n+1) - sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => sqrt (n + 1) - sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => sqrt (n + 1) - sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => sqrt (n + 1) - sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => sqrt (â†‘(n + 1)) - sqrt (â†‘n)) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) "
    ]
  },
  {
    "docString": "Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun n => x ^ (n + 1) / (â†‘n + 1)) (-Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\": \"Power series expansion of the logarithm around `1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\": \"âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\": \"âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"},\n {\"theorem\":\n  \"âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2`  \"},\n {\"theorem\":\n  \"âˆ€ {x y : â„¤} {n : â„•},\\n  2 âˆ£ x - y â†’\\n    Â¬2 âˆ£ x â†’\\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"âˆ€ (p : â„• â†’ Prop) [inst : DecidablePred p] (n : â„•), Nat.count p n = Fintype.card { k // k < n âˆ§ p k }\",\n  \"isProp\": true,\n  \"docString\":\n  \"`count p n` can be expressed as the cardinality of `{k // k < n âˆ§ p k}`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (z : â„¤), padicNorm p â†‘z â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"The `p`-adic norm of an integer is at most `1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {n : â„•} [inst_2 : CompleteSpace E]\\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) â†’ â„) â†’ E} {f' : (Fin (n + 1) â†’ â„) â†’L[â„] E},\\n  ContinuousOn f (â†‘BoxIntegral.Box.Icc I) â†’\\n    âˆ€ {x : Fin (n + 1) â†’ â„},\\n      x âˆˆ â†‘BoxIntegral.Box.Icc I â†’\\n        âˆ€ {a : E} {Îµ : â„},\\n          0 < Îµ â†’\\n            (âˆ€ (y : Fin (n + 1) â†’ â„), y âˆˆ â†‘BoxIntegral.Box.Icc I â†’ â€–f y - a - â†‘f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–) â†’\\n              âˆ€ {c : NNReal},\\n                BoxIntegral.Box.distortion I â‰¤ c â†’\\n                  â€–(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) â€¢\\n                          â†‘f' (Pi.single i 1) -\\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) âŠ¥\\n                            (f âˆ˜ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) âŠ¥\\n                            (f âˆ˜ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)â€– â‰¤\\n                    2 * Îµ * â†‘c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j\",\n  \"isProp\": true,\n  \"docString\": \"Auxiliary lemma for the divergence theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n k : â„•), multiplicity p n â‰¤ multiplicity p (Nat.choose n k) + multiplicity p k\",\n  \"isProp\": true,\n  \"docString\": \"A lower bound on the multiplicity of `p` in `choose n k`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\": \"Summability of the `p`-series over `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {p n k : â„•}, â†‘(Nat.factorization (Nat.choose n k)) p â‰¤ Nat.log p n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•} {A : Finset â„•}, (âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) â†’ Finset.sum A (Nat.pow 2) < 2 ^ k\",\n  \"isProp\": true,\n  \"docString\":\n  \"If everything in `A` is less than `k`, we can bound the sum of powers. \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- Power series expansion of the logarithm around `1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun n => x ^ (n + 1) / (â†‘n + 1)) (-Real.log (1 - x)) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem âˆ€ {Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} (n : â„•),\n  (âˆ€ (a : Î¹), a âˆˆ s â†’ 0 â‰¤ f a) â†’\n    (Finset.sum s fun x => f x) ^ (n + 1) / â†‘(Finset.card s) ^ n â‰¤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2` -/\ntheorem âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem âˆ€ {x y : â„¤} {n : â„•},\n  2 âˆ£ x - y â†’\n    Â¬2 âˆ£ x â†’\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n :=\n\n/-- `count p n` can be expressed as the cardinality of `{k // k < n âˆ§ p k}`. -/\ntheorem âˆ€ (p : â„• â†’ Prop) [inst : DecidablePred p] (n : â„•), Nat.count p n = Fintype.card { k // k < n âˆ§ p k } :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_1} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹},\n  Orthonormal ğ•œ v â†’ (Finset.sum s fun i => â€–inner (v i) xâ€– ^ 2) â‰¤ â€–xâ€– ^ 2 :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x)) :=\n\n/-- The `p`-adic norm of an integer is at most `1`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (z : â„¤), padicNorm p â†‘z â‰¤ 1 :=\n\n/-- Auxiliary lemma for the divergence theorem. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {n : â„•} [inst_2 : CompleteSpace E]\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) â†’ â„) â†’ E} {f' : (Fin (n + 1) â†’ â„) â†’L[â„] E},\n  ContinuousOn f (â†‘BoxIntegral.Box.Icc I) â†’\n    âˆ€ {x : Fin (n + 1) â†’ â„},\n      x âˆˆ â†‘BoxIntegral.Box.Icc I â†’\n        âˆ€ {a : E} {Îµ : â„},\n          0 < Îµ â†’\n            (âˆ€ (y : Fin (n + 1) â†’ â„), y âˆˆ â†‘BoxIntegral.Box.Icc I â†’ â€–f y - a - â†‘f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–) â†’\n              âˆ€ {c : NNReal},\n                BoxIntegral.Box.distortion I â‰¤ c â†’\n                  â€–(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) â€¢\n                          â†‘f' (Pi.single i 1) -\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) âŠ¥\n                            (f âˆ˜ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) âŠ¥\n                            (f âˆ˜ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)â€– â‰¤\n                    2 * Îµ * â†‘c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j :=\n\n/-- A lower bound on the multiplicity of `p` in `choose n k`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n k : â„•), multiplicity p n â‰¤ multiplicity p (Nat.choose n k) + multiplicity p k :=\n\n/-- Summability of the `p`-series over `â„¤`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. -/\ntheorem âˆ€ {p n k : â„•}, â†‘(Nat.factorization (Nat.choose n k)) p â‰¤ Nat.log p n :=\n\n/-- If everything in `A` is less than `k`, we can bound the sum of powers. -/\ntheorem âˆ€ {k : â„•} {A : Finset â„•}, (âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) â†’ Finset.sum A (Nat.pow 2) < 2 ^ k :=\n\n/-- Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$. -/\ntheorem",
    "choices": [
      "forall {p : â„}, (Summable fun k => (1 / â†‘k * log (â†‘k)) ^ p) â†” Â¬(p â‰¤ 1) ",
      "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem exp_sum_eq_of_nat {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•) :\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ ",
      "forall {p : â„}, (Summable fun k => 1 / (â†‘k * Real.log â†‘k ^ p)) â†” p > 1 ",
      "forall {p : â„}, 1 â‰¤ p â†’ Â¬ Summable (Î» k => 1 / ((â†‘k) * Real.log â†‘k) ^ p) ",
      "âˆ€ {p : â„}, 0 < p â†’ p â‰¤ 1 â†’ Â¬Summable (Î» k => 1 / â†‘k * log (â†‘k) ^ p) ",
      "âˆ€ {p : â„}, (Summable fun k => 1 / â†‘k * log (â†‘k) ^ p) â†’ 1 < p ",
      "âˆ€ {p : â„}, p â‰¤ 1 â†’ Â¬(Summable fun k => 1 / (â†‘k * Real.log (â†‘k) ^ p)) ",
      "âˆ€ {p : â„}, (Summable fun k => 1 / (â†‘k * Real.log â†‘k ^ p)) â†’ 1 < p ",
      "forall {p : â„}, (Summable fun k => 1 / (â†‘k * Real.log â†‘k ^ p)) â†” p > 1 ",
      "forall {p : â„}, p â‰¤ 1 â†’ Â¬(Summable fun k => 1 / (â†‘k * (Real.log â†‘k) ^ p)) "
    ]
  },
  {
    "docString": "Show that a group of order 5 must be abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := finRotate 5, property := (_ : finRotate (bit1 2) âˆˆ alternatingGroup (Fin (bit1 2))) }} =\\n  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\\n  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has strong epi-mono factorisations. \"},\n {\"theorem\":\n  \"âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’\\n    pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„, pâ‚…}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points lie in the affine span of two points, those five points are collinear. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i j : Fin (n + 1)},\\n  i â‰¤ j â†’\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Ïƒ X (Fin.castSucc i))\\n        (CategoryTheory.CosimplicialObject.Ïƒ X j) =\\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Ïƒ X (Fin.succ j))\\n        (CategoryTheory.CosimplicialObject.Ïƒ X i)\",\n  \"isProp\": true,\n  \"docString\": \"The fifth cosimplicial identity \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\\n  [inst_2 : CategoryTheory.WellPowered C], CategoryTheory.WellPowered Cáµ’áµ–\",\n  \"isProp\": true,\n  \"docString\": \"A well-powered abelian category is also well-copowered. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := finRotate 5, property := (_ : finRotate (bit1 2) âˆˆ alternatingGroup (Fin (bit1 2))) }} =\n  âŠ¤ :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\n  âŠ¤ :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- An abelian category has strong epi-mono factorisations. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- If three points lie in the affine span of two points, those five points are collinear. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’\n    pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„, pâ‚…} :=\n\n/-- The fifth cosimplicial identity -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i j : Fin (n + 1)},\n  i â‰¤ j â†’\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Ïƒ X (Fin.castSucc i))\n        (CategoryTheory.CosimplicialObject.Ïƒ X j) =\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Ïƒ X (Fin.succ j))\n        (CategoryTheory.CosimplicialObject.Ïƒ X i) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- A well-powered abelian category is also well-copowered. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.WellPowered C], CategoryTheory.WellPowered Cáµ’áµ– :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- Show that a group of order 5 must be abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 5 â†’ IsCommutative Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 5 â†’ IsLieAbelian Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 5 â†’ IsLieAbelian Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 5 â†’ IsLieAbelian Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 5 â†’ IsLieAbelian Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 5 â†’ IsLieAbelian Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Fintype.card Î± = 5 â†’ IsLieAbelian Î± ",
      "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 5 â†’ IsCommGroup Î± ",
      "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±]\n  (h : Fintype.card Î± = 5),\n  CommGroup Î± ",
      "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±],\n  Fintype.card Î± = 5 â†’ IsCommutative Î± "
    ]
  },
  {
    "docString": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$.",
    "prompts": "[{\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : DivisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤),\\n  â†‘f (g ^ n) = â†‘f g ^ n\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve integer power. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\\n  â†‘h (x / y) = â†‘h x / â†‘h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Group homomorphisms preserve integer power. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : DivisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤),\n  â†‘f (g ^ n) = â†‘f g ^ n :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\n  â†‘h (x / y) = â†‘h x / â†‘h y :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$. -/\ntheorem",
    "choices": [
      "âˆ€ (G : Type u) [inst : Group G] [inst_1 : Fintype G], âˆƒ m > 0, âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ (a : G), a ^ m = 1 ",
      "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ (a : G), a ^ m = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ (G : Type u) [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, 0 < m âˆ§ âˆ€ (a : G), a ^ m = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], âˆƒ m : â„•, m > 0 âˆ§ âˆ€ a : G, a ^ m = 1 "
    ]
  },
  {
    "docString": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (â†‘(CliffordAlgebra.Î¹ Q) a)] [inst_4 : Invertible (â†‘Q a)],\\n  â…Ÿ(â†‘(CliffordAlgebra.Î¹ Q) a) * â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\\n    â†‘(CliffordAlgebra.Î¹ Q) ((â…Ÿ(â†‘Q a) * QuadraticForm.polar (â†‘Q) a b) â€¢ a - b)\",\n  \"isProp\": true,\n  \"docString\": \"$a^{-1}ba$ is a vector. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c) :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- $a^{-1}ba$ is a vector. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (â†‘(CliffordAlgebra.Î¹ Q) a)] [inst_4 : Invertible (â†‘Q a)],\n  â…Ÿ(â†‘(CliffordAlgebra.Î¹ Q) a) * â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\n    â†‘(CliffordAlgebra.Î¹ Q) ((â…Ÿ(â†‘Q a) * QuadraticForm.polar (â†‘Q) a b) â€¢ a - b) :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b)^3 = a^3 * b^3) â†’ (âˆ€ a b : G, (a * b)^5 = a^5 * b^5) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h3 : âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) (h5 : âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5), IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (h3 : âˆ€ a b : G, (a * b)^3 = a^3 * b^3) (h5 : âˆ€ a b : G, (a * b)^5 = a^5 * b^5), IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’ (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’ CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b)^3 = a^3 * b^3) â†’ (âˆ€ a b : G, (a * b)^5 = a^5 * b^5) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’\n  (âˆ€ (a b : G), (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’\n  IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’ (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’ (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’ Commute (âˆ€ a b : G, a * b = b * a) ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’ (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) â†’ (âˆ€ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) â†’ IsCommutative G "
    ]
  },
  {
    "docString": "If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (u : MË£) (x : M), SemiconjBy (â†‘u) x (â†‘u * x * â†‘uâ»Â¹)\",\n  \"isProp\": true,\n  \"docString\": \"`a` semiconjugates `x` to `a * x * aâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x âˆˆ self.carrier â†’ xâ»Â¹ âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_2} {Gâ‚€' : Type u_1} {F : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : GroupWithZero Gâ‚€']\\n  [inst_2 : MonoidWithZeroHomClass F Gâ‚€ Gâ‚€'] (f : F) (a : Gâ‚€), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism between groups with zeros sending `0` to `0` sends `aâ»Â¹` to `(f a)â»Â¹`. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : CommGroup Î±], IsGroupHom Inv.inv\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inversion is a group homomorphism if the group is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {a : M} {x y : MË£}, SemiconjBy a â†‘x â†‘y â†’ SemiconjBy a â†‘xâ»Â¹ â†‘yâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `xâ»Â¹` to `yâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : CompleteLattice Î±] [inst_1 : Group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G),\\n  Function.Semiconj (fun x => â¨† (g' : G), â†‘(â†‘fâ‚ g')â»Â¹ (â†‘(â†‘fâ‚‚ g') x)) â†‘(â†‘fâ‚‚ g) â†‘(â†‘fâ‚ g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider two actions `fâ‚ fâ‚‚ : G â†’ Î± â†’ Î±` of a group on a complete lattice by order\\nisomorphisms. Then the map `x â†¦ â¨† g : G, (fâ‚ g)â»Â¹ (fâ‚‚ g x)` semiconjugates each `fâ‚ g'` to `fâ‚‚ g'`.\\n\\nThis is a version of Proposition 5.4 from [Ã‰tienne Ghys, Groupes d'homÃ©omorphismes du cercle et\\ncohomologie bornÃ©e][ghys87:groupes]. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a x y x' y' : S},\\n  SemiconjBy a x y â†’ SemiconjBy a x' y' â†’ SemiconjBy a (x * x') (y * y')\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\\nthen it semiconjugates `x * x'` to `y * y'`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (g * a)) â†’ (âˆ€ (a : G), P a â†’ P (gâ»Â¹ * a)) â†’ âˆ€ (n : â„¤), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `gâ»Â¹` on the left. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_left`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"}]\n",
    "prompt_cons": "/-- `a` semiconjugates `x` to `a * x * aâ»Â¹`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (u : MË£) (x : M), SemiconjBy (â†‘u) x (â†‘u * x * â†‘uâ»Â¹) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x :=\n\n/-- `G` is closed under inverses -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x âˆˆ self.carrier â†’ xâ»Â¹ âˆˆ self.carrier :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹ :=\n\n/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `aâ»Â¹` to `(f a)â»Â¹`. -/\ntheorem âˆ€ {Gâ‚€ : Type u_2} {Gâ‚€' : Type u_1} {F : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : GroupWithZero Gâ‚€']\n  [inst_2 : MonoidWithZeroHomClass F Gâ‚€ Gâ‚€'] (f : F) (a : Gâ‚€), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem âˆ€ {Î± : Type u} [inst : CommGroup Î±], IsGroupHom Inv.inv :=\n\n/-- By definition, if `x` is invertible then `inverse x = xâ»Â¹`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹ :=\n\n/-- If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `xâ»Â¹` to `yâ»Â¹`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {a : M} {x y : MË£}, SemiconjBy a â†‘x â†‘y â†’ SemiconjBy a â†‘xâ»Â¹ â†‘yâ»Â¹ :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹ :=\n\n/-- If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Consider two actions `fâ‚ fâ‚‚ : G â†’ Î± â†’ Î±` of a group on a complete lattice by order\nisomorphisms. Then the map `x â†¦ â¨† g : G, (fâ‚ g)â»Â¹ (fâ‚‚ g x)` semiconjugates each `fâ‚ g'` to `fâ‚‚ g'`.\n\nThis is a version of Proposition 5.4 from [Ã‰tienne Ghys, Groupes d'homÃ©omorphismes du cercle et\ncohomologie bornÃ©e][ghys87:groupes]. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : CompleteLattice Î±] [inst_1 : Group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G),\n  Function.Semiconj (fun x => â¨† (g' : G), â†‘(â†‘fâ‚ g')â»Â¹ (â†‘(â†‘fâ‚‚ g') x)) â†‘(â†‘fâ‚‚ g) â†‘(â†‘fâ‚ g) :=\n\n/-- If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a x y x' y' : S},\n  SemiconjBy a x y â†’ SemiconjBy a x' y' â†’ SemiconjBy a (x * x') (y * y') :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹ :=\n\n/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `gâ»Â¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. -/\ntheorem âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (g * a)) â†’ (âˆ€ (a : G), P a â†’ P (gâ»Â¹ * a)) â†’ âˆ€ (n : â„¤), P (g ^ n) :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$ -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), SemiconjBy xâ»Â¹ (a * x) (xâ»Â¹ * a * x) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate a x) = Conjugate (Conjugate a xâ»Â¹) x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate x a) = Conjugate (xâ»Â¹ * a) x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate x a) = Conjugate (xâ»Â¹ * a * x) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x a : G), conjugate (xâ»Â¹ * a * x) = xâ»Â¹ * conjugate a * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x a : G),\n  (conjugate xâ»Â¹ a x) = xâ»Â¹ * (conjugate a) * x ",
      "forall {G : Type u_1} [inst : Group G] {a x : G}, Conjugate (xâ»Â¹ * a * x) = xâ»Â¹ * Conjugate a * x ",
      "forall {G : Type u_1} [inst : Group G] (a x : G), Conjugate xâ»Â¹ (Conjugate x a) = Conjugate (xâ»Â¹ * a * x) a ",
      "forall {G : Type u_1} [inst : Group G] {a x : G}, Conjugate xâ»Â¹ a x = xâ»Â¹ * Conjugate a * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] (a x : G), Conjugate (xâ»Â¹ * a * x) = xâ»Â¹ * Conjugate a * x "
    ]
  },
  {
    "docString": "If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ Nat.totient n = Finsupp.prod (Nat.factorization n) fun p k => p ^ (k - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\": \"Euler's product formula for the totient function. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (Ïˆ : AddChar R R') (n : â„•),\\n  Ïˆ ^ n = AddChar.mulShift Ïˆ â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is a natural number, then `Ïˆ ^ n = mulShift Ïˆ n`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•},\\n  0 < n â†’\\n    âˆ€ (R : Type u_1) [inst : CommRing R],\\n      (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic i R) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\": \"`âˆ i in Nat.divisors n, cyclotomic i R = X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (Ï‡ : MulChar R R') {n : â„•},\\n  0 < n â†’ âˆ€ (a : R), â†‘(Ï‡ ^ n) a = â†‘Ï‡ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(Ï‡ ^ n) a = (Ï‡ a) ^ n`. \"}]\n",
    "prompt_cons": "/-- Euler's product formula for the totient function. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ Nat.totient n = Finsupp.prod (Nat.factorization n) fun p k => p ^ (k - 1) * (p - 1) :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `n` is a natural number, then `Ïˆ ^ n = mulShift Ïˆ n`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (Ïˆ : AddChar R R') (n : â„•),\n  Ïˆ ^ n = AddChar.mulShift Ïˆ â†‘n :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1 :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- `âˆ i in Nat.divisors n, cyclotomic i R = X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•},\n  0 < n â†’\n    âˆ€ (R : Type u_1) [inst : CommRing R],\n      (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic i R) = Polynomial.X ^ n - 1 :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If `n` is positive, then `(Ï‡ ^ n) a = (Ï‡ a) ^ n`. -/\ntheorem âˆ€ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (Ï‡ : MulChar R R') {n : â„•},\n  0 < n â†’ âˆ€ (a : R), â†‘(Ï‡ ^ n) a = â†‘Ï‡ a ^ n :=\n\n/-- If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function. -/\ntheorem",
    "choices": [
      "âˆ€ {a : â„•}, a > 1 â†’ âˆ€ (n : â„•), Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ n âˆ£ Nat.totient (a ^ n - 1) ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a : â„•}, a > 1 â†’ âˆ€ (n : â„•), n âˆ£ Nat.totient (a ^ n - 1) ",
      "âˆ€ {a : â„•}, a > 1 â†’ âˆ€ (n : â„•), Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n ",
      "âˆ€ {a : â„•} {n : â„•}, a > 1 â†’ n âˆ£ Nat.totient (a ^ n - 1) ",
      "âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ {a : â„•}, a > 1 â†’ Nat.totient (a^n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a^n - 1) âˆ£ n ",
      "âˆ€ {a n : â„•}, a > 1 â†’ Nat.totient (a ^ n - 1) âˆ£ n "
    ]
  },
  {
    "docString": "Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\\n  p â‰  0 â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (p : â„•) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R â‰  0 â†’ (IsUnit â†‘p â†” Â¬p âˆ£ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] {P : Prop},\\n  (âˆ€ (p : â„•), p > 0 â†’ MixedCharZero R p â†’ P) â†” âˆ€ (p : â„•), Nat.Prime p â†’ MixedCharZero R p â†’ P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\\ncan always assume that `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (p : â„•) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\\n  IsUnit â†‘p â†” Â¬p âˆ£ ringChar R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a finite commutative ring `R`\\niff it does not divide the characteristic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (p q : â„•) [hp : CharP R p] [hq : ExpChar R q], p = q â†” Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The characteristic equals the exponential characteristic iff the former is prime. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\n  p â‰  0 â†’ Nat.Prime p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (p : â„•) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R â‰  0 â†’ (IsUnit â†‘p â†” Â¬p âˆ£ ringChar R) :=\n\n/-- Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] {P : Prop},\n  (âˆ€ (p : â„•), p > 0 â†’ MixedCharZero R p â†’ P) â†” âˆ€ (p : â„•), Nat.Prime p â†’ MixedCharZero R p â†’ P :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- A prime `p` is a unit in a finite commutative ring `R`\niff it does not divide the characteristic. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (p : â„•) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\n  IsUnit â†‘p â†” Â¬p âˆ£ ringChar R :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- The characteristic equals the exponential characteristic iff the former is prime. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (p q : â„•) [hp : CharP R p] [hq : ExpChar R q], p = q â†” Nat.Prime p :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p * m â†’ Â¬ p âˆ£ m â†’ Subgroup.Normal H â†’ Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Characteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬p âˆ£ m â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Normal H â†’ Subgroup.IsCharSubgroup H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p â†’\n    âˆ€ (n : â„•), p * n = Fintype.card G â†’ Â¬ p âˆ£ n â†’ Subgroup.Characteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬ p âˆ£ m â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Normal H â†’ Subgroup.IsChar H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Normal H â†’ Subgroup.is_char H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)]\n  {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ p * m = Fintype.card G â†’\n    Nat.Coprime p m â†’ Subgroup.Normal H â†’ âˆ€ (Ï• : G â‰ƒ* G), âˆ€ (x : G), x âˆˆ H â†’ (Ï• x) âˆˆ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p m : â„•) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬p âˆ£ m â†’\n  âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Normal H â†’ Subgroup.IsCharSubgroup H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p * m â†’ Â¬p âˆ£ m â†’ Subgroup.Normal H â†’ Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.charact H ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m â†’ Â¬p âˆ£ m â†’\n  âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Normal H â†’ Subgroup.IsChar H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : â„•} [hp : Fact (Nat.Prime p)], p âˆ£ Fintype.card G â†’\n  (âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p â†’ Subgroup.Normal H â†’ Subgroup.IsChar H) "
    ]
  },
  {
    "docString": "If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T3Space Î“â‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is Tâ‚ƒ. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [self : IsSolvable G], âˆƒ n, derivedSeries G n = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group `G` is solvable if its derived series is eventually trivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is Tâ‚…. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\\nelement, then `S` is dense `G`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] (e : C â‰Œ D)\\n  (Y : D),\\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.app (CategoryTheory.Equivalence.unit e) (e.inverse.obj Y))\\n      (e.inverse.map (CategoryTheory.NatTrans.app (CategoryTheory.Equivalence.counit e) Y)) =\\n    CategoryTheory.CategoryStruct.id (e.inverse.obj Y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The other triangle equality. The proof follows the following proof in Globular:\\nhttp://globular.science/1905.001 \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚ƒ. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T3Space Î“â‚€ :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A group `G` is solvable if its derived series is eventually trivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [self : IsSolvable G], âˆƒ n, derivedSeries G n = âŠ¥ :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚…. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€ :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- The other triangle equality. The proof follows the following proof in Globular:\nhttp://globular.science/1905.001 -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] (e : C â‰Œ D)\n  (Y : D),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.app (CategoryTheory.Equivalence.unit e) (e.inverse.obj Y))\n      (e.inverse.map (CategoryTheory.NatTrans.app (CategoryTheory.Equivalence.counit e) Y)) =\n    CategoryTheory.CategoryStruct.id (e.inverse.obj Y) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  â†‘(CliffordAlgebra.changeForm h') (â†‘(CliffordAlgebra.changeForm h) x) =\n    â†‘(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 â†’ Nontrivial G â†’ Â¬IsLieAbelian G â†’ G â‰ƒ* S3 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 6) (hN : Â¬IsLieAbelian G),\n  Nonempty (G â‰ƒ* SymbGroup (Fin 3)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 â†’\n    Â¬IsLieAbelian G â†’\n      Group.toPermGroup G â‰ƒ* Perm S3 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 6) (h' : Â¬IsLieAbelian G), Nonempty (G â‰ƒ* Sâ‚ƒ) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 â†’ Nontrivial G â†’\n  âˆƒ (Ï† : G â‰ƒ* S3), Function.Bijective Ï† ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 â†’ NoncommGroup G â†’ Isomorphic G (SymmetricGroup (Fin 3)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 â†’ Â¬IsLieAbelian G â†’ G â‰ƒ* S3 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [h : Nontrivial G],\n  Fintype.card G = 6 â†’ Â¬IsLieAbelian G â†’ G â‰ƒ* SymmetricGroup (Fin 3) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 6) (h_nonabelian : Â¬IsLieAbelian G),\n  Nonempty (G â‰ƒ* S3) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 â†’ Nonabelian G â†’ G â‰ƒ* S3 "
    ]
  },
  {
    "docString": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ âˆ€ (a b : G), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group of order `p ^ 2` is commutative. See also `IsPGroup.commGroupOfCardEqPrimeSq`\\nfor the `CommGroup` instance. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A group of order `p ^ 2` is commutative. See also `IsPGroup.commGroupOfCardEqPrimeSq`\nfor the `CommGroup` instance. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆ€ (a b : G), a * b = b * a :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u} [inst : Group G] [inst_1 : Fintype G] [Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Subgroup.Normal H âˆ§ Fintype.card { x // x âˆˆ H } = p ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = p âˆ§ Subgroup.Normal H "
    ]
  },
  {
    "docString": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "prompts": "[{\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\\nhas `Î¼ ^ m` as root. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {n m : â„•}, n â‰  m â†’ IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•}, Nat.coprime m n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ m` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\nhas `Î¼ ^ m` as root. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m) :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. -/\ntheorem âˆ€ {n m : â„•}, n â‰  m â†’ IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š) :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ m` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•}, Nat.coprime m n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m) :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•},\n  Nat.coprime m n â†’ (âˆƒ x y : G, addOrderOf x = m âˆ§ addOrderOf y = n) â†’ âˆƒ z : G, addOrderOf z = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•} (x y : G),\n  addOrderOf x = m â†’ addOrderOf y = n â†’ Nat.Coprime m n â†’ addOrderOf (x + y) = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•} {a b : G},\n  addOrderOf a = m â†’ addOrderOf b = n â†’ Nat.Coprime m n â†’ addOrderOf (a + b) = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : â„•},\n  Nat.coprime m n â†’ (âˆƒ x, addOrderOf x = m) â†’ (âˆƒ y, addOrderOf y = n) â†’ âˆƒ z, addOrderOf z = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•} (hm : 0 < m) (hn : 0 < n) (x y : G),\n  addOrderOf x = m â†’ addOrderOf y = n â†’ Nat.coprime m n â†’ addOrderOf (x + y) = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {x y : G} {m n : â„•},\n  Nat.coprime m n â†’ addOrderOf x = m â†’ addOrderOf y = n â†’ addOrderOf (x + y) = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•},\n  Nat.Coprime m n â†’ (âˆƒ x : G, addOrderOf x = m) â†’ (âˆƒ y : G, addOrderOf y = n) â†’ âˆƒ z : G, addOrderOf z = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•}, Nat.coprime m n â†’\n  (âˆƒ (x : G), addOrderOf x = m) â†’ (âˆƒ (y : G), addOrderOf y = n) â†’ âˆƒ (z : G), addOrderOf z = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•} {a b : G},\n  Nat.Coprime m n â†’ addOrderOf a = m â†’ addOrderOf b = n â†’ âˆƒ c, addOrderOf c = m * n ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {m n : â„•} (hm : 0 < m) (hn : 0 < n),\n  Nat.coprime m n â†’ (âˆƒ x, addOrderOf x = m) â†’ (âˆƒ y, addOrderOf y = n) â†’ âˆƒ z, addOrderOf z = m * n "
    ]
  },
  {
    "docString": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R Ã— S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean rings is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LinearOrder Î±] [inst_1 : LinearOrder Î²] [inst_2 : Encodable Î±]\\n  [inst_3 : DenselyOrdered Î±] [inst_4 : NoMinOrder Î±] [inst_5 : NoMaxOrder Î±] [inst_6 : Nonempty Î±]\\n  [inst_7 : Encodable Î²] [inst_8 : DenselyOrdered Î²] [inst_9 : NoMinOrder Î²] [inst_10 : NoMaxOrder Î²]\\n  [inst_11 : Nonempty Î²], Nonempty (Î± â‰ƒo Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two countable dense, nonempty linear orders without endpoints are order isomorphic. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A â‰ƒ+* B â†’ NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B}\\n  (f : CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y),\\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X â†’ X = Y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\\nthe arrows. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : DivisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤),\\n  â†‘f (g ^ n) = â†‘f g ^ n\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve integer power. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G â†’* H),\\n  OpenEmbedding â†‘f â†’ NonarchimedeanGroup H\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"}]\n",
    "prompt_cons": "/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G Ã— K) :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f) :=\n\n/-- The cartesian product of two nonarchimedean rings is nonarchimedean. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R Ã— S) :=\n\n/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LinearOrder Î±] [inst_1 : LinearOrder Î²] [inst_2 : Encodable Î±]\n  [inst_3 : DenselyOrdered Î±] [inst_4 : NoMinOrder Î±] [inst_5 : NoMaxOrder Î±] [inst_6 : Nonempty Î±]\n  [inst_7 : Encodable Î²] [inst_8 : DenselyOrdered Î²] [inst_9 : NoMinOrder Î²] [inst_10 : NoMaxOrder Î²]\n  [inst_11 : Nonempty Î²], Nonempty (Î± â‰ƒo Î²) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A â‰ƒ+* B â†’ NoZeroDivisors A :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X â†’ X = Y :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Group homomorphisms preserve integer power. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : DivisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤),\n  â†‘f (g ^ n) = â†‘f g ^ n :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G â†’* H),\n  OpenEmbedding â†‘f â†’ NonarchimedeanGroup H :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b :=\n\n/-- Prove that any two nonabelian groups of order 21 are isomorphic. -/\ntheorem",
    "choices": [
      "forall {G H : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Group H] [inst_3 : Fintype H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Â¬CommGroup G â†’ Â¬CommGroup H â†’ Nonempty (G â‰ƒ* H) ",
      "forall {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  âˆƒ (n : â„•), group.card G = 21 * n â†’ âˆƒ (m : â„•), group.card H = 21 * m â†’ Â¬comm_group G â†’ Â¬comm_group H â†’ Nonempty (G â‰ƒ* H) ",
      "forall (G : Type u_1) (H : Type u_2) [inst : Group G] [inst_1 : Fintype G] [inst_2 : Group H] [inst_3 : Fintype H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Â¬IsAbelian G â†’ Â¬IsAbelian H â†’ Nonempty (G â‰ƒ* H) ",
      "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  (âˆ€ a b : G, a * b â‰  b * a) â†’ (âˆ€ a b : H, a * b â‰  b * a) â†’ Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Nonempty (G â‰ƒ* H) ",
      "forall (G H : Type u_1) [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Nonabelian G â†’ Nonabelian H â†’ Nonempty (G â‰ƒ* H) ",
      "forall (G : Type u_1) (H : Type u_2) [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Group.orderOf G = 21 â†’ Group.nonabelian G â†’ Group.orderOf H = 21 â†’ Group.nonabelian H â†’ Nonempty (G â‰ƒ* H) ",
      "any_two_nonabelian_groups_order_21_isomorphic : âˆ€ (G H : Type*) [inst : Group G] [inst_1 : Group H] [Fintype G] [Fintype H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Â¬CommGroup G â†’ Â¬CommGroup H â†’ Nonempty (G â‰ƒ* H) ",
      "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Nontrivial G â†’ Nontrivial H â†’ Nonabelian G â†’ Nonabelian H â†’ G â‰ƒ* H ",
      "forall (G H : Type u_1) [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  (Fintype.card G = 21) â†’ (Fintype.card H = 21) â†’ Â¬IsCommGroup G â†’ Â¬IsCommGroup H â†’ Nonempty (G â‰ƒ* H) ",
      "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 â†’ Fintype.card H = 21 â†’ Nonabelian G â†’ Nonabelian H â†’ Nonempty (G â‰ƒ* H) "
    ]
  },
  {
    "docString": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n m : â„•}, n â‰  m â†’ IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {x : M} (m : â„•) {n : â„•}, x ^ n = 1 â†’ x ^ m = x ^ (m % n)\",\n  \"isProp\": true,\n  \"docString\": \"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f g : Equiv.Perm Î±} {x : Î±} [inst : DecidableEq Î±] [inst_1 : Fintype Î±],\\n  Equiv.Perm.IsCycle f â†’\\n    Equiv.Perm.IsCycle g â†’\\n      (âˆ€ (x : Î±), x âˆˆ Equiv.Perm.support f âˆ© Equiv.Perm.support g â†’ â†‘f x = â†‘g x) â†’\\n        â†‘f x = â†‘g x â†’ x âˆˆ Equiv.Perm.support f â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two cyclic permutations agree on all terms in their intersection,\\nand that intersection is not empty, then the two cyclic permutations must be equal. \"},\n {\"theorem\":\n  \"âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type v} [inst : Ring R] {L M N K : ModuleCat R} {f : L âŸ¶ M} {g : M âŸ¶ N}\\n  (w : CategoryTheory.CategoryStruct.comp f g = 0) {h k : homology f g w âŸ¶ K},\\n  (âˆ€ (x : { x // x âˆˆ LinearMap.ker g }),\\n      â†‘h (â†‘(CategoryTheory.Limits.cokernel.Ï€ (imageToKernel f g w)) (â†‘ModuleCat.toKernelSubobject x)) =\\n        â†‘k (â†‘(CategoryTheory.Limits.cokernel.Ï€ (imageToKernel f g w)) (â†‘ModuleCat.toKernelSubobject x))) â†’\\n    h = k\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove that two maps out of a homology group are equal,\\nit suffices to check they are equal on the images of cycles.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w * y) (x * z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"}]\n",
    "prompt_cons": "/-- If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. -/\ntheorem âˆ€ {n m : â„•}, n â‰  m â†’ IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {x : M} (m : â„•) {n : â„•}, x ^ n = 1 â†’ x ^ m = x ^ (m % n) :=\n\n/-- If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. -/\ntheorem âˆ€ {Î± : Type u_1} {f g : Equiv.Perm Î±} {x : Î±} [inst : DecidableEq Î±] [inst_1 : Fintype Î±],\n  Equiv.Perm.IsCycle f â†’\n    Equiv.Perm.IsCycle g â†’\n      (âˆ€ (x : Î±), x âˆˆ Equiv.Perm.support f âˆ© Equiv.Perm.support g â†’ â†‘f x = â†‘g x) â†’\n        â†‘f x = â†‘g x â†’ x âˆˆ Equiv.Perm.support f â†’ f = g :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C :=\n\n/-- To prove that two maps out of a homology group are equal,\nit suffices to check they are equal on the images of cycles. -/\ntheorem âˆ€ {R : Type v} [inst : Ring R] {L M N K : ModuleCat R} {f : L âŸ¶ M} {g : M âŸ¶ N}\n  (w : CategoryTheory.CategoryStruct.comp f g = 0) {h k : homology f g w âŸ¶ K},\n  (âˆ€ (x : { x // x âˆˆ LinearMap.ker g }),\n      â†‘h (â†‘(CategoryTheory.Limits.cokernel.Ï€ (imageToKernel f g w)) (â†‘ModuleCat.toKernelSubobject x)) =\n        â†‘k (â†‘(CategoryTheory.Limits.cokernel.Ï€ (imageToKernel f g w)) (â†‘ModuleCat.toKernelSubobject x))) â†’\n    h = k :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- Multiplicative congruence relations preserve multiplication. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w * y) (x * z) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime. -/\ntheorem",
    "choices": [
      "âˆ€ {Gâ‚ : Type u_1} {Gâ‚‚ : Type u_2} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Fintype Gâ‚] [inst_3 : Fintype Gâ‚‚],\n  IsCyclic Gâ‚ â†’ IsCyclic Gâ‚‚ â†’ IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” Nat.Coprime (Fintype.card Gâ‚) (Fintype.card Gâ‚‚) ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚] [inst_1 : Fintype Gâ‚] [inst_2 : Fintype Gâ‚‚] {m n : â„•},\n  Fintype.card Gâ‚ = m â†’ Fintype.card Gâ‚‚ = n â†’ IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” IsCoprime m n ",
      "âˆ€ {G1 : Type u_1} {G2 : Type u_2} [inst_1 : Group G1] [inst_2 : Group G2] [inst_3 : Fintype G1] [inst_4 : Fintype G2],\n  IsCyclic G1 â†’ IsCyclic G2 â†’ IsCyclic (G1 Ã— G2) â†” Nat.Coprime (Fintype.card G1) (Fintype.card G2) ",
      "forall {G1 G2 : Type u} [inst1 : Group G1] [inst2 : Group G2] [inst3 : IsCyclic G1] [inst4 : IsCyclic G2] [inst5 : Fintype G1] [inst6 : Fintype G2],\n  IsCyclic (G1 Ã— G2) â†” Nat.Coprime (Fintype.card G1) (Fintype.card G2) ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚]\n  [inst_2 : Fintype Gâ‚] [inst_3 : Fintype Gâ‚‚] [inst_4 : IsCyclic Gâ‚] [inst_5 : IsCyclic Gâ‚‚],\n  IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” Nat.Coprime (Fintype.card Gâ‚) (Fintype.card Gâ‚‚) ",
      "âˆ€ {Gâ‚ : Type uâ‚} [instâ‚ : Group Gâ‚] [instâ‚â‚ : IsCyclic Gâ‚] [instâ‚â‚‚ : Fintype Gâ‚] {m : â„•} (hm : Fintype.card Gâ‚ = m)\n  {Gâ‚‚ : Type uâ‚‚} [instâ‚‚ : Group Gâ‚‚] [instâ‚‚â‚ : IsCyclic Gâ‚‚] [instâ‚‚â‚‚ : Fintype Gâ‚‚] {n : â„•} (hn : Fintype.card Gâ‚‚ = n),\n  IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” Nat.Coprime m n ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚] [inst_2 : Group Gâ‚‚] [inst_3 : IsCyclic Gâ‚] [inst_4 : IsCyclic Gâ‚‚] {m n : â„•},\n  Fintype.card Gâ‚ = m â†’ Fintype.card Gâ‚‚ = n â†’ (IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” Int.gcd m n = 1) ",
      "âˆ€ {Gâ‚ : Type u_1} {Gâ‚‚ : Type u_2} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Fintype Gâ‚] [inst_3 : Fintype Gâ‚‚],\n  IsCyclic Gâ‚ â†’ IsCyclic Gâ‚‚ â†’\n  (âˆ€ {m n : â„•}, Fintype.card Gâ‚ = m â†’ Fintype.card Gâ‚‚ = n â†’ IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” Nat.Coprime m n) ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u} [_inst_1Gâ‚ : Group Gâ‚] [_inst_2Gâ‚‚ : Group Gâ‚‚] [Fintype Gâ‚] [Fintype Gâ‚‚] [_inst_3CyclicGâ‚ : IsCyclic Gâ‚] [_inst_4CyclicGâ‚‚ : IsCyclic Gâ‚‚],\n  IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” IsCoprime (Fintype.card Gâ‚) (Fintype.card Gâ‚‚) ",
      "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Fintype Gâ‚] [inst_3 : Fintype Gâ‚‚] {m n : â„•},\n  IsCyclic Gâ‚ â†’ Fintype.card Gâ‚ = m â†’ IsCyclic Gâ‚‚ â†’ Fintype.card Gâ‚‚ = n â†’\n    IsCyclic (Gâ‚ Ã— Gâ‚‚) â†” Nat.gcd m n = 1 "
    ]
  },
  {
    "docString": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) âŠ” N = G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) âŠ” N = G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤ :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A p-group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)]\n  (P : Sylow p G) [inst_2 : Subgroup.Normal â†‘P], âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  Subgroup.Normal â†‘P â†’ âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  P.normal â†’ âˆ€ Q : Sylow p G, Q = P ",
      "forall {G : Type u_1} [inst : Group G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G) [inst_1 : Subgroup.Normal (â†‘P)],\n  âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [_hp : Fact (Nat.Prime p)] {P : Sylow p G},\n  Subgroup.Normal (â†‘P) â†’ âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {G : Type u_1} [inst : Group G] (p : â„•) [hp : Fact (Nat.Prime p)] {P : Sylow p G} [inst_1 : Subgroup.Normal â†‘P],\n  âˆ€ Q : Sylow p G, Q = P ",
      "forall {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  Subgroup.Normal â†‘P â†’ âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {P : Sylow p G} [_inst_2 : Subgroup.Normal â†‘P],\n  âˆ€ (Q : Sylow p G), Q = P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] {P : Sylow p G} [inst_2 : Subgroup.Normal (â†‘P)],\n  âˆ€ Q : Sylow p G, Q = P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  âˆ€ (P : Sylow p G) (hPN : âˆ€ (Q : Sylow p G), P = Q âˆ¨ P.1 * Q.1 âŠ† G.carrier â†’ P = Q), P.normal â†’ âˆ€ (Q : Sylow p G), P = Q "
    ]
  },
  {
    "docString": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x â‰  0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) âŠ” N = G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `n * x = 0`, but `n/p * x â‰  0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) âŠ” N = G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤ :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ n = Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ n â†’ Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n  âˆ€ {H : Subgroup G}, Fintype.card {x // x âˆˆ H} = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n ->\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ (n - 1) â†’ Subgroup.Normal H "
    ]
  },
  {
    "docString": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the quaternions, as a set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a set. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the quaternions, as a type. \"},\n {\"theorem\":\n  \"âˆ€ (q : Quaternion â„), q.re = 0 â†’ exp â„ q = â†‘(Real.cos â€–qâ€–) + (Real.sin â€–qâ€– / â€–qâ€–) â€¢ q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closed form for the quaternion exponential on imaginary quaternions. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"âˆ€ (z : â„‚),\\n  Filter.Tendsto (fun n => â†‘Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (â†‘Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : AddCommGroup M] [inst_1 : Module â„‚ M] [inst_2 : FiniteDimensional â„‚ M]\\n  (Qâ‚ Qâ‚‚ : QuadraticForm â„‚ M),\\n  BilinForm.Nondegenerate (â†‘QuadraticForm.associated Qâ‚) â†’\\n    BilinForm.Nondegenerate (â†‘QuadraticForm.associated Qâ‚‚) â†’ QuadraticForm.Equivalent Qâ‚ Qâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"All nondegenerate quadratic forms on the complex numbers are equivalent. \"},\n {\"theorem\":\n  \"âˆ€ (q : Quaternion â„),\\n  exp â„ q =\\n    exp â„ q.re â€¢ (â†‘(Real.cos â€–Quaternion.im qâ€–) + (Real.sin â€–Quaternion.im qâ€– / â€–Quaternion.im qâ€–) â€¢ Quaternion.im q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closed form for the quaternion exponential on arbitrary quaternions. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Algebraically closed fields are infinite since `Xâ¿âºÂ¹ - 1` is separable when `#K = n` \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, Odd a â†’ Odd b â†’ jacobiSym (â†‘a) b = (-1) ^ (a / 2 * (b / 2)) * jacobiSym (â†‘b) a\",\n  \"isProp\": true,\n  \"docString\": \"The Law of Quadratic Reciprocity for the Jacobi symbol \"},\n {\"theorem\":\n  \"âˆ€ {P : EReal â†’ EReal â†’ Prop},\\n  P âŠ¤ âŠ¤ â†’\\n    (âˆ€ (x : â„), 0 < x â†’ P âŠ¤ â†‘x) â†’\\n      P âŠ¤ 0 â†’\\n        (âˆ€ (x : â„), x < 0 â†’ P âŠ¤ â†‘x) â†’\\n          P âŠ¤ âŠ¥ â†’\\n            (âˆ€ (x : â„), 0 < x â†’ P â†‘x âŠ¤) â†’\\n              (âˆ€ (x : â„), 0 < x â†’ P â†‘x âŠ¥) â†’\\n                P 0 âŠ¤ â†’\\n                  (âˆ€ (x y : â„), P â†‘x â†‘y) â†’\\n                    P 0 âŠ¥ â†’\\n                      (âˆ€ (x : â„), x < 0 â†’ P â†‘x âŠ¤) â†’\\n                        (âˆ€ (x : â„), x < 0 â†’ P â†‘x âŠ¥) â†’\\n                          P âŠ¥ âŠ¤ â†’\\n                            (âˆ€ (x : â„), 0 < x â†’ P âŠ¥ â†‘x) â†’\\n                              P âŠ¥ 0 â†’ (âˆ€ (x : â„), x < 0 â†’ P âŠ¥ â†‘x) â†’ P âŠ¥ âŠ¥ â†’ âˆ€ (x y : EReal), P x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Induct on two ereals by performing case splits on the sign of one whenever the other is\\ninfinite. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk (QuaternionAlgebra R câ‚ câ‚‚) = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a type. \"},\n {\"theorem\": \"Cardinal.mk â†‘Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"}]\n",
    "prompt_cons": "/-- The cardinality of the quaternions, as a set. -/\ntheorem âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of the quaternions, as a type. -/\ntheorem âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4 :=\n\n/-- The closed form for the quaternion exponential on imaginary quaternions. -/\ntheorem âˆ€ (q : Quaternion â„), q.re = 0 â†’ exp â„ q = â†‘(Real.cos â€–qâ€–) + (Real.sin â€–qâ€– / â€–qâ€–) â€¢ q :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem âˆ€ (z : â„‚),\n  Filter.Tendsto (fun n => â†‘Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (â†‘Real.pi * z))) :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem âˆ€ (x : â„),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (â†‘j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- All nondegenerate quadratic forms on the complex numbers are equivalent. -/\ntheorem âˆ€ {M : Type u_1} [inst : AddCommGroup M] [inst_1 : Module â„‚ M] [inst_2 : FiniteDimensional â„‚ M]\n  (Qâ‚ Qâ‚‚ : QuadraticForm â„‚ M),\n  BilinForm.Nondegenerate (â†‘QuadraticForm.associated Qâ‚) â†’\n    BilinForm.Nondegenerate (â†‘QuadraticForm.associated Qâ‚‚) â†’ QuadraticForm.Equivalent Qâ‚ Qâ‚‚ :=\n\n/-- The closed form for the quaternion exponential on arbitrary quaternions. -/\ntheorem âˆ€ (q : Quaternion â„),\n  exp â„ q =\n    exp â„ q.re â€¢ (â†‘(Real.cos â€–Quaternion.im qâ€–) + (Real.sin â€–Quaternion.im qâ€– / â€–Quaternion.im qâ€–) â€¢ Quaternion.im q) :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Algebraically closed fields are infinite since `Xâ¿âºÂ¹ - 1` is separable when `#K = n` -/\ntheorem âˆ€ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol -/\ntheorem âˆ€ {a b : â„•}, Odd a â†’ Odd b â†’ jacobiSym (â†‘a) b = (-1) ^ (a / 2 * (b / 2)) * jacobiSym (â†‘b) a :=\n\n/-- Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. -/\ntheorem âˆ€ {P : EReal â†’ EReal â†’ Prop},\n  P âŠ¤ âŠ¤ â†’\n    (âˆ€ (x : â„), 0 < x â†’ P âŠ¤ â†‘x) â†’\n      P âŠ¤ 0 â†’\n        (âˆ€ (x : â„), x < 0 â†’ P âŠ¤ â†‘x) â†’\n          P âŠ¤ âŠ¥ â†’\n            (âˆ€ (x : â„), 0 < x â†’ P â†‘x âŠ¤) â†’\n              (âˆ€ (x : â„), 0 < x â†’ P â†‘x âŠ¥) â†’\n                P 0 âŠ¤ â†’\n                  (âˆ€ (x y : â„), P â†‘x â†‘y) â†’\n                    P 0 âŠ¥ â†’\n                      (âˆ€ (x : â„), x < 0 â†’ P â†‘x âŠ¤) â†’\n                        (âˆ€ (x : â„), x < 0 â†’ P â†‘x âŠ¥) â†’\n                          P âŠ¥ âŠ¤ â†’\n                            (âˆ€ (x : â„), 0 < x â†’ P âŠ¥ â†‘x) â†’\n                              P âŠ¥ 0 â†’ (âˆ€ (x : â„), x < 0 â†’ P âŠ¥ â†‘x) â†’ P âŠ¥ âŠ¥ â†’ âˆ€ (x y : EReal), P x y :=\n\n/-- The cardinality of a quaternion algebra, as a type. -/\ntheorem âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk (QuaternionAlgebra R câ‚ câ‚‚) = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk â†‘Set.univ = Cardinal.continuum :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) } :=\n\n/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions. -/\ntheorem",
    "choices": [
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R],\n  Infinite {x : R Ã— R Ã— R Ã— R | x.1 ^ 2 + x.2 ^ 2 + x.3 ^ 2 + x.4 ^ 2 = -1} ",
      "âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : Algebra R â„[R,câ‚,câ‚‚]],\n  âˆƒ (x : â„[R,câ‚,câ‚‚]), x^2 = -1 âˆ§ âˆ€ (y : â„[R,câ‚,câ‚‚]), y^2 = -1 â†’ âˆƒ (n : â„¤), x^n = y ",
      "âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : StarRing R],\n  (âˆƒ x : Quaternion R, x * x = -1) â†’ Infinite (Quaternion R) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : CharZero R] (a : R),\n  âˆƒ (n : â„•), Â¬Finset.card (Set.toFinset {x | x ^ 2 = a â€¢ 1}) < n ",
      "âˆ€ (R : Type u_1) [inst : Ring R], (âˆƒ x : Quaternion R, x â‰  0 âˆ§ x * x = -1) â†’ Infinite (Quaternion R) ",
      "âˆ€ (H : Type u_1) [inst : One H] [inst_1 : Neg H], Infinite {x : H | x ^ 2 = -1} ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R], âˆƒ (f : â„• â†’ Quaternion R), Function.Injective f âˆ§ âˆ€ (n : â„•), f n ^ 2 = -1 ",
      "âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : CharP R 0] [inst_2 : Nontrivial R],\n  Infinite {x : Quaternion R | x ^ 2 = -1} ",
      "âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : Neg R], Infinite {x : R | x ^ 2 = -1} ",
      "âˆ€ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : AddCommGroup R] [inst_3 : DivInvMonoid R],\n  Infinite {x : Quaternion R | x ^ 2 = -1} "
    ]
  },
  {
    "docString": "Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R], Â¬IsField (Polynomial R)\",\n  \"isProp\": true,\n  \"docString\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S),\\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The definition of `cyclotomic n R` commutes with any ring homomorphism. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Monoid R] (a : RË£), IsRegular â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"If `R` is a monoid, an element in `RË£` is regular. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {Ï‡ : MulChar R R'}, MulChar.IsQuadratic Ï‡ â†’ âˆ€ (f : R' â†’+* R''), MulChar.IsQuadratic (MulChar.ringHomComp Ï‡ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition with a ring homomorphism preserves the property of being a quadratic character. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Mul R] {a : R}, IsRightRegular a â†” IsSMulRegular R (MulOpposite.op a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right-regular multiplication on `R` is equivalent to `Ráµáµ’áµ–`-regularity of `R` itself. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type wâ‚) [inst : CommRing R], Algebra.FinitePresentation R (Polynomial R)\",\n  \"isProp\": true,\n  \"docString\": \"`R[X]` is finitely presented as `R`-algebra. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {x y : R},\\n  Commute x y â†’\\n    âˆ€ (n : â„•), (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * â†‘(Nat.choose n m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of the **binomial theorem** for commuting elements in noncommutative semirings. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right multiplication in a ring is an additive monoid morphism. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"}]\n",
    "prompt_cons": "/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- `R[X]` is never a field for any ring `R`. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R], Â¬IsField (Polynomial R) :=\n\n/-- The definition of `cyclotomic n R` commutes with any ring homomorphism. -/\ntheorem âˆ€ (n : â„•) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S),\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- If `R` is a monoid, an element in `RË£` is regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Monoid R] (a : RË£), IsRegular â†‘a :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {Ï‡ : MulChar R R'}, MulChar.IsQuadratic Ï‡ â†’ âˆ€ (f : R' â†’+* R''), MulChar.IsQuadratic (MulChar.ringHomComp Ï‡ f) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- Right-regular multiplication on `R` is equivalent to `Ráµáµ’áµ–`-regularity of `R` itself. -/\ntheorem âˆ€ {R : Type u_1} [inst : Mul R] {a : R}, IsRightRegular a â†” IsSMulRegular R (MulOpposite.op a) :=\n\n/-- `R[X]` is finitely presented as `R`-algebra. -/\ntheorem âˆ€ (R : Type wâ‚) [inst : CommRing R], Algebra.FinitePresentation R (Polynomial R) :=\n\n/-- A version of the **binomial theorem** for commuting elements in noncommutative semirings. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {x y : R},\n  Commute x y â†’\n    âˆ€ (n : â„•), (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * â†‘(Nat.choose n m) :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : Ring R], (âˆ€ a : R, a ^ 3 = a) â†’ IsCommutative R ",
      "âˆ€ {R : Type u_1} [inst : Ring R], (âˆ€ x : R, x * x * x = x) â†’ âˆ€ (x y : R), x * y = y * x ",
      "âˆ€ {R : Type u} [inst : Ring R], (âˆ€ x : R, x ^ 3 = x) â†’ âˆ€ (x y : R), x * y = y * x ",
      "âˆ€ {R : Type u} [inst : Ring R], (âˆ€ x : R, x ^ 3 = x) â†’ âˆ€ x y : R, x * y = y * x ",
      "âˆ€ {R : Type u_1} [inst : Ring R] (x : R) (hx : x^3 = x), âˆ€ (y : R) (hy : y^3 = y), x * y = y * x ",
      "âˆ€ {R : Type u_1} [inst : Ring R], (âˆ€ x : R, x * x * x = x) â†’ CommRing R ",
      "âˆ€ {R : Type u} [inst : NonAssocSemiring R] (h : âˆ€ x : R, x ^ 3 = x), IsCommutative R Mul ",
      "âˆ€ {R : Type u_1} [inst : Ring R], (âˆ€ x : R, x ^ 3 = x) â†’ IsCommutative R Add ",
      "âˆ€ {R : Type u_1} [inst : Mul R] [inst_1 : Add R], (âˆ€ x : R, x * x * x = x) â†’ AddCommSemigroup.IsCommutative R ",
      "âˆ€ {R : Type u_1} [inst : Ring R], (âˆ€ x : R, x ^ 3 = x) â†’ IsCommutative R (*) "
    ]
  },
  {
    "docString": "Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors b â†’ a â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, Nat.coprime a b â†’ p âˆˆ Nat.factors a â†’ â†‘(Nat.factorization (a * b)) p = â†‘(Nat.factorization a) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\\nfor any `b` coprime to `a`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p â†’ (p âˆ£ List.prod L â†” âˆƒ a, a âˆˆ L âˆ§ p âˆ£ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L` \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, Nat.coprime a b â†’ p âˆˆ Nat.factors b â†’ â†‘(Nat.factorization (a * b)) p = â†‘(Nat.factorization b) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then the power of `p` in `b` is the same that in `a * b`,\\nfor any `a` coprime to `b`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ (n p : â„•), Finset.card (Finset.filter (fun e => p âˆ£ e + 1) (Finset.range n)) = n / p\",\n  \"isProp\": true,\n  \"docString\": \"Exactly `n / p` naturals in `[1, n]` are multiples of `p`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (z : â„¤), padicNorm p â†‘z â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"The `p`-adic norm of an integer is at most `1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors b â†’ a â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\nfor any `b` coprime to `a`. -/\ntheorem âˆ€ {p a b : â„•}, Nat.coprime a b â†’ p âˆˆ Nat.factors a â†’ â†‘(Nat.factorization (a * b)) p = â†‘(Nat.factorization a) p :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L` -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p â†’ (p âˆ£ List.prod L â†” âˆƒ a, a âˆˆ L âˆ§ p âˆ£ a) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `p` is a prime factor of `b` then the power of `p` in `b` is the same that in `a * b`,\nfor any `a` coprime to `b`. -/\ntheorem âˆ€ {p a b : â„•}, Nat.coprime a b â†’ p âˆˆ Nat.factors b â†’ â†‘(Nat.factorization (a * b)) p = â†‘(Nat.factorization b) p :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1 :=\n\n/-- Exactly `n / p` naturals in `[1, n]` are multiples of `p`. -/\ntheorem âˆ€ (n p : â„•), Finset.card (Finset.filter (fun e => p âˆ£ e + 1) (Finset.range n)) = n / p :=\n\n/-- The `p`-adic norm of an integer is at most `1`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (z : â„¤), padicNorm p â†‘z â‰¤ 1 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)], p % 2 = 1 â†’ p âˆ£ (Finset.sum (Finset.range p) (Î» i, if i = 0 then 0 else (i * (p - i)).nat_odd_div)) ",
      "forall_odd_prime_sum_reciprocal_divides_numerator :\n  âˆ€ {p : â„•},\n  Nat.Prime p â†’\n  p % 2 = 1 â†’\n  âˆƒ (a b : â„•), p * b = a * (p - 1) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)], p % 2 = 1 â†’ p âˆ£ ((Finset.sum (Finset.range p) (Î» x, x)) / 2) ",
      "forall {p : â„•} [hp : Fact (Nat.Prime p)], p % 2 = 1 â†’ p âˆ£ (Finset.sum (Finset.range (p - 1)) (fun x => (x + 1).nat_degree)) ",
      "âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)], p % 2 = 1 â†’ p âˆ£ (Finset.sum (Finset.range (p - 1)) (fun x => x * (p - 1 - x))) ",
      "âˆ€ (p : â„•) [Fact (Nat.Prime p)], p % 2 = 1 â†’ p âˆ£ Nat.sum (List.range 1 p) (fun i => i * (Nat.gcdA i p)) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ p âˆ£ Nat.succ (Finset.sum (Finset.range (p - 1)) (fun i => i + 1)) ",
      "âˆ€ {p : â„•} (h_odd : p % 2 = 1) [inst : Fact (Nat.Prime p)], âˆƒ (a b : â„•), a % p = 0 âˆ§ b â‰  0 âˆ§ (Finset.sum (Finset.range (p - 1)) (Î» i, 1 / (i + 1))) = a / b ",
      "forall_odd_prime_p_divides_sum_of_reciprocals : âˆ€ {p : â„•}, Nat.Prime p â†’ p âˆ£ (((Finset.range (p - 1)).sum (Î» x, 1 / â†‘x)) : â„š).num ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ p âˆ£ (Finset.sum (Finset.range p) (Î» i, if i = 0 then 0 else (i * (p - i)).nat_abs.gcd p)) "
    ]
  },
  {
    "docString": "Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : Semiring A] [inst_1 : Algebra â„ A] â¦ƒf g : â„‚ â†’â‚[â„] Aâ¦„, â†‘f Complex.I = â†‘g Complex.I â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two `â„`-algebra homomorphisms from `â„‚` are equal if they agree on `Complex.I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : Ring S]\\n  [inst_3 : IsDomain S] [inst_4 : Algebra R S] {n : Type u_3} {m : Type u_4} [inst_5 : Fintype n] [inst_6 : Fintype m],\\n  Basis n R S â†’ âˆ€ {I : Ideal S}, I â‰  âŠ¥ â†’ Basis m R { x // x âˆˆ I } â†’ Fintype.card m = Fintype.card n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` a module-finite free `R`-algebra, then the `R`-rank of a nonzero `R`-free\\nideal `I` of `S` is the same as the rank of `S`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` has characteristic `0`, then so does `FractionRing R`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R]\\n  {S : Type u_3} [inst_3 : CommRing S] [inst_4 : IsDomain S] [inst_5 : Algebra R S] [inst_6 : Finite Î¹]\\n  (b : Basis Î¹ R S) (I : Ideal S) (hI : I â‰  âŠ¥) (i : Î¹),\\n  â†‘(â†‘(Ideal.selfBasis b I hI) i) = Ideal.smithCoeffs b I hI i â€¢ â†‘(Ideal.ringBasis b I hI) i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\\nmatrix.\\n\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R â†”\\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ Set.InjOn Int.cast {0, 1, -1}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\\nthat is nontrivial and of characteristic not `2`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"}]\n",
    "prompt_cons": "/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥ :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R â‰ƒ+* S), â†‘f 0 = 0 :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I :=\n\n/-- Two `â„`-algebra homomorphisms from `â„‚` are equal if they agree on `Complex.I`. -/\ntheorem âˆ€ {A : Type u_1} [inst : Semiring A] [inst_1 : Algebra â„ A] â¦ƒf g : â„‚ â†’â‚[â„] Aâ¦„, â†‘f Complex.I = â†‘g Complex.I â†’ f = g :=\n\n/-- If `S` a module-finite free `R`-algebra, then the `R`-rank of a nonzero `R`-free\nideal `I` of `S` is the same as the rank of `S`. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : Ring S]\n  [inst_3 : IsDomain S] [inst_4 : Algebra R S] {n : Type u_3} {m : Type u_4} [inst_5 : Fintype n] [inst_6 : Fintype m],\n  Basis n R S â†’ âˆ€ {I : Ideal S}, I â‰  âŠ¥ â†’ Basis m R { x // x âˆˆ I } â†’ Fintype.card m = Fintype.card n :=\n\n/-- If `R` has characteristic `0`, then so does `FractionRing R`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix. -/\ntheorem âˆ€ {Î¹ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R]\n  {S : Type u_3} [inst_3 : CommRing S] [inst_4 : IsDomain S] [inst_5 : Algebra R S] [inst_6 : Finite Î¹]\n  (b : Basis Î¹ R S) (I : Ideal S) (hI : I â‰  âŠ¥) (i : Î¹),\n  â†‘(â†‘(Ideal.selfBasis b I hI) i) = Ideal.smithCoeffs b I hI i â€¢ â†‘(Ideal.ringBasis b I hI) i :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R â†”\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\nthat is nontrivial and of characteristic not `2`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ Set.InjOn Int.cast {0, 1, -1} :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤ :=\n\n/-- Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$. -/\ntheorem",
    "choices": [
      "âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) â„)), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {Mâ‚‚ : Type u_1} [inst : Fintype Mâ‚‚] [inst_1 : DecidableEq Mâ‚‚] [inst_2 : Ring (Matrix Mâ‚‚ Mâ‚‚ â„)] (I : Ideal (Matrix Mâ‚‚ Mâ‚‚ â„)),\n  I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R],\n  (âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)), I = âŠ¥ âˆ¨ I = âŠ¤) â†”\n    âˆ€ (A : Matrix (Finâ‚“ 2) (Finâ‚“ 2) R),\n      A â‰  0 â†’ âˆƒ (c : R), âˆ€ (x : Finâ‚“ 2), âˆ€ (y : Finâ‚“ 2), c â€¢ A x y = 1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)),\n  Ideal.IsMaximal I â†” I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "forall {R : Type*} [CommRing R] (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "forall {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], (Matrix R 2 2).IsSimple ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : CharZero R] [inst_2 : Fintype (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)],\n  âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) â„)), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], CharZero R â†’ (2 : R) â‰  0 â†’\n  Ideal.IsJacobson R â†’ âˆ€ (I : Ideal (Matrix (Fin 2) (Fin 2) R)), I = âŠ¥ âˆ¨ I = âŠ¤ ",
      "âˆ€ {R : Type u_1} [inst : CommRing R], Matrix.det One.one = 1 â†’\n  (âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)), I â‰  âŠ¥ â†’ âˆ€ (A : Matrix (Finâ‚“ 2) (Finâ‚“ 2) R), A âˆˆ I â†’ Matrix.det A â‰  0) â†’\n    âˆ€ (I : Ideal (Matrix (Finâ‚“ 2) (Finâ‚“ 2) R)), I = âŠ¥ âˆ¨ I = âŠ¤ "
    ]
  },
  {
    "docString": "Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„š} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of `â„š[X]` by the ideal generated by an irreducible polynomial of `â„š[X]`\\nis a number field. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {Î¹ : Type u_1} {g : Î¹ â†’ Polynomial R} {s : Finset Î¹},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.Monic (g i)) â†’\\n    (Set.Pairwise â†‘s fun i j => IsCoprime (g i) (g j)) â†’\\n      âˆƒ q r,\\n        (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.degree (r i) < Polynomial.degree (g i)) âˆ§\\n          (â†‘f / Finset.prod s fun i => â†‘(g i)) = â†‘q + Finset.sum s fun i => â†‘(r i) / â†‘(g i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f âˆˆ R[X]. Let s be a finite index set.\\nThen, a fraction of the form f / âˆ (g i) can be rewritten as q + âˆ‘ (r i) / (g i), where\\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {K : Type v} {L : Type z} {p : R} [inst : CommRing R] [inst_1 : Field K] [inst_2 : Field L]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra R L] [inst_5 : Algebra R K] [inst_6 : IsScalarTower R K L]\\n  [inst_7 : IsSeparable K L] [inst_8 : IsDomain R] [inst_9 : IsFractionRing R K] [inst_10 : IsIntegrallyClosed R]\\n  {B : PowerBasis K L},\\n  Prime p â†’\\n    IsIntegral R B.gen â†’\\n      âˆ€ {z : L} {Q : Polynomial R},\\n        â†‘(Polynomial.aeval B.gen) Q = p â€¢ z â†’\\n          IsIntegral R z â†’ Polynomial.IsEisensteinAt (minpoly R B.gen) (Submodule.span R {p}) â†’ p âˆ£ Polynomial.coeff Q 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that\\n`aeval B.gen Q = p â€¢ z`, then `p âˆ£ Q.coeff 0`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- The quotient of `â„š[X]` by the ideal generated by an irreducible polynomial of `â„š[X]`\nis a number field. -/\ntheorem âˆ€ {f : Polynomial â„š} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f) :=\n\n/-- Let R be an integral domain and f âˆˆ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / âˆ (g i) can be rewritten as q + âˆ‘ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime. -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {Î¹ : Type u_1} {g : Î¹ â†’ Polynomial R} {s : Finset Î¹},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.Monic (g i)) â†’\n    (Set.Pairwise â†‘s fun i j => IsCoprime (g i) (g j)) â†’\n      âˆƒ q r,\n        (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.degree (r i) < Polynomial.degree (g i)) âˆ§\n          (â†‘f / Finset.prod s fun i => â†‘(g i)) = â†‘q + Finset.sum s fun i => â†‘(r i) / â†‘(g i) :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1 :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that\n`aeval B.gen Q = p â€¢ z`, then `p âˆ£ Q.coeff 0`. -/\ntheorem âˆ€ {R : Type u} {K : Type v} {L : Type z} {p : R} [inst : CommRing R] [inst_1 : Field K] [inst_2 : Field L]\n  [inst_3 : Algebra K L] [inst_4 : Algebra R L] [inst_5 : Algebra R K] [inst_6 : IsScalarTower R K L]\n  [inst_7 : IsSeparable K L] [inst_8 : IsDomain R] [inst_9 : IsFractionRing R K] [inst_10 : IsIntegrallyClosed R]\n  {B : PowerBasis K L},\n  Prime p â†’\n    IsIntegral R B.gen â†’\n      âˆ€ {z : L} {Q : Polynomial R},\n        â†‘(Polynomial.aeval B.gen) Q = p â€¢ z â†’\n          IsIntegral R z â†’ Polynomial.IsEisensteinAt (minpoly R B.gen) (Submodule.span R {p}) â†’ p âˆ£ Polynomial.coeff Q 0 :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {n : â„•} {q : Polynomial (Zmod p)}, Polynomial.degree q = â†‘n â†’ Irreducible q â†’ Fintype.card (Polynomial (Zmod p) â§¸ Ideal.span {q}) = p ^ n ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : CharP F p] {n : â„•} {q : Polynomial F},\n  Nat.Prime p â†’ Polynomial.degree q = n â†’ Irreducible q â†’ Fintype.card (F â§¸ Polynomial.quotientRing (Ideal.span {q})) = p ^ n ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {q : Polynomial (ZMod p)},\n  Irreducible q â†’ Fintype.card (Polynomial (ZMod p) â§¸ Ideal.span {q}) = p ^ Polynomial.natDegree q ",
      "âˆ€ {F : Type u} [inst : Field F] [_inst_1 : Fintype F] {p : â„•} [Fact (Nat.Prime p)] {n : â„•} (qn : F â†’+* Polynomial F),\n  Irreducible (Polynomial.map qn (Polynomial.X ^ n)) â†’ Fintype.card (Polynomial F â§¸ Ideal.span (singleton (Polynomial.map qn (Polynomial.X ^ n)))) = p ^ n ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p : â„•} [hp : Fact (Nat.Prime p)] {q : Polynomial F},\n  Polynomial.degree q = p ^ Nat.findGreatest (Î» n : â„•, Polynomial.degree q = p ^ n) (Polynomial.natDegree q) â†’\n    Irreducible q â†’ Fintype.card (Polynomial F â§¸ Ideal.span (singleton q)) = p ^ Polynomial.natDegree q ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {n : â„•} {q : Polynomial (Zmod p)},\n  Irreducible q â†’ Polynomial.degree q = n â†’\n    Fintype.card (Polynomial (Zmod p) â§¸ Ideal.span {q}) = p ^ n ",
      "âˆ€ {F : Type u_1} {q : Polynomial F} [inst : Field F] [inst_1 : Fact (Nat.Prime (Fintype.card F))],\n  Irreducible q â†’ Fintype.card (Polynomial F â§¸ Ideal.span {q}) = Fintype.card F ^ Polynomial.natDegree q ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {q : Polynomial (ZMod p)},\n  Irreducible q â†’\n    âˆ€ {n : â„•}, Polynomial.degree q = n â†’\n      IsField (Polynomial (ZMod p) â§¸ Ideal.span {q}) âˆ§ Fintype.card (Polynomial (ZMod p) â§¸ Ideal.span {q}) = p ^ n ",
      "âˆ€ {p : â„•} {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : CharP F p] [Fact (Nat.Prime p)] {n : â„•} {q : Polynomial F},\n  Polynomial.degree q = n â†’ Irreducible q â†’ Fintype.card (Polynomial F â§¸ Ideal.span {q}) = p ^ n ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p : â„•} [hp : Fact (Nat.Prime p)] {q : Polynomial F},\n  Irreducible q â†’ Polynomial.degree q = n â†’ Fintype.card (Polynomial F â§¸ Ideal.span {q}) = p ^ n "
    ]
  },
  {
    "docString": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `cyclotomic p R = âˆ‘ i in range p, X ^ i`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\": \"âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\\n  p + q â‰  0 â†’\\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p + q` is at least the minimum of the multiplicities. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\": \"Summability of the `p`-series over `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {p n : â„•},\\n  Nat.Prime p â†’ Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p ^ k` is a prime power, then\\n`cyclotomic (p ^ (n + 1)) R = âˆ‘ i in range p, (X ^ (p ^ n)) ^ i`. \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, padicNorm p 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The `p`-adic norm of `1` is `1`. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- If `p` is prime, then `cyclotomic p R = âˆ‘ i in range p, X ^ i`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] (p : â„•) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\n  p + q â‰  0 â†’\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q) :=\n\n/-- Summability of the `p`-series over `â„¤`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = âˆ‘ i in range p, (X ^ (p ^ n)) ^ i`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {p n : â„•},\n  Nat.Prime p â†’ Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- The `p`-adic norm of `1` is `1`. -/\ntheorem âˆ€ {p : â„•}, padicNorm p 1 = 1 :=\n\n/-- If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)],\n  Irreducible (Finset.sum (Finset.range p) fun x => Polynomial.x^(x : â„•) + 1 : Polynomial â„š) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)],\n  Irreducible (Finset.sum (Finset.range p) (Î» i => Polynomial.x ^ i) : Polynomial â„š) ",
      "âˆ€ {p : â„•} [Fact (Nat.Prime p)],\n  Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} (hp : Nat.Prime p),\n  Irreducible (Polynomial.sum (Finset.range p) (Î» x, Polynomial.X ^ x) : Polynomial â„š) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.C (1 : â„š) * Polynomial.X ^ i) ",
      "âˆ€ {p : â„•}, Nat.Prime p â†’ Irreducible (Polynomial.sum (Finset.range p) (Î» i => Polynomial.X ^ i) : Polynomial â„š) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.x ^ i) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.C (1:â„š) * Polynomial.X ^ i) "
    ]
  },
  {
    "docString": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite â†‘S] [inst_6 : IsCyclotomicExtension S A B],\\n  Algebra.IsIntegral A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite cyclotomic extension of an integral noetherian domain is integral \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type wâ‚) [inst : CommRing R] (Î¹ : Type u_2) [inst_1 : Finite Î¹], Algebra.FinitePresentation R (MvPolynomial Î¹ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of polynomials in finitely many variables is finitely presented. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\\n  Ideal.IsPrime P â†’\\n    Â¬Polynomial.leadingCoeff f âˆˆ P â†’\\n      (âˆ€ (n : â„•), â†‘n < Polynomial.degree f â†’ Polynomial.coeff f n âˆˆ P) â†’\\n        0 < Polynomial.degree f â†’ Â¬Polynomial.coeff f 0 âˆˆ P ^ 2 â†’ Polynomial.IsPrimitive f â†’ Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\\nirreducible. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Algebraically closed fields are infinite since `Xâ¿âºÂ¹ - 1` is separable when `#K = n` \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : DivisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤),\\n  â†‘f (g ^ n) = â†‘f g ^ n\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve integer power. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] (q : â„•) [hF : ExpChar F q] (f : Polynomial F),\\n  Irreducible f â†’ Polynomial.HasSeparableContraction q f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every irreducible polynomial can be contracted to a separable polynomial.\\nhttps://stacks.math.columbia.edu/tag/09H0 \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I :=\n\n/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem âˆ€ (S : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite â†‘S] [inst_6 : IsCyclotomicExtension S A B],\n  Algebra.IsIntegral A B :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The ring of polynomials in finitely many variables is finitely presented. -/\ntheorem âˆ€ (R : Type wâ‚) [inst : CommRing R] (Î¹ : Type u_2) [inst_1 : Finite Î¹], Algebra.FinitePresentation R (MvPolynomial Î¹ R) :=\n\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\n  Ideal.IsPrime P â†’\n    Â¬Polynomial.leadingCoeff f âˆˆ P â†’\n      (âˆ€ (n : â„•), â†‘n < Polynomial.degree f â†’ Polynomial.coeff f n âˆˆ P) â†’\n        0 < Polynomial.degree f â†’ Â¬Polynomial.coeff f 0 âˆˆ P ^ 2 â†’ Polynomial.IsPrimitive f â†’ Irreducible f :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Algebraically closed fields are infinite since `Xâ¿âºÂ¹ - 1` is separable when `#K = n` -/\ntheorem âˆ€ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- Group homomorphisms preserve integer power. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : DivisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤),\n  â†‘f (g ^ n) = â†‘f g ^ n :=\n\n/-- Every irreducible polynomial can be contracted to a separable polynomial.\nhttps://stacks.math.columbia.edu/tag/09H0 -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] (q : â„•) [hF : ExpChar F q] (f : Polynomial F),\n  Irreducible f â†’ Polynomial.HasSeparableContraction q f :=\n\n/-- Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ (a : â„¤), Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a) ",
      "âˆ€ {a : â„¤}, Irreducible (Polynomial.x ^ 7 + (15 : â„¤) * Polynomial.x ^ 2 - (30 : â„¤) * Polynomial.x + a) â†’ Infinite {a : â„¤} ",
      "âˆ€ {a : â„¤}, âˆƒ n : â„•, 0 < n âˆ§ Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + coe a + n) ",
      "âˆ€ a : â„¤, Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a) â†’ Infinite {a : â„¤ // Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a)} ",
      "âˆ€ (a : â„¤), Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + coeFn Polynomial.C a) ",
      "âˆ€ {a : â„¤}, âˆƒ c, âˆ€ (i : â„•), a + c * â†‘i âˆˆ {a : â„¤ | Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a)} ",
      "âˆ€ a : â„¤, Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a) ",
      "âˆ€ a : â„¤, Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a) ",
      "âˆ€ a : â„¤, Irreducible (Polynomial.x ^ 7 + (15 : â„š) * Polynomial.x ^ 2 - (30 : â„š) * Polynomial.x + â†‘a) ",
      "âˆ€ a : â„¤, Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a) "
    ]
  },
  {
    "docString": "Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    â†‘(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\\n    âˆ€ (f : V'' â†’â‚—[R] V),\\n      Function.Injective â†‘f â†’\\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\\n * the function `f' : V'' â†’ V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u) [inst : NontriviallyNormedField ğ•œ] (E : Type v) [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ] [inst : FiniteDimensional ğ•œ E], ProperSpace E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any finite-dimensional vector space over a proper field is proper.\\nWe do not register this as an instance to avoid an instance loop when trying to prove the\\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\\nexplicitly when needed. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\\n  [inst : T2Space Î±], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible Tâ‚‚ space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (p : Submodule K V), p < âŠ¤ â†’ âˆƒ f, f â‰  0 âˆ§ p â‰¤ LinearMap.ker f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p < âŠ¤` is a subspace of a vector space `V`, then there exists a nonzero linear map\\n`f : V â†’â‚—[K] K` such that `p â‰¤ ker f`. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), Â¬s1 â‰¤ s2 â†” âˆƒ p, p âˆˆ s1 âˆ§ Â¬p âˆˆ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is not less than or equal to another if and only if it has a point not in the\\nsecond subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K { x // x âˆˆ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    â†‘(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\n * the function `f' : V'' â†’ V'` doesn't need to be injective -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\n    âˆ€ (f : V'' â†’â‚—[R] V),\n      Function.Injective â†‘f â†’\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b) :=\n\n/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem âˆ€ (ğ•œ : Type u) [inst : NontriviallyNormedField ğ•œ] (E : Type v) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : ProperSpace ğ•œ] [inst : FiniteDimensional ğ•œ E], ProperSpace E :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- There does not exist a nontrivial preirreducible Tâ‚‚ space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\n  [inst : T2Space Î±], False :=\n\n/-- If `p < âŠ¤` is a subspace of a vector space `V`, then there exists a nonzero linear map\n`f : V â†’â‚—[K] K` such that `p â‰¤ ker f`. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (p : Submodule K V), p < âŠ¤ â†’ âˆƒ f, f â‰  0 âˆ§ p â‰¤ LinearMap.ker f :=\n\n/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), Â¬s1 â‰¤ s2 â†” âˆƒ p, p âˆˆ s1 âˆ§ Â¬p âˆˆ s2 :=\n\n/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K { x // x âˆˆ s } = FiniteDimensional.finrank K V :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$. -/\ntheorem",
    "choices": [
      "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [Infinity K],\n  let s : Set (Submodule K V) ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Infinite F] [inst_1 : Field F] [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  Â¬âˆƒ (n : â„•) (f : Finâ‚“ n â†’ Submodule F V), Â¬âˆ€ (i : Finâ‚“ n), f i = âŠ¤ âˆ§ V = â‹ƒ (i : Finâ‚“ n), â†‘(f i) ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] {Î¹ : Type u_1}\n  [inst_3 : Infinite F] (s : Î¹ â†’ Submodule F V) [inst_4 : Fintype Î¹],\n  Â¬âˆ€ (x : V), âˆƒ (i : Î¹), x âˆˆ s i ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] {Î¹ : Type w}\n  [inst_3 : Infinite F] {S : Î¹ â†’ Submodule F V},\n    Set.Finite (Set.Range S) â†’ (â‹ƒ (i : Î¹), â†‘(S i)) â‰  Set.Univ ",
      "âˆ€ (F : Type u) {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V],\n  Infinite F â†’ âˆ€ (s : Set (Submodule F V)), Set.Finite s â†’ Â¬V = â‹ƒâ‚€ s ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [hF : Infinite F],\n  âˆ€ {Î¹ : Type u_1} [hÎ¹ : Nonempty Î¹] [hÎ¹fin : Fintype Î¹] (s : Î¹ â†’ Submodule F V), Â¬(âˆ€ (i : Î¹), s i < âŠ¤) â†’ V â‰  â‹ƒ (i : Î¹), â†‘(s i) ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  {Î¹ : Type w} {s : Î¹ â†’ Submodule F V}, (âˆ€ i, s i < âŠ¤) â†’ Nontrivial V â†’ Fintype Î¹ â†’ Â¬(â‹ƒ i, â†‘(s i) : Set V) = Set.Univ ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Infinite F] [inst_1 : Field F] [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  âˆ€ (s : Set (Submodule F V)), Set.Finite s â†’ (âˆ€ (x : Submodule F V), x âˆˆ s â†’ x < âŠ¤) â†’ Â¬Set.Unionâ‚“ s = Set.Univ ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] {Î¹ : Type u_1} [inst_3 : Fintype Î¹]\n  (S : Î¹ â†’ Submodule F V), (âˆ€ i, S i < âŠ¤) â†’ Â¬(â‹ƒ i, â†‘(S i)) = Set.Univ ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V], Infinite F â†’\n  âˆ€ {Î¹ : Type u_1} (t : Î¹ â†’ Submodule F V) [inst_3 : Finite Î¹], Â¬V = â‹ƒ (i : Î¹), â†‘(t i) "
    ]
  },
  {
    "docString": "Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)},\\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.castSucc i)) =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.succ i))\",\n  \"isProp\": true,\n  \"docString\": \"The special case of the first cosimplicial identity \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a set. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"LieGroup (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin 1))) { x // x âˆˆ circle }\",\n  \"isProp\": true,\n  \"docString\": \"The unit circle in `â„‚` is a Lie group. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"âˆ€ {n : Type v} {Î± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Î±] (A B : Matrix n n Î±),\\n  Matrix.adjugate (Matrix.mul A B) = Matrix.mul (Matrix.adjugate B) (Matrix.adjugate A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proof follows from \\\"The trace Cayley-Hamilton theorem\\\" by Darij Grinberg, Section 5.3\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P},\\n  2 â€¢ EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚„ = 2 â€¢ EuclideanGeometry.oangle pâ‚ pâ‚ƒ pâ‚„ â†’\\n    EuclideanGeometry.Cospherical {pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„} âˆ¨ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Converse of \\\"angles in same segment are equal\\\" and \\\"opposite angles of a cyclic quadrilateral\\nadd to Ï€\\\", for oriented angles mod Ï€, with a \\\"cospherical or collinear\\\" conclusion. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : Semiring A] [inst_1 : Algebra â„ A] â¦ƒf g : â„‚ â†’â‚[â„] Aâ¦„, â†‘f Complex.I = â†‘g Complex.I â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two `â„`-algebra homomorphisms from `â„‚` are equal if they agree on `Complex.I`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), â†‘f (r â€¢ a) = r â€¢ â†‘f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a â‹†-algebra equivalence commutes with the action of scalars. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {Ï‡ : MulChar R R'}, MulChar.IsQuadratic Ï‡ â†’ âˆ€ (f : R' â†’+* R''), MulChar.IsQuadratic (MulChar.ringHomComp Ï‡ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition with a ring homomorphism preserves the property of being a quadratic character. \"}]\n",
    "prompt_cons": "/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- The special case of the first cosimplicial identity -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)},\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.castSucc i)) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.Î´ X i)\n      (CategoryTheory.CosimplicialObject.Î´ X (Fin.succ i)) :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem âˆ€ {R : Type u_1} (câ‚ câ‚‚ : R), Cardinal.mk â†‘Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) } :=\n\n/-- The unit circle in `â„‚` is a Lie group. -/\ntheorem LieGroup (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin 1))) { x // x âˆˆ circle } :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y :=\n\n/-- Proof follows from \"The trace Cayley-Hamilton theorem\" by Darij Grinberg, Section 5.3 -/\ntheorem âˆ€ {n : Type v} {Î± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Î±] (A B : Matrix n n Î±),\n  Matrix.adjugate (Matrix.mul A B) = Matrix.mul (Matrix.adjugate B) (Matrix.adjugate A) :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C :=\n\n/-- The square of the symbol is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1 :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- Converse of \"angles in same segment are equal\" and \"opposite angles of a cyclic quadrilateral\nadd to Ï€\", for oriented angles mod Ï€, with a \"cospherical or collinear\" conclusion. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P},\n  2 â€¢ EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚„ = 2 â€¢ EuclideanGeometry.oangle pâ‚ pâ‚ƒ pâ‚„ â†’\n    EuclideanGeometry.Cospherical {pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„} âˆ¨ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„} :=\n\n/-- Two `â„`-algebra homomorphisms from `â„‚` are equal if they agree on `Complex.I`. -/\ntheorem âˆ€ {A : Type u_1} [inst : Semiring A] [inst_1 : Algebra â„ A] â¦ƒf g : â„‚ â†’â‚[â„] Aâ¦„, â†‘f Complex.I = â†‘g Complex.I â†’ f = g :=\n\n/-- By definition, a â‹†-algebra equivalence commutes with the action of scalars. -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), â†‘f (r â€¢ a) = r â€¢ â†‘f a :=\n\n/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {Ï‡ : MulChar R R'}, MulChar.IsQuadratic Ï‡ â†’ âˆ€ (f : R' â†’+* R''), MulChar.IsQuadratic (MulChar.ringHomComp Ï‡ f) :=\n\n/-- Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "IsAlgebraic â„š (Real.cos (Real.deg (1 : â„))) ",
      "âˆ€ (x : â„š) (n : â„•), Polynomial.eval x (Polynomial.chebyshevâ‚ â„š n) = Real.cos (n * Real.arccos x) â†’\n  IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "IsAlgebraic â„š (Real.cos (Real.deg (1 : â„))) ",
      "IsAlgebraic â„š (Real.cos (Ï€ / 180)) ",
      "CosOne.algebraic : Algebraic â„š (Real.cos (Real.deg 1)) ",
      "IsAlgebraic â„š (Real.cos (Real.deg (1:â„))) ",
      "IsAlgebraic â„š (Real.cos (Real.pi / 180)) ",
      "IsAlgebraic â„š (Real.cos (Real.pi / 180)) "
    ]
  },
  {
    "docString": "Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_1) (B : Type u_2) [inst : Field A] [inst_1 : Ring B] [inst_2 : Algebra A B] [inst_3 : Nontrivial B],\\n  minpoly A 1 = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The minimal polynomial of `1` is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] (q : â„•) [hF : ExpChar F q] (f : Polynomial F),\\n  Irreducible f â†’ Polynomial.HasSeparableContraction q f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every irreducible polynomial can be contracted to a separable polynomial.\\nhttps://stacks.math.columbia.edu/tag/09H0 \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The minimal polynomial of `1` is `X - 1`. -/\ntheorem âˆ€ (A : Type u_1) (B : Type u_2) [inst : Field A] [inst_1 : Ring B] [inst_2 : Algebra A B] [inst_3 : Nontrivial B],\n  minpoly A 1 = Polynomial.X - 1 :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- Every irreducible polynomial can be contracted to a separable polynomial.\nhttps://stacks.math.columbia.edu/tag/09H0 -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] (q : â„•) [hF : ExpChar F q] (f : Polynomial F),\n  Irreducible f â†’ Polynomial.HasSeparableContraction q f :=\n\n/-- Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_minus_3x_minus_1 : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.X ^ 3 - 3 * Polynomial.X - 1 : Polynomial â„š) ",
      "irreducible_x_pow_3_sub_3x_sub_1 : Irreducible (Polynomial.X ^ 3 - 3 * Polynomial.X - 1 : Polynomial â„š) ",
      "irreducible_x_pow_minus_3x_minus_1 : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "irreducible_x_pow_three_sub_three_x_sub_one : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "irr_x_pow_sub_C_monomial : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "irreducible_x_pow_3_minus_3_x_minus_1 : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.X ^ 3 - 3 * Polynomial.X - 1 : Polynomial â„š) ",
      "irreducible_x_pow_3_minus_3_x_minus_1 : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial â„š) "
    ]
  },
  {
    "docString": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\\n  AddSubgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b + a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive subgroup has index two if and only if there exists `a` such that\\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"}]\n",
    "prompt_cons": "/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H) :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n  AddSubgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b + a âˆˆ H) (b âˆˆ H) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : {x // x âˆˆ Subgroup.closure {a, b}}), x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : {x // x âˆˆ Subgroup.closure {a, b}}), x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : {x // x âˆˆ Subgroup.closure {a, b}}), x.val * y.val = y.val * x.val ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G} (H : Subgroup G),\n  H = Subgroup.closure {a, b} â†’ Commute a b â†’ âˆ€ (x y : G), x âˆˆ H â†’ y âˆˆ H â†’ Commute x y ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : {x // x âˆˆ Subgroup.closure {a, b}}), x * y = y * x ",
      "forall {G : Type u_1} [inst : Group G] {a b : G} (H : Subgroup G) (h_comm : a * b = b * a),\n  H = Subgroup.closure {a, b} â†’ âˆ€ (x y : G), x âˆˆ H â†’ y âˆˆ H â†’ x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : G), x âˆˆ Subgroup.closure {a, b} â†’ y âˆˆ Subgroup.closure {a, b} â†’ x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : G), x âˆˆ Subgroup.closure {a, b} â†’ y âˆˆ Subgroup.closure {a, b} â†’ x * y = y * x ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ IsComm (Subgroup.closure ({a, b} : Set G)) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, a * b = b * a â†’ âˆ€ (x y : G), x âˆˆ Subgroup.closure {a, b} â†’ y âˆˆ Subgroup.closure {a, b} â†’ x * y = y * x "
    ]
  },
  {
    "docString": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\\n  Group.nilpotencyClass G = Group.nilpotencyClass (G â§¸ Subgroup.center G) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a non-trivial group is one more than its quotient by the center \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is Tâ‚…. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {H : Type u_1} [inst_1 : Group H] (f : G â†’* H),\\n  MonoidHom.ker f â‰¤ Subgroup.center G â†’ Group.IsNilpotent H â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a nilpotent group is nilpotent if the kernel of the homomorphism is contained\\nin the center \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\n  Group.nilpotencyClass G = Group.nilpotencyClass (G â§¸ Subgroup.center G) + 1 :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚…. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], T5Space Î“â‚€ :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- The preimage of a nilpotent group is nilpotent if the kernel of the homomorphism is contained\nin the center -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {H : Type u_1} [inst_1 : Group H] (f : G â†’* H),\n  MonoidHom.ker f â‰¤ Subgroup.center G â†’ Group.IsNilpotent H â†’ Group.IsNilpotent G :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0 :=\n\n/-- Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (âˆƒ! a : G, orderOf a = 2) â†’ âˆ€ (x : G), orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x : G) (hx : orderOf x = 2),\n  (âˆ€ (y : G), y â‰  x â†’ orderOf y â‰  2) â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ! x, orderOf x = 2) â†’ âˆ€ (x : G), orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆƒ! (a : G), orderOf a = 2) â†’ âˆ€ a, orderOf a = 2 â†’ a âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2 â†’ âˆƒ! y, yÂ² = x) â†’ âˆ€ (x : G), orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], \n  (âˆƒ! (x : G), orderOf x = 2) â†’ âˆ€ (y : G), orderOf y = 2 â†’ y âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G},\n  (âˆ€ y, orderOf y = 2 â†’ y = x) â†’ orderOf x = 2 â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (âˆƒ a : G, orderOf a = 2 âˆ§ âˆ€ (x : G), orderOf x = 2 â†’ x = a) â†’ âˆ€ (a : G), orderOf a = 2 â†’ a âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x : G), (âˆ€ (y : G), orderOf y = 2 â†’ x = y) â†’ x âˆˆ Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆƒ! a : G, orderOf a = 2) â†’ âˆ€ a, orderOf a = 2 â†’ a âˆˆ Subgroup.center G "
    ]
  },
  {
    "docString": "Prove that a group of even order contains an element of order $2 .$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ (p' : â„•), lucasLehmerResidue (p' + 2) = 0 â†’ orderOf (LucasLehmer.Ï‰Unit (p' + 2)) = 2 ^ (p' + 2)\",\n  \"isProp\": true,\n  \"docString\": \"The order of `Ï‰` in the unit group is exactly `2^p`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Fintype F] [inst_1 : Field F],\\n  ringChar F â‰  2 â†’ 2 ^ (Fintype.card F / 2) = â†‘(â†‘ZMod.Ï‡â‚ˆ â†‘(Fintype.card F))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite field `F` of odd characteristic, we have `2^(#F/2) = Ï‡â‚ˆ#F` in `F`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {b : â„•}, Odd b â†’ jacobiSym 2 b = â†‘ZMod.Ï‡â‚ˆ â†‘b\",\n  \"isProp\": true,\n  \"docString\": \"If `b` is odd, then `J(2 | b)` is given by `Ï‡â‚ˆ b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n",
    "prompt_cons": "/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The order of `Ï‰` in the unit group is exactly `2^p`. -/\ntheorem âˆ€ (p' : â„•), lucasLehmerResidue (p' + 2) = 0 â†’ orderOf (LucasLehmer.Ï‰Unit (p' + 2)) = 2 ^ (p' + 2) :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 :=\n\n/-- For every finite field `F` of odd characteristic, we have `2^(#F/2) = Ï‡â‚ˆ#F` in `F`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Fintype F] [inst_1 : Field F],\n  ringChar F â‰  2 â†’ 2 ^ (Fintype.card F / 2) = â†‘(â†‘ZMod.Ï‡â‚ˆ â†‘(Fintype.card F)) :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- If `b` is odd, then `J(2 | b)` is given by `Ï‡â‚ˆ b`. -/\ntheorem âˆ€ {b : â„•}, Odd b â†’ jacobiSym 2 b = â†‘ZMod.Ï‡â‚ˆ â†‘b :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- Prove that a group of even order contains an element of order $2 .$ -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ x : G, orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], 2 âˆ£ Fintype.card G â†’ âˆƒ x : G, orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ x : G, orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ a : G, orderOf a = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ x : G, orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [_inst_1 : Group G] [_inst_2 : Fintype G], Even (Fintype.card G) â†’ âˆƒ x : G, orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ (x : G), orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ x : G, orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) â†’ âˆƒ x : G, orderOf x = 2 "
    ]
  },
  {
    "docString": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.range b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite family of vectors is linearly independent if and only if\\nits cardinality equals the dimension of its span. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : â„•},\\n  (âˆ€ (s : Finset M), (LinearIndependent R fun i => â†‘i) â†’ Finset.card s â‰¤ n) â†’\\n    âˆ€ (s : Set M), LinearIndependent R Subtype.val â†’ Cardinal.mk â†‘s â‰¤ â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite set of linearly independent vectors has cardinality at most `n`,\\nthen the same is true for arbitrary sets of linearly independent vectors.\\n\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The direction of the affine span of a finite set is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x âˆˆ AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x âˆˆ vectorSpan k (insert p â†‘s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M}\\n  {x : M}, x âˆˆ Submodule.span R S â†’ âˆƒ T, â†‘T âŠ† S âˆ§ x âˆˆ Submodule.span R â†‘T\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every element in the span of a set, there exists a finite subset of the set\\nsuch that the element is contained in the span of the subset. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  Collinear k s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The direction of the affine span of collinear points is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Collinear k s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of collinear points is finite-dimensional. \"}]\n",
    "prompt_cons": "/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Fintype Î¹] {b : Î¹ â†’ V}, LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.range b) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- If every finite set of linearly independent vectors has cardinality at most `n`,\nthen the same is true for arbitrary sets of linearly independent vectors. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : â„•},\n  (âˆ€ (s : Finset M), (LinearIndependent R fun i => â†‘i) â†’ Finset.card s â‰¤ n) â†’\n    âˆ€ (s : Set M), LinearIndependent R Subtype.val â†’ Cardinal.mk â†‘s â‰¤ â†‘n :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F) :=\n\n/-- The direction of the affine span of a finite set is\nfinite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) } :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\n  [inst_4 : FiniteDimensional k { x // x âˆˆ AffineSubspace.direction s }] (p : P),\n  FiniteDimensional k { x // x âˆˆ vectorSpan k (insert p â†‘s) } :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M}\n  {x : M}, x âˆˆ Submodule.span R S â†’ âˆƒ T, â†‘T âŠ† S âˆ§ x âˆˆ Submodule.span R â†‘T :=\n\n/-- The direction of the affine span of collinear points is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  Collinear k s â†’ FiniteDimensional k { x // x âˆˆ AffineSubspace.direction (affineSpan k s) } :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- The `vectorSpan` of collinear points is finite-dimensional. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Collinear k s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M},\n  (âˆƒ (t : â„• â†’ M), Submodule.span R (Set.range t) = âŠ¤) â†’\n    âˆ€ (s : Set M), LinearIndependent R Subtype.val â†’ Set.Finite s âˆ¨ Set.Countable s ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {s : Set V},\n  (âˆƒ (t : Set V), Set.Countable t âˆ§ Submodule.span K t = âŠ¤) â†’\n    âˆ€ (l : Set V), LinearIndependent K Subtype.val â†’ Set.Finite l âˆ¨ Set.Countable l ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set V},\n  Set.Countable S â†’ Submodule.span K S = âŠ¤ â†’\n    âˆ€ (L : Set V), LinearIndependent K Subtype.val â†’ Set.Finite L âˆ¨ Set.Countable L ",
      "âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M}\n  (hs : âˆ€ x : M, x âˆˆ Submodule.span R S), Set.Countable S â†’\n  âˆ€ (T : Set M), LinearIndependent R Subtype.val â†’ Set.Countable T âˆ¨ Set.Finite T ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {s : Set V}, Submodule.span K s = âŠ¤ â†’ Set.Countable s â†’\n    âˆ€ (t : Set V), LinearIndependent K Subtype.val â†’ Set.Countable t âˆ¨ Set.Finite t ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  [inst_3 : Infinite Î¹], (âˆƒ b : Î¹ â†’ V, Submodule.span K (Set.range b) = âŠ¤) â†’\n    âˆ€ (s : Set V), LinearIndependent K Subtype.val â†’ Set.Countable s âˆ¨ Set.Finite s ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {s : Set V},\n  (âˆƒ t : â„• â†’ V, Submodule.span K (Set.range t) = Submodule.span K s) â†’\n    âˆ€ (l : Set V), LinearIndependent K Subtype.val â†’ Set.Countable l âˆ¨ Set.Finite l ",
      "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {S : Set M},\n  (âˆƒ T, (âˆ€ t : M, t âˆˆ T â†’ t âˆˆ S) âˆ§ Submodule.span R T = Submodule.span R S âˆ§ Set.Countable T) â†’\n    âˆ€ (s : Set M), LinearIndependent R Subtype.val â†’ Set.Finite s âˆ¨ Set.Countable s ",
      "âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M}\n  (hS : âˆƒ L, Set.Countable L âˆ§ Submodule.span R L = Submodule.span R S),\n  âˆ€ (T : Set M), LinearIndependent R Subtype.val â†’ Set.Countable T âˆ¨ Set.Finite T ",
      "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Set.Countable s â†’ Submodule.span K (Î» i, s i) = âŠ¤ â†’\n  âˆ€ (t : Set V), LinearIndependent K Subtype.val â†’ Set.Finite t âˆ¨ Set.Countable t "
    ]
  },
  {
    "docString": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {P : (G : Type u_1) â†’ [inst : Group G] â†’ [inst : Group.IsNilpotent G] â†’ Prop} (G : Type u_1) [inst : Group G]\\n  [inst_1 : Group.IsNilpotent G],\\n  (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Subsingleton G], P G) â†’\\n    (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Group.IsNilpotent G], P (G â§¸ Subgroup.center G) â†’ P G) â†’ P G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A custom induction principle for nilpotent groups. The base case is a trivial group\\n(`subsingleton G`), and in the induction step, one can assume the hypothesis for\\nthe group quotiented by its center. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G) :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- A custom induction principle for nilpotent groups. The base case is a trivial group\n(`subsingleton G`), and in the induction step, one can assume the hypothesis for\nthe group quotiented by its center. -/\ntheorem âˆ€ {P : (G : Type u_1) â†’ [inst : Group G] â†’ [inst : Group.IsNilpotent G] â†’ Prop} (G : Type u_1) [inst : Group G]\n  [inst_1 : Group.IsNilpotent G],\n  (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Subsingleton G], P G) â†’\n    (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Group.IsNilpotent G], P (G â§¸ Subgroup.center G) â†’ P G) â†’ P G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (G â§¸ Subgroup.center G) â†’ (âˆ€ a b : G, a * b = b * a) ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (G â§¸ Subgroup.center G) â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (G â§¸ Subgroup.center G)], IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsCyclic (G â§¸ Subgroup.center G)], IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (G â§¸ Subgroup.center G) â†’ IsAddAbelian G âˆ§ G = Subgroup.center G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (G â§¸ Subgroup.center G)], IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (G â§¸ Subgroup.center G)], IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (G â§¸ Subgroup.center G) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G â§¸ Subgroup.center G) â†’ AddGroup.IsAbelian G âˆ§ Subgroup.center G = âŠ¤ ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (G â§¸ Subgroup.center G)], IsAddCyclic G â†’ IsAddCyclic (Subgroup.center G) "
    ]
  },
  {
    "docString": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\\n  p â‰  p' â†’ Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`- and `q`-primary components are disjoint for `p â‰  q`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\\n  p â‰  p' â†’ Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\": \"The `p`- and `q`-primary components are disjoint for `p â‰  q`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\": \"âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\\n  p + q â‰  0 â†’\\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p + q` is at least the minimum of the multiplicities. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p â‰  q`. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\n  p â‰  p' â†’ Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p â‰  q`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddCommMonoid G] {p : â„•} [hp : Fact (Nat.Prime p)] {p' : â„•} [hp' : Fact (Nat.Prime p')],\n  p â‰  p' â†’ Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p') :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\n  p + q â‰  0 â†’\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [Fact (Nat.Prime p)] [Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card Î± = p * p * q â†’ Â¬IsSimpleGroup Î± ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q â†’ Â¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) â†’ S = T\",\n  \"isProp\": true,\n  \"docString\": \"Two subsemigroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"}]\n",
    "prompt_cons": "/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- Shows that `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.denominators g n = ppredB â†’\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB â†’\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- Two subsemigroups are equal if they have the same elements. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) â†’ S = T :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G}, Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "forall {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "forall {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * (b^2), b * a * (b^3)} ",
      "forall {G : Type u_1} [inst : Group G] {a b : G}, Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b ^ 2, b * a * b ^ 3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "âˆ€ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} "
    ]
  },
  {
    "docString": "Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A â‰ƒ+* B â†’ NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²},\\n  IsRingHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Ring Î³] {g : Î² â†’ Î³}, IsRingHom g â†’ IsRingHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two ring homomorphisms is a ring homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Setoid Î±} {x : Î±} {b : Set Î±},\\n  b âˆˆ Setoid.classes r â†’ x âˆˆ b â†’ âˆ€ {b' : Set Î±}, b' âˆˆ Setoid.classes r â†’ x âˆˆ b' â†’ b = b'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x âˆˆ Î± is in 2 equivalence classes, the equivalence classes are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R â†’+* S} {s : Set R},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {Ï‡ : MulChar R â„¤},\\n  MulChar.IsQuadratic Ï‡ â†’\\n    âˆ€ {Ï‡' : MulChar R' â„¤},\\n      MulChar.IsQuadratic Ï‡' â†’\\n        âˆ€ [inst_3 : Nontrivial R''], ringChar R'' â‰  2 â†’ âˆ€ {a : R} {a' : R'}, â†‘(â†‘Ï‡ a) = â†‘(â†‘Ï‡' a') â†’ â†‘Ï‡ a = â†‘Ï‡' a'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two values of quadratic characters with target `â„¤` agree after coercion into a ring\\nof characteristic not `2`, then they agree in `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)},\\n  (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ âˆ€ {x : Î±} {b b' : Set Î±}, b âˆˆ c â†’ x âˆˆ b â†’ b' âˆˆ c â†’ x âˆˆ b' â†’ b = b'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x âˆˆ Î± is in 2 elements of a set of sets partitioning Î±, those 2 sets are equal. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A â‰ƒ+* B â†’ IsDomain A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\": \"âˆ€ (z : UpperHalfPlane), âˆƒ g, g â€¢ z âˆˆ ModularGroup.fd\",\n  \"isProp\": true,\n  \"docString\": \"Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)`  \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R â†’+* S} {s : Set R},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right multiplication in a ring is an additive monoid morphism. \"}]\n",
    "prompt_cons": "/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A â‰ƒ+* B â†’ NoZeroDivisors A :=\n\n/-- The composition of two ring homomorphisms is a ring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²},\n  IsRingHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Ring Î³] {g : Î² â†’ Î³}, IsRingHom g â†’ IsRingHom (g âˆ˜ f) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K â†’+* L} {s : Set K},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subfield.closure s) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- If x âˆˆ Î± is in 2 equivalence classes, the equivalence classes are equal. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Setoid Î±} {x : Î±} {b : Set Î±},\n  b âˆˆ Setoid.classes r â†’ x âˆˆ b â†’ âˆ€ {b' : Set Î±}, b' âˆˆ Setoid.classes r â†’ x âˆˆ b' â†’ b = b' :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R â†’+* S} {s : Set R},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subring.closure s) :=\n\n/-- A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I :=\n\n/-- If two values of quadratic characters with target `â„¤` agree after coercion into a ring\nof characteristic not `2`, then they agree in `â„¤`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {Ï‡ : MulChar R â„¤},\n  MulChar.IsQuadratic Ï‡ â†’\n    âˆ€ {Ï‡' : MulChar R' â„¤},\n      MulChar.IsQuadratic Ï‡' â†’\n        âˆ€ [inst_3 : Nontrivial R''], ringChar R'' â‰  2 â†’ âˆ€ {a : R} {a' : R'}, â†‘(â†‘Ï‡ a) = â†‘(â†‘Ï‡' a') â†’ â†‘Ï‡ a = â†‘Ï‡' a' :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- If x âˆˆ Î± is in 2 elements of a set of sets partitioning Î±, those 2 sets are equal. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)},\n  (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ âˆ€ {x : Î±} {b b' : Set Î±}, b âˆˆ c â†’ x âˆˆ b â†’ b' âˆˆ c â†’ x âˆˆ b' â†’ b = b' :=\n\n/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A â‰ƒ+* B â†’ IsDomain A :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)` -/\ntheorem âˆ€ (z : UpperHalfPlane), âˆƒ g, g â€¢ z âˆˆ ModularGroup.fd :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R â†’+* S} {s : Set R},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subsemiring.closure s) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x :=\n\n/-- Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$. -/\ntheorem",
    "choices": [
      "Ideal.inter (Ideal.span {2}) (Ideal.span {x}) = Ideal.span {2 * x} ",
      "Ideal.eq_bot_or_top (Ideal.span {2} âŠ“ Ideal.span {Polynomial.x} : Ideal â„¤[Polynomial.x]) â†’\n  Ideal.span {2} âŠ“ Ideal.span {Polynomial.x} = Ideal.span {2 * Polynomial.x} ",
      "ideal.inter_eq_mul_ideal {R : Type u_1} [inst : CommRing R] (x : R) : ideal.span {2} âŠ“ ideal.span {x} = ideal.span {2 * x} ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {polynomial.X}) = Ideal.span {2 * polynomial.X} ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {x}) = Ideal.span {2 * x} ",
      "Ideal.inter_eq_left_iff_subset {R : Type u_1} [inst : CommRing R] : âˆ€ {I J : Ideal R}, I âŠ† J â†’ I âˆ© J = I ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {x}) = Ideal.span {2 * x} ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {x}) = Ideal.span {2 * x} ",
      "Ideal.inter_eq {x : â„¤[X]} (Ideal.span {2}) (Ideal.span {X}) = Ideal.span {2 * X} ",
      "Ideal.inter_eq_span_singleton 2 (singleton x) {R : Type u_1} [inst : CommRing R] :\n  Ideal.span (singleton (2 : R[x])) âŠ“ Ideal.span (singleton x) = Ideal.span (singleton (2 * x)) "
    ]
  },
  {
    "docString": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I â†’\\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R},\\n  Ideal.radical I = Ideal.jacobson I â†” Ideal.radical âŠ¥ = Ideal.jacobson âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (âˆ€ (P : Ideal R) (hP : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I â‰¤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\\n    I â‰¤ J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\\nthe localization of `J` at `P`, then `I â‰¤ J`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G â§¸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\\n  Function.Injective\\n    â†‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n        (_ :\\n          P â‰¤\\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be an ideal in `R[x]`.  The map\\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\\nis injective.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\\nthen `R â†’ R[X]/P` is an integral map. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {I : Ideal R},\\n  Ideal.jacobson I = I â†” âˆ€ (x : R), Â¬x âˆˆ I â†’ âˆƒ M, (I â‰¤ M âˆ§ Ideal.IsMaximal M) âˆ§ Â¬x âˆˆ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` equals its Jacobson radical if and only if every element outside `I`\\nalso lies outside of a maximal ideal containing `I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R â†”\\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"}]\n",
    "prompt_cons": "/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I â†’\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\n          P I :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥ :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\n    I = J :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R},\n  Ideal.radical I = Ideal.jacobson I â†” Ideal.radical âŠ¥ = Ideal.jacobson âŠ¥ :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I â‰¤ J`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (P : Ideal R) (hP : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I â‰¤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\n    I â‰¤ J :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G â§¸ H) :=\n\n/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\nis injective. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\n  Function.Injective\n    â†‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n        (_ :\n          P â‰¤\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P))) :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\nthen `R â†’ R[X]/P` is an integral map. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C) :=\n\n/-- A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- An ideal `I` equals its Jacobson radical if and only if every element outside `I`\nalso lies outside of a maximal ideal containing `I`. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {I : Ideal R},\n  Ideal.jacobson I = I â†” âˆ€ (x : R), Â¬x âˆˆ I â†’ âˆƒ M, (I â‰¤ M âˆ§ Ideal.IsMaximal M) âˆ§ Â¬x âˆˆ M :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R â†”\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : Ring R] {I J : Ideal R} (x : R) (hx : x âˆˆ I âˆ§ x âˆˆ J),\n  IsNilpotent (Submodule.Quotient.mk (x * I * J)) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ© J â†’ âˆƒ n : â„•, Quotient.mk (I * J) ^ n (Subtype.mk x _) = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x âˆˆ I âˆ§ x âˆˆ J â†’\n    âˆƒ n : â„•, (Ideal.Quotient.mk (I * J) x) ^ n = 0 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (x : R), x âˆˆ I âˆ© J â†’ âˆƒ (n : â„•), (Ideal.Quotient.mk (I * J) x) ^ n = 0) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {I J : Ideal R} (x : R), x âˆˆ I âŠ“ J â†’ IsNilpotent (Ideal.Quotient.mk (I * J) x) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  âˆ€ (x : R), x âˆˆ I âˆ© J â†’ âˆƒ n : â„•, (Ideal.Quotient.mk (I * J) x) ^ n = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R) (h : x âˆˆ I âŠ“ J),\n  IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  âˆ€ (x : R), x âˆˆ I âŠ“ J â†’ âˆƒ n : â„•, (Ideal.Quotient.mk (I * J) x) ^ n = 0 ",
      "âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R}, (âˆ€ (x : R), x âˆˆ I âˆ© J â†’ âˆƒ n : â„•, x + I * J = (x + I * J) ^ (n + 1)) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (I J : Ideal R) (x : R),\n  x âˆˆ I âˆ© J â†’\n    IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) "
    ]
  },
  {
    "docString": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R â†”\\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\\nthen `R â†’ R[X]/P` is an integral map. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  â†‘Polynomial.C x âˆˆ\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] (I : Ideal Î±), I â‰  âŠ¤ â†’ âˆƒ M, Ideal.IsMaximal M âˆ§ I â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Krull's theorem**: if `I` is an ideal that is not the whole ring, then it is included in some\\nmaximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R} [self : Ideal.IsLocal I], Ideal.IsMaximal (Ideal.jacobson I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is local if and only if its jacobson radical is maximal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] {p : â„•},\\n  Nat.Prime p â†’ ((âˆƒ I, I â‰  âŠ¤ âˆ§ CharP (R â§¸ I) p) â†” âˆƒ I, Ideal.IsMaximal I âˆ§ CharP (R â§¸ I) p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reduction to `I` prime ideal: When proving statements about mixed characteristic rings,\\nafter we reduced to `p` prime, we can assume that the ideal `I` in the definition is maximal.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S â‰¤ nonZeroDivisors R â†’\\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"}]\n",
    "prompt_cons": "/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing âŠ¤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R â†”\n    âˆ€ {I : Ideal R}, Ideal.IsPrime I â†’ âˆƒ M, (âˆ€ (J : Ideal R), J âˆˆ M â†’ Ideal.IsMaximal J âˆ¨ J = âŠ¤) âˆ§ I = sInf M :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\nthen `R â†’ R[X]/P` is an integral map. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C) :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R â†’ R[x] â†’ R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] â†’ R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' â†’ R'[x] â†’ R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x âˆˆ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  â†‘Polynomial.C x âˆˆ\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I â†’\n    x = 0 :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- **Krull's theorem**: if `I` is an ideal that is not the whole ring, then it is included in some\nmaximal ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] (I : Ideal Î±), I â‰  âŠ¤ â†’ âˆƒ M, Ideal.IsMaximal M âˆ§ I â‰¤ M :=\n\n/-- A ring `R` is local if and only if its jacobson radical is maximal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R} [self : Ideal.IsLocal I], Ideal.IsMaximal (Ideal.jacobson I) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (âˆ€ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) â†’\n    I = J :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- Reduction to `I` prime ideal: When proving statements about mixed characteristic rings,\nafter we reduced to `p` prime, we can assume that the ideal `I` in the definition is maximal. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] {p : â„•},\n  Nat.Prime p â†’ ((âˆƒ I, I â‰  âŠ¤ âˆ§ CharP (R â§¸ I) p) â†” âˆƒ I, Ideal.IsMaximal I âˆ§ CharP (R â§¸ I) p) :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S â‰¤ nonZeroDivisors R â†’\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I :=\n\n/-- Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] {M : Ideal R},\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (I : Ideal R), Ideal.IsMaximal I â†’ I = M ",
      "âˆ€ {R : Type u} [inst : CommRing R] {M : Ideal R},\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (M' : Ideal R), Ideal.IsMaximal M' â†’ M' = M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ (I : Ideal R), I â‰  âŠ¥ â†’ M â‰¤ I â†’ I = M âˆ¨ I = âŠ¤) âˆ§ âˆ€ (N : Ideal R), Ideal.IsMaximal N â†’ N = M ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ (I : Ideal R), Ideal.IsMaximal I â†” I = M) ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R), (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (M' : Ideal R), Ideal.IsMaximal M' â†’ M = M' ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R), (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (I : Ideal R), Ideal.IsMaximal I â†’ I = M ",
      "âˆ€ {R : Type u} [inst : CommRing R] {M : Ideal R},\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ (I : Ideal R), Ideal.IsMaximal I â†’ I = M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (x : R), x âˆ‰ M â†’ IsUnit x) â†’ (âˆ€ I : Ideal R, I â‰  âŠ¤ â†’ I = M) âˆ§ Ideal.IsMaximal M ",
      "âˆ€ {R : Type u} [inst : CommRing R] (M : Ideal R),\n  (âˆ€ (r : R), r âˆ‰ M â†’ IsUnit r) â†’ (âˆ€ (I : Ideal R), Ideal.IsMaximal I â†” I = M) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {M : Ideal R},\n  (âˆ€ x : R, x âˆ‰ M â†’ IsUnit x) â†’ Ideal.IsMaximal M âˆ§ âˆ€ P : Ideal R, Ideal.IsMaximal P â†’ P = M "
    ]
  },
  {
    "docString": "Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x âˆˆ â†‘(LieAlgebra.radical R L) } :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "Irreducible (Polynomial.map (Int.castRingHom â„š) (Polynomial.ofExponents [(0, 12), (1, 6), (3, 1)])) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Poly.mk â„š [12, 6, 0, 1]) ",
      "irreducible_x_pow_3_add_6_x_add_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "Irreducible (Polynomial.map (Int.castRingHom â„š) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6_x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) ",
      "Irreducible (Polynomial.ofString \"x^3 + 6*x + 12\" â„š) ",
      "irreducible_x_pow_3_6x_12 : Irreducible (Polynomial.x ^ 3 + 6 * Polynomial.x + 12 : Polynomial â„š) "
    ]
  },
  {
    "docString": "Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n j : â„•),\\n  j < p ^ n â†’\\n    p ^ (n - WittVector.pnat_multiplicity p { val := j + 1, property := (_ : 0 < Nat.succ j) }) âˆ£\\n      Nat.choose (p ^ n) (j + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key divisibility fact for the proof of `WittVector.map_frobeniusPoly`. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E] {Î± : E} {q : Polynomial F},\\n  Irreducible q â†’ â†‘(Polynomial.aeval Î±) q = 0 â†’ IsSolvableByRad F Î± â†’ IsSolvable (Polynomial.Gal q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Abel-Ruffini Theorem** (one direction): An irreducible polynomial with an\\n`IsSolvableByRad` root has solvable Galois group \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- A key divisibility fact for the proof of `WittVector.map_frobeniusPoly`. -/\ntheorem âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n j : â„•),\n  j < p ^ n â†’\n    p ^ (n - WittVector.pnat_multiplicity p { val := j + 1, property := (_ : 0 < Nat.succ j) }) âˆ£\n      Nat.choose (p ^ n) (j + 1) :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- **Abel-Ruffini Theorem** (one direction): An irreducible polynomial with an\n`IsSolvableByRad` root has solvable Galois group -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E] {Î± : E} {q : Polynomial F},\n  Irreducible q â†’ â†‘(Polynomial.aeval Î±) q = 0 â†’ IsSolvableByRad F Î± â†’ IsSolvable (Polynomial.Gal q) :=\n\n/-- Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$ -/\ntheorem",
    "choices": [
      "Polynomial.x_pow_2_add_1_irreducible_in_F7 : Irreducible ((((Polynomial.X ^ 2) + 1) : Polynomial (ZMod 7))) ",
      "irreducible_x_pow_add_one (Fintype.card_fin (7 - 1)) (by norm_num) : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_in_f7_x_sq_plus_one : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "Polynomial.X_pow_add_one_irreducible (show Fact (Nat.Prime 7), by exact âŸ¨nat.prime_iff_prime.2 (prime_int_iff_nat_abs_prime (show _root_.prime 7, by norm_num))âŸ©) ",
      "x_sq_plus_one_irreducible : Irreducible (Polynomial.map (Int.castRingHom (Zmod 7)) (Polynomial.x ^ 2 + 1)) ",
      "x_pow_two_add_one_irreducible : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_poly_x_pow2_add_one_F7 : Irreducible (@Polynomial.x (Zmod 7) ^ 2 + 1) ",
      "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], (CharP F 7) â†’ Irreducible (Polynomial.x ^ 2 + 1 : Polynomial F) ",
      "Polynomial.irreducible_X_pow_add_one {p : â„•} [hp : Fact (Nat.Prime p)] (hp_odd : p % 2 = 1) : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod p)) ",
      "Polynomial.Irreducible.X_pow_add_one {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharP R 7] (hp : Â¬(R)Ë£ = âŠ¥) : Irreducible (Polynomial.X ^ 2 + 1) "
    ]
  },
  {
    "docString": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [inst_1 : UniqueFactorizationMonoid Î±]\\n  [inst_2 : NormalizationMonoid Î±] [inst_3 : DecidableEq Î±] {x : Î±} {n : â„•}, factorization (x ^ n) = n â€¢ factorization x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ p` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] {P : Prop},\\n  (âˆ€ (p : â„•), p > 0 â†’ MixedCharZero R p â†’ P) â†” âˆ€ (p : â„•), Nat.Prime p â†’ MixedCharZero R p â†’ P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\\ncan always assume that `p` is prime.\\n\"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {n p k : â„•}, n â‰  0 â†’ Nat.factorization n = Finsupp.single p k â†’ n = p ^ k\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the factorization of `n` contains just one number `p` then `n` is a power of `p` \"}]\n",
    "prompt_cons": "/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [inst_1 : UniqueFactorizationMonoid Î±]\n  [inst_2 : NormalizationMonoid Î±] [inst_3 : DecidableEq Î±] {x : Î±} {n : â„•}, factorization (x ^ n) = n â€¢ factorization x :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ p` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] {P : Prop},\n  (âˆ€ (p : â„•), p > 0 â†’ MixedCharZero R p â†’ P) â†” âˆ€ (p : â„•), Nat.Prime p â†’ MixedCharZero R p â†’ P :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem âˆ€ {n p k : â„•}, n â‰  0 â†’ Nat.factorization n = Finsupp.single p k â†’ n = p ^ k :=\n\n/-- Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•} [hpos : 0 < n] {p : â„•} [inst : Fact (Nat.Prime p)],\n  Irreducible (Polynomial.x ^ n - Polynomial.C (coe p) : Polynomial â„š) ",
      "âˆ€ {n : â„•} {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ [inst : Fact (Nat.Prime p)], Irreducible (Polynomial.x ^ n - Polynomial.C (coe p)) ",
      "âˆ€ {n : â„•} {p : â„•} [inst : Fact (Nat.Prime p)],\n  Polynomial.irreducible (Polynomial.X ^ n - Polynomial.C (Int.of_nat p) : Polynomial â„š) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)], âˆ€ {n : â„•} (hn : 0 < n), Irreducible (Polynomial.x ^ n - Polynomial.C (p : â„š)) ",
      "âˆ€ {n p : â„•} [inst : Fact (Nat.Prime p)], Irreducible (Polynomial.x ^ n - Polynomial.C (coe p)) ",
      "âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] {n : â„•},\n  0 < n â†’ Irreducible (Polynomial.x ^ n - â†‘Polynomial.C p) ",
      "âˆ€ {p : â„•} [Fact (Nat.Prime p)] {n : â„•}, Irreducible (Polynomial.x ^ n - Polynomial.C (coe p) : Polynomial â„š) ",
      "âˆ€ {n : â„•} {p : â„•} [inst : Fact (Nat.Prime p)],\n  0 < n â†’ Irreducible (Polynomial.x ^ n - Polynomial.C (â†‘p) : Polynomial â„š) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {n : â„•}, 0 < n â†’ Irreducible (Polynomial.X ^ n - Polynomial.C (â†‘p)) ",
      "âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (n : â„•),\n  Irreducible (Polynomial.x ^ n - Polynomial.C (Int.cast p) : Polynomial â„š) "
    ]
  },
  {
    "docString": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p k : â„•}, Nat.Prime p â†’ Nat.factorization (p ^ k) = Finsupp.single p k\",\n  \"isProp\": true,\n  \"docString\":\n  \"For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` \"},\n {\"theorem\":\n  \"âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {x y : â„¤} {n : â„•},\\n  2 âˆ£ x - y â†’\\n    Â¬2 âˆ£ x â†’\\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\": \"âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {p n : â„•},\\n  Nat.Prime p â†’ Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p ^ k` is a prime power, then\\n`cyclotomic (p ^ (n + 1)) R = âˆ‘ i in range p, (X ^ (p ^ n)) ^ i`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•} (n : â„•), k â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there exists an arbitrarily large prime `p` such that\\n`p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ (k : â„•) {r : â„}, |r| < 1 â†’ Filter.Tendsto (fun n => â†‘n ^ k * r ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"}]\n",
    "prompt_cons": "/-- For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` -/\ntheorem âˆ€ {p k : â„•}, Nat.Prime p â†’ Nat.factorization (p ^ k) = Finsupp.single p k :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem âˆ€ {p k : â„•}, k â‰  0 â†’ Nat.Prime p â†’ List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem âˆ€ {x y : â„¤} {n : â„•},\n  2 âˆ£ x - y â†’\n    Â¬2 âˆ£ x â†’\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`. -/\ntheorem âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1) :=\n\n/-- If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = âˆ‘ i in range p, (X ^ (p ^ n)) ^ i`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {p n : â„•},\n  Nat.Prime p â†’ Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\n  PowerSeries.exp A ^ k = â†‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A) :=\n\n/-- For any positive `k : â„•` there exists an arbitrarily large prime `p` such that\n`p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•} (n : â„•), k â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k] :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem âˆ€ (k : â„•) {r : â„}, |r| < 1 â†’ Filter.Tendsto (fun n => â†‘n ^ k * r ^ n) Filter.atTop (nhds 0) :=\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = Finsupp.single p 1 :=\n\n/-- Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$. -/\ntheorem",
    "choices": [
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k, r = 2 ^ k ",
      "âˆ€ {p : â„•}, Nat.Prime p â†’ (âˆƒ r, p = 2 ^ r + 1) â†’ (âˆƒ k, p = 2 ^ (2 ^ k) + 1) ",
      "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆƒ k : â„•, âˆƒ r : â„•, p = 2 ^ r + 1 â†’ p = 2 ^ (2 ^ k) + 1 ",
      "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 ^ Nat.findGreatest (fun r => 2 ^ r + 1 = p) 1 + 1 â†’ âˆƒ k : â„•, p = 2 ^ (2 ^ k) + 1 ",
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k, r = 2 ^ k ",
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k : â„•, r = 2 ^ k ",
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k : â„•, r = 2 ^ k ",
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k : â„•, p = 2 ^ (2 ^ k) + 1 ",
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k : â„•, r = 2 ^ k ",
      "âˆ€ {p r : â„•}, Nat.Prime p â†’ p = 2 ^ r + 1 â†’ âˆƒ k : â„•, r = 2 ^ k "
    ]
  },
  {
    "docString": "Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w + y) (x + z)\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations preserve addition.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of additive monoid homomorphisms is associative.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] {c : AddCon M} (x y : M), â†‘(x + y) = â†‘x + â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of an additive congruence relation\\ncommutes with addition (by definition).\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\\n  â†‘f (a + b) = â†‘f a + â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve addition. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] (self : AddCon M) {w x y z : M}, Setoid.r w x â†’ Setoid.r y z â†’ Setoid.r (w + y) (x + z)\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are closed under addition \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : NonAssocRing Î±] [inst_1 : NonAssocRing Î²] (f : Î± â†’+* Î²) (x : Î±), â†‘f (-x) = -â†‘f x\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve additive inverse. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y z : M}, â†‘c x y â†’ â†‘c y z â†’ â†‘c x z\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are transitive.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Add M] {c : AddCon M} {C : AddCon.Quotient c â†’ Prop} (q : AddCon.Quotient c),\\n  (âˆ€ (x : M), C â†‘x) â†’ C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about\\nthe elements of a quotient by an additive congruence relation.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : NonUnitalSemiring Î±] (a b c : Î±), a * b * c = a * (b * c)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is associative \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w * y) (x * z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddZeroClass Î±] [inst_1 : AddZeroClass Î²] {f : Î± â†’ Î²},\\n  IsAddMonoidHom f â†’ âˆ€ (x y : Î±), f (x + y) = f x + f y\",\n  \"isProp\": true,\n  \"docString\": \"An additive monoid homomorphism preserves addition.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of monoid homomorphisms is associative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²} {x : Î±}, IsRingHom f â†’ f (-x) = -f x\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve additive inverses. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : AddGroup M] (c : AddCon M) {w x : M}, â†‘c w x â†’ â†‘c (-w) (-x)\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations preserve negation.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\\n  AddSubgroup.Normal H â†’ âˆ€ (n : A), n âˆˆ H â†’ âˆ€ (g : A), g + n + -g âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"`N` is closed under additive conjugation \"}]\n",
    "prompt_cons": "/-- Additive congruence relations preserve addition. -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w + y) (x + z) :=\n\n/-- Composition of additive monoid homomorphisms is associative. -/\ntheorem âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f) :=\n\n/-- The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition). -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] {c : AddCon M} (x y : M), â†‘(x + y) = â†‘x + â†‘y :=\n\n/-- Ring homomorphisms preserve addition. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\n  â†‘f (a + b) = â†‘f a + â†‘f b :=\n\n/-- Additive congruence relations are closed under addition -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] (self : AddCon M) {w x y z : M}, Setoid.r w x â†’ Setoid.r y z â†’ Setoid.r (w + y) (x + z) :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y :=\n\n/-- Ring homomorphisms preserve additive inverse. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : NonAssocRing Î±] [inst_1 : NonAssocRing Î²] (f : Î± â†’+* Î²) (x : Î±), â†‘f (-x) = -â†‘f x :=\n\n/-- Additive congruence relations are transitive. -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y z : M}, â†‘c x y â†’ â†‘c y z â†’ â†‘c x z :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y :=\n\n/-- The inductive principle used to prove propositions about\nthe elements of a quotient by an additive congruence relation. -/\ntheorem âˆ€ {M : Type u_1} [inst : Add M] {c : AddCon M} {C : AddCon.Quotient c â†’ Prop} (q : AddCon.Quotient c),\n  (âˆ€ (x : M), C â†‘x) â†’ C q :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼ :=\n\n/-- Multiplication is associative -/\ntheorem âˆ€ {Î± : Type u} [self : NonUnitalSemiring Î±] (a b c : Î±), a * b * c = a * (b * c) :=\n\n/-- Multiplicative congruence relations preserve multiplication. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w * y) (x * z) :=\n\n/-- An additive monoid homomorphism preserves addition. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddZeroClass Î±] [inst_1 : AddZeroClass Î²] {f : Î± â†’ Î²},\n  IsAddMonoidHom f â†’ âˆ€ (x y : Î±), f (x + y) = f x + f y :=\n\n/-- Composition of monoid homomorphisms is associative. -/\ntheorem âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f) :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²} {x : Î±}, IsRingHom f â†’ f (-x) = -f x :=\n\n/-- Additive congruence relations preserve negation. -/\ntheorem âˆ€ {M : Type u_1} [inst : AddGroup M] (c : AddCon M) {w x : M}, â†‘c w x â†’ â†‘c (-w) (-x) :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_1}\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f) :=\n\n/-- `N` is closed under additive conjugation -/\ntheorem âˆ€ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\n  AddSubgroup.Normal H â†’ âˆ€ (n : A), n âˆˆ H â†’ âˆ€ (g : A), g + n + -g âˆˆ H :=\n\n/-- Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "âˆ€ {n : â„•} (a b c : Zmod n), a + b + c = a + (b + c) "
    ]
  },
  {
    "docString": "Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\\n  Group.nilpotencyClass G = Group.nilpotencyClass (G â§¸ Subgroup.center G) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a non-trivial group is one more than its quotient by the center \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„), ProperlyDiscontinuousVAdd { x // x âˆˆ â†‘AddSubgroup.opposite (AddSubgroup.zmultiples p) } â„\",\n  \"isProp\": true,\n  \"docString\":\n  \"The action on `â„` by right multiplication of its the subgroup `zmultiples p` (the multiples of\\n`p:â„`) is properly discontinuous. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"}]\n",
    "prompt_cons": "/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\n  Group.nilpotencyClass G = Group.nilpotencyClass (G â§¸ Subgroup.center G) + 1 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- The action on `â„` by right multiplication of its the subgroup `zmultiples p` (the multiples of\n`p:â„`) is properly discontinuous. -/\ntheorem âˆ€ (p : â„), ProperlyDiscontinuousVAdd { x // x âˆˆ â†‘AddSubgroup.opposite (AddSubgroup.zmultiples p) } â„ :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•} (hn : n > 1), Â¬ IsGroup (Zmod n) ",
      "âˆ€ {n : â„•}, 1 < n â†’ Â¬IsGroup (Zmod n) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬IsGroup (Zmod n) ",
      "âˆ€ {n : â„•} (hn : n > 1), Nontrivial (Zmod n) â†’ Â¬ IsGroup { x : Zmod n // coe x * coe x â‰  0 } ",
      "âˆ€ {n : â„•}, 1 < n â†’ Â¬(IsGroup (Zmod n) [Mul.mul]) ",
      "âˆ€ {n : â„•} (hn : n > 1), Â¬ IsGroup (Zmod n) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬MulGroup (Zmod n) ",
      "âˆ€ {n : â„•} (hn : n > 1), Â¬ IsGroup (Zmod n) ",
      "âˆ€ {n : â„•}, n > 1 â†’ Â¬IsGroup (Zmod n) ",
      "âˆ€ {n : â„•} (hn : 1 < n), Â¬IsGroup (Zmod n) "
    ]
  },
  {
    "docString": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, d â‰  0 â†’ âˆ€ {a : Pell.Solutionâ‚ d}, Pell.Solutionâ‚.x a = 1 â†’ a = 1\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x = 1` is trivial. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {P : Type u_2} [inst : VAdd G P] [self : FaithfulVAdd G P] {gâ‚ gâ‚‚ : G},\\n  (âˆ€ (p : P), gâ‚ +áµ¥ p = gâ‚‚ +áµ¥ p) â†’ gâ‚ = gâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `gâ‚` and `gâ‚‚` are equal whenever they act in the same way on all points. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\": \"âˆ€ {x k l : â„•}, 1 < x â†’ (x ^ k âˆ£ x ^ l â†” k â‰¤ l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Setoid Î±} {x : Î±} {b : Set Î±},\\n  b âˆˆ Setoid.classes r â†’ x âˆˆ b â†’ âˆ€ {b' : Set Î±}, b' âˆˆ Setoid.classes r â†’ x âˆˆ b' â†’ b = b'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x âˆˆ Î± is in 2 equivalence classes, the equivalence classes are equal. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x â‰  0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F â‰  2 â†’ âˆ€ (a : FË£), IsSquare a â†” a ^ (Fintype.card F / 2) = 1 :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1 :=\n\n/-- A solution with `x = 1` is trivial. -/\ntheorem âˆ€ {d : â„¤}, d â‰  0 â†’ âˆ€ {a : Pell.Solutionâ‚ d}, Pell.Solutionâ‚.x a = 1 â†’ a = 1 :=\n\n/-- The square of the symbol is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- Two elements `gâ‚` and `gâ‚‚` are equal whenever they act in the same way on all points. -/\ntheorem âˆ€ {G : Type u_1} {P : Type u_2} [inst : VAdd G P] [self : FaithfulVAdd G P] {gâ‚ gâ‚‚ : G},\n  (âˆ€ (p : P), gâ‚ +áµ¥ p = gâ‚‚ +áµ¥ p) â†’ gâ‚ = gâ‚‚ :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1) :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. -/\ntheorem âˆ€ {x k l : â„•}, 1 < x â†’ (x ^ k âˆ£ x ^ l â†” k â‰¤ l) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- If x âˆˆ Î± is in 2 equivalence classes, the equivalence classes are equal. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Setoid Î±} {x : Î±} {b : Set Î±},\n  b âˆˆ Setoid.classes r â†’ x âˆˆ b â†’ âˆ€ {b' : Set Î±}, b' âˆˆ Setoid.classes r â†’ x âˆˆ b' â†’ b = b' :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5 :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1 :=\n\n/-- If `n * x = 0`, but `n/p * x â‰  0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n :=\n\n/-- Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x^2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 â†” (orderOf x = 1 âˆ¨ orderOf x = 2) ",
      "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 â†” (orderOf x = 1 âˆ¨ orderOf x = 2) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 â†” orderOf x = 1 âˆ¨ orderOf x = 2 "
    ]
  },
  {
    "docString": "Let $x$ and $y$ be elements of $G$. Prove that $xy=yx$ if and only if $y^{-1}xy=x$ if and only if $x^{-1}y^{-1}xy=1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} {x1 : Î±} {b1 : Bool} {x2 : Î±} {b2 : Bool},\\n  (x1, b1) â‰  (x2, b2) â†’ FreeGroup.Red ((x1, b1) :: Lâ‚) ((x2, b2) :: Lâ‚‚) â†’ FreeGroup.Red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are distinct letters and `wâ‚ wâ‚‚` are words such that `xwâ‚` reduces to `ywâ‚‚`, then\\n`wâ‚` reduces to `xâ»Â¹ywâ‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g â€¢ x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : VAdd M Î±] [self : AddAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g +áµ¥ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g +áµ¥ x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y : Î±}, r x y â†’ r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulRightInvariant Î½],\\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.fstâ»Â¹)\",\n  \"isProp\": true,\n  \"docString\": \"The map `(x, y) â†¦ (xy, xâ»Â¹)` is measure-preserving. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {a : M} {x y : MË£}, SemiconjBy a â†‘x â†‘y â†’ SemiconjBy a â†‘xâ»Â¹ â†‘yâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `xâ»Â¹` to `yâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a x y x' y' : S},\\n  SemiconjBy a x y â†’ SemiconjBy a x' y' â†’ SemiconjBy a (x * x') (y * y')\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\\nthen it semiconjugates `x * x'` to `y * y'`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²}, e â‰ˆ e' â†’ LocalEquiv.symm e â‰ˆ LocalEquiv.symm e'\",\n  \"isProp\": true,\n  \"docString\": \"If two local equivs are equivalent, so are their inverses. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x âˆˆ self.carrier â†’ xâ»Â¹ âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : DivisionMonoid G] [inst_1 : Monoid N]\\n  [inst_2 : MonoidHomClass F G N] {x : G}, IsUnit x â†’ âˆ€ (f g : F), â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphisms from a division monoid to a monoid are equal at a unit `x`, then they are\\nequal at `xâ»Â¹`. \"}]\n",
    "prompt_cons": "/-- If `x` and `y` are distinct letters and `wâ‚ wâ‚‚` are words such that `xwâ‚` reduces to `ywâ‚‚`, then\n`wâ‚` reduces to `xâ»Â¹ywâ‚‚`. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} {x1 : Î±} {b1 : Bool} {x2 : Î±} {b2 : Bool},\n  (x1, b1) â‰  (x2, b2) â†’ FreeGroup.Red ((x1, b1) :: Lâ‚) ((x2, b2) :: Lâ‚‚) â†’ FreeGroup.Red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `aâ»Â¹` semiconjugates `y` to `x`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {a : MË£} {x y : M}, SemiconjBy (â†‘a) x y â†’ SemiconjBy (â†‘aâ»Â¹) y x :=\n\n/-- There is `g` such that `g â€¢ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y :=\n\n/-- By definition, if `x` is invertible then `inverse x = xâ»Â¹`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹ :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- There is `g` such that `g +áµ¥ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : VAdd M Î±] [self : AddAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g +áµ¥ x = y :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y : Î±}, r x y â†’ r y x :=\n\n/-- The map `(x, y) â†¦ (xy, xâ»Â¹)` is measure-preserving. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulRightInvariant Î½],\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.fstâ»Â¹) :=\n\n/-- If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `xâ»Â¹` to `yâ»Â¹`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {a : M} {x y : MË£}, SemiconjBy a â†‘x â†‘y â†’ SemiconjBy a â†‘xâ»Â¹ â†‘yâ»Â¹ :=\n\n/-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a x y x' y' : S},\n  SemiconjBy a x y â†’ SemiconjBy a x' y' â†’ SemiconjBy a (x * x') (y * y') :=\n\n/-- If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- If two local equivs are equivalent, so are their inverses. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²}, e â‰ˆ e' â†’ LocalEquiv.symm e â‰ˆ LocalEquiv.symm e' :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- `G` is closed under inverses -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x âˆˆ self.carrier â†’ xâ»Â¹ âˆˆ self.carrier :=\n\n/-- If two homomorphisms from a division monoid to a monoid are equal at a unit `x`, then they are\nequal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : DivisionMonoid G] [inst_1 : Monoid N]\n  [inst_2 : MonoidHomClass F G N] {x : G}, IsUnit x â†’ âˆ€ (f g : F), â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- Let $x$ and $y$ be elements of $G$. Prove that $xy=yx$ if and only if $y^{-1}xy=x$ if and only if $x^{-1}y^{-1}xy=1$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {x y : G},\n  x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G], âˆ€ {x y : G}, x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G),\n  x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x y : G},\n  x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G),\n  x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G),\n  x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u} [inst : Group G] (x y : G),\n  x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x y : G), x * y = y * x â†” yâ»Â¹ * x * y = x â†” xâ»Â¹ * yâ»Â¹ * x * y = 1 "
    ]
  },
  {
    "docString": "If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (g * a)) â†’ (âˆ€ (a : G), P a â†’ P (gâ»Â¹ * a)) â†’ âˆ€ (n : â„¤), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `gâ»Â¹` on the left. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_left`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (a * g)) â†’ (âˆ€ (a : G), P a â†’ P (a * gâ»Â¹)) â†’ âˆ€ (n : â„¤), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `gâ»Â¹` on the right. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_right`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ Function.LeftInverse g f â†’ Function.IsFixedPt g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\\npoint of `g`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : VAdd M Î±] [self : AddAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g +áµ¥ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g +áµ¥ x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : AddGroup G] {g : G} {P : G â†’ Prop},\\n  P 0 â†’ (âˆ€ (a : G), P a â†’ P (g + a)) â†’ (âˆ€ (a : G), P a â†’ P (-g + a)) â†’ âˆ€ (n : â„¤), P (n â€¢ g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all multiples of `g` it suffices to show it is closed under\\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\\n`AddSubgroup.closure_induction_left`.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g â€¢ x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : AddGroup G] {g : G} {P : G â†’ Prop},\\n  P 0 â†’ (âˆ€ (a : G), P a â†’ P (a + g)) â†’ (âˆ€ (a : G), P a â†’ P (a + -g)) â†’ âˆ€ (n : â„¤), P (n â€¢ g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all multiples of `g` it suffices to show it is closed under\\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\\nsee `AddSubgroup.closure_induction_right`.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z)\\n  [inst_3 : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)], CategoryTheory.IsIso g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If\\n```\\n(f 0)\\n(0 g)\\n```\\nis invertible, then `g` is invertible.\\n\"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) â†’ G) (j : Fin (n + 1)) (k : Fin n),\\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))â»Â¹ *\\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\\n    Fin.contractNth j (fun x x_1 => x * x_1) g k\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `(gâ‚€, gâ‚, ..., gâ‚™)` be a tuple of elements in `Gâ¿âºÂ¹`.\\nThen if `k < j`, this says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚– = gâ‚–`.\\nIf `k = j`, it says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–gâ‚–â‚Šâ‚`.\\nIf `k > j`, it says `(gâ‚€gâ‚...gâ‚–)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–â‚Šâ‚.`\\nUseful for defining group cohomology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x âˆˆ self.carrier â†’ xâ»Â¹ âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : MulAction Î± Î²] (g : Î±) (x : Î²),\\n  MulAction.stabilizer Î± (g â€¢ x) = Subgroup.map (MulEquiv.toMonoidHom (â†‘MulAut.conj g)) (MulAction.stabilizer Î± x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the stabilizer of `x` is `S`, then the stabilizer of `g â€¢ x` is `gSgâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring Sâ‚] {f : R â†’+* Sâ‚}\\n  {g : Sâ‚ â†’+* R}, Function.LeftInverse â†‘f â†‘g â†’ Function.LeftInverse â†‘(MvPolynomial.map f) â†‘(MvPolynomial.map g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a left-inverse of `g` then `map f` is a left-inverse of `map g`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : CompleteLattice Î±] [inst_1 : Group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G),\\n  Function.Semiconj (fun x => â¨† (g' : G), â†‘(â†‘fâ‚ g')â»Â¹ (â†‘(â†‘fâ‚‚ g') x)) â†‘(â†‘fâ‚‚ g) â†‘(â†‘fâ‚ g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider two actions `fâ‚ fâ‚‚ : G â†’ Î± â†’ Î±` of a group on a complete lattice by order\\nisomorphisms. Then the map `x â†¦ â¨† g : G, (fâ‚ g)â»Â¹ (fâ‚‚ g x)` semiconjugates each `fâ‚ g'` to `fâ‚‚ g'`.\\n\\nThis is a version of Proposition 5.4 from [Ã‰tienne Ghys, Groupes d'homÃ©omorphismes du cercle et\\ncohomologie bornÃ©e][ghys87:groupes]. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring Sâ‚] {f : R â†’+* Sâ‚}\\n  {g : Sâ‚ â†’+* R}, Function.RightInverse â†‘f â†‘g â†’ Function.RightInverse â†‘(MvPolynomial.map f) â†‘(MvPolynomial.map g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a right-inverse of `g` then `map f` is a right-inverse of `map g`. \"}]\n",
    "prompt_cons": "/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `gâ»Â¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. -/\ntheorem âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (g * a)) â†’ (âˆ€ (a : G), P a â†’ P (gâ»Â¹ * a)) â†’ âˆ€ (n : â„¤), P (g ^ n) :=\n\n/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `gâ»Â¹` on the right. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_right`. -/\ntheorem âˆ€ {G : Type w} [inst : Group G] {g : G} {P : G â†’ Prop},\n  P 1 â†’ (âˆ€ (a : G), P a â†’ P (a * g)) â†’ (âˆ€ (a : G), P a â†’ P (a * gâ»Â¹)) â†’ âˆ€ (n : â„¤), P (g ^ n) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\npoint of `g`. -/\ntheorem âˆ€ {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ Function.LeftInverse g f â†’ Function.IsFixedPt g x :=\n\n/-- There is `g` such that `g +áµ¥ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : VAdd M Î±] [self : AddAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g +áµ¥ x = y :=\n\n/-- To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`AddSubgroup.closure_induction_left`. -/\ntheorem âˆ€ {G : Type w} [inst : AddGroup G] {g : G} {P : G â†’ Prop},\n  P 0 â†’ (âˆ€ (a : G), P a â†’ P (g + a)) â†’ (âˆ€ (a : G), P a â†’ P (-g + a)) â†’ âˆ€ (n : â„¤), P (n â€¢ g) :=\n\n/-- There is `g` such that `g â€¢ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y :=\n\n/-- To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `AddSubgroup.closure_induction_right`. -/\ntheorem âˆ€ {G : Type w} [inst : AddGroup G] {g : G} {P : G â†’ Prop},\n  P 0 â†’ (âˆ€ (a : G), P a â†’ P (a + g)) â†’ (âˆ€ (a : G), P a â†’ P (a + -g)) â†’ âˆ€ (n : â„¤), P (n â€¢ g) :=\n\n/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `g` is invertible. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z)\n  [inst_3 : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)], CategoryTheory.IsIso g :=\n\n/-- Let `(gâ‚€, gâ‚, ..., gâ‚™)` be a tuple of elements in `Gâ¿âºÂ¹`.\nThen if `k < j`, this says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚– = gâ‚–`.\nIf `k = j`, it says `(gâ‚€gâ‚...gâ‚–â‚‹â‚)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–gâ‚–â‚Šâ‚`.\nIf `k > j`, it says `(gâ‚€gâ‚...gâ‚–)â»Â¹ * gâ‚€gâ‚...gâ‚–â‚Šâ‚ = gâ‚–â‚Šâ‚.`\nUseful for defining group cohomology. -/\ntheorem âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) â†’ G) (j : Fin (n + 1)) (k : Fin n),\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))â»Â¹ *\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\n    Fin.contractNth j (fun x x_1 => x * x_1) g k :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- `G` is closed under inverses -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x âˆˆ self.carrier â†’ xâ»Â¹ âˆˆ self.carrier :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If the stabilizer of `x` is `S`, then the stabilizer of `g â€¢ x` is `gSgâ»Â¹`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : MulAction Î± Î²] (g : Î±) (x : Î²),\n  MulAction.stabilizer Î± (g â€¢ x) = Subgroup.map (MulEquiv.toMonoidHom (â†‘MulAut.conj g)) (MulAction.stabilizer Î± x) :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x : G), â†‘h xâ»Â¹ = (â†‘h x)â»Â¹ :=\n\n/-- If `f` is a left-inverse of `g` then `map f` is a left-inverse of `map g`. -/\ntheorem âˆ€ {R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring Sâ‚] {f : R â†’+* Sâ‚}\n  {g : Sâ‚ â†’+* R}, Function.LeftInverse â†‘f â†‘g â†’ Function.LeftInverse â†‘(MvPolynomial.map f) â†‘(MvPolynomial.map g) :=\n\n/-- By definition, if `x` is invertible then `inverse x = xâ»Â¹`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£), Ring.inverse â†‘u = â†‘uâ»Â¹ :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Consider two actions `fâ‚ fâ‚‚ : G â†’ Î± â†’ Î±` of a group on a complete lattice by order\nisomorphisms. Then the map `x â†¦ â¨† g : G, (fâ‚ g)â»Â¹ (fâ‚‚ g x)` semiconjugates each `fâ‚ g'` to `fâ‚‚ g'`.\n\nThis is a version of Proposition 5.4 from [Ã‰tienne Ghys, Groupes d'homÃ©omorphismes du cercle et\ncohomologie bornÃ©e][ghys87:groupes]. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : CompleteLattice Î±] [inst_1 : Group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G),\n  Function.Semiconj (fun x => â¨† (g' : G), â†‘(â†‘fâ‚ g')â»Â¹ (â†‘(â†‘fâ‚‚ g') x)) â†‘(â†‘fâ‚‚ g) â†‘(â†‘fâ‚ g) :=\n\n/-- If `f` is a right-inverse of `g` then `map f` is a right-inverse of `map g`. -/\ntheorem âˆ€ {R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring Sâ‚] {f : R â†’+* Sâ‚}\n  {g : Sâ‚ â†’+* R}, Function.RightInverse â†‘f â†‘g â†’ Function.RightInverse â†‘(MvPolynomial.map f) â†‘(MvPolynomial.map g) :=\n\n/-- If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type w} [inst : Group G] {x g : G}, orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] (x g : G), orderOf (gâ»Â¹ * x * g) = orderOf x ",
      "âˆ€ {G : Type w} [inst : Group G] (g x : G), orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (g x : G), orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x g : G),\n  orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "forall {G : Type w} [inst : Group G] (g x : G), orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (x g : G), orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "âˆ€ {G : Type w} [inst : Group G] {g x : G}, orderOf x = orderOf (gâ»Â¹ * x * g) ",
      "forall {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (gâ»Â¹ * x * g) ",
      "forall {G : Type u_1} [inst : Group G] (g x : G), orderOf x = orderOf (gâ»Â¹ * x * g) "
    ]
  },
  {
    "docString": "Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"âˆ€ {J K : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.SmallCategory K]\\n  (F : CategoryTheory.Functor (J Ã— K) (Type v)) [inst_2 : CategoryTheory.IsFiltered K] [inst_3 : Finite J],\\n  Function.Injective (CategoryTheory.Limits.colimitLimitToLimitColimit F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"This follows this proof from\\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\\n\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, d â‰  0 â†’ âˆ€ {a : Pell.Solutionâ‚ d}, Pell.Solutionâ‚.x a = 1 â†’ a = 1\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x = 1` is trivial. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [inst : Semiring k] [inst_1 : MulOneClass G] [inst_2 : Semiring R]\\n  {f g : MonoidAlgebra k G â†’+* R},\\n  (âˆ€ (b : k), â†‘f (MonoidAlgebra.single 1 b) = â†‘g (MonoidAlgebra.single 1 b)) â†’\\n    (âˆ€ (a : G), â†‘f (MonoidAlgebra.single a 1) = â†‘g (MonoidAlgebra.single a 1)) â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\\nand `single 1 b`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p :=\n\n/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4 -/\ntheorem âˆ€ {J K : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.SmallCategory K]\n  (F : CategoryTheory.Functor (J Ã— K) (Type v)) [inst_2 : CategoryTheory.IsFiltered K] [inst_3 : Finite J],\n  Function.Injective (CategoryTheory.Limits.colimitLimitToLimitColimit F) :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- A solution with `x = 1` is trivial. -/\ntheorem âˆ€ {d : â„¤}, d â‰  0 â†’ âˆ€ {a : Pell.Solutionâ‚ d}, Pell.Solutionâ‚.x a = 1 â†’ a = 1 :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1 :=\n\n/-- If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\nand `single 1 b`, then they are equal. -/\ntheorem âˆ€ {k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [inst : Semiring k] [inst_1 : MulOneClass G] [inst_2 : Semiring R]\n  {f g : MonoidAlgebra k G â†’+* R},\n  (âˆ€ (b : k), â†‘f (MonoidAlgebra.single 1 b) = â†‘g (MonoidAlgebra.single 1 b)) â†’\n    (âˆ€ (a : G), â†‘f (MonoidAlgebra.single a 1) = â†‘g (MonoidAlgebra.single a 1)) â†’ f = g :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (Î¼ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Î¼] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant Î¼ :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x ^ 2 = 1) â†’ IsLieAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsLieAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ x : G, x ^ 2 = 1) â†’ IsLieAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x ^ 2 = 1) â†’ IsCommutative G "
    ]
  },
  {
    "docString": "If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x â‰  0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {n : â„•},\\n  (âˆ€ (s : Finset A), (AlgebraicIndependent R fun i => â†‘i) â†’ Finset.card s â‰¤ n) â†’\\n    âˆ€ (s : Set A), AlgebraicIndependent R Subtype.val â†’ Cardinal.mk â†‘s â‰¤ â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite set of algebraically independent element has cardinality at most `n`,\\nthen the same is true for arbitrary sets of algebraically independent elements. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {F : Type u} [inst : Field F] {n : â„•}, Polynomial.Separable (Polynomial.X ^ n - 1) â†” â†‘n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"In a field `F`, `X ^ n - 1` is separable iff `â†‘n â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the order of a formal power series is finite,\\nthen the coefficient indexed by the order is nonzero.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] (n : â„•) (a : R) [inst_1 : Decidable (a = 0)],\\n  PowerSeries.order (â†‘(PowerSeries.monomial R n) a) = if a = 0 then âŠ¤ else â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise.\"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, Liouville x â†’ âˆ€ (n : â„•), âˆƒá¶  (b : â„•) in Filter.atTop, âˆƒ a, x â‰  â†‘a / â†‘b âˆ§ |x - â†‘a / â†‘b| < 1 / â†‘b ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\\nexists a numerator `a` such that `x â‰  a / b` and `|x - a / b| < 1 / b ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- If `n * x = 0`, but `n/p * x â‰  0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : â„•},\n  0 < n â†’ n â€¢ x = 0 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ (n / p) â€¢ x â‰  0) â†’ addOrderOf x = n :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If every finite set of algebraically independent element has cardinality at most `n`,\nthen the same is true for arbitrary sets of algebraically independent elements. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {n : â„•},\n  (âˆ€ (s : Finset A), (AlgebraicIndependent R fun i => â†‘i) â†’ Finset.card s â‰¤ n) â†’\n    âˆ€ (s : Set A), AlgebraicIndependent R Subtype.val â†’ Cardinal.mk â†‘s â‰¤ â†‘n :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- In a field `F`, `X ^ n - 1` is separable iff `â†‘n â‰  0`. -/\ntheorem âˆ€ {F : Type u} [inst : Field F] {n : â„•}, Polynomial.Separable (Polynomial.X ^ n - 1) â†” â†‘n â‰  0 :=\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0 :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] (n : â„•) (a : R) [inst_1 : Decidable (a = 0)],\n  PowerSeries.order (â†‘(PowerSeries.monomial R n) a) = if a = 0 then âŠ¤ else â†‘n :=\n\n/-- If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\nexists a numerator `a` such that `x â‰  a / b` and `|x - a / b| < 1 / b ^ n`. -/\ntheorem âˆ€ {x : â„}, Liouville x â†’ âˆ€ (n : â„•), âˆƒá¶  (b : â„•) in Filter.atTop, âˆƒ a, x â‰  â†‘a / â†‘b âˆ§ |x - â†‘a / â†‘b| < 1 / â†‘b ^ n :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G} (h : Â¬IsOfFinOrder x), Function.Injective (fun n : â„¤ => x ^ n) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (n m : â„¤), x ^ n = x ^ m â†” n = m ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (m n : â„¤), x ^ m = x ^ n â†’ m = n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ m n : â„¤, m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (n m : â„¤), n â‰  m â†’ x ^ n â‰  x ^ m ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’\n  âˆ€ (m n : â„¤), x ^ m = x ^ n â†” m = n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (m n : â„¤), x ^ m = x ^ n â†’ m = n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (n m : â„¤), n â‰  m â†’ x ^ n â‰  x ^ m ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (m n : â„¤), m â‰  n â†’ x ^ m â‰  x ^ n ",
      "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, Â¬IsOfFinOrder x â†’ âˆ€ (m n : â„¤), m â‰  n â†’ x ^ m â‰  x ^ n "
    ]
  },
  {
    "docString": "Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n R` is different from `0`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A â‰ƒ+* B â†’ NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R Ã— S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean rings is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\\n  â†‘f (a * b) = â†‘f a * â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (Mâ‚€ : Type u_1) [inst : MulZeroOneClass Mâ‚€] [inst_1 : Nontrivial Mâ‚€], NeZero 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nontrivial monoid with zero, zero and one are different. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\\n  â†‘h (x / y) = â†‘h x / â†‘h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M â‰ƒ* N) (x y : M), â†‘f (x * y) = â†‘f x * â†‘f y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative isomorphism preserves multiplication. \"}]\n",
    "prompt_cons": "/-- `cyclotomic n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0 :=\n\n/-- `cyclotomic' n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0 :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A â‰ƒ+* B â†’ NoZeroDivisors A :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G Ã— K) :=\n\n/-- The cartesian product of two nonarchimedean rings is nonarchimedean. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R Ã— S) :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- Ring homomorphisms preserve multiplication. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\n  â†‘f (a * b) = â†‘f a * â†‘f b :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- In a nontrivial monoid with zero, zero and one are different. -/\ntheorem âˆ€ (Mâ‚€ : Type u_1) [inst : MulZeroOneClass Mâ‚€] [inst_1 : Nontrivial Mâ‚€], NeZero 1 :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\n  â†‘h (x / y) = â†‘h x / â†‘h y :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A multiplicative isomorphism preserves multiplication. -/\ntheorem âˆ€ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M â‰ƒ* N) (x y : M), â†‘f (x * y) = â†‘f x * â†‘f y :=\n\n/-- Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic. -/\ntheorem",
    "choices": [
      "non_iso_real_complex_mul_groups : Â¬(â„â‰ â‚€ â‰ƒ* â„‚â‰ â‚€) ",
      "Â¬(units â„ â‰ƒ* units â„‚) ",
      "Â¬(units â„ â‰ƒ* units â„‚) ",
      "not_iso_real_complex_unit : Â¬(units â„ â‰ƒ* units â„‚) ",
      "â„â‚€ â‰ƒ* â„‚â‚€ â†’ False ",
      "not_isomorphic_complex_real : Â¬(units â„‚ â‰ƒ* units â„) ",
      ":notExistsIso â„â‚€ â„‚â‚€ ",
      "not_iso_mul_groups_real_complex : Â¬(units â„ â‰ƒ* units â„‚) ",
      "non_iso_real_complex_unit : Â¬(units â„ â‰ƒ* units â„‚) ",
      "not_iso_real_complex : Â¬(units â„ â‰ƒ* units â„‚) "
    ]
  },
  {
    "docString": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : CommGroup Î±], IsGroupHom Inv.inv\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inversion is a group homomorphism if the group is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsMulHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A map to a group preserving multiplication is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\\n  (f : F), Function.Injective â†‘f â†” âˆ€ (a : G), â†‘f a = 1 â†” a = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A homomorphism from a group to a monoid is injective iff its kernel is trivial,\\nstated as an iff on the triviality of the kernel.\\nFor the implication, see `injective_iff_map_eq_one`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : AddCommGroup Î²] {f g : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ IsAddGroupHom g â†’ IsAddGroupHom fun a => f a - g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The difference of two additive group homomorphisms is an additive group\\nhomomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\\n  (f : F), Function.Injective â†‘f â†” âˆ€ (a : G), â†‘f a = 1 â†’ a = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A homomorphism from a group to a monoid is injective iff its kernel is trivial.\\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\\n  IsMonoidHom f â†’ âˆ€ (x y : Î±), f (x * y) = f x * f y\",\n  \"isProp\": true,\n  \"docString\": \"A monoid homomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : AddCommGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ IsAddGroupHom fun a => -f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The negation of an additive group homomorphism is an additive group homomorphism\\nif the target is commutative.\"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_2} {Gâ‚€' : Type u_1} {F : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : GroupWithZero Gâ‚€']\\n  [inst_2 : MonoidWithZeroHomClass F Gâ‚€ Gâ‚€'] (f : F) (a : Gâ‚€), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism between groups with zeros sending `0` to `0` sends `aâ»Â¹` to `(f a)â»Â¹`. \"}]\n",
    "prompt_cons": "/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹ :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹ :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem âˆ€ {Î± : Type u} [inst : CommGroup Î±], IsGroupHom Inv.inv :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ f 1 = 1 :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `xâ»Â¹`. -/\ntheorem âˆ€ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, â†‘f x = â†‘g x â†’ â†‘f xâ»Â¹ = â†‘g xâ»Â¹ :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0) :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsMulHom f â†’ IsMonoidHom f :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s) :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c) :=\n\n/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`. -/\ntheorem âˆ€ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\n  (f : F), Function.Injective â†‘f â†” âˆ€ (a : G), â†‘f a = 1 â†” a = 1 :=\n\n/-- The difference of two additive group homomorphisms is an additive group\nhomomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : AddCommGroup Î²] {f g : Î± â†’ Î²},\n  IsAddGroupHom f â†’ IsAddGroupHom g â†’ IsAddGroupHom fun a => f a - g a :=\n\n/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`. -/\ntheorem âˆ€ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\n  (f : F), Function.Injective â†‘f â†” âˆ€ (a : G), â†‘f a = 1 â†’ a = 1 :=\n\n/-- A monoid homomorphism preserves multiplication. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\n  IsMonoidHom f â†’ âˆ€ (x y : Î±), f (x * y) = f x * f y :=\n\n/-- The negation of an additive group homomorphism is an additive group homomorphism\nif the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : AddCommGroup Î²] {f : Î± â†’ Î²},\n  IsAddGroupHom f â†’ IsAddGroupHom fun a => -f a :=\n\n/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `aâ»Â¹` to `(f a)â»Â¹`. -/\ntheorem âˆ€ {Gâ‚€ : Type u_2} {Gâ‚€' : Type u_1} {F : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : GroupWithZero Gâ‚€']\n  [inst_2 : MonoidWithZeroHomClass F Gâ‚€ Gâ‚€'] (f : F) (a : Gâ‚€), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom Inv.inv â†” âˆ€ (a b : Î±), a * b = b * a ",
      "âˆ€ {G : Type u} [inst : Group G], IsGroupHom Inv.inv â†” IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsGroupHom (Î» (g : G), gâ»Â¹) â†” IsCommGroup G ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom Inv.inv â†” IsCommGroup Î± ",
      "âˆ€ {G : Type u} [inst : Group G], IsGroupHom Inv.inv â†” IsCommutative G ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom Inv.inv â†” @IsCommutative Î± (*) ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom Inv.inv â†” IsCommGroup Î± ",
      "âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom Inv.inv â†” IsCommutative Î± ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsGroupHom (Î» (g : G), gâ»Â¹) â†” IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G], IsGroupHom Inv.inv â†” IsCommGroup G "
    ]
  },
  {
    "docString": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\\n  Nat.card { x // x âˆˆ commutator G } âˆ£\\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card â†‘(commutatorSet G) + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` has `n` commutators `[gâ‚, gâ‚‚]`, then `|G'| âˆ£ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\\nwhere `G'` denotes the commutator of `G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\\n  Nat.card { x // x âˆˆ commutator G } â‰¤ Subgroup.cardCommutatorBound (Nat.card â†‘(commutatorSet G))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\\ncommutators. \"},\n {\"theorem\": \"âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\\n  [inst : T2Space Î±], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible Tâ‚‚ space. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `G` has `n` commutators `[gâ‚, gâ‚‚]`, then `|G'| âˆ£ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\nwhere `G'` denotes the commutator of `G`. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\n  Nat.card { x // x âˆˆ commutator G } âˆ£\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card â†‘(commutatorSet G) + 1) :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\ncountable neighborhood basis. -/\ntheorem âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\ncommutators. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\n  Nat.card { x // x âˆˆ commutator G } â‰¤ Subgroup.cardCommutatorBound (Nat.card â†‘(commutatorSet G)) :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H) :=\n\n/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- There does not exist a nontrivial preirreducible Tâ‚‚ space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] [inst_2 : Nontrivial Î±]\n  [inst : T2Space Î±], False :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [Fintype G] {H : Subgroup G},\n  Fintype.card G > 2 â†’ Fintype.card { x // x âˆˆ H } â‰  Fintype.card G - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•} (H : Subgroup G),\n  Fintype.card G = n â†’ n > 2 â†’ Fintype.card { x // x âˆˆ H } â‰  n - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  2 < n â†’ Fintype.card G = n â†’ âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = n - 1 â†’ False ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (n : â„•) (H : Subgroup G),\n  Fintype.card G = n â†’ n > 2 â†’ Fintype.card { x // x âˆˆ H } â‰  n - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  2 < n â†’ Fintype.card G = n â†’ Â¬âˆƒ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = n - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  2 < Fintype.card G â†’ Fintype.card { x // x âˆˆ H } â‰  Fintype.card G - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [_inst : Fintype G] {H : Subgroup G},\n  2 < Fintype.card G â†’ Fintype.card { x // x âˆˆ H } = Fintype.card G - 1 â†’ False ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•} (H : Subgroup G),\n  Fintype.card G = n â†’ n > 2 â†’ Fintype.card { x // x âˆˆ H } â‰  n - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  Fintype.card G > 2 â†’ Fintype.card { x // x âˆˆ H } â‰  Fintype.card G - 1 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•}, Fintype.card G = n â†’ n > 2 â†’\n  âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } â‰  n - 1 "
    ]
  },
  {
    "docString": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {s : Set M}, s âŠ† â†‘(Subsemigroup.closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The subsemigroup generated by a set includes the set. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G],\\n  Group.nilpotencyClass { x // x âˆˆ H } â‰¤ Group.nilpotencyClass G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A the nilpotency class of a subgroup is less or equal to the nilpotency class of the group \"}]\n",
    "prompt_cons": "/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H) :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ :=\n\n/-- The subsemigroup generated by a set includes the set. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {s : Set M}, s âŠ† â†‘(Subsemigroup.closure s) :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- A the nilpotency class of a subgroup is less or equal to the nilpotency class of the group -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G],\n  Group.nilpotencyClass { x // x âˆˆ H } â‰¤ Group.nilpotencyClass G :=\n\n/-- Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H \\ {1}) ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (coe H \\ {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (coe H \\ {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H - {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H \\ {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G], âˆ€ (H : Subgroup G),\n  H = Subgroup.closure (H \\ {1}) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H \\ {1}) "
    ]
  },
  {
    "docString": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R} [self : Ideal.IsLocal I], Ideal.IsMaximal (Ideal.jacobson I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is local if and only if its jacobson radical is maximal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H) {f : LocalHomeomorph H H},\\n  f âˆˆ G â†’ f âˆˆ StructureGroupoid.maximalAtlas H G\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the model space, any element of the groupoid is in the maximal atlas. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G } :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- A ring `R` is local if and only if its jacobson radical is maximal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R} [self : Ideal.IsLocal I], Ideal.IsMaximal (Ideal.jacobson I) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- In the model space, any element of the groupoid is in the maximal atlas. -/\ntheorem âˆ€ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H) {f : LocalHomeomorph H H},\n  f âˆˆ G â†’ f âˆˆ StructureGroupoid.maximalAtlas H G :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Show that the subgroup of all rotations in a dihedral group is a maximal subgroup. -/\ntheorem",
    "choices": [
      "forall {n : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  IsDihedral G n â†’ H = Subgroup.rotationSubgroup n â†’ IsCoatom H ",
      "âˆ€ {n : â„•} (hn : 0 < n) (g : Zmod n) (h : nZmod.star n), IsCoatom (DihedralGroup.rotationSubgroup n) ",
      "âˆ€ {n : â„•} {hn : Zero.zero < n} (H : Subgroup (DihedralGroup n)),\n  (âˆ€ (i : Zmod n), DihedralGroup.r i âˆˆ H) â†’ IsCoatom H ",
      "âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] [dih : DihedralGroup n], n â‰¥ 3 â†’ IsCoatom (DihedralGroup.rotationsSubgroup n G) ",
      "âˆ€ {n : â„•} (hn : 0 < n), IsCoatom (DihedralGroup.rotationSubgroup n) ",
      "âˆ€ {n : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], DihedralGroup n â‰ƒ G â†’ IsMaximal (Subgroup.rotations n) ",
      "âˆ€ {n : â„•} (hn : 0 < n), IsCoatom (DihedralGroup.rotationSubgroup n) ",
      "forall {n : â„•} {G : Type u_1} [inst : Group G], IsDihedral G n â†’ IsCoatom (Dihedral.rotationSubgroup G n) ",
      "âˆ€ {n : â„•} {hn : Zero.zero < n} (H : Subgroup (DihedralGroup n)),\n  (âˆ€ (i : Zmod n), Subgroup.zpowers H (DihedralGroup.r i)) â†’ IsCoatom H â†’ Subgroup.Normal H ",
      "forall {n : â„•} (hn : 2 â‰¤ n), IsCoatom (Subgroup.zpowers (DihedralGroup.r (orderOf (DihedralGroup.r n)))) "
    ]
  },
  {
    "docString": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (i : Î¹), âˆƒ j, â†‘(B j) * â†‘(B j) âŠ† â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\\nthat the set-theoretic product `B' * B'` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\\n  â†‘h (x / y) = â†‘h x / â†‘h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} {A : Type u} {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] (x : B), x âˆˆ Algebra.adjoin A {b | âˆƒ n, n âˆˆ S âˆ§ b ^ â†‘n = 1}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`-th roots of unity, for `n âˆˆ S`, generate `B` as an `A`-algebra. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A â†’ Algebra.IsIntegral A B â†’ Algebra.IsIntegral R B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand B is an A-algebra all of whose elements are integral over A,\\nthen all elements of B are integral over R.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"}]\n",
    "prompt_cons": "/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), â†‘f (a / b) = â†‘f a / â†‘f b :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\nthat the set-theoretic product `B' * B'` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (i : Î¹), âˆƒ j, â†‘(B j) * â†‘(B j) âŠ† â†‘(B i) :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G â‰ƒ* H) (x y : G),\n  â†‘h (x / y) = â†‘h x / â†‘h y :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- The `n`-th roots of unity, for `n âˆˆ S`, generate `B` as an `A`-algebra. -/\ntheorem âˆ€ {S : Set â„•+} {A : Type u} {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] (x : B), x âˆˆ Algebra.adjoin A {b | âˆƒ n, n âˆˆ S âˆ§ b ^ â†‘n = 1} :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c â†’ Prop} (q : Con.Quotient c), (âˆ€ (x : M), C â†‘x) â†’ C q :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand B is an A-algebra all of whose elements are integral over A,\nthen all elements of B are integral over R. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A â†’ Algebra.IsIntegral A B â†’ Algebra.IsIntegral R B :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian. -/\ntheorem",
    "choices": [
      "forall {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), IsAddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), AddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), IsAddCommutative (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), IsAddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] {H : AddSubgroup G}, AddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), IsAddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), IsAddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), IsAddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), IsAddCommGroup (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), IsAddSubgroup H â†’ IsAddCommGroup (G â§¸ H) "
    ]
  },
  {
    "docString": "Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {P Q : Subgroup M},\\n  MulAction.fixedPoints { x // x âˆˆ P âŠ” Q } Î± =\\n    MulAction.fixedPoints { x // x âˆˆ P } Î± âˆ© MulAction.fixedPoints { x // x âˆˆ Q } Î±\",\n  \"isProp\": true,\n  \"docString\": \"Fixed points of sup of subgroups is intersection \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Î“ : Subgroup G}\\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G â§¸ Î“)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a second countable topological group by a subgroup is second countable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `âŠ¥` or `âŠ¤` \"},\n {\"theorem\":\n  \"âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"theorem\":\n  \"âˆ€ (M : Type u_2) (Î± : Type u_1) [inst : Group M] [inst_1 : MulAction M Î±] {s t : Set Î±},\\n  fixingSubgroup M (s âˆª t) = fixingSubgroup M s âŠ“ fixingSubgroup M t\",\n  \"isProp\": true,\n  \"docString\": \"Fixing subgroup of union is intersection \"}]\n",
    "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1 :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- Fixed points of sup of subgroups is intersection -/\ntheorem âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {P Q : Subgroup M},\n  MulAction.fixedPoints { x // x âˆˆ P âŠ” Q } Î± =\n    MulAction.fixedPoints { x // x âˆˆ P } Î± âˆ© MulAction.fixedPoints { x // x âˆˆ Q } Î± :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- The quotient of a second countable topological group by a subgroup is second countable. -/\ntheorem âˆ€ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Î“ : Subgroup G}\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G â§¸ Î“) :=\n\n/-- Any normal subgroup is either `âŠ¥` or `âŠ¤` -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤ :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\ncountable neighborhood basis. -/\ntheorem âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  0 :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- Fixing subgroup of union is intersection -/\ntheorem âˆ€ (M : Type u_2) (Î± : Type u_1) [inst : Group M] [inst_1 : MulAction M Î±] {s t : Set Î±},\n  fixingSubgroup M (s âˆª t) = fixingSubgroup M s âŠ“ fixingSubgroup M t :=\n\n/-- Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable). -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ Set.Nonempty S â†’ Subgroup.Normal (â¨… H âˆˆ S, H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {s : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ s â†’ Subgroup.Normal H) â†’ Set.Nonempty s â†’ Subgroup.Normal (â‹‚â‚€ s) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, \n  (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’\n  Set.Nonempty S â†’ Subgroup.Normal (â‹‚â‚€ S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {s : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ s â†’ Subgroup.Normal H) â†’ Set.Nonempty s â†’ Subgroup.Normal (â‹‚â‚€ s) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {s : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ s â†’ Subgroup.Normal H) â†’\n  (âˆƒ (x : Subgroup G), x âˆˆ s) â†’ Subgroup.Normal (â‹‚â‚€ s) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ Set.Nonempty S â†’ Subgroup.Normal (â‹‚â‚€ S) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î¹ : Type u_2} {s : Î¹ â†’ Subgroup G} (hs : âˆ€ i, Subgroup.Normal (s i)),\n  Subgroup.Normal (infi s) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î¹ : Type u_2} (S : Î¹ â†’ Subgroup G),\n  (âˆ€ i : Î¹, Subgroup.Normal (S i)) â†’ (âˆƒ i : Î¹, True) â†’ Subgroup.Normal (â‹‚ i, S i) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’\n  Set.Nonempty S â†’ Subgroup.Normal (â¨… H âˆˆ S, H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (âˆ€ (H : Subgroup G), H âˆˆ S â†’ Subgroup.Normal H) â†’ (âˆƒ x, x âˆˆ S) â†’\n  Subgroup.Normal (â‹‚â‚€ S) "
    ]
  },
  {
    "docString": "Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  IntermediateField.fixingSubgroup âŠ¥ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"This lemma says that `Gal(L/K) = L â‰ƒâ‚[K] L` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure â†‘K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\\n  â†‘f (a * b) = â†‘f a * â†‘f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {J : Type w}\\n  [inst_2 : CategoryTheory.Category J] (K : CategoryTheory.Functor J C) (F : CategoryTheory.Functor C D)\\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp K F)]\\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `F` creates the limit of `K` and `K â‹™ F` has a limit, then `K` has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K], IsCompl K Ká—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` admits an orthogonal projection, `K` and `Ká—®` are complements of each other. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Î“ T] [self : ProperlyDiscontinuousVAdd Î“ T]\\n  {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite {Î³ | (fun x => Î³ +áµ¥ x) '' K âˆ© L â‰  âˆ…}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets `K` and `L`, `Î³ +áµ¥ K âˆ© L` is nonempty for finitely many `Î³`. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Î“ T] [self : ProperlyDiscontinuousSMul Î“ T]\\n  {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite {Î³ | (fun x => Î³ â€¢ x) '' K âˆ© L â‰  âˆ…}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets `K` and `L`, `Î³ â€¢ K âˆ© L` is nonempty for finitely many `Î³`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\\n  Nat.card { x // x âˆˆ commutator G } â‰¤ Subgroup.cardCommutatorBound (Nat.card â†‘(commutatorSet G))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\\ncommutators. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F) :=\n\n/-- This lemma says that `Gal(L/K) = L â‰ƒâ‚[K] L` -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  IntermediateField.fixingSubgroup âŠ¥ = âŠ¤ :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure â†‘K = K :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- Ring homomorphisms preserve multiplication. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±),\n  â†‘f (a * b) = â†‘f a * â†‘f b :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `F` creates the limit of `K` and `K â‹™ F` has a limit, then `K` has a limit. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (K : CategoryTheory.Functor J C) (F : CategoryTheory.Functor C D)\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp K F)]\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K :=\n\n/-- If `K` admits an orthogonal projection, `K` and `Ká—®` are complements of each other. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K], IsCompl K Ká—® :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- Given two compact sets `K` and `L`, `Î³ +áµ¥ K âˆ© L` is nonempty for finitely many `Î³`. -/\ntheorem âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Î“ T] [self : ProperlyDiscontinuousVAdd Î“ T]\n  {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite {Î³ | (fun x => Î³ +áµ¥ x) '' K âˆ© L â‰  âˆ…} :=\n\n/-- Given two compact sets `K` and `L`, `Î³ â€¢ K âˆ© L` is nonempty for finitely many `Î³`. -/\ntheorem âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Î“ T] [self : ProperlyDiscontinuousSMul Î“ T]\n  {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite {Î³ | (fun x => Î³ â€¢ x) '' K âˆ© L â‰  âˆ…} :=\n\n/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\ncommutators. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)],\n  Nat.card { x // x âˆˆ commutator G } â‰¤ Subgroup.cardCommutatorBound (Nat.card â†‘(commutatorSet G)) :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite). -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H = Subgroup.index K * Subgroup.index (Subgroup.restrict H K) ",
      "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’ Fintype.card (K // H) * Fintype.card (G // K) = Fintype.card (G // H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H = Subgroup.index K * Subgroup.index (Subgroup.comap K.subtype H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  (H â‰¤ K) â†’ (K â‰¤ G) â†’ QuotientGroup.card (G â§¸ K) * QuotientGroup.card (K â§¸ H) = QuotientGroup.card (G â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Cardinal.mk (QuotientGroup.quotient H) * Cardinal.mk { x // x âˆˆ K } = Cardinal.mk (QuotientGroup.quotient K) * Cardinal.mk { x // x âˆˆ H } ",
      "âˆ€ {G : Type u} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’ âˆ€ (g1 g2 : QuotientGroup.quotient H),\n  g1 âˆˆ QuotientGroup.mk' K â†’\n    g2 âˆˆ QuotientGroup.mk' K â†’\n      âˆ€ (g3 g4 : QuotientGroup.quotient K),\n        QuotientGroup.lift H (QuotientGroup.mk' K) (_ : âˆ€ (x : G), x âˆˆ H â†’ (â†‘(QuotientGroup.mk' K) x).1 = 1) g1 = g3 â†’\n          QuotientGroup.lift H (QuotientGroup.mk' K) (_ : âˆ€ (x : G), x âˆˆ H â†’ (â†‘(QuotientGroup.mk' K) x).1 = 1) g2 = g4 â†’\n            QuotientGroup.lift K (QuotientGroup.mk' H) (_ : âˆ€ (x : G), x âˆˆ K â†’ (â†‘(QuotientGroup.mk' H) x).1 = 1) g3 *\n                QuotientGroup.lift K (QuotientGroup.mk' H) (_ : âˆ€ (x : G), x âˆˆ K â†’ (â†‘(QuotientGroup.mk' H) x).1 = 1) g4 =\n              QuotientGroup.lift H (QuotientGroup.mk' H) (_ : âˆ€ (x : G), x âˆˆ H â†’ (â†‘(QuotientGroup.mk' H) x).1 = 1) g1 *\n                QuotientGroup.lift H (QuotientGroup.mk' H) (_ : âˆ€ (x : G), x âˆˆ H â†’ (â†‘(QuotientGroup.mk' H) x).1 = 1) g2 ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  QuotientGroup.mk' (K.comap H.subtype) â‰ƒ QuotientGroup.mk' (G.comap K.subtype) Ã— QuotientGroup.mk' (K.comap H.subtype) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’ Fintype.card (G â§¸ H) = Fintype.card (G â§¸ K) * Fintype.card (K â§¸ H) ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’\n  Nat.card { x // x âˆˆ Subgroup.relindex H G } = Nat.card { x // x âˆˆ Subgroup.relindex K G } * Nat.card { x // x âˆˆ Subgroup.relindex H K } ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, H â‰¤ K â†’ Subgroup.index H = Subgroup.index K * Subgroup.index (K.comap H.subtype) "
    ]
  },
  {
    "docString": "Prove that $\\mathbb{Q}$ has no proper subgroups of finite index.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\\n  {s : Set Î¹} [inst_3 : IsNoetherian K V], Basis (â†‘s) K V â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian module over a division ring,\\nif a basis is indexed by a set, that set is finite. \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Semigroup M] [inst_1 : Nonempty M] (s : Set (Set M)),\\n  Set.Finite s â†’ âŠ¤ âŠ† â‹ƒâ‚€ s â†’ âˆƒ c, c âˆˆ s âˆ§ âˆƒ a, Hindman.FP a âŠ† c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The weak form of **Hindman's theorem**: in any finite cover of a nonempty semigroup, one of the\\nparts contains an FP-set. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : Finite Î“], ProperlyDiscontinuousSMul Î“ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G â†’* R), f â‰  1 â†’ (Finset.sum Finset.univ fun g => â†‘f g) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- The additive subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0 :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- In a noetherian module over a division ring,\nif a basis is indexed by a set, that set is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  {s : Set Î¹} [inst_3 : IsNoetherian K V], Basis (â†‘s) K V â†’ Set.Finite s :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- The weak form of **Hindman's theorem**: in any finite cover of a nonempty semigroup, one of the\nparts contains an FP-set. -/\ntheorem âˆ€ {M : Type u_1} [inst : Semigroup M] [inst_1 : Nonempty M] (s : Set (Set M)),\n  Set.Finite s â†’ âŠ¤ âŠ† â‹ƒâ‚€ s â†’ âˆƒ c, c âˆˆ s âˆ§ âˆƒ a, Hindman.FP a âŠ† c :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : Finite Î“], ProperlyDiscontinuousSMul Î“ T :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\n  (f : G â†’* R), f â‰  1 â†’ (Finset.sum Finset.univ fun g => â†‘f g) = 0 :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- Prove that $\\mathbb{Q}$ has no proper subgroups of finite index. -/\ntheorem",
    "choices": [
      "âˆ€ {H : AddSubgroup â„š} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H = 1 ",
      "forall {H : AddSubgroup â„š} [h : AddSubgroup.FiniteIndex H], H = âŠ¤ ",
      "âˆ€ {H : AddSubgroup â„š} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H = 1 ",
      "âˆ€ {H : AddSubgroup â„š}, AddSubgroup.FiniteIndex H â†’ AddSubgroup.index H = 1 ",
      "âˆ€ {H : AddSubgroup â„š} [inst : AddSubgroup.FiniteIndex H], AddSubgroup.index H = 0 ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Subgroup.FiniteIndex G], IsFractionRing â„š G â†’ G = âŠ¤ ",
      "âˆ€ {H : AddSubgroup â„š} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H = 1 ",
      "âˆ€ {H : AddSubgroup â„š}, AddSubgroup.FiniteIndex H â†’ AddSubgroup.index H = 1 ",
      "âˆ€ {H : AddSubgroup â„š} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H = 1 ",
      "âˆ€ {H : AddSubgroup â„š} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H = 1 "
    ]
  },
  {
    "docString": "Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"}]\n",
    "prompt_cons": "/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], âˆƒ Î¹ x p x e, Nonempty (G â‰ƒ+ â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `â„¤` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem âˆ€ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  âˆƒ n Î¹ x p x e, Nonempty (G â‰ƒ+ (Fin n â†’â‚€ â„¤) Ã— â¨ (i : Î¹), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0 :=\n\n/-- Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group). -/\ntheorem",
    "choices": [
      "âˆ€ (G : Type u) [inst : AddCommGroup G], IsSimpleAddGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : IsSimpleAddGroup G],\n  âˆƒ p [inst_2 : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [h : IsSimpleAddGroup G], âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G], IsSimpleAddGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [hG : IsSimpleAddGroup G], âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [is_simple : IsSimpleAddGroup G], âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ (G : Type u) [inst : AddCommGroup G], IsSimpleAddGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [h : IsSimpleAddGroup G], \n  âˆƒ (p : â„•) [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G], IsSimpleAddGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) ",
      "âˆ€ {G : Type u} [inst : AddCommGroup G] [inst_1 : IsSimpleAddGroup G], \n  âˆƒ (p : â„•) [hp : Fact (Nat.Prime p)], Nonempty (G â‰ƒ+ ZMod p) "
    ]
  },
  {
    "docString": "Prove that subgroups of a solvable group are solvable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [self : IsSolvable G], âˆƒ n, derivedSeries G n = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group `G` is solvable if its derived series is eventually trivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x âˆˆ H â†’ xâ»Â¹ âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under inverse. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {P Q : Subgroup M},\\n  MulAction.fixedPoints { x // x âˆˆ P âŠ” Q } Î± =\\n    MulAction.fixedPoints { x // x âˆˆ P } Î± âˆ© MulAction.fixedPoints { x // x âˆˆ Q } Î±\",\n  \"isProp\": true,\n  \"docString\": \"Fixed points of sup of subgroups is intersection \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) â†’ S = T\",\n  \"isProp\": true,\n  \"docString\": \"Two subsemigroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"âˆ€ (M : Type u_2) (Î± : Type u_1) [inst : Group M] [inst_1 : MulAction M Î±],\\n  GaloisConnection (â†‘OrderDual.toDual âˆ˜ fixingSubgroup M)\\n    ((fun P => MulAction.fixedPoints { x // x âˆˆ P } Î±) âˆ˜ â†‘OrderDual.ofDual)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Galois connection between fixing subgroups and fixed points of a group action \"}]\n",
    "prompt_cons": "/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A group `G` is solvable if its derived series is eventually trivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [self : IsSolvable G], âˆƒ n, derivedSeries G n = âŠ¥ :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- A subgroup is closed under inverse. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x âˆˆ H â†’ xâ»Â¹ âˆˆ H :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- Fixed points of sup of subgroups is intersection -/\ntheorem âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {P Q : Subgroup M},\n  MulAction.fixedPoints { x // x âˆˆ P âŠ” Q } Î± =\n    MulAction.fixedPoints { x // x âˆˆ P } Î± âˆ© MulAction.fixedPoints { x // x âˆˆ Q } Î± :=\n\n/-- Two subsemigroups are equal if they have the same elements. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) â†’ S = T :=\n\n/-- The Galois connection between fixing subgroups and fixed points of a group action -/\ntheorem âˆ€ (M : Type u_2) (Î± : Type u_1) [inst : Group M] [inst_1 : MulAction M Î±],\n  GaloisConnection (â†‘OrderDual.toDual âˆ˜ fixingSubgroup M)\n    ((fun P => MulAction.fixedPoints { x // x âˆˆ P } Î±) âˆ˜ â†‘OrderDual.ofDual) :=\n\n/-- Prove that subgroups of a solvable group are solvable. -/\ntheorem",
    "choices": [
      "forall {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "forall {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G), IsSolvable {x // x âˆˆ H} ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [is_solvable : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x âˆˆ H } "
    ]
  },
  {
    "docString": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G â†’* H),\\n  OpenEmbedding â†‘f â†’ NonarchimedeanGroup H\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"}]\n",
    "prompt_cons": "/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1 :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G â†’* H),\n  OpenEmbedding â†‘f â†’ NonarchimedeanGroup H :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' N H :=\n\n/-- Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] {H : Subgroup G} [inst_2 : Nontrivial { x // x âˆˆ H }],\n  Subgroup.Normal H â†’ âˆƒ A : Subgroup G, Subgroup.Normal A âˆ§ IsAbelian A âˆ§ Nontrivial { x // x âˆˆ A } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [is_solvable : IsSolvable G],\n  âˆ€ {H : Subgroup G} [inst_1 : Subgroup.Normal H] [nontrivial : Nontrivial { x // x âˆˆ H }],\n    âˆƒ (A : Subgroup G), A â‰¤ H âˆ§ A â‰  âŠ¥ âˆ§ Subgroup.Normal A âˆ§ IsAbelian { x // x âˆˆ A } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] {H : Subgroup G} [inst_2 : Subgroup.Normal H],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ A : Subgroup G, Nontrivial { x // x âˆˆ A } âˆ§ Subgroup.Normal A âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsSolvable G] (H : Subgroup G) [Subgroup.Normal H],\n  Nontrivial { x // x âˆˆ H } â†’ âˆƒ A : Subgroup G, A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsCommGroup A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G],\n  âˆ€ {H : Subgroup G} [_inst_1 : Subgroup.Normal H], Nontrivial { x // x âˆˆ H } â†’\n    âˆƒ A : Subgroup G, Nontrivial { x // x âˆˆ A } âˆ§ A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian G A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] {H : Subgroup G},\n  Nontrivial {x // x âˆˆ H} â†’ Subgroup.Normal H â†’\n  âˆƒ A : Subgroup G, Nontrivial {x // x âˆˆ A} âˆ§ A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian (â†¥A) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] (H : Subgroup G),\n  Nontrivial { x // x âˆˆ H } â†’ Subgroup.Normal H â†’ âˆƒ A : Subgroup G, A â‰¤ H âˆ§ Nontrivial { x // x âˆˆ A } âˆ§ Subgroup.Normal A âˆ§ IsAbelian A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] {H : Subgroup G}\n  [inst_1 : Subgroup.Normal H] [nontriv : Nontrivial { x // x âˆˆ H }],\n  âˆƒ (A : Subgroup G), A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian A âˆ§ Nontrivial { x // x âˆˆ A } ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] {H : Subgroup G},\n  Nontrivial { x // x âˆˆ H } â†’ Subgroup.Normal H â†’\n    âˆƒ (A : Subgroup G), Nontrivial { x // x âˆˆ A } âˆ§ A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian G A ",
      "âˆ€ {G : Type u_1} [inst : Group G] [h : IsSolvable G] {H : Subgroup G},\n  Nontrivial { x // x âˆˆ H } â†’ Subgroup.Normal H â†’ âˆƒ A : Subgroup G, Nontrivial { x // x âˆˆ A } âˆ§ A â‰¤ H âˆ§ Subgroup.Normal A âˆ§ IsAbelian A "
    ]
  },
  {
    "docString": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)},\\n  g âˆˆ alternatingGroup (Fin 5) â†’\\n    g â‰  1 â†’ (âˆ€ (n : â„•), n âˆˆ Equiv.Perm.cycleType g â†’ n = 2) â†’ IsConj (Equiv.swap 0 4 * Equiv.swap 1 3) g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\\nis conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\\nin $A_5$ is $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : Finite Î“], ProperlyDiscontinuousSMul Î“ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun Î± G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] {ğ”– : Set (Set Î±)} [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformOnFun Î± G ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `ğ”– : Set (Set Î±)`. If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group as\\nwell. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\\n  {K L : Set G}, IsCompact K â†’ IsCompact L â†’ âˆƒ g, Disjoint K (g â€¢ L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets in a noncompact topological group, there is a translate of the second\\none that is disjoint from the first one. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\\nelement, then `S` is dense `G`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_2} [inst : Group G],\\n  IsPGroup p G â†’\\n    âˆ€ [hp : Fact (Nat.Prime p)] (Î± : Type u_1) [inst_1 : MulAction G Î±] [inst_2 : Fintype Î±]\\n      [inst_3 : Fintype â†‘(MulAction.fixedPoints G Î±)],\\n      Fintype.card Î± â‰¡ Fintype.card â†‘(MulAction.fixedPoints G Î±) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a `p`-group acting on a finite set `Î±`, then the number of fixed points\\nof the action is congruent mod `p` to the cardinality of `Î±` \"}]\n",
    "prompt_cons": "/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\nis conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\nin $A_5$ is $A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)},\n  g âˆˆ alternatingGroup (Fin 5) â†’\n    g â‰  1 â†’ (âˆ€ (n : â„•), n âˆˆ Equiv.Perm.cycleType g â†’ n = 2) â†’ IsConj (Equiv.swap 0 4 * Equiv.swap 1 3) g :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : Finite Î“], ProperlyDiscontinuousSMul Î“ T :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g :=\n\n/-- If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun Î± G) :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Let `ğ”– : Set (Set Î±)`. If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group as\nwell. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] {ğ”– : Set (Set Î±)} [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformOnFun Î± G ğ”–) :=\n\n/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\n  {K L : Set G}, IsCompact K â†’ IsCompact L â†’ âˆƒ g, Disjoint K (g â€¢ L) :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S :=\n\n/-- If `G` is a `p`-group acting on a finite set `Î±`, then the number of fixed points\nof the action is congruent mod `p` to the cardinality of `Î±` -/\ntheorem âˆ€ {p : â„•} {G : Type u_2} [inst : Group G],\n  IsPGroup p G â†’\n    âˆ€ [hp : Fact (Nat.Prime p)] (Î± : Type u_1) [inst_1 : MulAction G Î±] [inst_2 : Fintype Î±]\n      [inst_3 : Fintype â†‘(MulAction.fixedPoints G Î±)],\n      Fintype.card Î± â‰¡ Fintype.card â†‘(MulAction.fixedPoints G Î±) [MOD p] :=\n\n/-- Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : DecidableEq A]\n  [MulAction G A] [has_faithful_scalar G A] (hg : MulAction.is_transitive G A) (hA : Fintype.card A > 1),\n  âˆƒ Ïƒ : G, âˆ€ a : A, MulAction.toPerm Ïƒ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : DecidableEq A]\n  [inst_3 : MulAction G A] [hA : Nonempty A] [hG : Nontrivial G] [h : MulAction.IsTransitive G A],\n  âˆƒ Ïƒ : G, âˆ€ a : A, Ïƒ â€¢ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : Fintype G] [inst_3 : MulAction G A]\n  (hA : Fintype.card A > 1), Transitive G A â†’ âˆƒ Ïƒ : G, âˆ€ a : A, MulAction.toFun Ïƒ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î± : Type u_2} [inst_1 : Fintype Î±] [inst_2 : DecidableEq Î±]\n  (H : G â†ª* Equiv.Perm Î±) (hH : Subgroup.IsTrans H) (hÎ± : Fintype.card Î± > 1),\n  âˆƒ g, âˆ€ a, coeFn (coeFn H g) a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î± : Type u_2} [inst_1 : Fintype Î±] [inst_2 : Fintype G] [inst_3 : DecidableEq Î±]\n  [inst_4 : MulAction G Î±], Nontrivial Î± â†’ MulAction.IsTransitive G Î± â†’ âˆƒ Ïƒ : G, âˆ€ a : Î±, MulAction.toFun Ïƒ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î± : Type u_2} [Fintype Î±] [MulAction G Î±] [Nontrivial Î±]\n  [inst_1 : Fintype G] [MulAction.IsTransitive G Î±],\n  âˆƒ g, g â‰  1 âˆ§ âˆ€ a, g â€¢ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î± : Type u_2} [inst_1 : Fintype Î±] [inst_2 : DecidableEq Î±] [inst_3 : MulAction G Î±],\n  Fintype.card Î± > 1 â†’ MulAction.IsTransitive G Î± â†’ âˆƒ (Ïƒ : G), âˆ€ (a : Î±), Ïƒ â€¢ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {Î± : Type u_2} [inst_1 : MulAction G Î±] [inst_2 : Fintype Î±]\n  (hG : MulAction.IsTransitive G Î±) (hÎ± : 1 < Fintype.card Î±),\n  âˆƒ g, g âˆˆ G âˆ§ âˆ€ (a : Î±), g â€¢ a â‰  a ",
      "âˆ€ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : MulAction G A] [hA : Nonempty A] [nontrivial : Fact (2 â‰¤ Fintype.card A)],\n  Transitive G A â†’ âˆƒ (Ïƒ : G), âˆ€ a : A, Ïƒ â€¢ a â‰  a ",
      "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±] [inst_2 : Nontrivial Î±] {G : Type u_3} [inst_3 : Group G] [inst_4 : MulAction G Î±],\n  MulAction.IsTransitive G Î± â†’ âˆƒ g, âˆ€ a, g â€¢ a â‰  a "
    ]
  },
  {
    "docString": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„•}, 0 < a â†’ ((âˆƒ k, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\\nelement, then `S` is dense `G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"âˆ€ {m n k : â„•}, n * k < m â†’ m < n * (k + 1) â†’ Â¬n âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"`m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ (m : â„¤) {n : â„¤}, 0 < n â†’ ((âˆƒ k, n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\\nfor some `k`. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- `n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. -/\ntheorem âˆ€ (n : â„•) {a : â„•}, 0 < a â†’ ((âˆƒ k, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n) :=\n\n/-- Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S â‰  âŠ¥ â†’ (Â¬âˆƒ a, IsLeast {g | g âˆˆ S âˆ§ 0 < g} a) â†’ Dense â†‘S :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If `x^n = 1`, but `x^(n/p) â‰  1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} {n : â„•},\n  0 < n â†’ x ^ n = 1 â†’ (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) â†’ orderOf x = n :=\n\n/-- `m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem âˆ€ {m n k : â„•}, n * k < m â†’ m < n * (k + 1) â†’ Â¬n âˆ£ m :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem âˆ€ {Î± : Type u} [self : OrderedCommGroup Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c * a â‰¤ c * b :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\nfor some `k`. -/\ntheorem âˆ€ (m : â„¤) {n : â„¤}, 0 < n â†’ ((âˆƒ k, n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m) :=\n\n/-- Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  0 < n â†’ composite n â†’ (âˆ€ (k : â„•), 0 < k â†’ k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  1 < n â†’ (âˆ€ k, 0 < k â†’ k âˆ£ n â†’ âˆƒ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  0 < n â†’ nat.comp n â†’ (âˆ€ (k : â„•), 0 < k â†’ k âˆ£ n â†’ âˆƒ (H : Subgroup G), Fintype.card {x // x âˆˆ H} = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  1 < n â†’ (âˆ€ (k : â„•), 0 < k â†’ k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : â„•),\n  0 < n â†’ Fintype.card G = n â†’ (Â¬Nat.Prime n) â†’ (âˆ€ k, k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : â„•),\n  (âˆ€ k, 0 < k â†’ k âˆ£ Fintype.card G â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’\n    Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  0 < n â†’ Fintype.card G = n â†’ (Â¬Nat.Prime n) â†’ (âˆ€ k, k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : â„•),\n  n = Fintype.card G â†’ Â¬Nat.Prime n â†’ (âˆ€ k, k > 0 â†’ k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  0 < n â†’ Fintype.card G = n â†’ (âˆ€ (k : â„•), k âˆ£ n â†’ âˆƒ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : â„•},\n  1 < n â†’ (âˆ€ k, k âˆ£ n â†’ âˆƒ H : Subgroup G, Fintype.card { x // x âˆˆ H } = k) â†’ Â¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that characteristic subgroups are normal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `âŠ¥` or `âŠ¤` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of `s` is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {P Q : Subgroup M},\\n  MulAction.fixedPoints { x // x âˆˆ P âŠ” Q } Î± =\\n    MulAction.fixedPoints { x // x âˆˆ P } Î± âˆ© MulAction.fixedPoints { x // x âˆˆ Q } Î±\",\n  \"isProp\": true,\n  \"docString\": \"Fixed points of sup of subgroups is intersection \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : AddGroup A] [self : IsSimpleAddGroup A] (H : AddSubgroup A),\\n  AddSubgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal additive subgroup is either `âŠ¥` or `âŠ¤` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\\n  p â‰  0 â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"}]\n",
    "prompt_cons": "/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Any normal subgroup is either `âŠ¥` or `âŠ¤` -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤ :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- The normal closure of `s` is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s) :=\n\n/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ âˆƒ x, x âˆˆ H âˆ§ x â‰  1 :=\n\n/-- Fixed points of sup of subgroups is intersection -/\ntheorem âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {P Q : Subgroup M},\n  MulAction.fixedPoints { x // x âˆˆ P âŠ” Q } Î± =\n    MulAction.fixedPoints { x // x âˆˆ P } Î± âˆ© MulAction.fixedPoints { x // x âˆˆ Q } Î± :=\n\n/-- Any normal additive subgroup is either `âŠ¥` or `âŠ¤` -/\ntheorem âˆ€ {A : Type u_1} [inst : AddGroup A] [self : IsSimpleAddGroup A] (H : AddSubgroup A),\n  AddSubgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤ :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\n  p â‰  0 â†’ Nat.Prime p :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K :=\n\n/-- Prove that characteristic subgroups are normal. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.IsCharSubgroup H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H â†’ Subgroup.Normal H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.IsCharacteristic H â†’ Subgroup.Normal H "
    ]
  },
  {
    "docString": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\\n  p â‰  0 â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u} [inst : Field k] {G : GroupCat} [inst_1 : IsAlgClosed k] [inst_2 : Fintype â†‘G]\\n  [inst_3 : Invertible â†‘(Fintype.card â†‘G)] (V W : FdRep k â†‘G) [inst_4 : CategoryTheory.Simple V]\\n  [inst_5 : CategoryTheory.Simple W],\\n  (â…Ÿâ†‘(Fintype.card â†‘G) â€¢ Finset.sum Finset.univ fun g => FdRep.character V g * FdRep.character W gâ»Â¹) =\\n    if Nonempty (V â‰… W) then 1 else 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Orthogonality of characters for irreducible representations of finite group over an\\nalgebraically closed field whose characteristic doesn't divide the order of the group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}\\n  (P : (Î± â†’ E) â†’ Prop),\\n  (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\\n    (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\\n        Disjoint (Function.support f) (Function.support g) â†’\\n          MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’ P f â†’ P g â†’ P (f + g)) â†’\\n      IsClosed {f | P â†‘â†‘f} â†’\\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Integrable f â†’ P f â†’ P g) â†’\\n          âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Integrable f â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary integrable function in a normed group,\\nit suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : â„•} [hp : CharP R p],\n  p â‰  0 â†’ Nat.Prime p :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- Orthogonality of characters for irreducible representations of finite group over an\nalgebraically closed field whose characteristic doesn't divide the order of the group. -/\ntheorem âˆ€ {k : Type u} [inst : Field k] {G : GroupCat} [inst_1 : IsAlgClosed k] [inst_2 : Fintype â†‘G]\n  [inst_3 : Invertible â†‘(Fintype.card â†‘G)] (V W : FdRep k â†‘G) [inst_4 : CategoryTheory.Simple V]\n  [inst_5 : CategoryTheory.Simple W],\n  (â…Ÿâ†‘(Fintype.card â†‘G) â€¢ Finset.sum Finset.univ fun g => FdRep.character V g * FdRep.character W gâ»Â¹) =\n    if Nonempty (V â‰… W) then 1 else 0 :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G â§¸ H) â†’ H = âŠ¤ :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}\n  (P : (Î± â†’ E) â†’ Prop),\n  (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\n    (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\n        Disjoint (Function.support f) (Function.support g) â†’\n          MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’ P f â†’ P g â†’ P (f + g)) â†’\n      IsClosed {f | P â†‘â†‘f} â†’\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Integrable f â†’ P f â†’ P g) â†’\n          âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Integrable f â†’ P f :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) (hH : âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = Fintype.card { x // x âˆˆ H } â†’ K = H),\n  Subgroup.IsCharacteristic H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {n : â„•} {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = n â†’ (âˆ€ K : Subgroup G, Fintype.card { x // x âˆˆ K } = n â†’ K = H) â†’ H.char =",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G) {n : â„•} (hn : Fintype.card { x // x âˆˆ H } = n),\n  (forall (K : Subgroup G), Fintype.card { x // x âˆˆ K } = n -> K = H) â†’ Subgroup.IsCharacteristic H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) (n : â„•)\n  (hH : Fintype.card { x // x âˆˆ H } = n)\n  (h_uniq : âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = n â†’ K = H),\n  Subgroup.IsCharacteristic H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G) [inst_2 : Fintype { x // x âˆˆ H }],\n  (âˆ€ {K : Subgroup G}, Fintype.card { x // x âˆˆ K } = Fintype.card { x // x âˆˆ H } â†’ K = H) â†’\n    Subgroup.characteristic H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) (n : â„•) [inst_1 : Fintype { x // x âˆˆ H }]\n  (hn : Fintype.card { x // x âˆˆ H } = n) (h : âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = n â†’ K = H),\n  Subgroup.IsChar H ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G}\n  (hH : âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = Fintype.card { x // x âˆˆ H } â†’ K = H),\n  Subgroup.IsCharacteristic H ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  (âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = Fintype.card { x // x âˆˆ H } â†’ K = H) â†’\n    Subgroup.IsCharacteristic H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {n : â„•} (hn : Fintype.card { x // x âˆˆ H } = n),\n  (âˆ€ (K : Subgroup G), Fintype.card { x // x âˆˆ K } = n â†’ K = H) â†’ Subgroup.IsChar H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} {n : â„•},\n  Fintype.card {x // x âˆˆ H} = n â†’ (âˆ€ (K : Subgroup G), Fintype.card {x // x âˆˆ K} = n â†’ H = K) â†’ H.charact "
    ]
  },
  {
    "docString": "Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) âŠ” N = G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) âŠ” N = G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤ :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ List.prod l âˆˆ K :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s) :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G}, â…â…Hâ‚‚, Hâ‚ƒâ†, Hâ‚â† = âŠ¥ â†’ â…â…Hâ‚ƒ, Hâ‚â†, Hâ‚‚â† = âŠ¥ â†’ â…â…Hâ‚, Hâ‚‚â†, Hâ‚ƒâ† = âŠ¥ :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G),\n  â†‘P â‰¤ H â†’ âˆƒ (Q : Sylow p { x // x âˆˆ H }), P â‰¤ â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G), â†‘P â‰¤ H â†’ âˆƒ (Q : Sylow p { x // x âˆˆ H }), P = â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] {P : Sylow p G} {H : Subgroup G},\n  â†‘P â‰¤ H â†’ âˆƒ Q : Sylow p { x // x âˆˆ H }, â†‘P = â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  â†‘P â‰¤ H â†’ âˆƒ Q : Sylow p { x // x âˆˆ H }, â†‘Q = â†‘P ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G), P.1 â‰¤ H â†’ âˆƒ Q : Sylow p { x // x âˆˆ H }, P.1 = â†‘Q ",
      "forall {p : â„•} {G : Type u_1} [inst : Group G] {P : Sylow p G} (H : Subgroup G), P â‰¤ H â†’ âˆƒ (Q : Sylow p {x // x âˆˆ H}), P â‰¤ â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G), â†‘P â‰¤ H â†’ âˆƒ (Q : Sylow p { x // x âˆˆ H }), P = â†‘Q ",
      "âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G), â†‘P â‰¤ H â†’ Sylow p { x // x âˆˆ H } ",
      "forall {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  â†‘P â‰¤ H â†’ âˆƒ (Q : Sylow p { x // x âˆˆ H }), â†‘P â‰¤ â†‘Q ",
      "forall {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) (P : Sylow p G),\n  P.carrier â‰¤ H.carrier â†’ âˆƒ (Q : Sylow p {x // x âˆˆ H}), P.carrier = Q.carrier "
    ]
  },
  {
    "docString": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n        p âˆ£\\n          Fintype.card\\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\\n      Nonempty\\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’\n        p âˆ£\n          Fintype.card\n            ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A p-group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\n      Nonempty\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)] :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p [hp : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ p âˆ£ Fintype.card G âˆ§ âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’\n    âˆƒ p [hp : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p [inst_2 : Fact (Nat.Prime p)], âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ (p : â„•) (P : Sylow p G) [hp : Fact (Nat.Prime p)], Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ âˆƒ P : Sylow p G, Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 â†’ âˆƒ (p : â„•) (hp : Fact (Nat.Prime p)) (P : Sylow p G), Subgroup.Normal â†‘P "
    ]
  },
  {
    "docString": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) âŠ” N = G`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\\n  p + q â‰  0 â†’\\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p + q` is at least the minimum of the multiplicities. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\\n      Nonempty\\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {q r : â„š},\\n  padicNorm p q â‰  padicNorm p r â†’ padicNorm p (q + r) = max (padicNorm p q) (padicNorm p r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p`-adic norms of `q` and `r` are different, then the norm of `q + r` is equal to the max\\nof the norms of `q` and `r`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) â‰¡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) âŠ” N = G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤ :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\n  p + q â‰  0 â†’\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q) :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\n      Nonempty\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)] :=\n\n/-- If the `p`-adic norms of `q` and `r` are different, then the norm of `q + r` is equal to the max\nof the norms of `q` and `r`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {q r : â„š},\n  padicNorm p q â‰  padicNorm p r â†’ padicNorm p (q + r) = max (padicNorm p q) (padicNorm p r) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’\n    (âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P) âˆ¨ (âˆƒ (Q : Sylow q G), Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ (R : Sylow r G), Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’\n    (âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P) âˆ¨ (âˆƒ (Q : Sylow q G), Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ (R : Sylow r G), Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [_hp : Fact (Nat.Prime p)] [_hq : Fact (Nat.Prime q)] [_hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’\n    (âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P) âˆ¨ (âˆƒ (Q : Sylow q G), Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ (R : Sylow r G), Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’\n    (âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P) âˆ¨ (âˆƒ (Q : Sylow q G), Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ (R : Sylow r G), Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’ \n    (âˆƒ P : Sylow p G, Subgroup.Normal â†‘P) âˆ¨ (âˆƒ Q : Sylow q G, Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ R : Sylow r G, Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [_hp : Fact (Nat.Prime p)] [_hq : Fact (Nat.Prime q)] [_hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’\n  (âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P) âˆ¨ (âˆƒ (Q : Sylow q G), Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ (R : Sylow r G), Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•}\n  [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’\n    (âˆƒ (P : Sylow p G), Subgroup.Normal â†‘P) âˆ¨\n    (âˆƒ (Q : Sylow q G), Subgroup.Normal â†‘Q) âˆ¨\n    (âˆƒ (R : Sylow r G), Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r â†’ p < q â†’ q < r â†’ âˆƒ (n : â„•), âˆƒ (H : Sylow n G), Subgroup.Normal â†‘H ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q r : â„•) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)]\n  [hr : Fact (Nat.Prime r)], p < q â†’ q < r â†’ Fintype.card G = p * q * r â†’\n  (âˆƒ P : Sylow p G, Subgroup.Normal â†‘P) âˆ¨ (âˆƒ Q : Sylow q G, Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ R : Sylow r G, Subgroup.Normal â†‘R) ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  p < q â†’ q < r â†’ Fintype.card G = p * q * r â†’ (âˆƒ P : Sylow p G, Subgroup.Normal â†‘P) âˆ¨ (âˆƒ Q : Sylow q G, Subgroup.Normal â†‘Q) âˆ¨ (âˆƒ R : Sylow r G, Subgroup.Normal â†‘R) "
    ]
  },
  {
    "docString": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\\n      Nonempty\\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\\n  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of `s` is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"}]\n",
    "prompt_cons": "/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x âˆˆ â†‘P } = p ^ â†‘(Nat.factorization (Fintype.card G)) p :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\n      Nonempty\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)] :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x âˆˆ P } â†’ âˆƒ Q, P â‰¤ â†‘Q :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\n  âŠ¤ :=\n\n/-- The normal closure of `s` is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s) :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Prove that a group of order 200 has a normal Sylow 5-subgroup. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 200 â†’\n  âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 â†’ âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 200 â†’\n  âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 200 â†’ \n  âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 200 â†’ \n  âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 â†’ âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 200 â†’\n  âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 200 â†’\n  âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G], Fintype.card G = 200 â†’ âˆƒ (P : Sylow 5 G), Subgroup.Normal â†‘P ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 â†’ âˆƒ (H : Sylow 5 G), Subgroup.Normal â†‘H "
    ]
  },
  {
    "docString": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ -1 â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"Characteristic `â‰  2` and nontrivial implies that `-1 â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (d : Module.Dual R M) (x : CliffordAlgebra Q),\\n  â†‘(â†‘CliffordAlgebra.contractRight (â†‘(â†‘CliffordAlgebra.contractRight x) d)) d = 0\",\n  \"isProp\": true,\n  \"docString\": \"This is [grinberg_clifford_2016][] Theorem 13 \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G â†’ SimpleGraph.IsAcyclic G\",\n  \"isProp\": true,\n  \"docString\": \"Graph is acyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the first two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the first two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±), Set.Nontrivial (f '' s) â†’ Set.Nontrivial s\",\n  \"isProp\": true,\n  \"docString\": \"If the image of a set is nontrivial, the set is nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (Ï‡ : MulChar R R'),\\n  MulChar.IsNontrivial Ï‡ â†” Ï‡ â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A multiplicative character is nontrivial iff it is not the trivial character. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (d : Module.Dual R M) (a : M) (b : CliffordAlgebra Q),\\n  â†‘(â†‘CliffordAlgebra.contractRight (b * â†‘(CliffordAlgebra.Î¹ Q) a)) d =\\n    â†‘d a â€¢ b - â†‘(â†‘CliffordAlgebra.contractRight b) d * â†‘(CliffordAlgebra.Î¹ Q) a\",\n  \"isProp\": true,\n  \"docString\": \"This is [grinberg_clifford_2016][] Theorem 12  \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Characteristic `â‰  2` and nontrivial implies that `-1 â‰  1`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ -1 â‰  1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x â‰  1 :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- This is [grinberg_clifford_2016][] Theorem 13 -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (d : Module.Dual R M) (x : CliffordAlgebra Q),\n  â†‘(â†‘CliffordAlgebra.contractRight (â†‘(â†‘CliffordAlgebra.contractRight x) d)) d = 0 :=\n\n/-- Graph is acyclic. -/\ntheorem âˆ€ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G â†’ SimpleGraph.IsAcyclic G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- If the angle between three points is `Ï€`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- If the angle between three points is `Ï€ / 2`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±), Set.Nontrivial (f '' s) â†’ Set.Nontrivial s :=\n\n/-- If the angle between three points is `Ï€`, the first and third points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- If the angle between three points is `Ï€ / 2`, the first and third points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- A multiplicative character is nontrivial iff it is not the trivial character. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (Ï‡ : MulChar R R'),\n  MulChar.IsNontrivial Ï‡ â†” Ï‡ â‰  1 :=\n\n/-- This is [grinberg_clifford_2016][] Theorem 12 -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (d : Module.Dual R M) (a : M) (b : CliffordAlgebra Q),\n  â†‘(â†‘CliffordAlgebra.contractRight (b * â†‘(CliffordAlgebra.Î¹ Q) a)) d =\n    â†‘d a â€¢ b - â†‘(â†‘CliffordAlgebra.contractRight b) d * â†‘(CliffordAlgebra.Î¹ Q) a :=\n\n/-- Prove that if $|G|=1365$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h1365 : Fintype.card G = 1365), Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hNat : Fact (Fintype.card G = 1365)], Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hF : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ (G : Type u_1) [inst : Fintype G] [inst_1 : Group G], Fintype.card G = 1365 â†’ Â¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that if $|G|=132$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\": \"IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {Râ‚ : Type u_3} {Râ‚‚ : Type u_4} (Mâ‚ : Type u_1) (Mâ‚‚ : Type u_5) [inst : CommSemiring R]\\n  [inst_1 : CommSemiring Râ‚] [inst_2 : AddCommMonoid Mâ‚] [inst_3 : Module Râ‚ Mâ‚] [inst_4 : CommSemiring Râ‚‚]\\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : Module Râ‚‚ Mâ‚‚] (Iâ‚ : Râ‚ â†’+* R) (Iâ‚‚ : Râ‚‚ â†’+* R) [inst_7 : Nontrivial Mâ‚],\\n  Â¬LinearMap.SeparatingLeft 0\",\n  \"isProp\": true,\n  \"docString\": \"In a non-trivial module, zero is not non-degenerate. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ -1 â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"Characteristic `â‰  2` and nontrivial implies that `-1 â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the first two points are not equal. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x â‰  1 :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x âˆˆ alternatingGroup (Fin 5) } :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n : â„•} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n âˆ£ Fintype.card G â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ n :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0 :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G â§¸ Subgroup.center G) â†’ Group.IsNilpotent G :=\n\n/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem âˆ€ {R : Type u_2} {Râ‚ : Type u_3} {Râ‚‚ : Type u_4} (Mâ‚ : Type u_1) (Mâ‚‚ : Type u_5) [inst : CommSemiring R]\n  [inst_1 : CommSemiring Râ‚] [inst_2 : AddCommMonoid Mâ‚] [inst_3 : Module Râ‚ Mâ‚] [inst_4 : CommSemiring Râ‚‚]\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : Module Râ‚‚ Mâ‚‚] (Iâ‚ : Râ‚ â†’+* R) (Iâ‚‚ : Râ‚‚ â†’+* R) [inst_7 : Nontrivial Mâ‚],\n  Â¬LinearMap.SeparatingLeft 0 :=\n\n/-- Characteristic `â‰  2` and nontrivial implies that `-1 â‰  1`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ -1 â‰  1 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- If the angle between three points is `Ï€ / 2`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- Prove that if $|G|=132$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬SimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬IsSimpleGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 â†’ Â¬Group.IsSimple G "
    ]
  },
  {
    "docString": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\\n  5 â‰¤ Fintype.card Î± â†’\\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\\n      Nonempty\\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\\n  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) âŠ” N = G`. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : DecidableEq Î±],\n  5 â‰¤ Fintype.card Î± â†’\n    âˆ€ {f : Equiv.Perm Î±} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f âˆˆ alternatingGroup Î±) }} = âŠ¤ :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, âˆ€ (H : Subgroup G), IsCoatom H â†’ Subgroup.Normal H,\n      âˆ€ (p : â„•), Fact (Nat.Prime p) â†’ âˆ€ (P : Sylow p G), Subgroup.Normal â†‘P,\n      Nonempty\n        (((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G)] :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 âˆˆ alternatingGroup (Fin 5)) }} =\n  âŠ¤ :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x âˆˆ â†‘P }) (Subgroup.index â†‘P) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) âŠ” N = G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {p : â„•} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x âˆˆ N })] (P : Sylow p G), â†‘P â‰¤ N â†’ Subgroup.normalizer â†‘P âŠ” N = âŠ¤ :=\n\n/-- Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      CommGroup G ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G], Fintype.card G = 105 â†’\n  (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n    CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 105 â†’\n  (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    âˆ€ {P : Sylow 3 G}, Subgroup.Normal â†‘P â†’ IsCommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 105 â†’\n  (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’ IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      CommGroup G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      IsCommutative G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 105 â†’\n  (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’ IsAbelian G ",
      "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h3 : âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P),\n  Fintype.card G = 105 â†’ âˆ€ (x y : G), Commute x y ",
      "âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 â†’\n    (âˆ€ (P : Sylow 3 G), Subgroup.Normal â†‘P) â†’\n      âˆ€ (a b : G), a * b = b * a "
    ]
  },
  {
    "docString": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x âˆˆ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ m âˆ£ Fintype.card G â†’\\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\\n      Fintype.card (G â§¸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G],\\n  Group.nilpotencyClass { x // x âˆˆ H } â‰¤ Group.nilpotencyClass G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A the nilpotency class of a subgroup is less or equal to the nilpotency class of the group \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.nilpotencyClass (G â§¸ H) â‰¤ Group.nilpotencyClass G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a quotient of `G` is less or equal the nilpotency class of `G` \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] â¦ƒh k : Set Gâ¦„, h âŠ† k â†’ Subgroup.closure h â‰¤ Subgroup.closure k\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroup closure of a set is monotone in its argument: if `h âŠ† k`,\\nthen `closure h â‰¤ closure k`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\\n    âˆ€ {H : Subgroup G},\\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card { x // x âˆˆ Subgroup.normalizer H } â‰¡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x âˆˆ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n â‰¤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : â„•) {n m : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ m âˆ£ Fintype.card G â†’\n    âˆ€ (H : Subgroup G), Fintype.card { x // x âˆˆ H } = p ^ n â†’ n â‰¤ m â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ m âˆ§ H â‰¤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G}, Fintype.card { x // x âˆˆ H } = p ^ n â†’ âˆƒ K, Fintype.card { x // x âˆˆ K } = p ^ (n + 1) âˆ§ H â‰¤ K :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x âˆˆ H } = p ^ n â†’\n    Fintype.card ({ x // x âˆˆ Subgroup.normalizer H } â§¸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) â‰¡\n      Fintype.card (G â§¸ H) [MOD p] :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- A the nilpotency class of a subgroup is less or equal to the nilpotency class of the group -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G],\n  Group.nilpotencyClass { x // x âˆˆ H } â‰¤ Group.nilpotencyClass G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype Î±] (s : Subgroup Î±) [inst_2 : Fintype { x // x âˆˆ s }],\n  Fintype.card { x // x âˆˆ s } âˆ£ Fintype.card Î± :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H âˆ© G_{>0}` then `H` is generated by `a`. -/\ntheorem âˆ€ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g âˆˆ H âˆ§ 0 < g} a â†’ H = AddSubgroup.closure {a} :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- The nilpotency class of a quotient of `G` is less or equal the nilpotency class of `G` -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.nilpotencyClass (G â§¸ H) â‰¤ Group.nilpotencyClass G :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G â†’* M} {s : Set G},\n  Set.EqOn (â†‘f) (â†‘g) s â†’ Set.EqOn â†‘f â†‘g â†‘(Subgroup.closure s) :=\n\n/-- Subgroup closure of a set is monotone in its argument: if `h âŠ† k`,\nthen `closure h â‰¤ closure k`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] â¦ƒh k : Set Gâ¦„, h âŠ† k â†’ Subgroup.closure h â‰¤ Subgroup.closure k :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x âˆˆ N }) (Subgroup.index N) â†’ âˆƒ H, Subgroup.IsComplement' H N :=\n\n/-- It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : â„•} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) âˆ£ Fintype.card G â†’\n    âˆ€ {H : Subgroup G},\n      Fintype.card { x // x âˆˆ H } = p ^ n â†’ p ^ (n + 1) âˆ£ Fintype.card { x // x âˆˆ Subgroup.normalizer H } :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$. -/\ntheorem",
    "choices": [
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†” Subgroup.commute H H â‰¤ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H â†” Subgroup.commGroup.relClosure H â‰¤ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†” Subgroup.commutator G H â‰¤ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†” Subgroup.comap (MulEquiv.toMonoidHom (MulAut.conjHom G)) H â‰¤ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†” Subgroup.comap (Subgroup.subtype H) (Subgroup.conjAct H) â‰¤ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Subgroup.Normal H â†” Subgroup.mem_closure (SetOf (Î» x, âˆƒ p q âˆˆ H, p * x * qâ»Â¹ âˆˆ H)) H ",
      "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Subgroup.Normal H â†” Subgroup.comap (Subgroup.subtype H) (Subgroup.mk' {x : G â§¸ H // x âˆˆ G â§¸ H}) â‰¤ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H â†” Subgroup.commuteSet G H â‰¤ H ",
      "âˆ€ {G : Type u} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H â†” âˆ€ (x : G), âˆ€ (y : G), x * y * xâ»Â¹ * yâ»Â¹ âˆˆ H ",
      "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†” Subgroup.commute_set H â‰¤ H "
    ]
  },
  {
    "docString": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand x is an element of an A-algebra that is integral over A, then x is integral over R.\"},\n {\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\\n  Polynomial.Monic gâ‚ â†’\\n    Polynomial.Monic gâ‚‚ â†’\\n      IsCoprime gâ‚ gâ‚‚ â†’\\n        âˆƒ q râ‚ râ‚‚,\\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\\ndeg(râ‚‚) < deg(gâ‚‚).\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type u_2) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K], IsIntegrallyClosed R â†” IsIntegralClosure R R K\",\n  \"isProp\": true,\n  \"docString\":\n  \"`R` is integrally closed iff it is the integral closure of itself in its field of fractions. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ Set.InjOn Int.cast {0, 1, -1}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\\nthat is nontrivial and of characteristic not `2`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : RË£), uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\\none's additive inverse. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {M : Type u_1}\\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M]\\n  [inst_7 : NoZeroSMulDivisors A M] (N : Submodule R M),\\n  N â‰  âŠ¥ â†’ Submodule.FG N â†’ âˆ€ (x : A), (âˆ€ (n : M), n âˆˆ N â†’ x â€¢ n âˆˆ N) â†’ IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `A` is an `R`-algebra, `M` is an `A`-module such that `a â€¢ m â‰  0` for all non-zero `a`\\nand `m`. If `x : A` fixes a nontrivial f.g. `R`-submodule `N` of `M`, then `x` is `R`-integral. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\\n  (Ï† : R â†’+* S) (f : Polynomial R), Polynomial.Monic f â†’ Irreducible (Polynomial.map Ï† f) â†’ Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial over an integral domain `R` is irreducible if it is monic and\\nirreducible after mapping into an integral domain `S`.\\n\\nA special case of this lemma is that a polynomial over `â„¤` is irreducible if\\nit is monic and irreducible over `â„¤/pâ„¤` for some prime `p`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, d â‰  0 â†’ âˆ€ {a : Pell.Solutionâ‚ d}, Pell.Solutionâ‚.x a = 1 â†’ a = 1\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x = 1` is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R],\\n  IsIntegrallyClosed R â†”\\n    âˆ€ (p : Polynomial R), Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integrally closed domains are precisely the domains for in which Gauss's lemma holds\\nfor monic polynomials \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a â†” a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a non-trivial integral domain, an element is regular iff it is non-zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G â†’* R), f â‰  1 â†’ (Finset.sum Finset.univ fun g => â†‘f g) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A â†’ Algebra.IsIntegral A B â†’ Algebra.IsIntegral R B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand B is an A-algebra all of whose elements are integral over A,\\nthen all elements of B are integral over R.\"}]\n",
    "prompt_cons": "/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P â†’ IsDomain (Polynomial R â§¸ Ideal.map Polynomial.C P) :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x :=\n\n/-- Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\ndeg(râ‚‚) < deg(gâ‚‚). -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\n  Polynomial.Monic gâ‚ â†’\n    Polynomial.Monic gâ‚‚ â†’\n      IsCoprime gâ‚ gâ‚‚ â†’\n        âˆƒ q râ‚ râ‚‚,\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚ :=\n\n/-- `R` is integrally closed iff it is the integral closure of itself in its field of fractions. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type u_2) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K], IsIntegrallyClosed R â†” IsIntegralClosure R R K :=\n\n/-- If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\nthat is nontrivial and of characteristic not `2`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ Set.InjOn Int.cast {0, 1, -1} :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\none's additive inverse. -/\ntheorem âˆ€ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : RË£), uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1 :=\n\n/-- Suppose `A` is an `R`-algebra, `M` is an `A`-module such that `a â€¢ m â‰  0` for all non-zero `a`\nand `m`. If `x : A` fixes a nontrivial f.g. `R`-submodule `N` of `M`, then `x` is `R`-integral. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {M : Type u_1}\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M]\n  [inst_7 : NoZeroSMulDivisors A M] (N : Submodule R M),\n  N â‰  âŠ¥ â†’ Submodule.FG N â†’ âˆ€ (x : A), (âˆ€ (n : M), n âˆˆ N â†’ x â€¢ n âˆˆ N) â†’ IsIntegral R x :=\n\n/-- A polynomial over an integral domain `R` is irreducible if it is monic and\nirreducible after mapping into an integral domain `S`.\n\nA special case of this lemma is that a polynomial over `â„¤` is irreducible if\nit is monic and irreducible over `â„¤/pâ„¤` for some prime `p`. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\n  (Ï† : R â†’+* S) (f : Polynomial R), Polynomial.Monic f â†’ Irreducible (Polynomial.map Ï† f) â†’ Irreducible f :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- A solution with `x = 1` is trivial. -/\ntheorem âˆ€ {d : â„¤}, d â‰  0 â†’ âˆ€ {a : Pell.Solutionâ‚ d}, Pell.Solutionâ‚.x a = 1 â†’ a = 1 :=\n\n/-- Integrally closed domains are precisely the domains for in which Gauss's lemma holds\nfor monic polynomials -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R],\n  IsIntegrallyClosed R â†”\n    âˆ€ (p : Polynomial R), Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- In a non-trivial integral domain, an element is regular iff it is non-zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a â†” a â‰  0 :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\n  (f : G â†’* R), f â‰  1 â†’ (Finset.sum Finset.univ fun g => â†‘f g) = 0 :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- A technical result telling us that `(I * S) âˆ© R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) âŠ” I = âŠ¤ â†’\n    Function.Injective â†‘(algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) â†’\n      Ideal.comap (algebraMap { x_1 // x_1 âˆˆ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 âˆˆ Algebra.adjoin R {x} }) I :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand B is an A-algebra all of whose elements are integral over A,\nthen all elements of B are integral over R. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A â†’ Algebra.IsIntegral A B â†’ Algebra.IsIntegral R B :=\n\n/-- Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 â†’ x = 1 âˆ¨ x = -1 "
    ]
  },
  {
    "docString": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²}, IsRingHom f â†’ IsSemiringHom f\",\n  \"isProp\": true,\n  \"docString\": \"A ring homomorphism is also a semiring homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {Ï‡ : MulChar R R'}, MulChar.IsQuadratic Ï‡ â†’ âˆ€ (f : R' â†’+* R''), MulChar.IsQuadratic (MulChar.ringHomComp Ï‡ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition with a ring homomorphism preserves the property of being a quadratic character. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {x y : R},\\n  Commute x y â†’\\n    âˆ€ (n : â„•), (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * â†‘(Nat.choose n m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of the **binomial theorem** for commuting elements in noncommutative semirings. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Representation of a difference of two squares in a commutative ring as a product. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S),\\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The definition of `cyclotomic n R` commutes with any ring homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] (self : RingCon R) {w x y z : R},\\n  Setoid.r w x â†’ Setoid.r y z â†’ Setoid.r (w * y) (x * z)\",\n  \"isProp\": true,\n  \"docString\": \"Ring congruence relations are closed under multiplication \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends one to one. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A â‰ƒ+* B â†’ IsDomain A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"}]\n",
    "prompt_cons": "/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem âˆ€ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- Multiplication in a boolean ring is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 â†’ IsUnit a âˆ¨ IsUnit b :=\n\n/-- A ring homomorphism is also a semiring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Ring Î±] [inst_1 : Ring Î²] {f : Î± â†’ Î²}, IsRingHom f â†’ IsSemiringHom f :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {Ï‡ : MulChar R R'}, MulChar.IsQuadratic Ï‡ â†’ âˆ€ (f : R' â†’+* R''), MulChar.IsQuadratic (MulChar.ringHomComp Ï‡ f) :=\n\n/-- A version of the **binomial theorem** for commuting elements in noncommutative semirings. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {x y : R},\n  Commute x y â†’\n    âˆ€ (n : â„•), (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * â†‘(Nat.choose n m) :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- Representation of a difference of two squares in a commutative ring as a product. -/\ntheorem âˆ€ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b) :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y :=\n\n/-- The definition of `cyclotomic n R` commutes with any ring homomorphism. -/\ntheorem âˆ€ (n : â„•) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S),\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S :=\n\n/-- Ring congruence relations are closed under multiplication -/\ntheorem âˆ€ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] (self : RingCon R) {w x y z : R},\n  Setoid.r w x â†’ Setoid.r y z â†’ Setoid.r (w * y) (x * z) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- A ring isomorphism sends one to one. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1 :=\n\n/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A â‰ƒ+* B â†’ IsDomain A :=\n\n/-- A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R Mul ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R Mul.mul ",
      "âˆ€ {R : Type u_1} [inst : Semiring R] [self : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R], IsCommutative R Mul.mul ",
      "âˆ€ {R : Type u_1} [inst : Ring R] [self : âˆ€ (a : R), a * a = a], CommRing R ",
      "âˆ€ {R : Type u_1} [inst : Ring R] [self : BooleanRing R], IsCommutative R (*) ",
      "âˆ€ {R : Type u_1} [inst : Ring R] (hr : âˆ€ a : R, a * a = a), IsCommutative R mul ",
      "âˆ€ {R : Type u_1} [inst : BooleanRing R] (a b : R), a * b = b * a "
    ]
  },
  {
    "docString": "Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\\n  AddSubgroup.Normal H â†’ âˆ€ (n : A), n âˆˆ H â†’ âˆ€ (g : A), g + n + -g âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"`N` is closed under additive conjugation \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) (Î² : Type v) [inst : AddGroup Î±] [inst_1 : AddAction Î± Î²] [inst_2 : Fintype Î±]\\n  [inst_3 : (a : Î±) â†’ Fintype â†‘(AddAction.fixedBy Î± Î² a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel Î± Î²))],\\n  (Finset.sum Finset.univ fun a => Fintype.card â†‘(AddAction.fixedBy Î± Î² a)) =\\n    Fintype.card (Quotient (AddAction.orbitRel Î± Î²)) * Fintype.card Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\\nthe average number of elements fixed by each `g âˆˆ G` is the number of orbits. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\\n  Group.nilpotencyClass G = Group.nilpotencyClass (G â§¸ Subgroup.center G) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a non-trivial group is one more than its quotient by the center \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological additive group `G` with normal additive subgroup\\n`N`, `0 : G â§¸ N` has a countable neighborhood basis.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\\n  (Finset.sum Finset.univ fun a => â†‘1 a) = â†‘(Fintype.card RË£)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over all values of the trivial multiplicative character on a finite ring is\\nthe cardinality of its unit group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} [hT : Fact (0 < T)] (I : Set (AddCircle T)) (u x : AddCircle T),\\n  IsOfFinAddOrder u â†’\\n    I =á¶ [MeasureTheory.Measure.ae MeasureTheory.volume] Metric.ball x (T / (2 * â†‘(addOrderOf u))) â†’\\n      MeasureTheory.IsAddFundamentalDomain { x // x âˆˆ AddSubgroup.zmultiples u } I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `G` be the subgroup of `AddCircle T` generated by a point `u` of finite order `n : â„•`. Then\\nany set `I` that is almost equal to a ball of radius `T / 2n` is a fundamental domain for the action\\nof `G` on `AddCircle T` by left addition. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G],\\n  Group.nilpotencyClass (G â§¸ Subgroup.center G) = Group.nilpotencyClass G - 1\",\n  \"isProp\": true,\n  \"docString\": \"Quotienting the `center G` reduces the nilpotency class by 1 \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R], SMulCommClass R { x // x âˆˆ Subring.center R } R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The center of a semiring acts commutatively on that semiring. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {P : (G : Type u_1) â†’ [inst : Group G] â†’ [inst : Group.IsNilpotent G] â†’ Prop} (G : Type u_1) [inst : Group G]\\n  [inst_1 : Group.IsNilpotent G],\\n  (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Subsingleton G], P G) â†’\\n    (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Group.IsNilpotent G], P (G â§¸ Subgroup.center G) â†’ P G) â†’ P G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A custom induction principle for nilpotent groups. The base case is a trivial group\\n(`subsingleton G`), and in the induction step, one can assume the hypothesis for\\nthe group quotiented by its center. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = â†‘(Subgroup.center G) :=\n\n/-- `N` is closed under additive conjugation -/\ntheorem âˆ€ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\n  AddSubgroup.Normal H â†’ âˆ€ (n : A), n âˆˆ H â†’ âˆ€ (g : A), g + n + -g âˆˆ H :=\n\n/-- **Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\nthe average number of elements fixed by each `g âˆˆ G` is the number of orbits. -/\ntheorem âˆ€ (Î± : Type u) (Î² : Type v) [inst : AddGroup Î±] [inst_1 : AddAction Î± Î²] [inst_2 : Fintype Î±]\n  [inst_3 : (a : Î±) â†’ Fintype â†‘(AddAction.fixedBy Î± Î² a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel Î± Î²))],\n  (Finset.sum Finset.univ fun a => Fintype.card â†‘(AddAction.fixedBy Î± Î² a)) =\n    Fintype.card (Quotient (AddAction.orbitRel Î± Î²)) * Fintype.card Î± :=\n\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\n  Group.nilpotencyClass G = Group.nilpotencyClass (G â§¸ Subgroup.center G) + 1 :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- In a first countable topological additive group `G` with normal additive subgroup\n`N`, `0 : G â§¸ N` has a countable neighborhood basis. -/\ntheorem âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0) :=\n\n/-- The sum over all values of the trivial multiplicative character on a finite ring is\nthe cardinality of its unit group. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\n  (Finset.sum Finset.univ fun a => â†‘1 a) = â†‘(Fintype.card RË£) :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G â§¸ N` has a\ncountable neighborhood basis. -/\ntheorem âˆ€ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- Let `G` be the subgroup of `AddCircle T` generated by a point `u` of finite order `n : â„•`. Then\nany set `I` that is almost equal to a ball of radius `T / 2n` is a fundamental domain for the action\nof `G` on `AddCircle T` by left addition. -/\ntheorem âˆ€ {T : â„} [hT : Fact (0 < T)] (I : Set (AddCircle T)) (u x : AddCircle T),\n  IsOfFinAddOrder u â†’\n    I =á¶ [MeasureTheory.Measure.ae MeasureTheory.volume] Metric.ball x (T / (2 * â†‘(addOrderOf u))) â†’\n      MeasureTheory.IsAddFundamentalDomain { x // x âˆˆ AddSubgroup.zmultiples u } I :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem âˆ€ {M : Type u_1} [inst : GroupWithZero M], Set.center MË£ = Units.val â»Â¹' Set.center M :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Quotienting the `center G` reduces the nilpotency class by 1 -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G],\n  Group.nilpotencyClass (G â§¸ Subgroup.center G) = Group.nilpotencyClass G - 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, addOrderOf x = p :=\n\n/-- The center of a semiring acts commutatively on that semiring. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R], SMulCommClass R { x // x âˆˆ Subring.center R } R :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite { x // x âˆˆ commutator G } :=\n\n/-- A custom induction principle for nilpotent groups. The base case is a trivial group\n(`subsingleton G`), and in the induction step, one can assume the hypothesis for\nthe group quotiented by its center. -/\ntheorem âˆ€ {P : (G : Type u_1) â†’ [inst : Group G] â†’ [inst : Group.IsNilpotent G] â†’ Prop} (G : Type u_1) [inst : Group G]\n  [inst_1 : Group.IsNilpotent G],\n  (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Subsingleton G], P G) â†’\n    (âˆ€ (G : Type u_1) [inst : Group G] [inst_2 : Group.IsNilpotent G], P (G â§¸ Subgroup.center G) â†’ P G) â†’ P G :=\n\n/-- Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommSemiring R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G], (Finset.sum Finset.univ fun g => g) âˆˆ Subring.center (R â‹Š[RingHom.id R] G) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type u_1} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G],\n  (Finset.sum Finset.univ fun g => â†‘g) âˆˆ Subring.center (R â§¸ G) ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G],\n  (Finset.sum Finset.univ fun g => (g : R[G])) âˆˆ Subring.center R[G] ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  (Finset.sum Finset.univ fun a => a) âˆˆ Subring.center (R[G]) ",
      "âˆ€ {R : Type u} [inst : Semiring R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type u_1} [inst_1 : Group G] [inst_2 : Fintype G], (Finset.sum Finset.univ fun g => g) âˆˆ Subring.center (R[G]) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  âˆƒ (N : R[G]), N = Finset.sum Finset.univ (fun a => a) âˆ§ âˆ€ (g : G), g * N = N * g ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  (Finset.sum Finset.univ fun g => Ring.submonoidOfClosure.coeff g) âˆˆ Subring.center (R G) ",
      "âˆ€ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N "
    ]
  },
  {
    "docString": "An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G â§¸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)] [inst_1 : Finite Î·]\\n  [inst_2 : âˆ€ (i : Î·), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"n-ary products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I â†’\\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚ : Type u_1} {Gâ‚‚ : Type u_2} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Group.IsNilpotent Gâ‚]\\n  [inst_3 : Group.IsNilpotent Gâ‚‚], Group.IsNilpotent (Gâ‚ Ã— Gâ‚‚)\",\n  \"isProp\": true,\n  \"docString\": \"Products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L},\\n  I â‰¤ LieAlgebra.center R L â†’ LieAlgebra.IsNilpotent R (L â§¸ I) â†’ LieAlgebra.IsNilpotent R L\",\n  \"isProp\": true,\n  \"docString\": \"A central extension of nilpotent Lie algebras is nilpotent. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_2} {Gs : Î· â†’ Type u_1} [inst : (i : Î·) â†’ Group (Gs i)] [inst_1 : âˆ€ (i : Î·), Group.IsNilpotent (Gs i)]\\n  (n : â„•), (âˆ€ (i : Î·), Group.nilpotencyClass (Gs i) â‰¤ n) â†’ Group.IsNilpotent ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"products of nilpotent groups are nilpotent if their nilpotency class is bounded \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent G â†” âˆƒ n, lowerCentralSeries G n = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is nilpotent if and only if its lower central series eventually reaches\\nthe trivial subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P â†’ IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {G' : Type u_1} [inst_1 : Group G'] [h : Group.IsNilpotent G] (f : G â†’* G'),\\n  Function.Surjective â†‘f â†’ Group.IsNilpotent G'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The range of a surjective homomorphism from a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"}]\n",
    "prompt_cons": "/-- A quotient of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G â§¸ H) :=\n\n/-- A p-group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : â„•} [hp : Fact (Nat.Prime p)], IsPGroup p G â†’ Group.IsNilpotent G :=\n\n/-- n-ary products of nilpotent groups are nilpotent -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)] [inst_1 : Finite Î·]\n  [inst_2 : âˆ€ (i : Î·), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : Î·) â†’ Gs i) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I â†’ P (J â§¸ I) â†’ P J`, then `P` holds for all nilpotent ideals. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I â†’\n    âˆ€ {P : â¦ƒS : Type u_1â¦„ â†’ [inst : CommRing S] â†’ Ideal S â†’ Prop},\n      (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I : Ideal S), I ^ 2 = âŠ¥ â†’ P I) â†’\n        (âˆ€ â¦ƒS : Type u_1â¦„ [inst : CommRing S] (I J : Ideal S),\n            I â‰¤ J â†’ P I â†’ P (Ideal.map (Ideal.Quotient.mk I) J) â†’ P J) â†’\n          P I :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A subgroup of a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x âˆˆ H } :=\n\n/-- Products of nilpotent groups are nilpotent -/\ntheorem âˆ€ {Gâ‚ : Type u_1} {Gâ‚‚ : Type u_2} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚] [inst_2 : Group.IsNilpotent Gâ‚]\n  [inst_3 : Group.IsNilpotent Gâ‚‚], Group.IsNilpotent (Gâ‚ Ã— Gâ‚‚) :=\n\n/-- A central extension of nilpotent Lie algebras is nilpotent. -/\ntheorem âˆ€ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L},\n  I â‰¤ LieAlgebra.center R L â†’ LieAlgebra.IsNilpotent R (L â§¸ I) â†’ LieAlgebra.IsNilpotent R L :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- products of nilpotent groups are nilpotent if their nilpotency class is bounded -/\ntheorem âˆ€ {Î· : Type u_2} {Gs : Î· â†’ Type u_1} [inst : (i : Î·) â†’ Group (Gs i)] [inst_1 : âˆ€ (i : Î·), Group.IsNilpotent (Gs i)]\n  (n : â„•), (âˆ€ (i : Î·), Group.nilpotencyClass (Gs i) â‰¤ n) â†’ Group.IsNilpotent ((i : Î·) â†’ Gs i) :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- A group is nilpotent if and only if its lower central series eventually reaches\nthe trivial subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.IsNilpotent G â†” âˆƒ n, lowerCentralSeries G n = âŠ¥ :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1 :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0 :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P â†’ IsUnit (Polynomial.coeff P 0) âˆ§ âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i) :=\n\n/-- The range of a surjective homomorphism from a nilpotent group is nilpotent -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {G' : Type u_1} [inst_1 : Group G'] [h : Group.IsNilpotent G] (f : G â†’* G'),\n  Function.Surjective â†‘f â†’ Group.IsNilpotent G' :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I â†” Ideal.jacobson âŠ¥ = âŠ¥ :=\n\n/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) â†’ (âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (Polynomial.coeff P i)) â†’ IsUnit P :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I :=\n\n/-- An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$. -/\ntheorem",
    "choices": [
      "âˆ€ {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {(p : Zmod (p ^ m))}) ",
      "âˆ€ {p m : â„•} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      "âˆ€ {p m : â„•} [hp : Fact (Nat.Prime p)] (hm : 0 < m),\n  IsNilpotent (Ideal.span {â†‘p} : Ideal (zmod (p ^ m))) ",
      "âˆ€ (p m : â„•) [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {â†‘p} : Ideal (Zmod (p ^ m))) ",
      "âˆ€ {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent ((Ideal.span {p}) â§¸ (Ideal.span {p ^ m})) ",
      "âˆ€ {m : â„•} {p : â„•} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Submodule.mk (p â€¢ (â„¤ / (p ^ m â€¢ â„¤))) _ _) ",
      "âˆ€ {p m : â„•} [hp : Fact (Nat.Prime p)] (hpm : 0 < m),\n  IsNilpotent (Ideal.span {coe p} : Ideal (Zmod (p ^ m))) ",
      "âˆ€ {p m : â„•} [hp : Fact (Nat.Prime p)], IsNilpotent (Ideal.span {â†‘p} : Ideal (Zmod (p ^ m))) ",
      "âˆ€ (m : â„•) (p : â„•) [hp : Fact (Nat.Prime p)],\n  IsNilpotent (Ideal.span {â†‘p} : Ideal (Zmod (p ^ m))) ",
      "âˆ€ {m : â„•} (p : â„•) [hp : Fact (Nat.Prime p)],\n  IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) "
    ]
  },
  {
    "docString": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"âˆ€ {n d : â„•}, d âˆ£ n â†’ Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `d âˆ£ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) (n : â„¤) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve integer powers. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w / y) (x / z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve division. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Î¹ : Type u_1} {s : Finset Î¹}\\n  (P : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•),\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Prime (P i)) â†’\\n    (âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ P i â‰  P j) â†’\\n      âˆ€ (x : (i : { x // x âˆˆ s }) â†’ R â§¸ P â†‘i ^ e â†‘i),\\n        âˆƒ y, âˆ€ (i : Î¹) (hi : i âˆˆ s), â†‘(Ideal.Quotient.mk (P i ^ e i)) y = x { val := i, property := hi }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the Chinese remainder theorem: given elements `x i : R / P i ^ e i`,\\nwe can choose a representative `y : R` such that `y â‰¡ x i (mod P i ^ e i)`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"}]\n",
    "prompt_cons": "/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : â„•) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘n = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) = 1 â†’ Int.gcd a â†‘m = 1 :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoid M] {Î¶ : M} {n a b : â„•},\n  0 < n â†’ IsPrimitiveRoot Î¶ n â†’ n = a * b â†’ IsPrimitiveRoot (Î¶ ^ a) b :=\n\n/-- For `d âˆ£ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` -/\ntheorem âˆ€ {n d : â„•}, d âˆ£ n â†’ Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n)) :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- If `gcd a (m * n) â‰  1`, then `gcd a m â‰  1` or `gcd a n â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {m n : â„•}, Int.gcd a (â†‘m * â†‘n) â‰  1 â†” Int.gcd a â†‘m â‰  1 âˆ¨ Int.gcd a â†‘n â‰  1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- Multiplicative congruence relations preserve integer powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) (n : â„¤) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- Multiplicative congruence relations preserve division. -/\ntheorem âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) {w x y z : M}, â†‘c w x â†’ â†‘c y z â†’ â†‘c (w / y) (x / z) :=\n\n/-- Corollary of the Chinese remainder theorem: given elements `x i : R / P i ^ e i`,\nwe can choose a representative `y : R` such that `y â‰¡ x i (mod P i ^ e i)`. -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Î¹ : Type u_1} {s : Finset Î¹}\n  (P : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•),\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Prime (P i)) â†’\n    (âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ P i â‰  P j) â†’\n      âˆ€ (x : (i : { x // x âˆˆ s }) â†’ R â§¸ P â†‘i ^ e â†‘i),\n        âˆƒ y, âˆ€ (i : Î¹) (hi : i âˆˆ s), â†‘(Ideal.Quotient.mk (P i ^ e i)) y = x { val := i, property := hi } :=\n\n/-- Proof of right inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- Proof of left inverse -/\ntheorem âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$. -/\ntheorem",
    "choices": [
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M d : â„¤}, IsCoprime M â†‘N â†’ IsCoprime d (Nat.totient N) â†’\n  let M1 ",
      "âˆ€ {N : â„•}, 0 < N â†’ âˆ€ {M : â„¤}, Int.gcd M â†‘N = 1 â†’ âˆ€ {d : â„¤}, Int.gcd d (Int.ofNat (Nat.totient N)) = 1 â†’\n  âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ (M ^ d) [ZMOD â†‘N] â†’\n    âˆƒ d' : â„¤, d * d' â‰¡ 1 [ZMOD (Int.ofNat (Nat.totient N))] âˆ§ M â‰¡ Mâ‚ ^ d' [ZMOD â†‘N] ",
      "âˆ€ {N M d : â„¤}, 0 < N â†’ IsCoprime M N â†’ IsCoprime d (Euler.phi N) â†’\n  âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ M ^ d [ZMOD N] â†’ âˆƒ d' : â„¤, d * d' â‰¡ 1 [ZMOD (Euler.phi N)] âˆ§ M â‰¡ Mâ‚ ^ d' [ZMOD N] ",
      "âˆ€ {N : â„•}, N > 0 â†’ âˆ€ {M d : â„¤}, IsCoprime M â†‘N â†’ IsCoprime d (Int.ofNat (Nat.totient N)) â†’ let M1 ",
      "âˆ€ {N M d Mâ‚ : â„¤},\n  0 < N â†’\n  IsCoprime M N â†’\n  IsCoprime d (Int.natAbs (EulerTotient.evalN N)) â†’\n  (Mâ‚ â‰¡ M ^ d [ZMOD N]) â†’\n  âˆƒ d' : â„¤, d * d' â‰¡ 1 [ZMOD (Int.natAbs (EulerTotient.evalN N))] âˆ§ M â‰¡ Mâ‚ ^ d' [ZMOD N] ",
      "âˆ€ {N : â„•}, N â‰  0 â†’ âˆ€ {M d : â„¤}, (Int.gcd M â†‘N = 1) â†’ (Int.gcd d (Int.ofNat (Nat.totient N)) = 1) â†’ âˆ€ Mâ‚,\n  (Mâ‚ â‰¡ (M ^ d) [ZMOD N]) â†’ âˆƒ d' : â„¤, (d * d' â‰¡ 1 [ZMOD (Int.ofNat (Nat.totient N))]) âˆ§ (M â‰¡ Mâ‚ ^ d' [ZMOD N]) ",
      "âˆ€ {N M d Mâ‚ : â„•}, N > 0 â†’ IsCoprime M N â†’ IsCoprime d (Euler.phi N) â†’ Mâ‚ â‰¡ M ^ d [MOD N] â†’ âˆƒ d', d * d' â‰¡ 1 [MOD (Euler.phi N)] âˆ§ M â‰¡ Mâ‚ ^ d' [MOD N] ",
      "âˆ€ {Mâ‚ : â„¤} {M : â„•} {N : â„•} {d : â„•} {d' : â„•},\n  0 < N â†’\n  Int.gcd M N = 1 â†’\n  Int.gcd d (Nat.totient N) = 1 â†’\n  (Mâ‚ â‰¡ M ^ d [ZMOD N]) â†’\n  (d * d' â‰¡ 1 [ZMOD (Nat.totient N)]) â†’\n  (M â‰¡ Mâ‚ ^ d' [ZMOD N]) ",
      "âˆ€ {N M : â„•}, N â‰  0 â†’ Int.gcd M â†‘N = 1 â†’ âˆ€ {d : â„•}, Int.gcd d (Nat.totient N) = 1 â†’ âˆ€ {Mâ‚ : â„•}, Mâ‚ â‰¡ M ^ d [MOD N] â†’ âˆƒ d', d * d' â‰¡ 1 [MOD (Nat.totient N)] âˆ§ M â‰¡ Mâ‚ ^ d' [MOD N] ",
      "âˆ€ {N : â„•}, N â‰  0 â†’ âˆ€ {M : â„¤}, Int.gcd M â†‘N = 1 â†’ âˆ€ {d : â„¤}, Int.gcd d (Int.ofNat (Nat.totient N)) = 1 â†’\n  âˆ€ {Mâ‚ : â„¤}, Mâ‚ â‰¡ M ^ d [ZMOD â†‘N] â†’\n    âˆƒ (d' : â„¤), d * d' â‰¡ 1 [ZMOD (Int.ofNat (Nat.totient N))] âˆ§ M â‰¡ Mâ‚ ^ d' [ZMOD â†‘N] "
    ]
  },
  {
    "docString": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) (n : â„¤) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve integer powers. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {b : â„•}, Int.gcd a â†‘b = 1 â†’ jacobiSym a b ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of `J(a | b)` is `1` when `a` and `b` are coprime. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 0 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆ‘á¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on the summands.\"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1) :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- Multiplicative congruence relations preserve integer powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Group M] (c : Con M) (n : â„¤) {w x : M}, â†‘c w x â†’ â†‘c (w ^ n) (x ^ n) :=\n\n/-- The square of `J(a | b)` is `1` when `a` and `b` are coprime. -/\ntheorem âˆ€ {a : â„¤} {b : â„•}, Int.gcd a â†‘b = 1 â†’ jacobiSym a b ^ 2 = 1 :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on the summands. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : AddCommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 0 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆ‘á¶  (i : Î±), f i) :=\n\n/-- Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„¤}, (âˆƒ x y : â„š, n = x ^ 2 + y ^ 2) â†’ âˆƒ a b : â„¤, n = a ^ 2 + b ^ 2 ",
      "âˆ€ {a : â„¤}, (âˆƒ x y : â„š, a = x ^ 2 + y ^ 2) â†’ âˆƒ m n : â„¤, a = m ^ 2 + n ^ 2 ",
      "âˆ€ {a b : â„•}, (âˆƒ x y : â„š, a = x ^ 2 + y ^ 2) â†’ âˆƒ x y : â„•, a = x ^ 2 + y ^ 2 ",
      "âˆ€ {n : â„¤}, (âˆƒ x y : â„š, n = x ^ 2 + y ^ 2) â†’ âˆƒ a b : â„¤, n = a ^ 2 + b ^ 2 ",
      "âˆ€ {n : â„¤}, (âˆƒ x y : â„š, n = x ^ 2 + y ^ 2) â†’ âˆƒ a b : â„¤, n = a ^ 2 + b ^ 2 ",
      "âˆ€ {a b c : â„¤}, a = (b ^ 2) + (c ^ 2) â†’ âˆƒ x y : â„¤, a = (x ^ 2) + (y ^ 2) ",
      "âˆ€ {a : â„¤}, (âˆƒ x y : â„š, a = x ^ 2 + y ^ 2) â†’ âˆƒ m n : â„¤, a = m ^ 2 + n ^ 2 ",
      "âˆ€ {a : â„¤}, (âˆƒ x y : â„š, a = x ^ 2 + y ^ 2) â†’ âˆƒ m n : â„¤, a = m ^ 2 + n ^ 2 ",
      "âˆ€ {z : â„¤}, (âˆƒ x y : â„š, z = x ^ 2 + y ^ 2) â†’ (âˆƒ p q : â„¤, z = p ^ 2 + q ^ 2) ",
      "âˆ€ {a b x y : â„¤}, a = x ^ 2 + y ^ 2 â†’ b = x ^ 2 + (-y) ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 "
    ]
  },
  {
    "docString": "Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±], 0 â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"In a strict ordered ring, `0 â‰¤ 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\": \"âˆ€ (z : UpperHalfPlane), âˆƒ g, g â€¢ z âˆˆ ModularGroup.fd\",\n  \"isProp\": true,\n  \"docString\": \"Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)`  \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R â†’+* S),\\n  Function.Surjective â†‘f â†’ IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A â‰ƒ+* B â†’ NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„š} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of `â„š[X]` by the ideal generated by an irreducible polynomial of `â„š[X]`\\nis a number field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right multiplication in a ring is an additive monoid morphism. \"}]\n",
    "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  âˆƒ V, â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- In a strict ordered ring, `0 â‰¤ 1`. -/\ntheorem âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±], 0 â‰¤ 1 :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I â†’ Algebra.FinitePresentation R A â†’ Algebra.FinitePresentation R (A â§¸ I) :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- Any `z : â„` can be moved to `ğ’Ÿ` by an element of `SL(2,â„¤)` -/\ntheorem âˆ€ (z : UpperHalfPlane), âˆƒ g, g â€¢ z âˆˆ ModularGroup.fd :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem âˆ€ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R â†’+* S),\n  Function.Surjective â†‘f â†’ IsPrincipalIdealRing S :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem âˆ€ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem âˆ€ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A â‰ƒ+* B â†’ NoZeroDivisors A :=\n\n/-- The quotient of `â„š[X]` by the ideal generated by an irreducible polynomial of `â„š[X]`\nis a number field. -/\ntheorem âˆ€ {f : Polynomial â„š} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), â†‘(x * y) = â†‘x * â†‘y :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => y * x :=\n\n/-- Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) ",
      "Ideal.Quotient.is_field_iff_mk_ker_is_maximal (Ideal.span {1 + I}) : IsField (â„¤[i] â§¸ Ideal.span {1 + I}) â†” Ideal.IsMaximal (Ideal.span {1 + I}) ",
      "Ideal_is_field_quotient_iff_is_maximal {R : Type u} [inst : CommRing R] (I : Ideal R) : Ideal.IsMaximal I â†” IsField (R â§¸ I) ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 + I)}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 + I)}) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 + I)}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 + I)}) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 + I)}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 + I)}) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span {(1 : â„¤[i]) + I}) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span {(1 : â„¤[i]) + I}) = 2 ",
      "âˆ€ {I : Ideal (â„¤[i])}, I = Ideal.span {1 + I} â†’ IsField (â„¤[i] â§¸ I) âˆ§ Fintype.card (â„¤[i] â§¸ I) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span (singleton (1 + I))) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span (singleton (1 + I))) = 2 ",
      "IsField (â„¤[i] â§¸ Ideal.span (singleton (1 + I))) âˆ§ Fintype.card (â„¤[i] â§¸ Ideal.span (singleton (1 + I))) = 2 "
    ]
  },
  {
    "docString": "Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x â†’ Polynomial.Monic a â†’ DvdNotUnit a (minpoly A x) â†’ â†‘(Polynomial.aeval x) a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\\n  I â‰  0 â†’\\n    Â¬v.asIdeal ^ (Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) + 1) âˆ£\\n        âˆá¶  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `âˆ_v v^(val_v(I))`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R},\\n  Ideal.IsPrime P â†’\\n    âˆ€ [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {x : R},\\n      x âˆˆ P â†’ Â¬x âˆˆ P ^ 2 â†’ (âˆ€ (Q : Ideal R), Ideal.IsPrime Q â†’ Q â‰  P â†’ Â¬x âˆˆ Q) â†’ P = Ideal.span {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a prime ideal, `x âˆˆ P \\\\ PÂ²` and `x âˆ‰ Q` for all prime ideals `Q â‰  P`.\\nThen `P` is generated by `x`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], Â¬IsField R\",\n  \"isProp\": true,\n  \"docString\": \"A discrete valuation ring `R` is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\": \"Â¬IsField â„¤\",\n  \"isProp\": true,\n  \"docString\": \"`â„¤` with its usual ring structure is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem âˆ€ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R Ã— S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x â‰  1 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0 :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x â†’ Polynomial.Monic a â†’ DvdNotUnit a (minpoly A x) â†’ â†‘(Polynomial.aeval x) a â‰  0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `âˆ_v v^(val_v(I))`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\n  I â‰  0 â†’\n    Â¬v.asIdeal ^ (Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) + 1) âˆ£\n        âˆá¶  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- Let `P` be a prime ideal, `x âˆˆ P \\ PÂ²` and `x âˆ‰ Q` for all prime ideals `Q â‰  P`.\nThen `P` is generated by `x`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal R},\n  Ideal.IsPrime P â†’\n    âˆ€ [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {x : R},\n      x âˆˆ P â†’ Â¬x âˆˆ P ^ 2 â†’ (âˆ€ (Q : Ideal R), Ideal.IsPrime Q â†’ Q â‰  P â†’ Â¬x âˆˆ Q) â†’ P = Ideal.span {x} :=\n\n/-- A discrete valuation ring `R` is not a field. -/\ntheorem âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], Â¬IsField R :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem Â¬IsField â„¤ :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$. -/\ntheorem",
    "choices": [
      "Â¬IsPrincipal (Ideal.span {Polynomial.x, Polynomial.y} : Ideal (Polynomial â„š)) ",
      "Â¬IsPrincipalIdeal (Ideal.span ({(X : Polynomial â„š), (Y : Polynomial â„š)} : Set (Polynomial â„š))) ",
      "Â¬IsPrincipalIdeal (Ideal.span {X, Y} : Ideal (Polynomial â„š)) ",
      "not_is_principal_ideal_Qxy : Â¬IsPrincipalIdeal (Ideal.span {polynomial.X, polynomial.Y} : Ideal (polynomial â„š)) ",
      "âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : IsDomain (R Ã— S)], Â¬IsField (R Ã— S) ",
      "âˆ€ (A : Type u_1) [inst : CommRing A], Â¬Ideal.IsPrincipal (Ideal.span ({Polynomial.x, Polynomial.y} : Set (Polynomial A))) ",
      "âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] {x y : B}\n  [inst_3 : IsDomain A], Ideal.span {x, y} â‰  Ideal.span {1} ",
      "Â¬IsPrincipalIdealRing (FractionRing (Polynomial (â„š Ã— â„š))) ",
      "âˆ€ (R : Type u_1) (S : Type u_2) [inst : CommRing R] [inst_1 : CommRing S],\n  Â¬IsPrincipalIdealRing (R Ã— S) ",
      "not_is_principal_X_Y : Â¬IsPrincipalIdealRing (Polynomial â„š Ã— Polynomial â„š) "
    ]
  },
  {
    "docString": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\\n  Polynomial.Monic gâ‚ â†’\\n    Polynomial.Monic gâ‚‚ â†’\\n      IsCoprime gâ‚ gâ‚‚ â†’\\n        âˆƒ q râ‚ râ‚‚,\\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\\ndeg(râ‚‚) < deg(gâ‚‚).\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_2} {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : MonoidWithZeroHomClass F â„š Mâ‚€] {f g : F},\\n  (âˆ€ (m : â„¤), â†‘f â†‘m = â†‘g â†‘m) â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` agree on the integers then they are equal `Ï†`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {Î¹ : Type u_1} {g : Î¹ â†’ Polynomial R} {s : Finset Î¹},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.Monic (g i)) â†’\\n    (Set.Pairwise â†‘s fun i j => IsCoprime (g i) (g j)) â†’\\n      âˆƒ q r,\\n        (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.degree (r i) < Polynomial.degree (g i)) âˆ§\\n          (â†‘f / Finset.prod s fun i => â†‘(g i)) = â†‘q + Finset.sum s fun i => â†‘(r i) / â†‘(g i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f âˆˆ R[X]. Let s be a finite index set.\\nThen, a fraction of the form f / âˆ (g i) can be rewritten as q + âˆ‘ (r i) / (g i), where\\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\\n  Ideal.IsPrime P â†’\\n    Â¬Polynomial.leadingCoeff f âˆˆ P â†’\\n      (âˆ€ (n : â„•), â†‘n < Polynomial.degree f â†’ Polynomial.coeff f n âˆˆ P) â†’\\n        0 < Polynomial.degree f â†’ Â¬Polynomial.coeff f 0 âˆˆ P ^ 2 â†’ Polynomial.IsPrimitive f â†’ Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\\nirreducible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R] {f g : Polynomial R},\\n  Polynomial.degree f = 2 â†’\\n    Polynomial.degree g = 2 â†’ Fintype.card R % 2 = 1 â†’ âˆƒ a b, Polynomial.eval a f + Polynomial.eval b g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A},\\n  Polynomial.Monic p â†’ âˆ€ {r : K}, â†‘(Polynomial.aeval r) p = 0 â†’ IsLocalization.IsInteger A r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral root theorem:\\nif `r : f.codomain` is a root of a monic polynomial over the ufd `A`,\\nthen `r` is an integer \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : Semiring R] [inst_1 : Add A] {f g : AddMonoidAlgebra R A} {a0 b0 : A},\\n  (âˆ€ {a b : A}, a âˆˆ f.support â†’ b âˆˆ g.support â†’ a â‰  a0 âˆ¨ b â‰  b0 â†’ a + b â‰  a0 + b0) â†’ â†‘(f * g) (a0 + b0) = â†‘f a0 * â†‘g b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coefficient of a monomial in a product `f * g` that can be reached in at most one way\\nas a product of monomials in the supports of `f` and `g` is a product. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type v} {s : Finset Î±} {M : Type u_1} [inst : CommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop),\\n  (âˆ€ (a b : M), p a â†’ p b â†’ p (a * b)) â†’\\n    Finset.Nonempty s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (Finset.prod s fun x => f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a product, it suffices to prove that\\nthe property is multiplicative and holds on factors. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial Ïƒ R)) (p : MvPolynomial Ïƒ R),\\n  (âˆ€ (m : Ïƒ â†’â‚€ â„•), MvPolynomial.coeff m p âˆˆ Ideal.comap MvPolynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\\nmultivariate version. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f1 f2 : Î± â†’â‚€ M},\\n  Disjoint f1.support f2.support â†’\\n    âˆ€ {Î² : Type u_3} [inst_1 : CommMonoid Î²] (g : Î± â†’ M â†’ Î²),\\n      Finsupp.prod (f1 + f2) g = Finsupp.prod f1 g * Finsupp.prod f2 g\",\n  \"isProp\": true,\n  \"docString\":\n  \"For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`\\nover `f1` and `f2` equals the product of `g` over `f1 + f2` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Infinite R] {Ïƒ : Type u_1}\\n  {p q : MvPolynomial Ïƒ R}, (âˆ€ (x : Ïƒ â†’ R), â†‘(MvPolynomial.eval x) p = â†‘(MvPolynomial.eval x) q) â†’ p = q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two multivariate polynomials over an infinite integral domain are equal\\nif they are equal upon evaluating them on an arbitrary assignment of the variables. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {f : Polynomial R} {I : Ideal (Polynomial R)},\\n  (âˆ€ (i : â„•), â†‘Polynomial.C (Polynomial.coeff f i) âˆˆ I) â†’\\n    Ideal.span {g | âˆƒ i, g = â†‘Polynomial.C (Polynomial.coeff f i)} â‰¤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the coefficients of a polynomial belong to an ideal, then that ideal contains\\nthe ideal spanned by the coefficients of the polynomial. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  â†‘(Polynomial.aeval r) p = 0 â†’ IsFractionRing.num A r âˆ£ Polynomial.coeff p 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 1:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the numerator of `r` divides the constant coefficient \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f g : Î± â†’ M},\\n  Set.Finite (Function.mulSupport f) â†’\\n    Set.Finite (Function.mulSupport g) â†’ âˆá¶  (i : Î±), f i * g i = (âˆá¶  (i : Î±), f i) * âˆá¶  (i : Î±), g i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the multiplicative supports of `f` and `g` are finite, then the product of `f i * g i` equals\\nthe product of `f i` multiplied by the product of `g i`. \"}]\n",
    "prompt_cons": "/-- Let R be an integral domain and f, gâ‚, gâ‚‚ âˆˆ R[X]. Let gâ‚ and gâ‚‚ be monic and coprime.\nThen, âˆƒ q, râ‚, râ‚‚ âˆˆ R[X] such that f / gâ‚gâ‚‚ = q + râ‚/gâ‚ + râ‚‚/gâ‚‚ and deg(râ‚) < deg(gâ‚) and\ndeg(râ‚‚) < deg(gâ‚‚). -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {gâ‚ gâ‚‚ : Polynomial R},\n  Polynomial.Monic gâ‚ â†’\n    Polynomial.Monic gâ‚‚ â†’\n      IsCoprime gâ‚ gâ‚‚ â†’\n        âˆƒ q râ‚ râ‚‚,\n          Polynomial.degree râ‚ < Polynomial.degree gâ‚ âˆ§\n            Polynomial.degree râ‚‚ < Polynomial.degree gâ‚‚ âˆ§ â†‘f / (â†‘gâ‚ * â†‘gâ‚‚) = â†‘q + â†‘râ‚ / â†‘gâ‚ + â†‘râ‚‚ / â†‘gâ‚‚ :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I :=\n\n/-- If `f` and `g` agree on the integers then they are equal `Ï†`. -/\ntheorem âˆ€ {F : Type u_2} {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : MonoidWithZeroHomClass F â„š Mâ‚€] {f g : F},\n  (âˆ€ (m : â„¤), â†‘f â†‘m = â†‘g â†‘m) â†’ f = g :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Sort u_2} [inst : CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (i : Î±), p (f i)) â†’ p (âˆá¶  (i : Î±), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop),\n  p 1 â†’ (âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (âˆá¶  (i : Î±) (_ : i âˆˆ s), f i) :=\n\n/-- Let R be an integral domain and f âˆˆ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / âˆ (g i) can be rewritten as q + âˆ‘ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime. -/\ntheorem âˆ€ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {Î¹ : Type u_1} {g : Î¹ â†’ Polynomial R} {s : Finset Î¹},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.Monic (g i)) â†’\n    (Set.Pairwise â†‘s fun i j => IsCoprime (g i) (g j)) â†’\n      âˆƒ q r,\n        (âˆ€ (i : Î¹), i âˆˆ s â†’ Polynomial.degree (r i) < Polynomial.degree (g i)) âˆ§\n          (â†‘f / Finset.prod s fun i => â†‘(g i)) = â†‘q + Finset.sum s fun i => â†‘(r i) / â†‘(g i) :=\n\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\n  Ideal.IsPrime P â†’\n    Â¬Polynomial.leadingCoeff f âˆˆ P â†’\n      (âˆ€ (n : â„•), â†‘n < Polynomial.degree f â†’ Polynomial.coeff f n âˆˆ P) â†’\n        0 < Polynomial.degree f â†’ Â¬Polynomial.coeff f 0 âˆˆ P ^ 2 â†’ Polynomial.IsPrimitive f â†’ Irreducible f :=\n\n/-- If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R] {f g : Polynomial R},\n  Polynomial.degree f = 2 â†’\n    Polynomial.degree g = 2 â†’ Fintype.card R % 2 = 1 â†’ âˆƒ a b, Polynomial.eval a f + Polynomial.eval b g = 0 :=\n\n/-- Integral root theorem:\nif `r : f.codomain` is a root of a monic polynomial over the ufd `A`,\nthen `r` is an integer -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A},\n  Polynomial.Monic p â†’ âˆ€ {r : K}, â†‘(Polynomial.aeval r) p = 0 â†’ IsLocalization.IsInteger A r :=\n\n/-- The coefficient of a monomial in a product `f * g` that can be reached in at most one way\nas a product of monomials in the supports of `f` and `g` is a product. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : Semiring R] [inst_1 : Add A] {f g : AddMonoidAlgebra R A} {a0 b0 : A},\n  (âˆ€ {a b : A}, a âˆˆ f.support â†’ b âˆˆ g.support â†’ a â‰  a0 âˆ¨ b â‰  b0 â†’ a + b â‰  a0 + b0) â†’ â†‘(f * g) (a0 + b0) = â†‘f a0 * â†‘g b0 :=\n\n/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. -/\ntheorem âˆ€ {Î± : Type v} {s : Finset Î±} {M : Type u_1} [inst : CommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop),\n  (âˆ€ (a b : M), p a â†’ p b â†’ p (a * b)) â†’\n    Finset.Nonempty s â†’ (âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) â†’ p (Finset.prod s fun x => f x) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem âˆ€ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K â†’+* L) (f : Polynomial K),\n  Polynomial.Splits i f â†” f = 0 âˆ¨ âˆ€ {g : Polynomial L}, Irreducible g â†’ g âˆ£ Polynomial.map i f â†’ Polynomial.degree g = 1 :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. -/\ntheorem âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial Ïƒ R)) (p : MvPolynomial Ïƒ R),\n  (âˆ€ (m : Ïƒ â†’â‚€ â„•), MvPolynomial.coeff m p âˆˆ Ideal.comap MvPolynomial.C I) â†’ p âˆˆ I :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R),\n  (âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) â†’ (âˆ€ (n : â„•) (a : R), M (â†‘(Polynomial.monomial n) a)) â†’ M p :=\n\n/-- For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`\nover `f1` and `f2` equals the product of `g` over `f1 + f2` -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f1 f2 : Î± â†’â‚€ M},\n  Disjoint f1.support f2.support â†’\n    âˆ€ {Î² : Type u_3} [inst_1 : CommMonoid Î²] (g : Î± â†’ M â†’ Î²),\n      Finsupp.prod (f1 + f2) g = Finsupp.prod f1 g * Finsupp.prod f2 g :=\n\n/-- Two multivariate polynomials over an infinite integral domain are equal\nif they are equal upon evaluating them on an arbitrary assignment of the variables. -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Infinite R] {Ïƒ : Type u_1}\n  {p q : MvPolynomial Ïƒ R}, (âˆ€ (x : Ïƒ â†’ R), â†‘(MvPolynomial.eval x) p = â†‘(MvPolynomial.eval x) q) â†’ p = q :=\n\n/-- If the coefficients of a polynomial belong to an ideal, then that ideal contains\nthe ideal spanned by the coefficients of the polynomial. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {f : Polynomial R} {I : Ideal (Polynomial R)},\n  (âˆ€ (i : â„•), â†‘Polynomial.C (Polynomial.coeff f i) âˆˆ I) â†’\n    Ideal.span {g | âˆƒ i, g = â†‘Polynomial.C (Polynomial.coeff f i)} â‰¤ I :=\n\n/-- Rational root theorem part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  â†‘(Polynomial.aeval r) p = 0 â†’ IsFractionRing.num A r âˆ£ Polynomial.coeff p 0 :=\n\n/-- If the multiplicative supports of `f` and `g` are finite, then the product of `f i * g i` equals\nthe product of `f i` multiplied by the product of `g i`. -/\ntheorem âˆ€ {Î± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f g : Î± â†’ M},\n  Set.Finite (Function.mulSupport f) â†’\n    Set.Finite (Function.mulSupport g) â†’ âˆá¶  (i : Î±), f i * g i = (âˆá¶  (i : Î±), f i) * âˆá¶  (i : Î±), g i :=\n\n/-- Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer. -/\ntheorem",
    "choices": [
      "âˆ€ {f g : Polynomial â„š},\n  (âˆ€ (n : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff (f * g) n)) â†’\n    âˆ€ (m n : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff f m * Polynomial.coeff g n) ",
      "âˆ€ {f g : Polynomial â„š} {P : â„¤[X]},\n  (f * g = Polynomial.map (Rat.castRingHom â„¤) P) â†’\n    âˆ€ (i j : â„•), (Polynomial.coeff f i) * (Polynomial.coeff g j) âˆˆ â„¤ ",
      "âˆ€ {f g : Polynomial â„š} {i j : â„•},\n  (âˆ€ (k : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff (f * g) k)) â†’\n    IsLocalization.IsInteger â„¤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "âˆ€ {R S : Type} [inst : CommRing R] [inst_1 : CommRing S] [Algebra R S] {f g : Polynomial R} (hf : âˆ€ (n : â„•), IsInteger (Polynomial.coeff f n)) (hg : âˆ€ (n : â„•), IsInteger (Polynomial.coeff g n)), (âˆ€ {r s : â„•}, IsInteger (Polynomial.coeff f r * Polynomial.coeff g s)) ",
      "âˆ€ {f g : Polynomial â„š} (h_fg : âˆ€ (n : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff (f * g) n)),\n  âˆ€ (m : â„•) (n : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff f m * Polynomial.coeff g n) ",
      "âˆ€ {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f g : Polynomial R),\n  (âˆ€ (n : â„•), IsLocalization.IsInteger R (Polynomial.coeff (f * g) n)) â†’\n    (âˆ€ (i j : â„•), IsLocalization.IsInteger R (Polynomial.coeff f i * Polynomial.coeff g j)) ",
      "âˆ€ {f g : Polynomial â„š}, (âˆ€ (i : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff (f * g) i)) â†’\n  âˆ€ (i j : â„•), IsLocalization.IsInteger â„¤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "forall {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R]\n  (K : Type) [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  (f g : Polynomial R),\n  (âˆ€ n, Polynomial.coeff (f * g) n âˆˆ R) â†’\n    âˆ€ i j, IsFractionRing.num R (Polynomial.coeff f i) * IsFractionRing.num R (Polynomial.coeff g j) âˆˆ R ",
      "âˆ€ (f g : Polynomial â„š) (n m : â„•),\n  (âˆ€ (i : â„•), Rat.denom (Polynomial.coeff (f * g) i) = 1) â†’\n  IsInteger (Polynomial.coeff f n * Polynomial.coeff g m) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {f g : Polynomial R},\n  (âˆ€ (n : â„•), IsInteger R (Polynomial.coeff (f * g) n)) â†’\n    âˆ€ (i j : â„•), IsInteger R (Polynomial.coeff f i * Polynomial.coeff g j) "
    ]
  },
  {
    "docString": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\\n  â†‘(Polynomial.aeval x) (minpoly A x) = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is a root of its minimal polynomial. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Polynomial.Monic (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is monic. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0 :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem âˆ€ {g : Equiv.Perm (Fin 5)}, 3 âˆˆ Equiv.Perm.cycleType g â†’ Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem âˆ€ (S T : Set â„•+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective â†‘(algebraMap B C) â†’ IsCyclotomicExtension (S âˆª T) A C :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- An element is a root of its minimal polynomial. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\n  â†‘(Polynomial.aeval x) (minpoly A x) = 0 :=\n\n/-- A minimal polynomial is monic. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Polynomial.Monic (minpoly A x) :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], Â¬IsUnit (minpoly A x) :=\n\n/-- Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 :\n  Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_of_degree_pos_of_monic_irreducible_map (by norm_num : 0 < 6) (Polynomial.monic_X_pow_sub_C 6 120) (irreducible_of_eisenstein_criterion\n  (by norm_num : 0 < 6) (by norm_num : 6 âˆ£ 30) (by norm_num : 6 âˆ£ 6) (by norm_num : 6 ^ 2 âˆ£ 6) (by norm_num : Â¬6 âˆ£ 1) (by norm_num : 6 âˆ£ 120) (by norm_num : Â¬6 ^ 2 âˆ£ 120))",
      "irreducible_x_pow_6_plus_30x_pow_5_minus_15x_pow_3_plus_6x_minus_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_poly : Irreducible (6 + Polynomial.x ^ 5 * 30 - Polynomial.x ^ 3 * 15 + Polynomial.x * 6 - 120 : Polynomial â„¤) ",
      "irreducible_x_pow_6_plus_30x_pow_5_minus_15x_pow_3_plus_6x_minus_120 :\n  Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_add_30x_pow_5_sub_15x_pow_3_add_6x_sub_120 :\n  Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_add_30x_pow_5_sub_15x_pow_3_add_6x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_30_x_pow_5_neg_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_example : Irreducible (Polynomial.x ^ 6 + (30 : â„¤) * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) "
    ]
  },
  {
    "docString": "Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L]\\n  [hpri : Fact (Nat.Prime â†‘p)] [hcyc : IsCyclotomicExtension {p} K L],\\n  IsPrimitiveRoot Î¶ â†‘p â†’ Irreducible (Polynomial.cyclotomic (â†‘p) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (Î¶ - 1) = â†‘â†‘p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic p K)` (in particular for `K = â„š`) and `p` is an odd prime,\\nthen the norm of `Î¶ - 1` is `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {x y : â„¤} {n : â„•},\\n  2 âˆ£ x - y â†’\\n    Â¬2 âˆ£ x â†’\\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\\n  IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1)) â†’\\n    âˆ€ [hpri : Fact (Nat.Prime â†‘p)] [inst_3 : IsCyclotomicExtension {p ^ (k + 1)} K L],\\n      Irreducible (Polynomial.cyclotomic (â†‘(p ^ (k + 1))) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (Î¶ - 1) = â†‘â†‘p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = â„š`) and `p` is an odd\\nprime, then the norm of `Î¶ - 1` is `p`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : Fact (Nat.Prime â†‘p)] [inst_4 : IsCyclotomicExtension {p} K L],\\n  Irreducible (Polynomial.cyclotomic (â†‘p) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta p K L - 1) = â†‘â†‘p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic p K)` (in particular for `K = â„š`) and `p` is an odd prime,\\nthen the norm of `zeta p K L - 1` is `p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    Odd p â†’\\n      âˆ€ {x y : â„¤},\\n        â†‘p âˆ£ x - y â†’\\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•}\\n  [inst_3 : Fact (Nat.Prime â†‘p)] [inst_4 : IsCyclotomicExtension {p ^ (k + 1)} K L],\\n  Irreducible (Polynomial.cyclotomic (â†‘(p ^ (k + 1))) K) â†’\\n    p â‰  2 â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (p ^ (k + 1)) K L - 1) = â†‘â†‘p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = â„š`) and `p` is an odd\\nprime, then the norm of `zeta (p ^ (k + 1)) K L - 1` is `p`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"}]\n",
    "prompt_cons": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- If `Irreducible (cyclotomic p K)` (in particular for `K = â„š`) and `p` is an odd prime,\nthen the norm of `Î¶ - 1` is `p`. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L]\n  [hpri : Fact (Nat.Prime â†‘p)] [hcyc : IsCyclotomicExtension {p} K L],\n  IsPrimitiveRoot Î¶ â†‘p â†’ Irreducible (Polynomial.cyclotomic (â†‘p) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (Î¶ - 1) = â†‘â†‘p :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem âˆ€ {x y : â„¤} {n : â„•},\n  2 âˆ£ x - y â†’\n    Â¬2 âˆ£ x â†’\n      Even n â†’ multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 â†‘n :=\n\n/-- If `Irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = â„š`) and `p` is an odd\nprime, then the norm of `Î¶ - 1` is `p`. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\n  IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1)) â†’\n    âˆ€ [hpri : Fact (Nat.Prime â†‘p)] [inst_3 : IsCyclotomicExtension {p ^ (k + 1)} K L],\n      Irreducible (Polynomial.cyclotomic (â†‘(p ^ (k + 1))) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (Î¶ - 1) = â†‘â†‘p :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- If `Irreducible (cyclotomic p K)` (in particular for `K = â„š`) and `p` is an odd prime,\nthen the norm of `zeta p K L - 1` is `p`. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : Fact (Nat.Prime â†‘p)] [inst_4 : IsCyclotomicExtension {p} K L],\n  Irreducible (Polynomial.cyclotomic (â†‘p) K) â†’ p â‰  2 â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta p K L - 1) = â†‘â†‘p :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    Odd p â†’\n      âˆ€ {x y : â„¤},\n        â†‘p âˆ£ x - y â†’\n          Â¬â†‘p âˆ£ x â†’ âˆ€ (n : â„•), multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- If `Irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = â„š`) and `p` is an odd\nprime, then the norm of `zeta (p ^ (k + 1)) K L - 1` is `p`. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•}\n  [inst_3 : Fact (Nat.Prime â†‘p)] [inst_4 : IsCyclotomicExtension {p ^ (k + 1)} K L],\n  Irreducible (Polynomial.cyclotomic (â†‘(p ^ (k + 1))) K) â†’\n    p â‰  2 â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (p ^ (k + 1)) K L - 1) = â†‘â†‘p :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is squarefree. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ Irreducible (Polynomial.x_pow_sub p (Polynomial.x + 2) 2) ",
      "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ Irreducible (Polynomial.xC (2 ^ p) + (Polynomial.x + 2) ^ p - 1) ",
      "âˆ€ {p : â„•} [Fact (Nat.Prime p)], Odd p â†’ Irreducible (Polynomial.x ^ p + (2 ^ p - 1) * Polynomial.x + 1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)],\n  Odd p â†’ Irreducible (Polynomial.xgcd (Polynomial.x + 2) ^ p - 2 ^ p) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’\nIrreducible (Polynomial.x ^ p + (2 ^ p - 1) * Polynomial.xC 1 - (2 ^ p) * Polynomial.xC 0) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)],\n  Odd p â†’ Irreducible (Polynomial.x ^ p + 2 * Polynomial.x ^ (p - 1) - 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ Irreducible (Polynomial.map (Int.castRingHom â„š) (Polynomial.x ^ p + 2 ^ p) - 2 ^ p * Polynomial.C x) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Irreducible (Polynomial.eval 2 (Polynomial.x ^ p) - Polynomial.x ^ p) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ Irreducible (Polynomial.x ^ p + 2 ^ p - 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)],\n  Odd p â†’\n    Irreducible (Polynomial.x ^ p + (2 ^ p - 1) â€¢ Polynomial.x - 2 ^ p) "
    ]
  },
  {
    "docString": "Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„¤` is irreducible. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n â„š` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  legendreSym p a = -1 â†’ âˆ€ {x y : ZMod p}, x ^ 2 - â†‘a * y ^ 2 = 0 â†’ x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `â„¤/pâ„¤`\\nis the trivial one. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\": \"âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `â„š`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  legendreSym p a = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `legendreSym p a = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide `x` and `y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„š},\\n  Irreducible p â†’\\n    Nat.Prime (Polynomial.natDegree p) â†’\\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"}]\n",
    "prompt_cons": "/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- `cyclotomic n â„¤` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„¤) :=\n\n/-- `cyclotomic n â„š` is irreducible. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Irreducible (Polynomial.cyclotomic n â„š) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsUnitTrinomial p â†’ IsCoprime p (Polynomial.mirror p) â†’ Irreducible p :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `â„¤/pâ„¤`\nis the trivial one. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  legendreSym p a = -1 â†’ âˆ€ {x y : ZMod p}, x ^ 2 - â†‘a * y ^ 2 = 0 â†’ x = 0 âˆ§ y = 0 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„‚) = Fintype.card â†‘(Polynomial.rootSet p â„) + 2 â†’\n        Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1 :=\n\n/-- **Gauss's Lemma** for `â„¤` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `â„š`. -/\ntheorem âˆ€ {p : Polynomial â„¤}, Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)) :=\n\n/-- If `legendreSym p a = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide `x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  legendreSym p a = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem âˆ€ {p : Polynomial â„š},\n  Irreducible p â†’\n    Nat.Prime (Polynomial.natDegree p) â†’\n      Fintype.card â†‘(Polynomial.rootSet p â„) + 1 â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„‚) â†’\n        Fintype.card â†‘(Polynomial.rootSet p â„‚) â‰¤ Fintype.card â†‘(Polynomial.rootSet p â„) + 3 â†’\n          Function.Bijective â†‘(Polynomial.Gal.galActionHom p â„‚) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : â„•},\n      n â‰  0 â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p â†’ (Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$. -/\ntheorem",
    "choices": [
      "Irreducible (Polynomial.mapâ‚‚ (Int.castRingHom â„š) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š[X,Y]) ",
      "Irreducible (Polynomial.map (Polynomial.evalâ‚‚RingHom (Int.castRingHom â„š) Polynomial.x) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š[X, Y]) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š[Polynomial.y]) ",
      "Irreducible (Polynomial.evalâ‚‚ (RingHom.comp (Polynomial.evalRingHom (C (Polynomial.map (RingHom.id â„š) X))) Polynomial.C) (C (Polynomial.map (RingHom.id â„š) Y)) (X ^ 2 + Y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š[â„š]) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial â„š) ",
      "Irreducible (Polynomial.map (algebraMap â„š (Polynomial â„š)) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) "
    ]
  }
]